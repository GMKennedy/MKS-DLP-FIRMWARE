###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:56:50
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\endstops.cpp
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\endstops.cpp
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\endstops.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\endstops.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\endstops.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * endstops.cpp - A singleton object to manage endstops
     25           */
     26          
     27          #include "Marlin.h"

    #define MIN_SOFTWARE_ENDSTOPS mksCfg.min_software_endstops	/*--mks cfg--*/
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\Configuration.h",824  Warning[Pe047]: 
          incompatible redefinition of macro "MIN_SOFTWARE_ENDSTOPS" (declared
          at line 819)

    #define MAX_SOFTWARE_ENDSTOPS mksCfg.max_software_endstops	/*--mks cfg--*/
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\Configuration.h",834  Warning[Pe047]: 
          incompatible redefinition of macro "MAX_SOFTWARE_ENDSTOPS" (declared
          at line 829)

  #define UNUSED(x) ((void)(x))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Inc\mks_cfg.h",351  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_iwdg.h",80  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_PRESCALER" (declared at
          line 209 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_iwdg.h")

  #define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_iwdg.h",97  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_RELOAD" (declared at
          line 222 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_iwdg.h")

  #define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",272  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NORSRAM_BANK" (declared
          at line 834 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",277  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NAND_BANK" (declared at
          line 855 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",298  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MUX" (declared at line
          839 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",311  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MEMORY" (declared at
          line 842 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",336  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_BURSTMODE" (declared at
          line 894 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",347  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ASYNWAIT" (declared at
          line 915 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",358  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_POLARITY" (declared
          at line 897 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",369  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRAP_MODE" (declared at
          line 900 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",380  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_SIGNAL_ACTIVE"
          (declared at line 903 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",391  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_OPERATION"
          (declared at line 906 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",402  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAITE_SIGNAL" (declared
          at line 909 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",414  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_EXTENDED_MODE" (declared
          at line 912 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",426  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_BURST" (declared
          at line 920 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",435  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_SETUP_TIME"
          (declared at line 923 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_HOLD_TIME"
          (declared at line 925 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",451  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATASETUP_TIME"
          (declared at line 927 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",459  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TURNAROUND_TIME"
          (declared at line 929 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",467  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_CLK_DIV" (declared at
          line 934 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATA_LATENCY" (declared
          at line 918 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",487  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ACCESS_MODE" (declared
          at line 850 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",508  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_FEATURE" (declared
          at line 858 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",520  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECC_STATE" (declared at
          line 864 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",535  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECCPAGE_SIZE" (declared
          at line 867 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",548  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TCLR_TIME" (declared at
          line 874 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",556  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TAR_TIME" (declared at
          line 876 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",564  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_SETUP_TIME" (declared at
          line 878 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",572  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_TIME" (declared at
          line 880 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",580  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HOLD_TIME" (declared at
          line 882 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",588  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HIZ_TIME" (declared at
          line 884 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define FSMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",613  Warning[Pe047]: 
          incompatible redefinition of macro "FSMC_FLAG_FEMPT" (declared at
          line 530 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

    #define assert_param(expr) ((void)0)        
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\stm32f4xx_conf.h",149  Warning[Pe047]: 
          incompatible redefinition of macro "assert_param" (declared at line
          431 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\stm32f4x
          x_hal_conf.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial6
     28          #include "cardreader.h"

  #define SD_DETECT_INVERTED false
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.h",27  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DETECT_INVERTED" (declared at
          line 512 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Configuration_adv.h")

  #define PSTR(s) s
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.h",31  Warning[Pe047]: 
          incompatible redefinition of macro "PSTR" (declared at line 63 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin.h")

  #define pgm_read_byte(x) (*(char*)x)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.h",32  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_byte" (declared at line
          64 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.h",582  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.h",583  Warning[Pe815]: 
          type qualifier on return type is meaningless

   \                                 In section .text, align 4
   \   __interwork __softfp bool Stepper::motor_direction(AxisEnum)
   \                     _ZN7Stepper15motor_directionE8AxisEnum: (+1)
   \   00000000   0x4905             LDR.N    R1,??motor_direction_0
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xFA02 0xF000      LSL      R0,R2,R0
   \   0000000A   0x4001             ANDS     R1,R0,R1
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x4180             SBCS     R0,R0,R0
   \   00000012   0x43C0             MVNS     R0,R0
   \   00000014   0x0FC0             LSRS     R0,R0,#+31
   \   00000016   0x4770             BX       LR               ;; return
   \                     ??motor_direction_0:
   \   00000018   0x........         DC32     _ZN7Stepper19last_direction_bitsE

   \                                 In section .text, align 4
   \   __interwork __vfp float Stepper::triggered_position_mm(AxisEnum)
   \                     _ZN7Stepper21triggered_position_mmE8AxisEnum: (+1)
   \   00000000   0x4907             LDR.N    R1,??triggered_position_mm_0
   \   00000002   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000006   0xEE00 0x1A10      VMOV     S0,R1
   \   0000000A   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000000E   0x4905             LDR.N    R1,??triggered_position_mm_0+0x4
   \   00000010   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000014   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000018   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000001C   0x4770             BX       LR               ;; return
   \   0000001E   0xBF00             Nop      
   \                     ??triggered_position_mm_0:
   \   00000020   0x........         DC32     _ZN7Stepper18endstops_trigstepsE
   \   00000024   0x........         DC32     _ZN7Planner11steps_to_mmE

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\temperature.h",397  Warning[Pa093]: 
          implicit conversion from floating point to integer

  #define LONG_FILENAME_LENGTH (13*MAX_VFAT_ENTRIES+1)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\cardreader.h",61  Warning[Pe047]: 
          incompatible redefinition of macro "LONG_FILENAME_LENGTH" (declared
          at line 119 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\SdFatConfig.h")

  #define ALLOW_DEPRECATED_FUNCTIONS 0
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\SdFat.h",635  Warning[Pe047]: 
          incompatible redefinition of macro "ALLOW_DEPRECATED_FUNCTIONS"
          (declared at line 67 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\SdFatConfig.h")

  #define SPI_SD_INIT_RATE 11
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\SdFat.h",647  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_SD_INIT_RATE" (declared at
          line 79 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\SdFatConfig.h")
     29          #include "endstops.h"

   \                                 In section .text, align 2
   \   __code __interwork __softfp Endstops::Endstops()
   \                     _ZN8EndstopsC1Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       _ZN8Endstops15enable_globallyEb
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::enable_globally(bool)
   \                     _ZN8Endstops15enable_globallyEb: (+1)
   \   00000000   0x4901             LDR.N    R1,??enable_globally_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x7048             STRB     R0,[R1, #+1]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??enable_globally_0:
   \   00000008   0x........         DC32     _ZN8Endstops7enabledE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::hit_on_purpose()
   \                     _ZN8Endstops14hit_on_purposeEv: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4901             LDR.N    R1,??hit_on_purpose_0
   \   00000004   0x7008             STRB     R0,[R1, #+0]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??hit_on_purpose_0:
   \   00000008   0x........         DC32     _ZN8Endstops16endstop_hit_bitsE
     30          #include "temperature.h"
     31          #include "stepper.h"
     32          #include "ultralcd.h"
     33          
     34          // TEST_ENDSTOP: test the old and the current status of an endstop
     35          #define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits & old_endstop_bits, ENDSTOP))
     36          

   \                                 In section .bss, align 4
     37          Endstops endstops;
   \                     endstops:
   \   00000000                      DS8 4
     38          
     39          // public:
     40          

   \                                 In section .bss, align 1
     41          bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
   \                     _ZN8Endstops7enabledE:
   \   00000000                      DS8 1
   \                     _ZN8Endstops16enabled_globallyE:
   \   00000001                      DS8 1

   \                                 In section .bss, align 1
     42          volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value
   \                     _ZN8Endstops16endstop_hit_bitsE:
   \   00000000                      DS8 1
     43          
     44          #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
     45            uint16_t
     46          #else
     47            byte
     48          #endif
     49              Endstops::current_endstop_bits = 0,
   \                     _ZN8Endstops20current_endstop_bitsE:
   \   00000001                      DS8 1
     50              Endstops::old_endstop_bits = 0;
   \                     _ZN8Endstops16old_endstop_bitsE:
   \   00000002                      DS8 1
     51          
     52          #if HAS_BED_PROBE
     53            volatile bool Endstops::z_probe_enabled = false;
     54          #endif
     55          
     56          /**
     57           * Class and Instance Methods
     58           */
     59          

   \                                 In section .text, align 2, keep-with-next
     60          void Endstops::init() {
     61          
     62            #if HAS_X_MIN
     63              #if ENABLED(ENDSTOPPULLUP_XMIN)
     64                SET_INPUT_PULLUP(X_MIN_PIN);
     65              #else
     66                SET_INPUT(X_MIN_PIN);
     67              #endif
     68            #endif
     69          
     70            #if HAS_X2_MIN
     71              #if ENABLED(ENDSTOPPULLUP_XMIN)
     72                SET_INPUT_PULLUP(X2_MIN_PIN);
     73              #else
     74                SET_INPUT(X2_MIN_PIN);
     75              #endif
     76            #endif
     77          
     78            #if HAS_Y_MIN
     79              #if ENABLED(ENDSTOPPULLUP_YMIN)
     80                SET_INPUT_PULLUP(Y_MIN_PIN);
     81              #else
     82                SET_INPUT(Y_MIN_PIN);
     83              #endif
     84            #endif
     85          
     86            #if HAS_Y2_MIN
     87              #if ENABLED(ENDSTOPPULLUP_YMIN)
     88                SET_INPUT_PULLUP(Y2_MIN_PIN);
     89              #else
     90                SET_INPUT(Y2_MIN_PIN);
     91              #endif
     92            #endif
     93          
     94            #if HAS_Z_MIN
     95              #if ENABLED(ENDSTOPPULLUP_ZMIN)
     96                SET_INPUT_PULLUP(Z_MIN_PIN);
     97              #else
     98                SET_INPUT(Z_MIN_PIN);
     99              #endif
    100            #endif
    101          
    102            #if HAS_Z2_MIN
    103              #if ENABLED(ENDSTOPPULLUP_ZMIN)
    104                SET_INPUT_PULLUP(Z2_MIN_PIN);
    105              #else
    106                SET_INPUT(Z2_MIN_PIN);
    107              #endif
    108            #endif
    109          
    110            #if HAS_X_MAX
    111              #if ENABLED(ENDSTOPPULLUP_XMAX)
    112                SET_INPUT_PULLUP(X_MAX_PIN);
    113              #else
    114                SET_INPUT(X_MAX_PIN);
    115              #endif
    116            #endif
    117          
    118            #if HAS_X2_MAX
    119              #if ENABLED(ENDSTOPPULLUP_XMAX)
    120                SET_INPUT_PULLUP(X2_MAX_PIN);
    121              #else
    122                SET_INPUT(X2_MAX_PIN);
    123              #endif
    124            #endif
    125          
    126            #if HAS_Y_MAX
    127              #if ENABLED(ENDSTOPPULLUP_YMAX)
    128                SET_INPUT_PULLUP(Y_MAX_PIN);
    129              #else
    130                SET_INPUT(Y_MAX_PIN);
    131              #endif
    132            #endif
    133          
    134            #if HAS_Y2_MAX
    135              #if ENABLED(ENDSTOPPULLUP_YMAX)
    136                SET_INPUT_PULLUP(Y2_MAX_PIN);
    137              #else
    138                SET_INPUT(Y2_MAX_PIN);
    139              #endif
    140            #endif
    141          
    142            #if HAS_Z_MAX
    143              #if ENABLED(ENDSTOPPULLUP_ZMAX)
    144                SET_INPUT_PULLUP(Z_MAX_PIN);
    145              #else
    146                SET_INPUT(Z_MAX_PIN);
    147              #endif
    148            #endif
    149          
    150            #if HAS_Z2_MAX
    151              #if ENABLED(ENDSTOPPULLUP_ZMAX)
    152                SET_INPUT_PULLUP(Z2_MAX_PIN);
    153              #else
    154                SET_INPUT(Z2_MAX_PIN);
    155              #endif
    156            #endif
    157          
    158            #if ENABLED(Z_MIN_PROBE_ENDSTOP)
    159              #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
    160                SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
    161              #else
    162                SET_INPUT(Z_MIN_PROBE_PIN);
    163              #endif
    164            #endif
    165          
    166          } // Endstops::init
   \                     _ZN8Endstops4initEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    167          

   \                                 In section .text, align 2, keep-with-next
    168          void Endstops::report_state() {
   \                     _ZN8Endstops12report_stateEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    169            if (endstop_hit_bits) {
   \   00000002   0x....             LDR.N    R4,??DataTable12_4
   \   00000004   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD038             BEQ.N    ??report_state_0
    170              #if ENABLED(ULTRA_LCD)
    171                char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
    172                #define _SET_STOP_CHAR(A,C) (chr## A = C)
    173              #else
    174                #define _SET_STOP_CHAR(A,C) ;
    175              #endif
    176          
    177              #define _ENDSTOP_HIT_ECHO(A,C) do{ \
    178                SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", stepper.triggered_position_mm(A ##_AXIS)); \
    179                _SET_STOP_CHAR(A,C); }while(0)
    180          
    181              #define _ENDSTOP_HIT_TEST(A,C) \
    182                if (TEST(endstop_hit_bits, A ##_MIN) || TEST(endstop_hit_bits, A ##_MAX)) \
    183                  _ENDSTOP_HIT_ECHO(A,C)
    184          
    185              #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
    186              #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
    187              #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
    188          
    189              SERIAL_ECHO_START();
   \   0000000C   0x....             LDR.N    R0,??DataTable12_5
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
    190              SERIAL_ECHOPGM(MSG_ENDSTOPS_HIT);
   \   00000012   0x.... 0x....      ADR.W    R0,`?<Constant "endstops hit: ">`
   \   00000016   0x.... 0x....      BL       _Z14serialprintPGMPKc
    191              ENDSTOP_HIT_TEST_X();
   \   0000001A   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD403             BMI.N    ??report_state_1
   \   00000022   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000026   0x06C0             LSLS     R0,R0,#+27
   \   00000028   0xD505             BPL.N    ??report_state_2
   \                     ??report_state_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       _ZN7Stepper21triggered_position_mmE8AxisEnum
   \   00000030   0x....             ADR.N    R0,??DataTable12  ;; " X:"
   \   00000032   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
    192              ENDSTOP_HIT_TEST_Y();
   \                     ??report_state_2: (+1)
   \   00000036   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000003A   0x0780             LSLS     R0,R0,#+30
   \   0000003C   0xD403             BMI.N    ??report_state_3
   \   0000003E   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000042   0x0680             LSLS     R0,R0,#+26
   \   00000044   0xD505             BPL.N    ??report_state_4
   \                     ??report_state_3: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x.... 0x....      BL       _ZN7Stepper21triggered_position_mmE8AxisEnum
   \   0000004C   0x....             ADR.N    R0,??DataTable12_1  ;; " Y:"
   \   0000004E   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
    193              ENDSTOP_HIT_TEST_Z();
   \                     ??report_state_4: (+1)
   \   00000052   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000056   0x0740             LSLS     R0,R0,#+29
   \   00000058   0xD403             BMI.N    ??report_state_5
   \   0000005A   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000005E   0x0640             LSLS     R0,R0,#+25
   \   00000060   0xD505             BPL.N    ??report_state_6
   \                     ??report_state_5: (+1)
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x.... 0x....      BL       _ZN7Stepper21triggered_position_mmE8AxisEnum
   \   00000068   0x....             ADR.N    R0,??DataTable12_2  ;; " Z:"
   \   0000006A   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
    194          
    195              #if ENABLED(Z_MIN_PROBE_ENDSTOP)
    196                #define P_AXIS Z_AXIS
    197                if (TEST(endstop_hit_bits, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
    198              #endif
    199              SERIAL_EOL();
   \                     ??report_state_6: (+1)
   \   0000006E   0x210A             MOVS     R1,#+10
   \   00000070   0x....             LDR.N    R0,??DataTable12_6
   \   00000072   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    200          
    201              #if ENABLED(ULTRA_LCD)
    202                lcd_status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
    203              #endif
    204          
    205              hit_on_purpose();
   \   00000076   0xE8BD 0x4010      POP      {R4,LR}
   \   0000007A   0x.... 0x....      B.W      _ZN8Endstops14hit_on_purposeEv
    206          
    207              #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
    208                if (stepper.abort_on_endstop_hit) {
    209                  card.sdprinting = false;
    210                  card.closefile();
    211                  quickstop_stepper();
    212                  thermalManager.disable_all_heaters(); // switch off all heaters.
    213                }
    214              #endif
    215            }
    216          } // Endstops::report_state
   \                     ??report_state_0: (+1)
   \   0000007E   0xBD10             POP      {R4,PC}          ;; return
    217          

   \                                 In section .text, align 2, keep-with-next
    218          void Endstops::M119() {
   \                     _ZN8Endstops4M119Ev: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    219            SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);
   \   00000002   0x.... 0x....      ADR.W    R0,`?<Constant "Reporting endstop sta...">`
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
    220            #define ES_REPORT(AXIS) do{ \
    221              SERIAL_PROTOCOLPGM(MSG_##AXIS); \
    222              SERIAL_PROTOCOLLN(((READ(AXIS##_PIN)^AXIS##_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN)); \
    223            }while(0)
    224            #if HAS_X_MIN
    225              ES_REPORT(X_MIN);
    226            #endif
    227            #if HAS_X2_MIN
    228              ES_REPORT(X2_MIN);
    229            #endif
    230            #if HAS_X_MAX
    231              ES_REPORT(X_MAX);
    232            #endif
    233            #if HAS_X2_MAX
    234              ES_REPORT(X2_MAX);
    235            #endif
    236            #if HAS_Y_MIN
    237              ES_REPORT(Y_MIN);
    238            #endif
    239            #if HAS_Y2_MIN
    240              ES_REPORT(Y2_MIN);
    241            #endif
    242            #if HAS_Y_MAX
    243              ES_REPORT(Y_MAX);
    244            #endif
    245            #if HAS_Y2_MAX
    246              ES_REPORT(Y2_MAX);
    247            #endif
    248            #if HAS_Z_MIN
    249              ES_REPORT(Z_MIN);
   \   0000000A   0x.... 0x....      ADR.W    R0,`?<Constant "z_min: ">`
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000012   0x....             LDR.N    R4,??DataTable12_7
   \   00000014   0x....             LDR.N    R5,??DataTable12_8
   \   00000016   0x88E9             LDRH     R1,[R5, #+6]
   \   00000018   0x68E0             LDR      R0,[R4, #+12]
   \   0000001A   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000001E   0x....             LDR.N    R6,??DataTable12_9
   \   00000020   0x7D31             LDRB     R1,[R6, #+20]
   \   00000022   0xEA91 0x0F00      TEQ      R1,R0
   \   00000026   0xD002             BEQ.N    ??M119_0
   \   00000028   0x.... 0x....      ADR.W    R1,`?<Constant "TRIGGERED">`
   \   0000002C   0xE001             B.N      ??M119_1
   \                     ??M119_0: (+1)
   \   0000002E   0x.... 0x....      ADR.W    R1,`?<Constant "open">`
   \                     ??M119_1: (+1)
   \   00000032   0x....             LDR.N    R7,??DataTable12_6
   \   00000034   0x4638             MOV      R0,R7
   \   00000036   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000003A   0x210A             MOVS     R1,#+10
   \   0000003C   0x4638             MOV      R0,R7
   \   0000003E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    250            #endif
    251            #if HAS_Z2_MIN
    252              ES_REPORT(Z2_MIN);
    253            #endif
    254            #if HAS_Z_MAX
    255              ES_REPORT(Z_MAX);
   \   00000042   0x.... 0x....      ADR.W    R0,`?<Constant "z_max: ">`
   \   00000046   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   0000004A   0x8929             LDRH     R1,[R5, #+8]
   \   0000004C   0x6920             LDR      R0,[R4, #+16]
   \   0000004E   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000052   0x7D71             LDRB     R1,[R6, #+21]
   \   00000054   0xEA91 0x0F00      TEQ      R1,R0
   \   00000058   0xD002             BEQ.N    ??M119_2
   \   0000005A   0x.... 0x....      ADR.W    R1,`?<Constant "TRIGGERED">`
   \   0000005E   0xE001             B.N      ??M119_3
   \                     ??M119_2: (+1)
   \   00000060   0x.... 0x....      ADR.W    R1,`?<Constant "open">`
   \                     ??M119_3: (+1)
   \   00000064   0x4638             MOV      R0,R7
   \   00000066   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000006A   0x210A             MOVS     R1,#+10
   \   0000006C   0x4638             MOV      R0,R7
   \   0000006E   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   00000072   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    256            #endif
    257            #if HAS_Z2_MAX
    258              ES_REPORT(Z2_MAX);
    259            #endif
    260            #if ENABLED(Z_MIN_PROBE_ENDSTOP)
    261              SERIAL_PROTOCOLPGM(MSG_Z_PROBE);
    262              SERIAL_PROTOCOLLN(((READ(Z_MIN_PROBE_PIN)^Z_MIN_PROBE_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
    263            #endif
    264            #if ENABLED(FILAMENT_RUNOUT_SENSOR)
    265              SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
    266              SERIAL_PROTOCOLLN(((READ(FIL_RUNOUT_PIN)^FIL_RUNOUT_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
    267            #endif
    268          } // Endstops::M119
    269          
    270          #if ENABLED(X_DUAL_ENDSTOPS)
    271            void Endstops::test_dual_x_endstops(const EndstopEnum es1, const EndstopEnum es2) {
    272              byte x_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for X, bit 1 for X2
    273              if (x_test && stepper.current_block->steps[X_AXIS] > 0) {
    274                SBI(endstop_hit_bits, X_MIN);
    275                if (!stepper.performing_homing || (x_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
    276                  stepper.kill_current_block();
    277              }
    278            }
    279          #endif
    280          #if ENABLED(Y_DUAL_ENDSTOPS)
    281            void Endstops::test_dual_y_endstops(const EndstopEnum es1, const EndstopEnum es2) {
    282              byte y_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Y, bit 1 for Y2
    283              if (y_test && stepper.current_block->steps[Y_AXIS] > 0) {
    284                SBI(endstop_hit_bits, Y_MIN);
    285                if (!stepper.performing_homing || (y_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
    286                  stepper.kill_current_block();
    287              }
    288            }
    289          #endif
    290          #if ENABLED(Z_DUAL_ENDSTOPS)
    291            void Endstops::test_dual_z_endstops(const EndstopEnum es1, const EndstopEnum es2) {
    292              byte z_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Z, bit 1 for Z2
    293              if (z_test && stepper.current_block->steps[Z_AXIS] > 0) {
    294                SBI(endstop_hit_bits, Z_MIN);
    295                if (!stepper.performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
    296                  stepper.kill_current_block();
    297              }
    298            }
    299          #endif
    300          
    301          // Check endstops - Called from ISR!

   \                                 In section .text, align 2, keep-with-next
    302          void Endstops::update() {
   \                     _ZN8Endstops6updateEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    303          
    304            #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
    305            #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
    306            #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
    307            #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(endstop_hit_bits, _ENDSTOP(AXIS, MINMAX))
    308          
    309            // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
    310            //#define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
    311               #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) __SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
    312          
    313            // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
    314            //#define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
    315          	#define COPY_BIT(bits, COPY_BIT, BIT) __SET_BIT(bits, BIT, TEST(bits, COPY_BIT))
    316          
    317            #define UPDATE_ENDSTOP(AXIS,MINMAX) do { \
    318                UPDATE_ENDSTOP_BIT(AXIS, MINMAX); \
    319                if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX)) && stepper.current_block->steps[_AXIS(AXIS)] > 0) { \
    320                  _ENDSTOP_HIT(AXIS, MINMAX); \
    321                  stepper.endstop_triggered(_AXIS(AXIS)); \
    322                } \
    323              }while(0)
    324          
    325            #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
    326              // If G38 command is active check Z_MIN_PROBE for ALL movement
    327              if (G38_move) {
    328                UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
    329                if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
    330                  if      (stepper.current_block->steps[_AXIS(X)] > 0) { _ENDSTOP_HIT(X, MIN); stepper.endstop_triggered(_AXIS(X)); }
    331                  else if (stepper.current_block->steps[_AXIS(Y)] > 0) { _ENDSTOP_HIT(Y, MIN); stepper.endstop_triggered(_AXIS(Y)); }
    332                  else if (stepper.current_block->steps[_AXIS(Z)] > 0) { _ENDSTOP_HIT(Z, MIN); stepper.endstop_triggered(_AXIS(Z)); }
    333                  G38_endstop_hit = true;
    334                }
    335              }
    336            #endif
    337          
    338            /**
    339             * Define conditions for checking endstops
    340             */
    341          
    342            #if IS_CORE
    343              #define S_(N) stepper.current_block->steps[CORE_AXIS_##N]
    344              #define D_(N) stepper.motor_direction(CORE_AXIS_##N)
    345            #endif
    346          
    347            #if CORE_IS_XY || CORE_IS_XZ
    348              /**
    349               * Head direction in -X axis for CoreXY and CoreXZ bots.
    350               *
    351               * If steps differ, both axes are moving.
    352               * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z, handled below)
    353               * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X)
    354               */
    355              #if ENABLED(COREXY) || ENABLED(COREXZ)
    356                #define X_CMP ==
    357              #else
    358                #define X_CMP !=
    359              #endif
    360              #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) X_CMP D_(2)) )
    361              #define X_AXIS_HEAD X_HEAD
    362            #else
    363              #define X_MOVE_TEST stepper.current_block->steps[X_AXIS] > 0
    364              #define X_AXIS_HEAD X_AXIS
    365            #endif
    366          
    367            #if CORE_IS_XY || CORE_IS_YZ
    368              /**
    369               * Head direction in -Y axis for CoreXY / CoreYZ bots.
    370               *
    371               * If steps differ, both axes are moving
    372               * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y)
    373               * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z)
    374               */
    375              #if ENABLED(COREYX) || ENABLED(COREYZ)
    376                #define Y_CMP ==
    377              #else
    378                #define Y_CMP !=
    379              #endif
    380              #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Y_CMP D_(2)) )
    381              #define Y_AXIS_HEAD Y_HEAD
    382            #else
    383              #define Y_MOVE_TEST stepper.current_block->steps[Y_AXIS] > 0
    384              #define Y_AXIS_HEAD Y_AXIS
    385            #endif
    386          
    387            #if CORE_IS_XZ || CORE_IS_YZ
    388              /**
    389               * Head direction in -Z axis for CoreXZ or CoreYZ bots.
    390               *
    391               * If steps differ, both axes are moving
    392               * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y, already handled above)
    393               * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Z)
    394               */
    395              #if ENABLED(COREZX) || ENABLED(COREZY)
    396                #define Z_CMP ==
    397              #else
    398                #define Z_CMP !=
    399              #endif
    400              #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Z_CMP D_(2)) )
    401              #define Z_AXIS_HEAD Z_HEAD
    402            #else
    403              #define Z_MOVE_TEST stepper.current_block->steps[Z_AXIS] > 0
    404              #define Z_AXIS_HEAD Z_AXIS
    405            #endif
    406          
    407            // With Dual X, endstops are only checked in the homing direction for the active extruder
    408            #if ENABLED(DUAL_X_CARRIAGE)
    409              #define E0_ACTIVE stepper.current_block->active_extruder == 0
    410              #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
    411              #define X_MAX_TEST ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
    412            #else
    413              #define X_MIN_TEST true
    414              #define X_MAX_TEST true
    415            #endif
    416          
    417            /**
    418             * Check and update endstops according to conditions
    419             */
    420            if (X_MOVE_TEST) {
   \   00000004   0x....             LDR.N    R4,??DataTable12_10
   \   00000006   0x6826             LDR      R6,[R4, #+0]
   \   00000008   0x6870             LDR      R0,[R6, #+4]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xDB02             BLT.N    ??update_0
    421              if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
    422                #if HAS_X_MIN
    423                  #if ENABLED(X_DUAL_ENDSTOPS)
    424                    UPDATE_ENDSTOP_BIT(X, MIN);
    425                    #if HAS_X2_MIN
    426                      UPDATE_ENDSTOP_BIT(X2, MIN);
    427                    #else
    428                      COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
    429                    #endif
    430                    test_dual_x_endstops(X_MIN, X2_MIN);
    431                  #else
    432                    if (X_MIN_TEST) UPDATE_ENDSTOP(X, MIN);
    433                  #endif
    434                #endif
    435              }
    436              else { // +direction
    437                #if HAS_X_MAX
    438                  #if ENABLED(X_DUAL_ENDSTOPS)
    439                    UPDATE_ENDSTOP_BIT(X, MAX);
    440                    #if HAS_X2_MAX
    441                      UPDATE_ENDSTOP_BIT(X2, MAX);
    442                    #else
    443                      COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
    444                    #endif
    445                    test_dual_x_endstops(X_MAX, X2_MAX);
    446                  #else
    447                    if (X_MIN_TEST) UPDATE_ENDSTOP(X, MAX);
    448                  #endif
    449          
    450                #endif
    451              }
    452            }
    453          
    454            if (Y_MOVE_TEST) {
   \                     ??update_0: (+1)
   \   00000014   0x68B0             LDR      R0,[R6, #+8]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xDB02             BLT.N    ??update_1
    455              if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
    456                #if HAS_Y_MIN
    457                  #if ENABLED(Y_DUAL_ENDSTOPS)
    458                    UPDATE_ENDSTOP_BIT(Y, MIN);
    459                    #if HAS_Y2_MIN
    460                      UPDATE_ENDSTOP_BIT(Y2, MIN);
    461                    #else
    462                      COPY_BIT(current_endstop_bits, Y_MIN, Y2_MIN);
    463                    #endif
    464                    test_dual_y_endstops(Y_MIN, Y2_MIN);
    465                  #else
    466                    UPDATE_ENDSTOP(Y, MIN);
    467                  #endif
    468                #endif
    469              }
    470              else { // +direction
    471                #if HAS_Y_MAX
    472                  #if ENABLED(Y_DUAL_ENDSTOPS)
    473                    UPDATE_ENDSTOP_BIT(Y, MAX);
    474                    #if HAS_Y2_MAX
    475                      UPDATE_ENDSTOP_BIT(Y2, MAX);
    476                    #else
    477                      COPY_BIT(current_endstop_bits, Y_MAX, Y2_MAX);
    478                    #endif
    479                    test_dual_y_endstops(Y_MAX, Y2_MAX);
    480                  #else
    481                    UPDATE_ENDSTOP(Y, MAX);
    482                  #endif
    483                #endif
    484              }
    485            }
    486          
    487            if (Z_MOVE_TEST) {
   \                     ??update_1: (+1)
   \   00000020   0x....             LDR.N    R5,??DataTable12_4
   \   00000022   0x68F0             LDR      R0,[R6, #+12]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xDB4B             BLT.N    ??update_2
    488              if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
   \   00000028   0x....             LDR.N    R6,??DataTable12_9
   \   0000002A   0x....             LDR.N    R7,??DataTable12_7
   \   0000002C   0x.... 0x....      LDR.W    R8,??DataTable12_8
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0x.... 0x....      BL       _ZN7Stepper15motor_directionE8AxisEnum
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD021             BEQ.N    ??update_3
    489                #if HAS_Z_MIN
    490                  #if ENABLED(Z_DUAL_ENDSTOPS)
    491                    UPDATE_ENDSTOP_BIT(Z, MIN);
    492                    #if HAS_Z2_MIN
    493                      UPDATE_ENDSTOP_BIT(Z2, MIN);
    494                    #else
    495                      COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
    496                    #endif
    497                    test_dual_z_endstops(Z_MIN, Z2_MIN);
    498                  #else
    499                    #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
    500                      if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
    501                    #else
    502                      UPDATE_ENDSTOP(Z, MIN);
   \   0000003A   0xF8B8 0x1006      LDRH     R1,[R8, #+6]
   \   0000003E   0x68F8             LDR      R0,[R7, #+12]
   \   00000040   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000044   0x7D31             LDRB     R1,[R6, #+20]
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD001             BEQ.N    ??update_4
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xE000             B.N      ??update_5
   \                     ??update_4: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??update_5: (+1)
   \   00000050   0x7869             LDRB     R1,[R5, #+1]
   \   00000052   0x4240             RSBS     R0,R0,#+0
   \   00000054   0x4048             EORS     R0,R1,R0
   \   00000056   0xF000 0x0004      AND      R0,R0,#0x4
   \   0000005A   0x4048             EORS     R0,R0,R1
   \   0000005C   0x7068             STRB     R0,[R5, #+1]
   \   0000005E   0x78A9             LDRB     R1,[R5, #+2]
   \   00000060   0x4008             ANDS     R0,R1,R0
   \   00000062   0x0740             LSLS     R0,R0,#+29
   \   00000064   0xD52C             BPL.N    ??update_2
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x68C0             LDR      R0,[R0, #+12]
   \   0000006A   0x2801             CMP      R0,#+1
   \   0000006C   0xDB28             BLT.N    ??update_2
   \   0000006E   0x7828             LDRB     R0,[R5, #+0]
   \   00000070   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000074   0x7028             STRB     R0,[R5, #+0]
   \   00000076   0x2002             MOVS     R0,#+2
   \   00000078   0x.... 0x....      BL       _ZN7Stepper17endstop_triggeredE8AxisEnum
   \   0000007C   0xE020             B.N      ??update_2
    503                    #endif
    504                  #endif
    505                #endif
    506          
    507                // When closing the gap check the enabled probe
    508                #if ENABLED(Z_MIN_PROBE_ENDSTOP)
    509                  if (z_probe_enabled) {
    510                    UPDATE_ENDSTOP(Z, MIN_PROBE);
    511                    if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
    512                  }
    513                #endif
    514              }
    515              else { // Z +direction. Gantry up, bed down.
    516                #if HAS_Z_MAX
    517                  // Check both Z dual endstops
    518                  #if ENABLED(Z_DUAL_ENDSTOPS)
    519                    UPDATE_ENDSTOP_BIT(Z, MAX);
    520                    #if HAS_Z2_MAX
    521                      UPDATE_ENDSTOP_BIT(Z2, MAX);
    522                    #else
    523                      COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
    524                    #endif
    525                    test_dual_z_endstops(Z_MAX, Z2_MAX);
    526                  // If this pin is not hijacked for the bed probe
    527                  // then it belongs to the Z endstop
    528                  #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
    529                    UPDATE_ENDSTOP(Z, MAX);
   \                     ??update_3: (+1)
   \   0000007E   0xF8B8 0x1008      LDRH     R1,[R8, #+8]
   \   00000082   0x6938             LDR      R0,[R7, #+16]
   \   00000084   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000088   0x7D71             LDRB     R1,[R6, #+21]
   \   0000008A   0x4288             CMP      R0,R1
   \   0000008C   0xD001             BEQ.N    ??update_6
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xE000             B.N      ??update_7
   \                     ??update_6: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \                     ??update_7: (+1)
   \   00000094   0x7869             LDRB     R1,[R5, #+1]
   \   00000096   0x4240             RSBS     R0,R0,#+0
   \   00000098   0x4048             EORS     R0,R1,R0
   \   0000009A   0xF000 0x0040      AND      R0,R0,#0x40
   \   0000009E   0x4048             EORS     R0,R0,R1
   \   000000A0   0x7068             STRB     R0,[R5, #+1]
   \   000000A2   0x78A9             LDRB     R1,[R5, #+2]
   \   000000A4   0x4008             ANDS     R0,R1,R0
   \   000000A6   0x0640             LSLS     R0,R0,#+25
   \   000000A8   0xD50A             BPL.N    ??update_2
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x68C0             LDR      R0,[R0, #+12]
   \   000000AE   0x2801             CMP      R0,#+1
   \   000000B0   0xDB06             BLT.N    ??update_2
   \   000000B2   0x7828             LDRB     R0,[R5, #+0]
   \   000000B4   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000B8   0x7028             STRB     R0,[R5, #+0]
   \   000000BA   0x2002             MOVS     R0,#+2
   \   000000BC   0x.... 0x....      BL       _ZN7Stepper17endstop_triggeredE8AxisEnum
    530                  #endif
    531                #endif
    532              }
    533            }
    534          
    535            old_endstop_bits = current_endstop_bits;
   \                     ??update_2: (+1)
   \   000000C0   0x7868             LDRB     R0,[R5, #+1]
   \   000000C2   0x70A8             STRB     R0,[R5, #+2]
    536          
    537          } // Endstops::update()
   \   000000C4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " X:">`:
   \   00000000   0x20 0x58          DC8 " X:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Y:">`:
   \   00000000   0x20 0x59          DC8 " Y:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Z:">`:
   \   00000000   0x20 0x5A          DC8 " Z:"
   \              0x3A 0x00    

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_3
   \   00000002   0x.... 0x....      B.W      _ZN8EndstopsC1Ev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x20 0x58          DC8      " X:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x20 0x59          DC8      " Y:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x20 0x5A          DC8      " Z:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x........         DC32     endstops

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x........         DC32     _ZN8Endstops16endstop_hit_bitsE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x........         DC32     Serial6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   0x........         DC32     _ZN7Stepper13current_blockE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "endstops hit: ">`:
   \   00000000   0x65 0x6E          DC8 "endstops hit: "
   \              0x64 0x73    
   \              0x74 0x6F    
   \              0x70 0x73    
   \              0x20 0x68    
   \              0x69 0x74    
   \              0x3A 0x20    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Reporting endstop sta...">`:
   \   00000000   0x52 0x65          DC8 "Reporting endstop status\012"
   \              0x70 0x6F    
   \              0x72 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x65 0x6E    
   \              0x64 0x73    
   \              0x74 0x6F    
   \              0x70 0x20    
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x75 0x73    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "z_min: ">`:
   \   00000000   0x7A 0x5F          DC8 "z_min: "
   \              0x6D 0x69    
   \              0x6E 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "TRIGGERED">`:
   \   00000000   0x54 0x52          DC8 "TRIGGERED"
   \              0x49 0x47    
   \              0x47 0x45    
   \              0x52 0x45    
   \              0x44 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "open">`:
   \   00000000   0x6F 0x70          DC8 "open"
   \              0x65 0x6E    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "z_max: ">`:
   \   00000000   0x7A 0x5F          DC8 "z_max: "
   \              0x6D 0x61    
   \              0x78 0x3A    
   \              0x20 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Endstops::Endstops()
         8   -> Endstops::enable_globally(bool)
      24   Endstops::M119()
        24   -> HAL_GPIO_ReadPin
        24   -> Print::print(char const *)
         0   -> USARTClass::write(uint8_t)
        24   -> USARTClass::write(uint8_t)
        24   -> serialprintPGM(char const *)
       0   Endstops::enable_globally(bool)
       0   Endstops::hit_on_purpose()
       0   Endstops::init()
       8   Endstops::report_state()
         0   -> Endstops::hit_on_purpose()
         8   -> Stepper::triggered_position_mm(AxisEnum)
         8   -> USARTClass::write(uint8_t)
         8   -> serial_echopair_P(char const *, float)
         8   -> serialprintPGM(char const *)
      24   Endstops::update()
        24   -> HAL_GPIO_ReadPin
        24   -> Stepper::endstop_triggered(AxisEnum)
        24   -> Stepper::motor_direction(AxisEnum)
       0   Stepper::motor_direction(AxisEnum)
       0   Stepper::triggered_position_mm(AxisEnum)
       0   __sti__routine()
         0   -> Endstops::Endstops()
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant " X:">
       4  ?<Constant " Y:">
       4  ?<Constant " Z:">
      28  ?<Constant "Reporting endstop sta...">
      12  ?<Constant "TRIGGERED">
      16  ?<Constant "endstops hit: ">
       8  ?<Constant "open">
       8  ?<Constant "z_max: ">
       8  ?<Constant "z_min: ">
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
      14  Endstops::Endstops()
     118  Endstops::M119()
      12  Endstops::enable_globally(bool)
       2  Endstops::enabled
          Endstops::enabled_globally
       3  Endstops::endstop_hit_bits
          Endstops::current_endstop_bits
          Endstops::old_endstop_bits
      12  Endstops::hit_on_purpose()
       2  Endstops::init()
     128  Endstops::report_state()
     200  Endstops::update()
      28  Stepper::motor_direction(AxisEnum)
      40  Stepper::triggered_position_mm(AxisEnum)
       6  __sti__routine()
       4  endstops
      28  serialprintPGM(char const *)
       5  -- Other

 
   9 bytes in section .bss
   4 bytes in section .init_array
  13 bytes in section .rodata
 712 bytes in section .text
 
 582 bytes of CODE  memory (+ 134 bytes shared)
  12 bytes of CONST memory (+   1 byte  shared)
   9 bytes of DATA  memory

Errors: none
Warnings: 50
