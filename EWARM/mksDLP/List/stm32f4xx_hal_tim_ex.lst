###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:21
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim_ex.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim_ex.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\stm32f4xx_hal_tim_ex.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\stm32f4xx_hal_tim_ex.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_tim_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.5.2
      6            * @date    22-September-2016
      7            * @brief   TIM HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Timer extension peripheral:
     10            *           + Time Hall Sensor Interface Initialization
     11            *           + Time Hall Sensor Interface Start
     12            *           + Time Complementary signal bread and dead time configuration  
     13            *           + Time Master and Slave synchronization configuration
     14            @verbatim 
     15            ==============================================================================
     16                                ##### TIMER Extended features #####
     17            ==============================================================================
     18            [..] 
     19              The Timer Extension features include: 
     20              (#) Complementary outputs with programmable dead-time for :
     21                  (++) Input Capture
     22                  (++) Output Compare
     23                  (++) PWM generation (Edge and Center-aligned Mode)
     24                  (++) One-pulse mode output
     25              (#) Synchronization circuit to control the timer with external signals and to 
     26                  interconnect several timers together.
     27              (#) Break input to put the timer output signals in reset state or in a known state.
     28              (#) Supports incremental (quadrature) encoder and hall-sensor circuitry for 
     29                  positioning purposes                
     30             
     31                                  ##### How to use this driver #####
     32            ==============================================================================
     33            [..]
     34               (#) Initialize the TIM low level resources by implementing the following functions 
     35                   depending from feature used :
     36                     (++) Complementary Output Compare : HAL_TIM_OC_MspInit()
     37                     (++) Complementary PWM generation : HAL_TIM_PWM_MspInit()
     38                     (++) Complementary One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     39                     (++) Hall Sensor output : HAL_TIM_HallSensor_MspInit()
     40                     
     41               (#) Initialize the TIM low level resources :
     42                  (##) Enable the TIM interface clock using __TIMx_CLK_ENABLE(); 
     43                  (##) TIM pins configuration
     44                      (+++) Enable the clock for the TIM GPIOs using the following function:
     45                           __GPIOx_CLK_ENABLE();   
     46                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();  
     47          
     48               (#) The external Clock can be configured, if needed (the default clock is the 
     49                   internal clock from the APBx), using the following function:
     50                   HAL_TIM_ConfigClockSource, the clock configuration should be done before 
     51                   any start function.
     52            
     53              (#) Configure the TIM in the desired functioning mode using one of the 
     54                  initialization function of this driver:
     55                  (++) HAL_TIMEx_HallSensor_Init and HAL_TIMEx_ConfigCommutationEvent: to use the 
     56                       Timer Hall Sensor Interface and the commutation event with the corresponding 
     57                       Interrupt and DMA request if needed (Note that One Timer is used to interface 
     58                       with the Hall sensor Interface and another Timer should be used to use 
     59                       the commutation event).
     60          
     61              (#) Activate the TIM peripheral using one of the start functions: 
     62                     (++) Complementary Output Compare : HAL_TIMEx_OCN_Start(), HAL_TIMEx_OCN_Start_DMA(), HAL_TIMEx_OC_Start_IT()
     63                     (++) Complementary PWM generation : HAL_TIMEx_PWMN_Start(), HAL_TIMEx_PWMN_Start_DMA(), HAL_TIMEx_PWMN_Start_IT()
     64                     (++) Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(), HAL_TIMEx_OnePulseN_Start_IT()
     65                     (++) Hall Sensor output : HAL_TIMEx_HallSensor_Start(), HAL_TIMEx_HallSensor_Start_DMA(), HAL_TIMEx_HallSensor_Start_IT().
     66          
     67            
     68            @endverbatim
     69            ******************************************************************************
     70            * @attention
     71            *
     72            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     73            *
     74            * Redistribution and use in source and binary forms, with or without modification,
     75            * are permitted provided that the following conditions are met:
     76            *   1. Redistributions of source code must retain the above copyright notice,
     77            *      this list of conditions and the following disclaimer.
     78            *   2. Redistributions in binary form must reproduce the above copyright notice,
     79            *      this list of conditions and the following disclaimer in the documentation
     80            *      and/or other materials provided with the distribution.
     81            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     82            *      may be used to endorse or promote products derived from this software
     83            *      without specific prior written permission.
     84            *
     85            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     86            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     87            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     88            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     89            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     90            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     91            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     92            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     93            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     94            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     95            *
     96            ******************************************************************************
     97            */ 
     98          
     99          /* Includes ------------------------------------------------------------------*/
    100          #include "stm32f4xx_hal.h"
    101          
    102          /** @addtogroup STM32F4xx_HAL_Driver
    103            * @{
    104            */
    105          
    106          /** @defgroup TIMEx  TIMEx
    107            * @brief TIM HAL module driver
    108            * @{
    109            */
    110          
    111          #ifdef HAL_TIM_MODULE_ENABLED
    112          
    113          /* Private typedef -----------------------------------------------------------*/
    114          /* Private define ------------------------------------------------------------*/
    115          /* Private macro -------------------------------------------------------------*/
    116          /* Private variables ---------------------------------------------------------*/
    117          /** @addtogroup TIMEx_Private_Functions
    118            * @{
    119            */
    120          /* Private function prototypes -----------------------------------------------*/
    121          static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState);
    122          /**
    123            * @}
    124            */
    125                
    126          /* Exported functions --------------------------------------------------------*/
    127          /** @defgroup TIMEx_Exported_Functions TIM Exported Functions
    128            * @{
    129            */
    130          
    131          /** @defgroup TIMEx_Exported_Functions_Group1 Timer Hall Sensor functions 
    132           *  @brief    Timer Hall Sensor functions 
    133           *
    134          @verbatim    
    135            ==============================================================================
    136                                ##### Timer Hall Sensor functions #####
    137            ==============================================================================
    138            [..]  
    139              This section provides functions allowing to:
    140              (+) Initialize and configure TIM HAL Sensor. 
    141              (+) De-initialize TIM HAL Sensor.
    142              (+) Start the Hall Sensor Interface.
    143              (+) Stop the Hall Sensor Interface.
    144              (+) Start the Hall Sensor Interface and enable interrupts.
    145              (+) Stop the Hall Sensor Interface and disable interrupts.
    146              (+) Start the Hall Sensor Interface and enable DMA transfers.
    147              (+) Stop the Hall Sensor Interface and disable DMA transfers.
    148           
    149          @endverbatim
    150            * @{
    151            */
    152          /**
    153            * @brief  Initializes the TIM Hall Sensor Interface and create the associated handle.
    154            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    155            *                the configuration information for TIM module.
    156            * @param  sConfig: TIM Hall Sensor configuration structure
    157            * @retval HAL status
    158            */

   \                                 In section .text, align 2, keep-with-next
    159          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef* sConfig)
    160          {
   \                     HAL_TIMEx_HallSensor_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    161            TIM_OC_InitTypeDef OC_Config;
    162              
    163            /* Check the TIM handle allocation */
    164            if(htim == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_TIMEx_HallSensor_Init_0
    165            {
    166              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE04F             B.N      ??HAL_TIMEx_HallSensor_Init_1
    167            }
    168            
    169            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    170            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    171            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    172            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
    173            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
    174            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
    175          
    176            /* Set the TIM state */
    177            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_HallSensor_Init_0: (+1)
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xF884 0x0039      STRB     R0,[R4, #+57]
    178            
    179            /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    180            HAL_TIMEx_HallSensor_MspInit(htim);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_TIMEx_HallSensor_MspInit
    181            
    182            /* Configure the Time base in the Encoder Mode */
    183            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   0000001C   0x1D21             ADDS     R1,R4,#+4
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       TIM_Base_SetConfig
    184            
    185            /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
    186            TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
   \   00000024   0x68AB             LDR      R3,[R5, #+8]
   \   00000026   0x2203             MOVS     R2,#+3
   \   00000028   0x6829             LDR      R1,[R5, #+0]
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_TI1_SetConfig
    187            
    188            /* Reset the IC1PSC Bits */
    189            htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6981             LDR      R1,[R0, #+24]
   \   00000034   0xF021 0x010C      BIC      R1,R1,#0xC
   \   00000038   0x6181             STR      R1,[R0, #+24]
    190            /* Set the IC1PSC value */
    191            htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6981             LDR      R1,[R0, #+24]
   \   0000003E   0x686A             LDR      R2,[R5, #+4]
   \   00000040   0x4311             ORRS     R1,R2,R1
   \   00000042   0x6181             STR      R1,[R0, #+24]
    192            
    193            /* Enable the Hall sensor interface (XOR function of the three inputs) */
    194            htim->Instance->CR2 |= TIM_CR2_TI1S;
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6841             LDR      R1,[R0, #+4]
   \   00000048   0xF041 0x0180      ORR      R1,R1,#0x80
   \   0000004C   0x6041             STR      R1,[R0, #+4]
    195            
    196            /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
    197            htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6881             LDR      R1,[R0, #+8]
   \   00000052   0xF021 0x0170      BIC      R1,R1,#0x70
   \   00000056   0x6081             STR      R1,[R0, #+8]
    198            htim->Instance->SMCR |= TIM_TS_TI1F_ED;
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6881             LDR      R1,[R0, #+8]
   \   0000005C   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000060   0x6081             STR      R1,[R0, #+8]
    199            
    200            /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */  
    201            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6881             LDR      R1,[R0, #+8]
   \   00000066   0x08C9             LSRS     R1,R1,#+3
   \   00000068   0x00C9             LSLS     R1,R1,#+3
   \   0000006A   0x6081             STR      R1,[R0, #+8]
    202            htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6881             LDR      R1,[R0, #+8]
   \   00000070   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000074   0x6081             STR      R1,[R0, #+8]
    203            
    204            /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
    205            OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x9004             STR      R0,[SP, #+16]
    206            OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
   \   0000007A   0x9005             STR      R0,[SP, #+20]
    207            OC_Config.OCMode = TIM_OCMODE_PWM2;
   \   0000007C   0x2070             MOVS     R0,#+112
   \   0000007E   0x9000             STR      R0,[SP, #+0]
    208            OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x9006             STR      R0,[SP, #+24]
    209            OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
   \   00000084   0x9003             STR      R0,[SP, #+12]
    210            OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
   \   00000086   0x9002             STR      R0,[SP, #+8]
    211            OC_Config.Pulse = sConfig->Commutation_Delay; 
   \   00000088   0x68E8             LDR      R0,[R5, #+12]
   \   0000008A   0x9001             STR      R0,[SP, #+4]
    212              
    213            TIM_OC2_SetConfig(htim->Instance, &OC_Config);
   \   0000008C   0xA900             ADD      R1,SP,#+0
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x.... 0x....      BL       TIM_OC2_SetConfig
    214            
    215            /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
    216              register to 101 */
    217            htim->Instance->CR2 &= ~TIM_CR2_MMS;
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6841             LDR      R1,[R0, #+4]
   \   00000098   0xF021 0x0170      BIC      R1,R1,#0x70
   \   0000009C   0x6041             STR      R1,[R0, #+4]
    218            htim->Instance->CR2 |= TIM_TRGO_OC2REF; 
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6841             LDR      R1,[R0, #+4]
   \   000000A2   0xF041 0x0150      ORR      R1,R1,#0x50
   \   000000A6   0x6041             STR      R1,[R0, #+4]
    219            
    220            /* Initialize the TIM state*/
    221            htim->State= HAL_TIM_STATE_READY;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xF884 0x0039      STRB     R0,[R4, #+57]
    222          
    223            return HAL_OK;
   \   000000AE   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_HallSensor_Init_1: (+1)
   \   000000B0   0xB007             ADD      SP,SP,#+28
   \   000000B2   0xBD30             POP      {R4,R5,PC}       ;; return
    224          }
    225          
    226          /**
    227            * @brief  DeInitializes the TIM Hall Sensor interface  
    228            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    229            *                the configuration information for TIM module.
    230            * @retval HAL status
    231            */

   \                                 In section .text, align 2, keep-with-next
    232          HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
    233          {
   \                     HAL_TIMEx_HallSensor_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    234            /* Check the parameters */
    235            assert_param(IS_TIM_INSTANCE(htim->Instance));
    236          
    237            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
    238            
    239            /* Disable the TIM Peripheral Clock */
    240            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIMEx_HallSensor_DeInit_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIMEx_HallSensor_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
    241              
    242            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    243            HAL_TIMEx_HallSensor_MspDeInit(htim);
   \                     ??HAL_TIMEx_HallSensor_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIMEx_HallSensor_MspDeInit
    244              
    245            /* Change TIM state */  
    246            htim->State = HAL_TIM_STATE_RESET; 
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
    247          
    248            /* Release Lock */
    249            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
    250          
    251            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    252          }
    253          
    254          /**
    255            * @brief  Initializes the TIM Hall Sensor MSP.
    256            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    257            *                the configuration information for TIM module.
    258            * @retval None
    259            */

   \                                 In section .text, align 2, keep-with-next
    260          __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
    261          {
    262            /* Prevent unused argument(s) compilation warning */
    263            UNUSED(htim);
    264            /* NOTE : This function Should not be modified, when the callback is needed,
    265                      the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
    266             */
    267          }
   \                     HAL_TIMEx_HallSensor_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    268          
    269          /**
    270            * @brief  DeInitializes TIM Hall Sensor MSP.
    271            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    272            *                the configuration information for TIM module.
    273            * @retval None
    274            */

   \                                 In section .text, align 2, keep-with-next
    275          __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
    276          {
    277            /* Prevent unused argument(s) compilation warning */
    278            UNUSED(htim);
    279            /* NOTE : This function Should not be modified, when the callback is needed,
    280                      the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
    281             */
    282          }
   \                     HAL_TIMEx_HallSensor_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    283          
    284          /**
    285            * @brief  Starts the TIM Hall Sensor Interface.
    286            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    287            *                the configuration information for TIM module.
    288            * @retval HAL status
    289            */

   \                                 In section .text, align 2, keep-with-next
    290          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
    291          {
   \                     HAL_TIMEx_HallSensor_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    292            /* Check the parameters */
    293            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    294            
    295            /* Enable the Input Capture channels 1
    296              (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
    297            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    298            
    299            /* Enable the Peripheral */
    300            __HAL_TIM_ENABLE(htim);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000016   0x6001             STR      R1,[R0, #+0]
    301            
    302            /* Return function status */
    303            return HAL_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    304          }
    305          
    306          /**
    307            * @brief  Stops the TIM Hall sensor Interface.
    308            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    309            *                the configuration information for TIM module.
    310            * @retval HAL status
    311            */

   \                                 In section .text, align 2, keep-with-next
    312          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
    313          {
   \                     HAL_TIMEx_HallSensor_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    314            /* Check the parameters */
    315            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    316            
    317            /* Disable the Input Capture channels 1, 2 and 3
    318              (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
    319            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    320          
    321            /* Disable the Peripheral */
    322            __HAL_TIM_DISABLE(htim);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0xF241 0x1211      MOVW     R2,#+4369
   \   00000016   0x4211             TST      R1,R2
   \   00000018   0xD108             BNE.N    ??HAL_TIMEx_HallSensor_Stop_0
   \   0000001A   0x6A01             LDR      R1,[R0, #+32]
   \   0000001C   0xF240 0x4244      MOVW     R2,#+1092
   \   00000020   0x4211             TST      R1,R2
   \   00000022   0xD103             BNE.N    ??HAL_TIMEx_HallSensor_Stop_0
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x0849             LSRS     R1,R1,#+1
   \   00000028   0x0049             LSLS     R1,R1,#+1
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    323            
    324            /* Return function status */
    325            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_0: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    326          }
    327          
    328          /**
    329            * @brief  Starts the TIM Hall Sensor Interface in interrupt mode.
    330            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    331            *                the configuration information for TIM module.
    332            * @retval HAL status
    333            */

   \                                 In section .text, align 2, keep-with-next
    334          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
    335          { 
   \                     HAL_TIMEx_HallSensor_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    336            /* Check the parameters */
    337            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    338            
    339            /* Enable the capture compare Interrupts 1 event */
    340            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
    341            
    342            /* Enable the Input Capture channels 1
    343              (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
    344            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);  
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
    345            
    346            /* Enable the Peripheral */
    347            __HAL_TIM_ENABLE(htim);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000020   0x6001             STR      R1,[R0, #+0]
    348            
    349            /* Return function status */
    350            return HAL_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    351          }
    352          
    353          /**
    354            * @brief  Stops the TIM Hall Sensor Interface in interrupt mode.
    355            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    356            *                the configuration information for TIM module.
    357            * @retval HAL status
    358            */

   \                                 In section .text, align 2, keep-with-next
    359          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
    360          {
   \                     HAL_TIMEx_HallSensor_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    361            /* Check the parameters */
    362            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    363            
    364            /* Disable the Input Capture channels 1
    365              (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
    366            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    367            
    368            /* Disable the capture compare Interrupts event */
    369            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x68C1             LDR      R1,[R0, #+12]
   \   00000012   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000016   0x60C1             STR      R1,[R0, #+12]
    370            
    371            /* Disable the Peripheral */
    372            __HAL_TIM_DISABLE(htim);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6A01             LDR      R1,[R0, #+32]
   \   0000001C   0xF241 0x1211      MOVW     R2,#+4369
   \   00000020   0x4211             TST      R1,R2
   \   00000022   0xD108             BNE.N    ??HAL_TIMEx_HallSensor_Stop_IT_0
   \   00000024   0x6A01             LDR      R1,[R0, #+32]
   \   00000026   0xF240 0x4244      MOVW     R2,#+1092
   \   0000002A   0x4211             TST      R1,R2
   \   0000002C   0xD103             BNE.N    ??HAL_TIMEx_HallSensor_Stop_IT_0
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0x0849             LSRS     R1,R1,#+1
   \   00000032   0x0049             LSLS     R1,R1,#+1
   \   00000034   0x6001             STR      R1,[R0, #+0]
    373            
    374            /* Return function status */
    375            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_IT_0: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    376          }
    377          
    378          /**
    379            * @brief  Starts the TIM Hall Sensor Interface in DMA mode.
    380            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    381            *                the configuration information for TIM module.
    382            * @param  pData: The destination Buffer address.
    383            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
    384            * @retval HAL status
    385            */

   \                                 In section .text, align 2, keep-with-next
    386          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    387          {
   \                     HAL_TIMEx_HallSensor_Start_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
    388            /* Check the parameters */
    389            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    390            
    391             if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_0
    392            {
    393               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD70             POP      {R4-R6,PC}
    394            }
    395            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_0: (+1)
   \   00000014   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD108             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_1
    396            {
    397              if(((uint32_t)pData == 0U) && (Length > 0U)) 
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD103             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_2
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD001             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_2
    398              {
    399                return HAL_ERROR;                                    
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD70             POP      {R4-R6,PC}
    400              }
    401              else
    402              {
    403                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
    404              }
    405            }
    406            /* Enable the Input Capture channels 1
    407              (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
    408            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_1: (+1)
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x.... 0x....      BL       TIM_CCxChannelCmd
    409            
    410            /* Set the DMA Input Capture 1 Callback */
    411            htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;     
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable3
   \   0000003C   0x6A21             LDR      R1,[R4, #+32]
   \   0000003E   0x63C8             STR      R0,[R1, #+60]
    412            /* Set the DMA error callback */
    413            htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   00000044   0x6A21             LDR      R1,[R4, #+32]
   \   00000046   0x64C8             STR      R0,[R1, #+76]
    414            
    415            /* Enable the DMA Stream for Capture 1*/
    416            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);    
   \   00000048   0x462B             MOV      R3,R5
   \   0000004A   0x4632             MOV      R2,R6
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000052   0x6A20             LDR      R0,[R4, #+32]
   \   00000054   0x.... 0x....      BL       HAL_DMA_Start_IT
    417            
    418            /* Enable the capture compare 1 Interrupt */
    419            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x68C1             LDR      R1,[R0, #+12]
   \   0000005C   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000060   0x60C1             STR      R1,[R0, #+12]
    420           
    421            /* Enable the Peripheral */
    422            __HAL_TIM_ENABLE(htim);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6801             LDR      R1,[R0, #+0]
   \   00000066   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000006A   0x6001             STR      R1,[R0, #+0]
    423            
    424            /* Return function status */
    425            return HAL_OK;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
    426          }
    427          
    428          /**
    429            * @brief  Stops the TIM Hall Sensor Interface in DMA mode.
    430            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    431            *                the configuration information for TIM module.
    432            * @retval HAL status
    433            */

   \                                 In section .text, align 2, keep-with-next
    434          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
    435          {
   \                     HAL_TIMEx_HallSensor_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    436            /* Check the parameters */
    437            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    438            
    439            /* Disable the Input Capture channels 1
    440              (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
    441            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    442           
    443            
    444            /* Disable the capture compare Interrupts 1 event */
    445            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x68C1             LDR      R1,[R0, #+12]
   \   00000012   0xF421 0x7100      BIC      R1,R1,#0x200
   \   00000016   0x60C1             STR      R1,[R0, #+12]
    446           
    447            /* Disable the Peripheral */
    448            __HAL_TIM_DISABLE(htim);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6A01             LDR      R1,[R0, #+32]
   \   0000001C   0xF241 0x1211      MOVW     R2,#+4369
   \   00000020   0x4211             TST      R1,R2
   \   00000022   0xD108             BNE.N    ??HAL_TIMEx_HallSensor_Stop_DMA_0
   \   00000024   0x6A01             LDR      R1,[R0, #+32]
   \   00000026   0xF240 0x4244      MOVW     R2,#+1092
   \   0000002A   0x4211             TST      R1,R2
   \   0000002C   0xD103             BNE.N    ??HAL_TIMEx_HallSensor_Stop_DMA_0
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0x0849             LSRS     R1,R1,#+1
   \   00000032   0x0049             LSLS     R1,R1,#+1
   \   00000034   0x6001             STR      R1,[R0, #+0]
    449            
    450            /* Return function status */
    451            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_DMA_0: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    452          }
    453          /**
    454            * @}
    455            */
    456            
    457          /** @defgroup TIMEx_Exported_Functions_Group2 Timer Complementary Output Compare functions
    458           *  @brief    Timer Complementary Output Compare functions 
    459           *
    460          @verbatim   
    461            ==============================================================================
    462                        ##### Timer Complementary Output Compare functions #####
    463            ==============================================================================  
    464            [..]  
    465              This section provides functions allowing to:
    466              (+) Start the Complementary Output Compare/PWM.
    467              (+) Stop the Complementary Output Compare/PWM.
    468              (+) Start the Complementary Output Compare/PWM and enable interrupts.
    469              (+) Stop the Complementary Output Compare/PWM and disable interrupts.
    470              (+) Start the Complementary Output Compare/PWM and enable DMA transfers.
    471              (+) Stop the Complementary Output Compare/PWM and disable DMA transfers.
    472                         
    473          @endverbatim
    474            * @{
    475            */
    476            
    477          /**
    478            * @brief  Starts the TIM Output Compare signal generation on the complementary
    479            *         output.
    480            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    481            *                the configuration information for TIM module.  
    482            * @param  Channel: TIM Channel to be enabled.
    483            *          This parameter can be one of the following values:
    484            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    485            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    486            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    487            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    488            * @retval HAL status
    489            */

   \                                 In section .text, align 2, keep-with-next
    490          HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    491          {
   \                     HAL_TIMEx_OCN_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    492            /* Check the parameters */
    493            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    494            
    495               /* Enable the Capture compare channel N */
    496               TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \   00000004   0x2204             MOVS     R2,#+4
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
    497              
    498            /* Enable the Main Output */
    499              __HAL_TIM_MOE_ENABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6C41             LDR      R1,[R0, #+68]
   \   00000010   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000014   0x6441             STR      R1,[R0, #+68]
    500          
    501            /* Enable the Peripheral */
    502            __HAL_TIM_ENABLE(htim);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    503            
    504            /* Return function status */
    505            return HAL_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    506          } 
    507          
    508          /**
    509            * @brief  Stops the TIM Output Compare signal generation on the complementary
    510            *         output.
    511            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    512            *                the configuration information for TIM module.
    513            * @param  Channel: TIM Channel to be disabled.
    514            *          This parameter can be one of the following values:
    515            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    516            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    517            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    518            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    519            * @retval HAL status
    520            */

   \                                 In section .text, align 2, keep-with-next
    521          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    522          { 
   \                     HAL_TIMEx_OCN_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    523            /* Check the parameters */
    524            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    525            
    526              /* Disable the Capture compare channel N */
    527            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
    528              
    529            /* Disable the Main Output */
    530              __HAL_TIM_MOE_DISABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x6A02             LDR      R2,[R0, #+32]
   \   00000014   0x420A             TST      R2,R1
   \   00000016   0xD108             BNE.N    ??HAL_TIMEx_OCN_Stop_0
   \   00000018   0x6A02             LDR      R2,[R0, #+32]
   \   0000001A   0xF240 0x4344      MOVW     R3,#+1092
   \   0000001E   0x421A             TST      R2,R3
   \   00000020   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_0
   \   00000022   0x6C42             LDR      R2,[R0, #+68]
   \   00000024   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000028   0x6442             STR      R2,[R0, #+68]
    531          
    532            /* Disable the Peripheral */
    533            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_0: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6A02             LDR      R2,[R0, #+32]
   \   0000002E   0x420A             TST      R2,R1
   \   00000030   0xD108             BNE.N    ??HAL_TIMEx_OCN_Stop_1
   \   00000032   0x6A01             LDR      R1,[R0, #+32]
   \   00000034   0xF240 0x4244      MOVW     R2,#+1092
   \   00000038   0x4211             TST      R1,R2
   \   0000003A   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_1
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x0849             LSRS     R1,R1,#+1
   \   00000040   0x0049             LSLS     R1,R1,#+1
   \   00000042   0x6001             STR      R1,[R0, #+0]
    534            
    535            /* Return function status */
    536            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Stop_1: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    537          } 
    538          
    539          /**
    540            * @brief  Starts the TIM Output Compare signal generation in interrupt mode 
    541            *         on the complementary output.
    542            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    543            *                the configuration information for TIM module.
    544            * @param  Channel: TIM Channel to be enabled.
    545            *          This parameter can be one of the following values:
    546            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    547            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    548            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    549            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    550            * @retval HAL status
    551            */

   \                                 In section .text, align 2, keep-with-next
    552          HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    553          {
   \                     HAL_TIMEx_OCN_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    554            /* Check the parameters */
    555            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    556            
    557            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIMEx_OCN_Start_IT_4
    558            {
    559              case TIM_CHANNEL_1:
    560              {       
    561                /* Enable the TIM Output Compare interrupt */
    562                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_OCN_Start_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
    563              }
    564              break;
   \   00000020   0xE010             B.N      ??HAL_TIMEx_OCN_Start_IT_4
    565              
    566              case TIM_CHANNEL_2:
    567              {
    568                /* Enable the TIM Output Compare interrupt */
    569                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_OCN_Start_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
    570              }
    571              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIMEx_OCN_Start_IT_4
    572              
    573              case TIM_CHANNEL_3:
    574              {
    575                /* Enable the TIM Output Compare interrupt */
    576                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_OCN_Start_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
    577              }
    578              break;
   \   00000038   0xE004             B.N      ??HAL_TIMEx_OCN_Start_IT_4
    579              
    580              case TIM_CHANNEL_4:
    581              {
    582                /* Enable the TIM Output Compare interrupt */
    583                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIMEx_OCN_Start_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
    584              }
    585              break;
    586              
    587              default:
    588              break;
    589            } 
    590            
    591            /* Enable the TIM Break interrupt */
    592            __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
   \                     ??HAL_TIMEx_OCN_Start_IT_4: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C2             LDR      R2,[R0, #+12]
   \   00000048   0xF042 0x0280      ORR      R2,R2,#0x80
   \   0000004C   0x60C2             STR      R2,[R0, #+12]
    593            
    594            /* Enable the Capture compare channel N */
    595            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \   0000004E   0x2204             MOVS     R2,#+4
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       TIM_CCxNChannelCmd
    596            
    597            /* Enable the Main Output */
    598            __HAL_TIM_MOE_ENABLE(htim);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6C41             LDR      R1,[R0, #+68]
   \   0000005A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000005E   0x6441             STR      R1,[R0, #+68]
    599            
    600            /* Enable the Peripheral */
    601            __HAL_TIM_ENABLE(htim);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000068   0x6001             STR      R1,[R0, #+0]
    602            
    603            /* Return function status */
    604            return HAL_OK;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
    605          } 
    606          
    607          /**
    608            * @brief  Stops the TIM Output Compare signal generation in interrupt mode 
    609            *         on the complementary output.
    610            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    611            *                the configuration information for TIM module.
    612            * @param  Channel: TIM Channel to be disabled.
    613            *          This parameter can be one of the following values:
    614            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    615            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    616            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    617            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    618            * @retval HAL status
    619            */

   \                                 In section .text, align 2, keep-with-next
    620          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    621          {
   \                     HAL_TIMEx_OCN_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    622            /* Check the parameters */
    623            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    624            
    625            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIMEx_OCN_Stop_IT_4
    626            {
    627              case TIM_CHANNEL_1:
    628              {       
    629                /* Disable the TIM Output Compare interrupt */
    630                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_OCN_Stop_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
    631              }
    632              break;
   \   00000020   0xE010             B.N      ??HAL_TIMEx_OCN_Stop_IT_4
    633              
    634              case TIM_CHANNEL_2:
    635              {
    636                /* Disable the TIM Output Compare interrupt */
    637                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_OCN_Stop_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF022 0x0204      BIC      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
    638              }
    639              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIMEx_OCN_Stop_IT_4
    640              
    641              case TIM_CHANNEL_3:
    642              {
    643                /* Disable the TIM Output Compare interrupt */
    644                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_OCN_Stop_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF022 0x0208      BIC      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
    645              }
    646              break;
   \   00000038   0xE004             B.N      ??HAL_TIMEx_OCN_Stop_IT_4
    647              
    648              case TIM_CHANNEL_4:
    649              {
    650                /* Disable the TIM Output Compare interrupt */
    651                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIMEx_OCN_Stop_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
    652              }
    653              break;
    654              
    655              default:
    656              break; 
    657            }
    658            
    659            /* Disable the Capture compare channel N */
    660            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_OCN_Stop_IT_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxNChannelCmd
    661          
    662            /* Disable the TIM Break interrupt (only if no more channel is active) */
    663            if((READ_REG(htim->Instance->CCER) & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0xF240 0x4044      MOVW     R0,#+1092
   \   00000052   0x6A0A             LDR      R2,[R1, #+32]
   \   00000054   0x4202             TST      R2,R0
   \   00000056   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_5
    664            {
    665              __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
   \   00000058   0x68CA             LDR      R2,[R1, #+12]
   \   0000005A   0xF022 0x0280      BIC      R2,R2,#0x80
   \   0000005E   0x60CA             STR      R2,[R1, #+12]
    666            }
    667            
    668            /* Disable the Main Output */
    669            __HAL_TIM_MOE_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_IT_5: (+1)
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0xF241 0x1211      MOVW     R2,#+4369
   \   00000066   0x6A0B             LDR      R3,[R1, #+32]
   \   00000068   0x4213             TST      R3,R2
   \   0000006A   0xD106             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_6
   \   0000006C   0x6A0B             LDR      R3,[R1, #+32]
   \   0000006E   0x4203             TST      R3,R0
   \   00000070   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_6
   \   00000072   0x6C4B             LDR      R3,[R1, #+68]
   \   00000074   0xF423 0x4300      BIC      R3,R3,#0x8000
   \   00000078   0x644B             STR      R3,[R1, #+68]
    670            
    671            /* Disable the Peripheral */
    672            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_IT_6: (+1)
   \   0000007A   0x6821             LDR      R1,[R4, #+0]
   \   0000007C   0x6A0B             LDR      R3,[R1, #+32]
   \   0000007E   0x4213             TST      R3,R2
   \   00000080   0xD106             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_7
   \   00000082   0x6A0A             LDR      R2,[R1, #+32]
   \   00000084   0x4202             TST      R2,R0
   \   00000086   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_7
   \   00000088   0x6808             LDR      R0,[R1, #+0]
   \   0000008A   0x0840             LSRS     R0,R0,#+1
   \   0000008C   0x0040             LSLS     R0,R0,#+1
   \   0000008E   0x6008             STR      R0,[R1, #+0]
    673            
    674            /* Return function status */
    675            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Stop_IT_7: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xBD10             POP      {R4,PC}          ;; return
    676          } 
    677          
    678          /**
    679            * @brief  Starts the TIM Output Compare signal generation in DMA mode 
    680            *         on the complementary output.
    681            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    682            *                the configuration information for TIM module.
    683            * @param  Channel: TIM Channel to be enabled.
    684            *          This parameter can be one of the following values:
    685            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    686            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    687            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    688            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    689            * @param  pData: The source Buffer address.
    690            * @param  Length: The length of data to be transferred from memory to TIM peripheral
    691            * @retval HAL status
    692            */

   \                                 In section .text, align 2, keep-with-next
    693          HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    694          {
   \                     HAL_TIMEx_OCN_Start_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4611             MOV      R1,R2
    695            /* Check the parameters */
    696            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    697            
    698            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_0
    699            {
    700               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}
    701            }
    702            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIMEx_OCN_Start_DMA_0: (+1)
   \   00000014   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD108             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_1
    703            {
    704              if(((uint32_t)pData == 0U) && (Length > 0U)) 
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD103             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_2
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD001             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_2
    705              {
    706                return HAL_ERROR;                                    
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
    707              }
    708              else
    709              {
    710                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_OCN_Start_DMA_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
    711              }
    712            }    
    713            switch (Channel)
   \                     ??HAL_TIMEx_OCN_Start_DMA_1: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0xD006             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_3
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD018             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_4
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xD02A             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_5
   \   0000003A   0x280C             CMP      R0,#+12
   \   0000003C   0xD03C             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_6
   \   0000003E   0xE04E             B.N      ??HAL_TIMEx_OCN_Start_DMA_7
    714            {
    715              case TIM_CHANNEL_1:
    716              {      
    717                /* Set the DMA Period elapsed callback */
    718                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_3: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   00000044   0x6A22             LDR      R2,[R4, #+32]
   \   00000046   0x63D0             STR      R0,[R2, #+60]
    719               
    720                /* Set the DMA error callback */
    721                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   0000004C   0x6A22             LDR      R2,[R4, #+32]
   \   0000004E   0x64D0             STR      R0,[R2, #+76]
    722                
    723                /* Enable the DMA Stream */
    724                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0xF100 0x0234      ADD      R2,R0,#+52
   \   00000056   0x6A20             LDR      R0,[R4, #+32]
   \   00000058   0x.... 0x....      BL       HAL_DMA_Start_IT
    725                
    726                /* Enable the TIM Output Compare DMA request */
    727                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x68C1             LDR      R1,[R0, #+12]
   \   00000060   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000064   0x60C1             STR      R1,[R0, #+12]
    728              }
    729              break;
   \   00000066   0xE03A             B.N      ??HAL_TIMEx_OCN_Start_DMA_7
    730              
    731              case TIM_CHANNEL_2:
    732              {
    733                /* Set the DMA Period elapsed callback */
    734                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_4: (+1)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   0000006C   0x6A62             LDR      R2,[R4, #+36]
   \   0000006E   0x63D0             STR      R0,[R2, #+60]
    735               
    736                /* Set the DMA error callback */
    737                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   00000074   0x6A62             LDR      R2,[R4, #+36]
   \   00000076   0x64D0             STR      R0,[R2, #+76]
    738                
    739                /* Enable the DMA Stream */
    740                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0xF100 0x0238      ADD      R2,R0,#+56
   \   0000007E   0x6A60             LDR      R0,[R4, #+36]
   \   00000080   0x.... 0x....      BL       HAL_DMA_Start_IT
    741                
    742                /* Enable the TIM Output Compare DMA request */
    743                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x68C1             LDR      R1,[R0, #+12]
   \   00000088   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000008C   0x60C1             STR      R1,[R0, #+12]
    744              }
    745              break;
   \   0000008E   0xE026             B.N      ??HAL_TIMEx_OCN_Start_DMA_7
    746              
    747              case TIM_CHANNEL_3:
    748          {
    749                /* Set the DMA Period elapsed callback */
    750                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_5: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   00000094   0x6AA2             LDR      R2,[R4, #+40]
   \   00000096   0x63D0             STR      R0,[R2, #+60]
    751               
    752                /* Set the DMA error callback */
    753                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   0000009C   0x6AA2             LDR      R2,[R4, #+40]
   \   0000009E   0x64D0             STR      R0,[R2, #+76]
    754                
    755                /* Enable the DMA Stream */
    756                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0xF100 0x023C      ADD      R2,R0,#+60
   \   000000A6   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A8   0x.... 0x....      BL       HAL_DMA_Start_IT
    757                
    758                /* Enable the TIM Output Compare DMA request */
    759                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x68C1             LDR      R1,[R0, #+12]
   \   000000B0   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000B4   0x60C1             STR      R1,[R0, #+12]
    760              }
    761              break;
   \   000000B6   0xE012             B.N      ??HAL_TIMEx_OCN_Start_DMA_7
    762              
    763              case TIM_CHANNEL_4:
    764              {
    765               /* Set the DMA Period elapsed callback */
    766                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_6: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   000000BC   0x6AE2             LDR      R2,[R4, #+44]
   \   000000BE   0x63D0             STR      R0,[R2, #+60]
    767               
    768                /* Set the DMA error callback */
    769                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   000000C4   0x6AE2             LDR      R2,[R4, #+44]
   \   000000C6   0x64D0             STR      R0,[R2, #+76]
    770                
    771                /* Enable the DMA Stream */
    772                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0xF100 0x0240      ADD      R2,R0,#+64
   \   000000CE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000D0   0x.... 0x....      BL       HAL_DMA_Start_IT
    773                
    774                /* Enable the TIM Output Compare DMA request */
    775                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x68C1             LDR      R1,[R0, #+12]
   \   000000D8   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000DC   0x60C1             STR      R1,[R0, #+12]
    776              }
    777              break;
    778              
    779              default:
    780              break;
    781            }
    782          
    783            /* Enable the Capture compare channel N */
    784            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \                     ??HAL_TIMEx_OCN_Start_DMA_7: (+1)
   \   000000DE   0x2204             MOVS     R2,#+4
   \   000000E0   0x4629             MOV      R1,R5
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x.... 0x....      BL       TIM_CCxNChannelCmd
    785            
    786            /* Enable the Main Output */
    787            __HAL_TIM_MOE_ENABLE(htim);
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6C41             LDR      R1,[R0, #+68]
   \   000000EC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000F0   0x6441             STR      R1,[R0, #+68]
    788            
    789            /* Enable the Peripheral */
    790            __HAL_TIM_ENABLE(htim); 
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x6801             LDR      R1,[R0, #+0]
   \   000000F6   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000FA   0x6001             STR      R1,[R0, #+0]
    791            
    792            /* Return function status */
    793            return HAL_OK;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    794          }
    795          
    796          /**
    797            * @brief  Stops the TIM Output Compare signal generation in DMA mode 
    798            *         on the complementary output.
    799            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    800            *                the configuration information for TIM module.
    801            * @param  Channel: TIM Channel to be disabled.
    802            *          This parameter can be one of the following values:
    803            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    804            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    805            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    806            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    807            * @retval HAL status
    808            */

   \                                 In section .text, align 2, keep-with-next
    809          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    810          {
   \                     HAL_TIMEx_OCN_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    811            /* Check the parameters */
    812            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    813            
    814            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_3
   \   00000014   0xE016             B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
    815            {
    816              case TIM_CHANNEL_1:
    817              {       
    818                /* Disable the TIM Output Compare DMA request */
    819                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF422 0x7200      BIC      R2,R2,#0x200
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
    820              }
    821              break;
   \   00000020   0xE010             B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
    822              
    823              case TIM_CHANNEL_2:
    824              {
    825                /* Disable the TIM Output Compare DMA request */
    826                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
    827              }
    828              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
    829              
    830              case TIM_CHANNEL_3:
    831              {
    832                /* Disable the TIM Output Compare DMA request */
    833                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000036   0x60C2             STR      R2,[R0, #+12]
    834              }
    835              break;
   \   00000038   0xE004             B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
    836              
    837              case TIM_CHANNEL_4:
    838              {
    839                /* Disable the TIM Output Compare interrupt */
    840                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000042   0x60C2             STR      R2,[R0, #+12]
    841              }
    842              break;
    843              
    844              default:
    845              break;
    846            } 
    847            
    848            /* Disable the Capture compare channel N */
    849            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxNChannelCmd
    850            
    851            /* Disable the Main Output */
    852            __HAL_TIM_MOE_DISABLE(htim);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000052   0x6A02             LDR      R2,[R0, #+32]
   \   00000054   0x420A             TST      R2,R1
   \   00000056   0xD108             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_5
   \   00000058   0x6A02             LDR      R2,[R0, #+32]
   \   0000005A   0xF240 0x4344      MOVW     R3,#+1092
   \   0000005E   0x421A             TST      R2,R3
   \   00000060   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_5
   \   00000062   0x6C42             LDR      R2,[R0, #+68]
   \   00000064   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000068   0x6442             STR      R2,[R0, #+68]
    853            
    854            /* Disable the Peripheral */
    855            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_5: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6A02             LDR      R2,[R0, #+32]
   \   0000006E   0x420A             TST      R2,R1
   \   00000070   0xD108             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_6
   \   00000072   0x6A01             LDR      R1,[R0, #+32]
   \   00000074   0xF240 0x4244      MOVW     R2,#+1092
   \   00000078   0x4211             TST      R1,R2
   \   0000007A   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_6
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0x0849             LSRS     R1,R1,#+1
   \   00000080   0x0049             LSLS     R1,R1,#+1
   \   00000082   0x6001             STR      R1,[R0, #+0]
    856            
    857            /* Change the htim state */
    858            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIMEx_OCN_Stop_DMA_6: (+1)
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xF884 0x0039      STRB     R0,[R4, #+57]
    859            
    860            /* Return function status */
    861            return HAL_OK;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xBD10             POP      {R4,PC}          ;; return
    862          }
    863          /**
    864            * @}
    865            */
    866            
    867          /** @defgroup TIMEx_Exported_Functions_Group3 Timer Complementary PWM functions
    868           *  @brief    Timer Complementary PWM functions 
    869           *
    870          @verbatim   
    871            ==============================================================================
    872                           ##### Timer Complementary PWM functions #####
    873            ==============================================================================  
    874            [..]  
    875              This section provides functions allowing to:
    876              (+) Start the Complementary PWM.
    877              (+) Stop the Complementary PWM.
    878              (+) Start the Complementary PWM and enable interrupts.
    879              (+) Stop the Complementary PWM and disable interrupts.
    880              (+) Start the Complementary PWM and enable DMA transfers.
    881              (+) Stop the Complementary PWM and disable DMA transfers.
    882              (+) Start the Complementary Input Capture measurement.
    883              (+) Stop the Complementary Input Capture.
    884              (+) Start the Complementary Input Capture and enable interrupts.
    885              (+) Stop the Complementary Input Capture and disable interrupts.
    886              (+) Start the Complementary Input Capture and enable DMA transfers.
    887              (+) Stop the Complementary Input Capture and disable DMA transfers.
    888              (+) Start the Complementary One Pulse generation.
    889              (+) Stop the Complementary One Pulse.
    890              (+) Start the Complementary One Pulse and enable interrupts.
    891              (+) Stop the Complementary One Pulse and disable interrupts.
    892                         
    893          @endverbatim
    894            * @{
    895            */
    896          
    897          /**
    898            * @brief  Starts the PWM signal generation on the complementary output.
    899            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    900            *                the configuration information for TIM module.
    901            * @param  Channel: TIM Channel to be enabled.
    902            *          This parameter can be one of the following values:
    903            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    904            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    905            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    906            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    907            * @retval HAL status
    908            */

   \                                 In section .text, align 2, keep-with-next
    909          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    910          {
   \                     HAL_TIMEx_PWMN_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    911            /* Check the parameters */
    912            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    913            
    914            /* Enable the complementary PWM output  */
    915            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \   00000004   0x2204             MOVS     R2,#+4
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
    916            
    917            /* Enable the Main Output */
    918            __HAL_TIM_MOE_ENABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6C41             LDR      R1,[R0, #+68]
   \   00000010   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000014   0x6441             STR      R1,[R0, #+68]
    919            
    920            /* Enable the Peripheral */
    921            __HAL_TIM_ENABLE(htim);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    922            
    923            /* Return function status */
    924            return HAL_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    925          } 
    926          
    927          /**
    928            * @brief  Stops the PWM signal generation on the complementary output.
    929            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    930            *                the configuration information for TIM module.
    931            * @param  Channel: TIM Channel to be disabled.
    932            *          This parameter can be one of the following values:
    933            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    934            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    935            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    936            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    937            * @retval HAL status
    938            */

   \                                 In section .text, align 2, keep-with-next
    939          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    940          { 
   \                     HAL_TIMEx_PWMN_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    941            /* Check the parameters */
    942            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    943            
    944            /* Disable the complementary PWM output  */
    945            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);  
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
    946            
    947            /* Disable the Main Output */
    948            __HAL_TIM_MOE_DISABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x6A02             LDR      R2,[R0, #+32]
   \   00000014   0x420A             TST      R2,R1
   \   00000016   0xD108             BNE.N    ??HAL_TIMEx_PWMN_Stop_0
   \   00000018   0x6A02             LDR      R2,[R0, #+32]
   \   0000001A   0xF240 0x4344      MOVW     R3,#+1092
   \   0000001E   0x421A             TST      R2,R3
   \   00000020   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_0
   \   00000022   0x6C42             LDR      R2,[R0, #+68]
   \   00000024   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000028   0x6442             STR      R2,[R0, #+68]
    949            
    950            /* Disable the Peripheral */
    951            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_0: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6A02             LDR      R2,[R0, #+32]
   \   0000002E   0x420A             TST      R2,R1
   \   00000030   0xD108             BNE.N    ??HAL_TIMEx_PWMN_Stop_1
   \   00000032   0x6A01             LDR      R1,[R0, #+32]
   \   00000034   0xF240 0x4244      MOVW     R2,#+1092
   \   00000038   0x4211             TST      R1,R2
   \   0000003A   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_1
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x0849             LSRS     R1,R1,#+1
   \   00000040   0x0049             LSLS     R1,R1,#+1
   \   00000042   0x6001             STR      R1,[R0, #+0]
    952            
    953            /* Return function status */
    954            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Stop_1: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    955          } 
    956          
    957          /**
    958            * @brief  Starts the PWM signal generation in interrupt mode on the 
    959            *         complementary output.
    960            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    961            *                the configuration information for TIM module.
    962            * @param  Channel: TIM Channel to be disabled.
    963            *          This parameter can be one of the following values:
    964            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    965            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    966            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    967            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    968            * @retval HAL status
    969            */

   \                                 In section .text, align 2, keep-with-next
    970          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    971          {
   \                     HAL_TIMEx_PWMN_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    972            /* Check the parameters */
    973            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
    974            
    975            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIMEx_PWMN_Start_IT_4
    976            {
    977              case TIM_CHANNEL_1:
    978              {       
    979                /* Enable the TIM Capture/Compare 1 interrupt */
    980                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_PWMN_Start_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
    981              }
    982              break;
   \   00000020   0xE010             B.N      ??HAL_TIMEx_PWMN_Start_IT_4
    983              
    984              case TIM_CHANNEL_2:
    985              {
    986                /* Enable the TIM Capture/Compare 2 interrupt */
    987                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_PWMN_Start_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
    988              }
    989              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIMEx_PWMN_Start_IT_4
    990              
    991              case TIM_CHANNEL_3:
    992              {
    993                /* Enable the TIM Capture/Compare 3 interrupt */
    994                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_PWMN_Start_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
    995              }
    996              break;
   \   00000038   0xE004             B.N      ??HAL_TIMEx_PWMN_Start_IT_4
    997              
    998              case TIM_CHANNEL_4:
    999              {
   1000                /* Enable the TIM Capture/Compare 4 interrupt */
   1001                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIMEx_PWMN_Start_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1002              }
   1003              break;
   1004              
   1005              default:
   1006              break;
   1007            } 
   1008            
   1009            /* Enable the TIM Break interrupt */
   1010            __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
   \                     ??HAL_TIMEx_PWMN_Start_IT_4: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C2             LDR      R2,[R0, #+12]
   \   00000048   0xF042 0x0280      ORR      R2,R2,#0x80
   \   0000004C   0x60C2             STR      R2,[R0, #+12]
   1011            
   1012            /* Enable the complementary PWM output  */
   1013            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \   0000004E   0x2204             MOVS     R2,#+4
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1014            
   1015            /* Enable the Main Output */
   1016            __HAL_TIM_MOE_ENABLE(htim);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6C41             LDR      R1,[R0, #+68]
   \   0000005A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000005E   0x6441             STR      R1,[R0, #+68]
   1017            
   1018            /* Enable the Peripheral */
   1019            __HAL_TIM_ENABLE(htim);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000068   0x6001             STR      R1,[R0, #+0]
   1020            
   1021            /* Return function status */
   1022            return HAL_OK;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
   1023          } 
   1024          
   1025          /**
   1026            * @brief  Stops the PWM signal generation in interrupt mode on the 
   1027            *         complementary output.
   1028            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1029            *                the configuration information for TIM module.
   1030            * @param  Channel: TIM Channel to be disabled.
   1031            *          This parameter can be one of the following values:
   1032            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1033            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1034            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1035            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1036            * @retval HAL status
   1037            */

   \                                 In section .text, align 2, keep-with-next
   1038          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1039          {
   \                     HAL_TIMEx_PWMN_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1040            /* Check the parameters */
   1041            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
   1042          
   1043            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
   1044            {
   1045              case TIM_CHANNEL_1:
   1046              {       
   1047                /* Disable the TIM Capture/Compare 1 interrupt */
   1048                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1049              }
   1050              break;
   \   00000020   0xE010             B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
   1051              
   1052              case TIM_CHANNEL_2:
   1053              {
   1054                /* Disable the TIM Capture/Compare 2 interrupt */
   1055                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF022 0x0204      BIC      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1056              }
   1057              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
   1058              
   1059              case TIM_CHANNEL_3:
   1060              {
   1061                /* Disable the TIM Capture/Compare 3 interrupt */
   1062                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF022 0x0208      BIC      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1063              }
   1064              break;
   \   00000038   0xE004             B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
   1065              
   1066              case TIM_CHANNEL_4:
   1067              {
   1068                /* Disable the TIM Capture/Compare 3 interrupt */
   1069                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1070              }
   1071              break;
   1072              
   1073              default:
   1074              break; 
   1075            }
   1076            
   1077            /* Disable the complementary PWM output  */
   1078            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1079            
   1080            /* Disable the TIM Break interrupt (only if no more channel is active) */
   1081            if((READ_REG(htim->Instance->CCER) & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0xF240 0x4044      MOVW     R0,#+1092
   \   00000052   0x6A0A             LDR      R2,[R1, #+32]
   \   00000054   0x4202             TST      R2,R0
   \   00000056   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_5
   1082            {
   1083              __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
   \   00000058   0x68CA             LDR      R2,[R1, #+12]
   \   0000005A   0xF022 0x0280      BIC      R2,R2,#0x80
   \   0000005E   0x60CA             STR      R2,[R1, #+12]
   1084            }
   1085            
   1086            /* Disable the Main Output */
   1087            __HAL_TIM_MOE_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_5: (+1)
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0xF241 0x1211      MOVW     R2,#+4369
   \   00000066   0x6A0B             LDR      R3,[R1, #+32]
   \   00000068   0x4213             TST      R3,R2
   \   0000006A   0xD106             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_6
   \   0000006C   0x6A0B             LDR      R3,[R1, #+32]
   \   0000006E   0x4203             TST      R3,R0
   \   00000070   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_6
   \   00000072   0x6C4B             LDR      R3,[R1, #+68]
   \   00000074   0xF423 0x4300      BIC      R3,R3,#0x8000
   \   00000078   0x644B             STR      R3,[R1, #+68]
   1088            
   1089            /* Disable the Peripheral */
   1090            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_6: (+1)
   \   0000007A   0x6821             LDR      R1,[R4, #+0]
   \   0000007C   0x6A0B             LDR      R3,[R1, #+32]
   \   0000007E   0x4213             TST      R3,R2
   \   00000080   0xD106             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_7
   \   00000082   0x6A0A             LDR      R2,[R1, #+32]
   \   00000084   0x4202             TST      R2,R0
   \   00000086   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_7
   \   00000088   0x6808             LDR      R0,[R1, #+0]
   \   0000008A   0x0840             LSRS     R0,R0,#+1
   \   0000008C   0x0040             LSLS     R0,R0,#+1
   \   0000008E   0x6008             STR      R0,[R1, #+0]
   1091            
   1092            /* Return function status */
   1093            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Stop_IT_7: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xBD10             POP      {R4,PC}          ;; return
   1094          } 
   1095          
   1096          /**
   1097            * @brief  Starts the TIM PWM signal generation in DMA mode on the 
   1098            *         complementary output
   1099            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1100            *                the configuration information for TIM module.
   1101            * @param  Channel: TIM Channel to be enabled.
   1102            *          This parameter can be one of the following values:
   1103            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1104            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1105            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1106            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1107            * @param  pData: The source Buffer address.
   1108            * @param  Length: The length of data to be transferred from memory to TIM peripheral
   1109            * @retval HAL status
   1110            */

   \                                 In section .text, align 2, keep-with-next
   1111          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1112          {
   \                     HAL_TIMEx_PWMN_Start_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4611             MOV      R1,R2
   1113            /* Check the parameters */
   1114            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
   1115            
   1116            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_0
   1117            {
   1118               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}
   1119            }
   1120            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIMEx_PWMN_Start_DMA_0: (+1)
   \   00000014   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD108             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_1
   1121            {
   1122              if(((uint32_t)pData == 0U) && (Length > 0U)) 
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_2
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD001             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_2
   1123              {
   1124                return HAL_ERROR;                                    
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
   1125              }
   1126              else
   1127              {
   1128                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
   1129              }
   1130            }    
   1131            switch (Channel)
   \                     ??HAL_TIMEx_PWMN_Start_DMA_1: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0xD006             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_3
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD016             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_4
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xD026             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_5
   \   0000003A   0x280C             CMP      R0,#+12
   \   0000003C   0xD036             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_6
   \   0000003E   0xE046             B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
   1132            {
   1133              case TIM_CHANNEL_1:
   1134              {      
   1135                /* Set the DMA Period elapsed callback */
   1136                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_3: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable3_2
   \   00000042   0x6A22             LDR      R2,[R4, #+32]
   \   00000044   0x63D0             STR      R0,[R2, #+60]
   1137               
   1138                /* Set the DMA error callback */
   1139                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000046   0x....             LDR.N    R0,??DataTable3_1
   \   00000048   0x6A22             LDR      R2,[R4, #+32]
   \   0000004A   0x64D0             STR      R0,[R2, #+76]
   1140                
   1141                /* Enable the DMA Stream */
   1142                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0xF100 0x0234      ADD      R2,R0,#+52
   \   00000052   0x6A20             LDR      R0,[R4, #+32]
   \   00000054   0x.... 0x....      BL       HAL_DMA_Start_IT
   1143                
   1144                /* Enable the TIM Capture/Compare 1 DMA request */
   1145                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x68C1             LDR      R1,[R0, #+12]
   \   0000005C   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000060   0x60C1             STR      R1,[R0, #+12]
   1146              }
   1147              break;
   \   00000062   0xE034             B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
   1148              
   1149              case TIM_CHANNEL_2:
   1150              {
   1151                /* Set the DMA Period elapsed callback */
   1152                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_4: (+1)
   \   00000064   0x....             LDR.N    R0,??DataTable3_2
   \   00000066   0x6A62             LDR      R2,[R4, #+36]
   \   00000068   0x63D0             STR      R0,[R2, #+60]
   1153               
   1154                /* Set the DMA error callback */
   1155                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   0000006A   0x....             LDR.N    R0,??DataTable3_1
   \   0000006C   0x6A62             LDR      R2,[R4, #+36]
   \   0000006E   0x64D0             STR      R0,[R2, #+76]
   1156                
   1157                /* Enable the DMA Stream */
   1158                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0xF100 0x0238      ADD      R2,R0,#+56
   \   00000076   0x6A60             LDR      R0,[R4, #+36]
   \   00000078   0x.... 0x....      BL       HAL_DMA_Start_IT
   1159                
   1160                /* Enable the TIM Capture/Compare 2 DMA request */
   1161                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x68C1             LDR      R1,[R0, #+12]
   \   00000080   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000084   0x60C1             STR      R1,[R0, #+12]
   1162              }
   1163              break;
   \   00000086   0xE022             B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
   1164              
   1165              case TIM_CHANNEL_3:
   1166              {
   1167                /* Set the DMA Period elapsed callback */
   1168                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_5: (+1)
   \   00000088   0x....             LDR.N    R0,??DataTable3_2
   \   0000008A   0x6AA2             LDR      R2,[R4, #+40]
   \   0000008C   0x63D0             STR      R0,[R2, #+60]
   1169               
   1170                /* Set the DMA error callback */
   1171                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   0000008E   0x....             LDR.N    R0,??DataTable3_1
   \   00000090   0x6AA2             LDR      R2,[R4, #+40]
   \   00000092   0x64D0             STR      R0,[R2, #+76]
   1172                
   1173                /* Enable the DMA Stream */
   1174                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0xF100 0x023C      ADD      R2,R0,#+60
   \   0000009A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000009C   0x.... 0x....      BL       HAL_DMA_Start_IT
   1175                
   1176                /* Enable the TIM Capture/Compare 3 DMA request */
   1177                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x68C1             LDR      R1,[R0, #+12]
   \   000000A4   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000A8   0x60C1             STR      R1,[R0, #+12]
   1178              }
   1179              break;
   \   000000AA   0xE010             B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
   1180              
   1181              case TIM_CHANNEL_4:
   1182              {
   1183               /* Set the DMA Period elapsed callback */
   1184                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_6: (+1)
   \   000000AC   0x....             LDR.N    R0,??DataTable3_2
   \   000000AE   0x6AE2             LDR      R2,[R4, #+44]
   \   000000B0   0x63D0             STR      R0,[R2, #+60]
   1185               
   1186                /* Set the DMA error callback */
   1187                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000B2   0x....             LDR.N    R0,??DataTable3_1
   \   000000B4   0x6AE2             LDR      R2,[R4, #+44]
   \   000000B6   0x64D0             STR      R0,[R2, #+76]
   1188                
   1189                /* Enable the DMA Stream */
   1190                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0xF100 0x0240      ADD      R2,R0,#+64
   \   000000BE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C0   0x.... 0x....      BL       HAL_DMA_Start_IT
   1191                
   1192                /* Enable the TIM Capture/Compare 4 DMA request */
   1193                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x68C1             LDR      R1,[R0, #+12]
   \   000000C8   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000CC   0x60C1             STR      R1,[R0, #+12]
   1194              }
   1195              break;
   1196              
   1197              default:
   1198              break;
   1199            }
   1200          
   1201            /* Enable the complementary PWM output  */
   1202               TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \                     ??HAL_TIMEx_PWMN_Start_DMA_7: (+1)
   \   000000CE   0x2204             MOVS     R2,#+4
   \   000000D0   0x4629             MOV      R1,R5
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1203              
   1204            /* Enable the Main Output */
   1205              __HAL_TIM_MOE_ENABLE(htim);
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0x6C41             LDR      R1,[R0, #+68]
   \   000000DC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000E0   0x6441             STR      R1,[R0, #+68]
   1206            
   1207            /* Enable the Peripheral */
   1208            __HAL_TIM_ENABLE(htim); 
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x6801             LDR      R1,[R0, #+0]
   \   000000E6   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000EA   0x6001             STR      R1,[R0, #+0]
   1209            
   1210            /* Return function status */
   1211            return HAL_OK;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1212          }
   1213          
   1214          /**
   1215            * @brief  Stops the TIM PWM signal generation in DMA mode on the complementary
   1216            *         output
   1217            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1218            *                the configuration information for TIM module.
   1219            * @param  Channel: TIM Channel to be disabled.
   1220            *          This parameter can be one of the following values:
   1221            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1222            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1223            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1224            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1225            * @retval HAL status
   1226            */

   \                                 In section .text, align 2, keep-with-next
   1227          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1228          {
   \                     HAL_TIMEx_PWMN_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1229            /* Check the parameters */
   1230            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
   1231            
   1232            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_3
   \   00000014   0xE016             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
   1233            {
   1234              case TIM_CHANNEL_1:
   1235              {       
   1236                /* Disable the TIM Capture/Compare 1 DMA request */
   1237                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF422 0x7200      BIC      R2,R2,#0x200
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1238              }
   1239              break;
   \   00000020   0xE010             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
   1240              
   1241              case TIM_CHANNEL_2:
   1242              {
   1243                /* Disable the TIM Capture/Compare 2 DMA request */
   1244                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1245              }
   1246              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
   1247              
   1248              case TIM_CHANNEL_3:
   1249              {
   1250                /* Disable the TIM Capture/Compare 3 DMA request */
   1251                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1252              }
   1253              break;
   \   00000038   0xE004             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
   1254              
   1255              case TIM_CHANNEL_4:
   1256              {
   1257                /* Disable the TIM Capture/Compare 4 DMA request */
   1258                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1259              }
   1260              break;
   1261              
   1262              default:
   1263              break;
   1264            } 
   1265            
   1266            /* Disable the complementary PWM output */
   1267              TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1268               
   1269            /* Disable the Main Output */
   1270              __HAL_TIM_MOE_DISABLE(htim);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000052   0x6A02             LDR      R2,[R0, #+32]
   \   00000054   0x420A             TST      R2,R1
   \   00000056   0xD108             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_5
   \   00000058   0x6A02             LDR      R2,[R0, #+32]
   \   0000005A   0xF240 0x4344      MOVW     R3,#+1092
   \   0000005E   0x421A             TST      R2,R3
   \   00000060   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_5
   \   00000062   0x6C42             LDR      R2,[R0, #+68]
   \   00000064   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000068   0x6442             STR      R2,[R0, #+68]
   1271          
   1272            /* Disable the Peripheral */
   1273            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_5: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6A02             LDR      R2,[R0, #+32]
   \   0000006E   0x420A             TST      R2,R1
   \   00000070   0xD108             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_6
   \   00000072   0x6A01             LDR      R1,[R0, #+32]
   \   00000074   0xF240 0x4244      MOVW     R2,#+1092
   \   00000078   0x4211             TST      R1,R2
   \   0000007A   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_6
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0x0849             LSRS     R1,R1,#+1
   \   00000080   0x0049             LSLS     R1,R1,#+1
   \   00000082   0x6001             STR      R1,[R0, #+0]
   1274            
   1275            /* Change the htim state */
   1276            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_6: (+1)
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xF884 0x0039      STRB     R0,[R4, #+57]
   1277            
   1278            /* Return function status */
   1279            return HAL_OK;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xBD10             POP      {R4,PC}          ;; return
   1280          }
   1281          
   1282          /**
   1283            * @}
   1284            */
   1285            
   1286          /** @defgroup TIMEx_Exported_Functions_Group4 Timer Complementary One Pulse functions
   1287           *  @brief    Timer Complementary One Pulse functions 
   1288           *
   1289          @verbatim   
   1290            ==============================================================================
   1291                          ##### Timer Complementary One Pulse functions #####
   1292            ==============================================================================  
   1293            [..]  
   1294              This section provides functions allowing to:
   1295              (+) Start the Complementary One Pulse generation.
   1296              (+) Stop the Complementary One Pulse.
   1297              (+) Start the Complementary One Pulse and enable interrupts.
   1298              (+) Stop the Complementary One Pulse and disable interrupts.
   1299                         
   1300          @endverbatim
   1301            * @{
   1302            */
   1303          
   1304          /**
   1305            * @brief  Starts the TIM One Pulse signal generation on the complementary 
   1306            *         output.
   1307            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1308            *                the configuration information for TIM module.
   1309            * @param  OutputChannel: TIM Channel to be enabled.
   1310            *          This parameter can be one of the following values:
   1311            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1312            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1313            * @retval HAL status
   1314            */

   \                                 In section .text, align 2, keep-with-next
   1315          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1316            {
   \                     HAL_TIMEx_OnePulseN_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1317            /* Check the parameters */
   1318            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
   1319            
   1320            /* Enable the complementary One Pulse output */
   1321            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE); 
   \   00000004   0x2204             MOVS     R2,#+4
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1322            
   1323            /* Enable the Main Output */
   1324            __HAL_TIM_MOE_ENABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6C41             LDR      R1,[R0, #+68]
   \   00000010   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000014   0x6441             STR      R1,[R0, #+68]
   1325            
   1326            /* Return function status */
   1327            return HAL_OK;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1328          }
   1329          
   1330          /**
   1331            * @brief  Stops the TIM One Pulse signal generation on the complementary 
   1332            *         output.
   1333            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1334            *                the configuration information for TIM module.
   1335            * @param  OutputChannel: TIM Channel to be disabled.
   1336            *          This parameter can be one of the following values:
   1337            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1338            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1339            * @retval HAL status
   1340            */

   \                                 In section .text, align 2, keep-with-next
   1341          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1342          {
   \                     HAL_TIMEx_OnePulseN_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1343          
   1344            /* Check the parameters */
   1345            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
   1346          
   1347            /* Disable the complementary One Pulse output */
   1348              TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1349            
   1350            /* Disable the Main Output */
   1351              __HAL_TIM_MOE_DISABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x6A02             LDR      R2,[R0, #+32]
   \   00000014   0x420A             TST      R2,R1
   \   00000016   0xD108             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_0
   \   00000018   0x6A02             LDR      R2,[R0, #+32]
   \   0000001A   0xF240 0x4344      MOVW     R3,#+1092
   \   0000001E   0x421A             TST      R2,R3
   \   00000020   0xD103             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_0
   \   00000022   0x6C42             LDR      R2,[R0, #+68]
   \   00000024   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000028   0x6442             STR      R2,[R0, #+68]
   1352            
   1353            /* Disable the Peripheral */
   1354            __HAL_TIM_DISABLE(htim); 
   \                     ??HAL_TIMEx_OnePulseN_Stop_0: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6A02             LDR      R2,[R0, #+32]
   \   0000002E   0x420A             TST      R2,R1
   \   00000030   0xD108             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_1
   \   00000032   0x6A01             LDR      R1,[R0, #+32]
   \   00000034   0xF240 0x4244      MOVW     R2,#+1092
   \   00000038   0x4211             TST      R1,R2
   \   0000003A   0xD103             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_1
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x0849             LSRS     R1,R1,#+1
   \   00000040   0x0049             LSLS     R1,R1,#+1
   \   00000042   0x6001             STR      R1,[R0, #+0]
   1355             
   1356            /* Return function status */
   1357            return HAL_OK;
   \                     ??HAL_TIMEx_OnePulseN_Stop_1: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
   1358          }
   1359          
   1360          /**
   1361            * @brief  Starts the TIM One Pulse signal generation in interrupt mode on the
   1362            *         complementary channel.
   1363            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1364            *                the configuration information for TIM module.
   1365            * @param  OutputChannel: TIM Channel to be enabled.
   1366            *          This parameter can be one of the following values:
   1367            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1368            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1369            * @retval HAL status
   1370            */

   \                                 In section .text, align 2, keep-with-next
   1371          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1372          {
   \                     HAL_TIMEx_OnePulseN_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1373            /* Check the parameters */
   1374            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
   1375          
   1376            /* Enable the TIM Capture/Compare 1 interrupt */
   1377            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C2             LDR      R2,[R0, #+12]
   \   00000008   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000000C   0x60C2             STR      R2,[R0, #+12]
   1378            
   1379            /* Enable the TIM Capture/Compare 2 interrupt */
   1380            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x68C2             LDR      R2,[R0, #+12]
   \   00000012   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000016   0x60C2             STR      R2,[R0, #+12]
   1381            
   1382            /* Enable the complementary One Pulse output */
   1383            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE); 
   \   00000018   0x2204             MOVS     R2,#+4
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1384            
   1385            /* Enable the Main Output */
   1386            __HAL_TIM_MOE_ENABLE(htim);
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6C41             LDR      R1,[R0, #+68]
   \   00000024   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000028   0x6441             STR      R1,[R0, #+68]
   1387            
   1388            /* Return function status */
   1389            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
   1390            } 
   1391            
   1392          /**
   1393            * @brief  Stops the TIM One Pulse signal generation in interrupt mode on the
   1394            *         complementary channel.
   1395            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1396            *                the configuration information for TIM module.
   1397            * @param  OutputChannel: TIM Channel to be disabled.
   1398            *          This parameter can be one of the following values:
   1399            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1400            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1401            * @retval HAL status
   1402            */

   \                                 In section .text, align 2, keep-with-next
   1403          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1404          {
   \                     HAL_TIMEx_OnePulseN_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1405            /* Check the parameters */
   1406            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
   1407          
   1408            /* Disable the TIM Capture/Compare 1 interrupt */
   1409            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C2             LDR      R2,[R0, #+12]
   \   00000008   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000000C   0x60C2             STR      R2,[R0, #+12]
   1410            
   1411            /* Disable the TIM Capture/Compare 2 interrupt */
   1412            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x68C2             LDR      R2,[R0, #+12]
   \   00000012   0xF022 0x0204      BIC      R2,R2,#0x4
   \   00000016   0x60C2             STR      R2,[R0, #+12]
   1413            
   1414            /* Disable the complementary One Pulse output */
   1415            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1416            
   1417            /* Disable the Main Output */
   1418            __HAL_TIM_MOE_DISABLE(htim);
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0xF241 0x1111      MOVW     R1,#+4369
   \   00000026   0x6A02             LDR      R2,[R0, #+32]
   \   00000028   0x420A             TST      R2,R1
   \   0000002A   0xD108             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_0
   \   0000002C   0x6A02             LDR      R2,[R0, #+32]
   \   0000002E   0xF240 0x4344      MOVW     R3,#+1092
   \   00000032   0x421A             TST      R2,R3
   \   00000034   0xD103             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_0
   \   00000036   0x6C42             LDR      R2,[R0, #+68]
   \   00000038   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   0000003C   0x6442             STR      R2,[R0, #+68]
   1419            
   1420            /* Disable the Peripheral */
   1421             __HAL_TIM_DISABLE(htim);  
   \                     ??HAL_TIMEx_OnePulseN_Stop_IT_0: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6A02             LDR      R2,[R0, #+32]
   \   00000042   0x420A             TST      R2,R1
   \   00000044   0xD108             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_1
   \   00000046   0x6A01             LDR      R1,[R0, #+32]
   \   00000048   0xF240 0x4244      MOVW     R2,#+1092
   \   0000004C   0x4211             TST      R1,R2
   \   0000004E   0xD103             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_1
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x0849             LSRS     R1,R1,#+1
   \   00000054   0x0049             LSLS     R1,R1,#+1
   \   00000056   0x6001             STR      R1,[R0, #+0]
   1422            
   1423            /* Return function status */
   1424            return HAL_OK;
   \                     ??HAL_TIMEx_OnePulseN_Stop_IT_1: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
   1425          }
   1426          /**
   1427            * @}
   1428            */
   1429            
   1430          /** @defgroup TIMEx_Exported_Functions_Group5 Peripheral Control functions
   1431           *  @brief   	Peripheral Control functions 
   1432           *
   1433          @verbatim   
   1434            ==============================================================================
   1435                              ##### Peripheral Control functions #####
   1436            ==============================================================================  
   1437            [..]  
   1438              This section provides functions allowing to:
   1439              (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode. 
   1440              (+) Configure External Clock source.
   1441              (+) Configure Complementary channels, break features and dead time.
   1442              (+) Configure Master and the Slave synchronization.
   1443              (+) Configure the commutation event in case of use of the Hall sensor interface.
   1444              (+) Configure the DMA Burst Mode.
   1445                
   1446          @endverbatim
   1447            * @{
   1448            */
   1449          /**
   1450            * @brief  Configure the TIM commutation event sequence.
   1451            * @note  This function is mandatory to use the commutation event in order to 
   1452            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1453            *        the typical use of this feature is with the use of another Timer(interface Timer) 
   1454            *        configured in Hall sensor interface, this interface Timer will generate the 
   1455            *        commutation at its TRGO output (connected to Timer used in this function) each time 
   1456            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1457            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1458            *                the configuration information for TIM module.
   1459            * @param  InputTrigger: the Internal trigger corresponding to the Timer Interfacing with the Hall sensor.
   1460            *          This parameter can be one of the following values:
   1461            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1462            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1463            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1464            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1465            *            @arg TIM_TS_NONE: No trigger is needed  
   1466            * @param  CommutationSource: the Commutation Event source.
   1467            *          This parameter can be one of the following values:
   1468            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1469            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1470            * @retval HAL status
   1471            */

   \                                 In section .text, align 2, keep-with-next
   1472          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
   1473          {
   \                     HAL_TIMEx_ConfigCommutationEvent: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1474            /* Check the parameters */
   1475            assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
   1476            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1477            
   1478            __HAL_LOCK(htim);
   \   00000002   0xF990 0x3038      LDRSB    R3,[R0, #+56]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE025             B.N      ??HAL_TIMEx_ConfigCommutationEvent_1
   \                     ??HAL_TIMEx_ConfigCommutationEvent_0: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF880 0x3038      STRB     R3,[R0, #+56]
   1479            
   1480            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1481                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD005             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_2
   \   00000018   0x2910             CMP      R1,#+16
   \   0000001A   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_2
   \   0000001C   0x2920             CMP      R1,#+32
   \   0000001E   0xD001             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_2
   \   00000020   0x2930             CMP      R1,#+48
   \   00000022   0xD108             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_3
   1482            {    
   1483              /* Select the Input trigger */
   1484              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_2: (+1)
   \   00000024   0x6803             LDR      R3,[R0, #+0]
   \   00000026   0x689C             LDR      R4,[R3, #+8]
   \   00000028   0xF024 0x0470      BIC      R4,R4,#0x70
   \   0000002C   0x609C             STR      R4,[R3, #+8]
   1485              htim->Instance->SMCR |= InputTrigger;
   \   0000002E   0x6803             LDR      R3,[R0, #+0]
   \   00000030   0x689C             LDR      R4,[R3, #+8]
   \   00000032   0x4321             ORRS     R1,R1,R4
   \   00000034   0x6099             STR      R1,[R3, #+8]
   1486            }
   1487              
   1488            /* Select the Capture Compare preload feature */
   1489            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_3: (+1)
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0x684B             LDR      R3,[R1, #+4]
   \   0000003A   0xF043 0x0301      ORR      R3,R3,#0x1
   \   0000003E   0x604B             STR      R3,[R1, #+4]
   1490            /* Select the Commutation event source */
   1491            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0x684B             LDR      R3,[R1, #+4]
   \   00000044   0xF023 0x0304      BIC      R3,R3,#0x4
   \   00000048   0x604B             STR      R3,[R1, #+4]
   1492            htim->Instance->CR2 |= CommutationSource;
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0x684B             LDR      R3,[R1, #+4]
   \   0000004E   0x431A             ORRS     R2,R2,R3
   \   00000050   0x604A             STR      R2,[R1, #+4]
   1493              
   1494            __HAL_UNLOCK(htim);
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0xF880 0x1038      STRB     R1,[R0, #+56]
   1495            
   1496            return HAL_OK;
   \   00000058   0x4608             MOV      R0,R1
   \                     ??HAL_TIMEx_ConfigCommutationEvent_1: (+1)
   \   0000005A   0xBC10             POP      {R4}
   \   0000005C   0x4770             BX       LR               ;; return
   1497          }
   1498          
   1499          /**
   1500            * @brief  Configure the TIM commutation event sequence with interrupt.
   1501            * @note  This function is mandatory to use the commutation event in order to 
   1502            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1503            *        the typical use of this feature is with the use of another Timer(interface Timer) 
   1504            *        configured in Hall sensor interface, this interface Timer will generate the 
   1505            *        commutation at its TRGO output (connected to Timer used in this function) each time 
   1506            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1507            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1508            *                the configuration information for TIM module.
   1509            * @param  InputTrigger: the Internal trigger corresponding to the Timer Interfacing with the Hall sensor.
   1510            *          This parameter can be one of the following values:
   1511            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1512            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1513            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1514            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1515            *            @arg TIM_TS_NONE: No trigger is needed
   1516            * @param  CommutationSource: the Commutation Event source.
   1517            *          This parameter can be one of the following values:
   1518            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1519            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1520            * @retval HAL status
   1521            */

   \                                 In section .text, align 2, keep-with-next
   1522          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
   1523          {
   \                     HAL_TIMEx_ConfigCommutationEvent_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1524            /* Check the parameters */
   1525            assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
   1526            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1527            
   1528            __HAL_LOCK(htim);
   \   00000002   0xF990 0x3038      LDRSB    R3,[R0, #+56]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE02A             B.N      ??HAL_TIMEx_ConfigCommutationEvent_IT_1
   \                     ??HAL_TIMEx_ConfigCommutationEvent_IT_0: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF880 0x3038      STRB     R3,[R0, #+56]
   1529            
   1530            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1531                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD005             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_2
   \   00000018   0x2910             CMP      R1,#+16
   \   0000001A   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_2
   \   0000001C   0x2920             CMP      R1,#+32
   \   0000001E   0xD001             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_2
   \   00000020   0x2930             CMP      R1,#+48
   \   00000022   0xD108             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_3
   1532            {    
   1533              /* Select the Input trigger */
   1534              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_IT_2: (+1)
   \   00000024   0x6803             LDR      R3,[R0, #+0]
   \   00000026   0x689C             LDR      R4,[R3, #+8]
   \   00000028   0xF024 0x0470      BIC      R4,R4,#0x70
   \   0000002C   0x609C             STR      R4,[R3, #+8]
   1535              htim->Instance->SMCR |= InputTrigger;
   \   0000002E   0x6803             LDR      R3,[R0, #+0]
   \   00000030   0x689C             LDR      R4,[R3, #+8]
   \   00000032   0x4321             ORRS     R1,R1,R4
   \   00000034   0x6099             STR      R1,[R3, #+8]
   1536            }
   1537            
   1538            /* Select the Capture Compare preload feature */
   1539            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_IT_3: (+1)
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0x684B             LDR      R3,[R1, #+4]
   \   0000003A   0xF043 0x0301      ORR      R3,R3,#0x1
   \   0000003E   0x604B             STR      R3,[R1, #+4]
   1540            /* Select the Commutation event source */
   1541            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0x684B             LDR      R3,[R1, #+4]
   \   00000044   0xF023 0x0304      BIC      R3,R3,#0x4
   \   00000048   0x604B             STR      R3,[R1, #+4]
   1542            htim->Instance->CR2 |= CommutationSource;
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0x684B             LDR      R3,[R1, #+4]
   \   0000004E   0x431A             ORRS     R2,R2,R3
   \   00000050   0x604A             STR      R2,[R1, #+4]
   1543              
   1544            /* Enable the Commutation Interrupt Request */
   1545            __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0x68CA             LDR      R2,[R1, #+12]
   \   00000056   0xF042 0x0220      ORR      R2,R2,#0x20
   \   0000005A   0x60CA             STR      R2,[R1, #+12]
   1546          
   1547            __HAL_UNLOCK(htim);
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1548            
   1549            return HAL_OK;
   \   00000062   0x4608             MOV      R0,R1
   \                     ??HAL_TIMEx_ConfigCommutationEvent_IT_1: (+1)
   \   00000064   0xBC10             POP      {R4}
   \   00000066   0x4770             BX       LR               ;; return
   1550          }
   1551          
   1552          /**
   1553            * @brief  Configure the TIM commutation event sequence with DMA.
   1554            * @note  This function is mandatory to use the commutation event in order to 
   1555            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1556            *        the typical use of this feature is with the use of another Timer(interface Timer) 
   1557            *        configured in Hall sensor interface, this interface Timer will generate the 
   1558            *        commutation at its TRGO output (connected to Timer used in this function) each time 
   1559            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1560            * @note: The user should configure the DMA in his own software, in This function only the COMDE bit is set
   1561            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1562            *                the configuration information for TIM module.
   1563            * @param  InputTrigger: the Internal trigger corresponding to the Timer Interfacing with the Hall sensor.
   1564            *          This parameter can be one of the following values:
   1565            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1566            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1567            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1568            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1569            *            @arg TIM_TS_NONE: No trigger is needed
   1570            * @param  CommutationSource: the Commutation Event source.
   1571            *          This parameter can be one of the following values:
   1572            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1573            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1574            * @retval HAL status
   1575            */

   \                                 In section .text, align 2, keep-with-next
   1576          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
   1577          {
   \                     HAL_TIMEx_ConfigCommutationEvent_DMA: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1578            /* Check the parameters */
   1579            assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
   1580            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1581            
   1582            __HAL_LOCK(htim);
   \   00000002   0xF990 0x3038      LDRSB    R3,[R0, #+56]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE031             B.N      ??HAL_TIMEx_ConfigCommutationEvent_DMA_1
   \                     ??HAL_TIMEx_ConfigCommutationEvent_DMA_0: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF880 0x3038      STRB     R3,[R0, #+56]
   1583            
   1584            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1585                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD005             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_2
   \   00000018   0x2910             CMP      R1,#+16
   \   0000001A   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_2
   \   0000001C   0x2920             CMP      R1,#+32
   \   0000001E   0xD001             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_2
   \   00000020   0x2930             CMP      R1,#+48
   \   00000022   0xD108             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_3
   1586            {    
   1587              /* Select the Input trigger */
   1588              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_DMA_2: (+1)
   \   00000024   0x6803             LDR      R3,[R0, #+0]
   \   00000026   0x689C             LDR      R4,[R3, #+8]
   \   00000028   0xF024 0x0470      BIC      R4,R4,#0x70
   \   0000002C   0x609C             STR      R4,[R3, #+8]
   1589              htim->Instance->SMCR |= InputTrigger;
   \   0000002E   0x6803             LDR      R3,[R0, #+0]
   \   00000030   0x689C             LDR      R4,[R3, #+8]
   \   00000032   0x4321             ORRS     R1,R1,R4
   \   00000034   0x6099             STR      R1,[R3, #+8]
   1590            }
   1591            
   1592            /* Select the Capture Compare preload feature */
   1593            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_DMA_3: (+1)
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0x684B             LDR      R3,[R1, #+4]
   \   0000003A   0xF043 0x0301      ORR      R3,R3,#0x1
   \   0000003E   0x604B             STR      R3,[R1, #+4]
   1594            /* Select the Commutation event source */
   1595            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0x684B             LDR      R3,[R1, #+4]
   \   00000044   0xF023 0x0304      BIC      R3,R3,#0x4
   \   00000048   0x604B             STR      R3,[R1, #+4]
   1596            htim->Instance->CR2 |= CommutationSource;
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0x684B             LDR      R3,[R1, #+4]
   \   0000004E   0x431A             ORRS     R2,R2,R3
   \   00000050   0x604A             STR      R2,[R1, #+4]
   1597            
   1598            /* Enable the Commutation DMA Request */
   1599            /* Set the DMA Commutation Callback */
   1600            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;     
   \   00000052   0x.... 0x....      ADR.W    R1,TIMEx_DMACommutationCplt
   \   00000056   0x6B02             LDR      R2,[R0, #+48]
   \   00000058   0x63D1             STR      R1,[R2, #+60]
   1601            /* Set the DMA error callback */
   1602            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
   \   0000005A   0x....             LDR.N    R1,??DataTable3_1
   \   0000005C   0x6B02             LDR      R2,[R0, #+48]
   \   0000005E   0x64D1             STR      R1,[R2, #+76]
   1603            
   1604            /* Enable the Commutation DMA Request */
   1605            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0x68CA             LDR      R2,[R1, #+12]
   \   00000064   0xF442 0x5200      ORR      R2,R2,#0x2000
   \   00000068   0x60CA             STR      R2,[R1, #+12]
   1606          
   1607            __HAL_UNLOCK(htim);
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0xF880 0x1038      STRB     R1,[R0, #+56]
   1608            
   1609            return HAL_OK;
   \   00000070   0x4608             MOV      R0,R1
   \                     ??HAL_TIMEx_ConfigCommutationEvent_DMA_1: (+1)
   \   00000072   0xBC10             POP      {R4}
   \   00000074   0x4770             BX       LR               ;; return
   1610          }
   1611          
   1612          /**
   1613            * @brief  Configures the TIM in master mode.
   1614            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1615            *                the configuration information for TIM module.   
   1616            * @param  sMasterConfig: pointer to a TIM_MasterConfigTypeDef structure that
   1617            *         contains the selected trigger output (TRGO) and the Master/Slave 
   1618            *         mode. 
   1619            * @retval HAL status
   1620            */

   \                                 In section .text, align 2, keep-with-next
   1621          HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
   1622          {
   \                     HAL_TIMEx_MasterConfigSynchronization: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1623            /* Check the parameters */
   1624            assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   1625            assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
   1626            assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
   1627            
   1628            __HAL_LOCK(htim);
   \   00000002   0xF990 0x2038      LDRSB    R2,[R0, #+56]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIMEx_MasterConfigSynchronization_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE020             B.N      ??HAL_TIMEx_MasterConfigSynchronization_1
   \                     ??HAL_TIMEx_MasterConfigSynchronization_0: (+1)
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0xF880 0x2038      STRB     R2,[R0, #+56]
   1629            
   1630            htim->State = HAL_TIM_STATE_BUSY;
   \   00000014   0x2202             MOVS     R2,#+2
   \   00000016   0xF880 0x2039      STRB     R2,[R0, #+57]
   1631          
   1632            /* Reset the MMS Bits */
   1633            htim->Instance->CR2 &= ~TIM_CR2_MMS;
   \   0000001A   0x6802             LDR      R2,[R0, #+0]
   \   0000001C   0x6853             LDR      R3,[R2, #+4]
   \   0000001E   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000022   0x6053             STR      R3,[R2, #+4]
   1634            /* Select the TRGO source */
   1635            htim->Instance->CR2 |= sMasterConfig->MasterOutputTrigger;
   \   00000024   0x6802             LDR      R2,[R0, #+0]
   \   00000026   0x6853             LDR      R3,[R2, #+4]
   \   00000028   0x680C             LDR      R4,[R1, #+0]
   \   0000002A   0x4323             ORRS     R3,R4,R3
   \   0000002C   0x6053             STR      R3,[R2, #+4]
   1636          
   1637            /* Reset the MSM Bit */
   1638            htim->Instance->SMCR &= ~TIM_SMCR_MSM;
   \   0000002E   0x6802             LDR      R2,[R0, #+0]
   \   00000030   0x6893             LDR      R3,[R2, #+8]
   \   00000032   0xF023 0x0380      BIC      R3,R3,#0x80
   \   00000036   0x6093             STR      R3,[R2, #+8]
   1639            /* Set or Reset the MSM Bit */
   1640            htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
   \   00000038   0x6802             LDR      R2,[R0, #+0]
   \   0000003A   0x6893             LDR      R3,[R2, #+8]
   \   0000003C   0x6849             LDR      R1,[R1, #+4]
   \   0000003E   0x4319             ORRS     R1,R1,R3
   \   00000040   0x6091             STR      R1,[R2, #+8]
   1641            
   1642            htim->State = HAL_TIM_STATE_READY;
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0xF880 0x1039      STRB     R1,[R0, #+57]
   1643            
   1644            __HAL_UNLOCK(htim);
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xF880 0x1038      STRB     R1,[R0, #+56]
   1645            
   1646            return HAL_OK;
   \   0000004E   0x4608             MOV      R0,R1
   \                     ??HAL_TIMEx_MasterConfigSynchronization_1: (+1)
   \   00000050   0xBC10             POP      {R4}
   \   00000052   0x4770             BX       LR               ;; return
   1647          } 
   1648                                                               
   1649          /**
   1650            * @brief   Configures the Break feature, dead time, Lock level, OSSI/OSSR State
   1651            *         and the AOE(automatic output enable).
   1652            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1653            *                the configuration information for TIM module.
   1654            * @param  sBreakDeadTimeConfig: pointer to a TIM_ConfigBreakDeadConfig_TypeDef structure that
   1655            *         contains the BDTR Register configuration  information for the TIM peripheral. 
   1656            * @retval HAL status
   1657            */    

   \                                 In section .text, align 2, keep-with-next
   1658          HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim, 
   1659                                                        TIM_BreakDeadTimeConfigTypeDef * sBreakDeadTimeConfig)
   1660          {
   1661            /* Check the parameters */
   1662            assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   1663            assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
   1664            assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
   1665            assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
   1666            assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
   1667            assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
   1668            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
   1669            assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
   1670            
   1671            /* Process Locked */
   1672            __HAL_LOCK(htim);
   \                     HAL_TIMEx_ConfigBreakDeadTime: (+1)
   \   00000000   0xF990 0x2038      LDRSB    R2,[R0, #+56]
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD101             BNE.N    ??HAL_TIMEx_ConfigBreakDeadTime_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_0: (+1)
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xF880 0x2038      STRB     R2,[R0, #+56]
   1673            
   1674            htim->State = HAL_TIM_STATE_BUSY;
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0xF880 0x2039      STRB     R2,[R0, #+57]
   1675          
   1676            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
   1677               the OSSI State, the dead time value and the Automatic Output Enable Bit */
   1678            htim->Instance->BDTR = (uint32_t)sBreakDeadTimeConfig->OffStateRunMode  | 
   1679                                             sBreakDeadTimeConfig->OffStateIDLEMode |
   1680                                             sBreakDeadTimeConfig->LockLevel        |
   1681                                             sBreakDeadTimeConfig->DeadTime         |
   1682                                             sBreakDeadTimeConfig->BreakState       |
   1683                                             sBreakDeadTimeConfig->BreakPolarity    |
   1684                                             sBreakDeadTimeConfig->AutomaticOutput;
   \   00000018   0x680A             LDR      R2,[R1, #+0]
   \   0000001A   0x684B             LDR      R3,[R1, #+4]
   \   0000001C   0x431A             ORRS     R2,R3,R2
   \   0000001E   0x688B             LDR      R3,[R1, #+8]
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x68CB             LDR      R3,[R1, #+12]
   \   00000024   0x431A             ORRS     R2,R3,R2
   \   00000026   0x690B             LDR      R3,[R1, #+16]
   \   00000028   0x431A             ORRS     R2,R3,R2
   \   0000002A   0x694B             LDR      R3,[R1, #+20]
   \   0000002C   0x431A             ORRS     R2,R3,R2
   \   0000002E   0x6989             LDR      R1,[R1, #+24]
   \   00000030   0x4311             ORRS     R1,R1,R2
   \   00000032   0x6802             LDR      R2,[R0, #+0]
   \   00000034   0x6451             STR      R1,[R2, #+68]
   1685            
   1686                                             
   1687            htim->State = HAL_TIM_STATE_READY;                                 
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0xF880 0x1039      STRB     R1,[R0, #+57]
   1688            
   1689            __HAL_UNLOCK(htim);
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1690            
   1691            return HAL_OK;
   \   00000042   0x4608             MOV      R0,R1
   \   00000044   0x4770             BX       LR               ;; return
   1692          }
   1693          
   1694          /**
   1695            * @brief  Configures the TIM2, TIM5 and TIM11 Remapping input capabilities.
   1696            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1697            *                the configuration information for TIM module.
   1698            * @param  Remap: specifies the TIM input remapping source.
   1699            *          This parameter can be one of the following values:
   1700            *            @arg TIM_TIM2_TIM8_TRGO: TIM2 ITR1 input is connected to TIM8 Trigger output(default)
   1701            *            @arg TIM_TIM2_ETH_PTP:   TIM2 ITR1 input is connected to ETH PTP trigger output.
   1702            *            @arg TIM_TIM2_USBFS_SOF: TIM2 ITR1 input is connected to USB FS SOF. 
   1703            *            @arg TIM_TIM2_USBHS_SOF: TIM2 ITR1 input is connected to USB HS SOF. 
   1704            *            @arg TIM_TIM5_GPIO:      TIM5 CH4 input is connected to dedicated Timer pin(default)
   1705            *            @arg TIM_TIM5_LSI:       TIM5 CH4 input is connected to LSI clock.
   1706            *            @arg TIM_TIM5_LSE:       TIM5 CH4 input is connected to LSE clock.
   1707            *            @arg TIM_TIM5_RTC:       TIM5 CH4 input is connected to RTC Output event.
   1708            *            @arg TIM_TIM11_GPIO:     TIM11 CH4 input is connected to dedicated Timer pin(default) 
   1709            *            @arg TIM_TIM11_HSE:      TIM11 CH4 input is connected to HSE_RTC clock
   1710            *                                     (HSE divided by a programmable prescaler)  
   1711            * @retval HAL status
   1712            */

   \                                 In section .text, align 2, keep-with-next
   1713          HAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap)
   1714          {
   1715            __HAL_LOCK(htim);
   \                     HAL_TIMEx_RemapConfig: (+1)
   \   00000000   0xF990 0x2038      LDRSB    R2,[R0, #+56]
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD101             BNE.N    ??HAL_TIMEx_RemapConfig_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_TIMEx_RemapConfig_0: (+1)
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xF880 0x2038      STRB     R2,[R0, #+56]
   1716              
   1717            /* Check parameters */
   1718            assert_param(IS_TIM_REMAP_INSTANCE(htim->Instance));
   1719            assert_param(IS_TIM_REMAP(Remap));
   1720            
   1721            /* Set the Timer remapping configuration */
   1722            htim->Instance->OR = Remap;
   \   00000012   0x6802             LDR      R2,[R0, #+0]
   \   00000014   0x6511             STR      R1,[R2, #+80]
   1723            
   1724            htim->State = HAL_TIM_STATE_READY;
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0xF880 0x1039      STRB     R1,[R0, #+57]
   1725            
   1726            __HAL_UNLOCK(htim);  
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1727            
   1728            return HAL_OK;
   \   00000022   0x4608             MOV      R0,R1
   \   00000024   0x4770             BX       LR               ;; return
   1729          }
   1730          
   1731          /**
   1732            * @}
   1733            */
   1734          
   1735          /** @defgroup TIMEx_Exported_Functions_Group6 Extension Callbacks functions 
   1736           *  @brief   Extension Callbacks functions 
   1737           *
   1738          @verbatim   
   1739            ==============================================================================
   1740                              ##### Extension Callbacks functions #####
   1741            ==============================================================================  
   1742            [..]  
   1743              This section provides Extension TIM callback functions:
   1744              (+) Timer Commutation callback
   1745              (+) Timer Break callback
   1746          
   1747          @endverbatim
   1748            * @{
   1749            */
   1750          
   1751          /**
   1752            * @brief  Hall commutation changed callback in non blocking mode 
   1753            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1754            *                the configuration information for TIM module.
   1755            * @retval None
   1756            */

   \                                 In section .text, align 2, keep-with-next
   1757          __weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
   1758          {
   1759            /* Prevent unused argument(s) compilation warning */
   1760            UNUSED(htim);
   1761            /* NOTE : This function Should not be modified, when the callback is needed,
   1762                      the HAL_TIMEx_CommutationCallback could be implemented in the user file
   1763             */
   1764          }
   \                     HAL_TIMEx_CommutationCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1765          
   1766          /**
   1767            * @brief  Hall Break detection callback in non blocking mode 
   1768            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1769            *                the configuration information for TIM module.
   1770            * @retval None
   1771            */

   \                                 In section .text, align 2, keep-with-next
   1772          __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
   1773          {
   1774            /* Prevent unused argument(s) compilation warning */
   1775            UNUSED(htim);
   1776            /* NOTE : This function Should not be modified, when the callback is needed,
   1777                      the HAL_TIMEx_BreakCallback could be implemented in the user file
   1778             */
   1779          }
   \                     HAL_TIMEx_BreakCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1780          /**
   1781            * @}
   1782            */
   1783          
   1784          /** @defgroup TIMEx_Exported_Functions_Group7 Extension Peripheral State functions 
   1785           *  @brief   Extension Peripheral State functions 
   1786           *
   1787          @verbatim   
   1788            ==============================================================================
   1789                          ##### Extension Peripheral State functions #####
   1790            ==============================================================================  
   1791            [..]
   1792              This subsection permits to get in run-time the status of the peripheral 
   1793              and the data flow.
   1794          
   1795          @endverbatim
   1796            * @{
   1797            */
   1798          
   1799          /**
   1800            * @brief  Return the TIM Hall Sensor interface state
   1801            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1802            *                the configuration information for TIM module.
   1803            * @retval HAL state
   1804            */

   \                                 In section .text, align 2, keep-with-next
   1805          HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
   1806          {
   1807            return htim->State;
   \                     HAL_TIMEx_HallSensor_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   1808          }
   1809          
   1810          /**
   1811            * @}
   1812            */
   1813          
   1814          /**
   1815            * @brief  TIM DMA Commutation callback. 
   1816            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1817            *                the configuration information for the specified DMA module.
   1818            * @retval None
   1819            */

   \                                 In section .text, align 4, keep-with-next
   1820          void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
   1821          {
   \                     TIMEx_DMACommutationCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1822            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   1823            
   1824            htim->State= HAL_TIM_STATE_READY;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF880 0x1039      STRB     R1,[R0, #+57]
   1825              
   1826            HAL_TIMEx_CommutationCallback(htim); 
   \   0000000A   0x.... 0x....      BL       HAL_TIMEx_CommutationCallback
   1827          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   1828          /**
   1829            * @}
   1830            */
   1831            
   1832          /**
   1833            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   1834            * @param  TIMx to select the TIM peripheral
   1835            * @param  Channel: specifies the TIM Channel
   1836            *          This parameter can be one of the following values:
   1837            *            @arg TIM_Channel_1: TIM Channel 1
   1838            *            @arg TIM_Channel_2: TIM Channel 2
   1839            *            @arg TIM_Channel_3: TIM Channel 3
   1840            * @param  ChannelNState: specifies the TIM Channel CCxNE bit new state.
   1841            *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable. 
   1842            * @retval None
   1843            */

   \                                 In section .text, align 2, keep-with-next
   1844          static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState)
   1845          {
   \                     TIM_CCxNChannelCmd: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1846            uint32_t tmp = 0U;
   1847          
   1848            /* Check the parameters */
   1849            assert_param(IS_TIM_CC4_INSTANCE(TIMx));
   1850            assert_param(IS_TIM_COMPLEMENTARY_CHANNELS(Channel));
   1851          
   1852            tmp = TIM_CCER_CC1NE << Channel;
   1853          
   1854            /* Reset the CCxNE Bit */
   1855            TIMx->CCER &= ~tmp;
   \   00000002   0x6A03             LDR      R3,[R0, #+32]
   \   00000004   0x2404             MOVS     R4,#+4
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0x6203             STR      R3,[R0, #+32]
   1856          
   1857            /* Set or reset the CCxNE Bit */ 
   1858            TIMx->CCER |= (uint32_t)(ChannelNState << Channel);
   \   0000000C   0x6A03             LDR      R3,[R0, #+32]
   \   0000000E   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000012   0x4319             ORRS     R1,R1,R3
   \   00000014   0x6201             STR      R1,[R0, #+32]
   1859          }
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     TIM_DMADelayPulseCplt
   1860          
   1861          /**
   1862            * @}
   1863            */
   1864          
   1865          #endif /* HAL_TIM_MODULE_ENABLED */
   1866          /**
   1867            * @}
   1868            */ 
   1869          
   1870          /**
   1871            * @}
   1872            */ 
   1873          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_TIMEx_BreakCallback
       0   HAL_TIMEx_CommutationCallback
       0   HAL_TIMEx_ConfigBreakDeadTime
       4   HAL_TIMEx_ConfigCommutationEvent
       4   HAL_TIMEx_ConfigCommutationEvent_DMA
       4   HAL_TIMEx_ConfigCommutationEvent_IT
       8   HAL_TIMEx_HallSensor_DeInit
         8   -> HAL_TIMEx_HallSensor_MspDeInit
       0   HAL_TIMEx_HallSensor_GetState
      40   HAL_TIMEx_HallSensor_Init
        40   -> HAL_TIMEx_HallSensor_MspInit
        40   -> TIM_Base_SetConfig
        40   -> TIM_OC2_SetConfig
        40   -> TIM_TI1_SetConfig
       0   HAL_TIMEx_HallSensor_MspDeInit
       0   HAL_TIMEx_HallSensor_MspInit
       8   HAL_TIMEx_HallSensor_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIMEx_HallSensor_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Stop_DMA
         8   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Stop_IT
         8   -> TIM_CCxChannelCmd
       4   HAL_TIMEx_MasterConfigSynchronization
       8   HAL_TIMEx_OCN_Start
         8   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OCN_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_OCN_Start_IT
         8   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_OCN_Stop
         8   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_OCN_Stop_DMA
         8   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_OCN_Stop_IT
         8   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_OnePulseN_Start
         8   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_OnePulseN_Start_IT
         8   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_OnePulseN_Stop
         8   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_OnePulseN_Stop_IT
         8   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_PWMN_Start
         8   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_PWMN_Start_IT
         8   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_PWMN_Stop
         8   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_PWMN_Stop_DMA
         8   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_PWMN_Stop_IT
         8   -> TIM_CCxNChannelCmd
       0   HAL_TIMEx_RemapConfig
       8   TIMEx_DMACommutationCplt
         8   -> HAL_TIMEx_CommutationCallback
       4   TIM_CCxNChannelCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       2  HAL_TIMEx_BreakCallback
       2  HAL_TIMEx_CommutationCallback
      70  HAL_TIMEx_ConfigBreakDeadTime
      94  HAL_TIMEx_ConfigCommutationEvent
     118  HAL_TIMEx_ConfigCommutationEvent_DMA
     104  HAL_TIMEx_ConfigCommutationEvent_IT
      58  HAL_TIMEx_HallSensor_DeInit
       6  HAL_TIMEx_HallSensor_GetState
     180  HAL_TIMEx_HallSensor_Init
       2  HAL_TIMEx_HallSensor_MspDeInit
       2  HAL_TIMEx_HallSensor_MspInit
      28  HAL_TIMEx_HallSensor_Start
     112  HAL_TIMEx_HallSensor_Start_DMA
      38  HAL_TIMEx_HallSensor_Start_IT
      48  HAL_TIMEx_HallSensor_Stop
      58  HAL_TIMEx_HallSensor_Stop_DMA
      58  HAL_TIMEx_HallSensor_Stop_IT
      84  HAL_TIMEx_MasterConfigSynchronization
      36  HAL_TIMEx_OCN_Start
     256  HAL_TIMEx_OCN_Start_DMA
     110  HAL_TIMEx_OCN_Start_IT
      72  HAL_TIMEx_OCN_Stop
     142  HAL_TIMEx_OCN_Stop_DMA
     148  HAL_TIMEx_OCN_Stop_IT
      26  HAL_TIMEx_OnePulseN_Start
      46  HAL_TIMEx_OnePulseN_Start_IT
      72  HAL_TIMEx_OnePulseN_Stop
      92  HAL_TIMEx_OnePulseN_Stop_IT
      36  HAL_TIMEx_PWMN_Start
     240  HAL_TIMEx_PWMN_Start_DMA
     110  HAL_TIMEx_PWMN_Start_IT
      72  HAL_TIMEx_PWMN_Stop
     142  HAL_TIMEx_PWMN_Stop_DMA
     148  HAL_TIMEx_PWMN_Stop_IT
      38  HAL_TIMEx_RemapConfig
      16  TIMEx_DMACommutationCplt
      26  TIM_CCxNChannelCmd

 
 2 904 bytes in section .text
 
 2 904 bytes of CODE memory

Errors: none
Warnings: none
