###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:09
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_adc_ex.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_adc_ex.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\stm32f4xx_hal_adc_ex.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\stm32f4xx_hal_adc_ex.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_adc_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_adc_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.5.2
      6            * @date    22-September-2016
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the ADC extension peripheral:
      9            *           + Extended features functions
     10            *         
     11            @verbatim
     12            ==============================================================================
     13                              ##### How to use this driver #####
     14            ==============================================================================
     15              [..]
     16              (#)Initialize the ADC low level resources by implementing the HAL_ADC_MspInit():
     17                 (##) Enable the ADC interface clock using __HAL_RCC_ADC_CLK_ENABLE()
     18                 (##) ADC pins configuration
     19                       (+++) Enable the clock for the ADC GPIOs using the following function:
     20                             __HAL_RCC_GPIOx_CLK_ENABLE()  
     21                       (+++) Configure these ADC pins in analog mode using HAL_GPIO_Init() 
     22                 (##) In case of using interrupts (e.g. HAL_ADC_Start_IT())
     23                       (+++) Configure the ADC interrupt priority using HAL_NVIC_SetPriority()
     24                       (+++) Enable the ADC IRQ handler using HAL_NVIC_EnableIRQ()
     25                       (+++) In ADC IRQ handler, call HAL_ADC_IRQHandler()
     26                (##) In case of using DMA to control data transfer (e.g. HAL_ADC_Start_DMA())
     27                       (+++) Enable the DMAx interface clock using __HAL_RCC_DMAx_CLK_ENABLE()
     28                       (+++) Configure and enable two DMA streams stream for managing data
     29                           transfer from peripheral to memory (output stream)
     30                       (+++) Associate the initialized DMA handle to the ADC DMA handle
     31                           using  __HAL_LINKDMA()
     32                       (+++) Configure the priority and enable the NVIC for the transfer complete
     33                           interrupt on the two DMA Streams. The output stream should have higher
     34                           priority than the input stream.
     35               (#) Configure the ADC Prescaler, conversion resolution and data alignment 
     36                   using the HAL_ADC_Init() function. 
     37            
     38               (#) Configure the ADC Injected channels group features, use HAL_ADC_Init()
     39                   and HAL_ADC_ConfigChannel() functions.
     40                   
     41               (#) Three operation modes are available within this driver :     
     42            
     43               *** Polling mode IO operation ***
     44               =================================
     45               [..]    
     46                 (+) Start the ADC peripheral using HAL_ADCEx_InjectedStart() 
     47                 (+) Wait for end of conversion using HAL_ADC_PollForConversion(), at this stage
     48                     user can specify the value of timeout according to his end application      
     49                 (+) To read the ADC converted values, use the HAL_ADCEx_InjectedGetValue() function.
     50                 (+) Stop the ADC peripheral using HAL_ADCEx_InjectedStop()
     51            
     52               *** Interrupt mode IO operation ***    
     53               ===================================
     54               [..]    
     55                 (+) Start the ADC peripheral using HAL_ADCEx_InjectedStart_IT() 
     56                 (+) Use HAL_ADC_IRQHandler() called under ADC_IRQHandler() Interrupt subroutine
     57                 (+) At ADC end of conversion HAL_ADCEx_InjectedConvCpltCallback() function is executed and user can 
     58                      add his own code by customization of function pointer HAL_ADCEx_InjectedConvCpltCallback 
     59                 (+) In case of ADC Error, HAL_ADCEx_InjectedErrorCallback() function is executed and user can 
     60                      add his own code by customization of function pointer HAL_ADCEx_InjectedErrorCallback
     61                 (+) Stop the ADC peripheral using HAL_ADCEx_InjectedStop_IT()
     62                 
     63                      
     64               *** DMA mode IO operation ***    
     65               ==============================
     66               [..]    
     67                 (+) Start the ADC peripheral using HAL_ADCEx_InjectedStart_DMA(), at this stage the user specify the length 
     68                     of data to be transferred at each end of conversion 
     69                 (+) At The end of data transfer ba HAL_ADCEx_InjectedConvCpltCallback() function is executed and user can 
     70                      add his own code by customization of function pointer HAL_ADCEx_InjectedConvCpltCallback 
     71                 (+) In case of transfer Error, HAL_ADCEx_InjectedErrorCallback() function is executed and user can 
     72                      add his own code by customization of function pointer HAL_ADCEx_InjectedErrorCallback
     73                  (+) Stop the ADC peripheral using HAL_ADCEx_InjectedStop_DMA()
     74                  
     75               *** Multi mode ADCs Regular channels configuration ***
     76               ======================================================
     77               [..]        
     78                 (+) Select the Multi mode ADC regular channels features (dual or triple mode)  
     79                    and configure the DMA mode using HAL_ADCEx_MultiModeConfigChannel() functions. 
     80                 (+) Start the ADC peripheral using HAL_ADCEx_MultiModeStart_DMA(), at this stage the user specify the length 
     81                     of data to be transferred at each end of conversion           
     82                 (+) Read the ADCs converted values using the HAL_ADCEx_MultiModeGetValue() function.
     83            
     84            
     85              @endverbatim
     86            ******************************************************************************
     87            * @attention
     88            *
     89            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     90            *
     91            * Redistribution and use in source and binary forms, with or without modification,
     92            * are permitted provided that the following conditions are met:
     93            *   1. Redistributions of source code must retain the above copyright notice,
     94            *      this list of conditions and the following disclaimer.
     95            *   2. Redistributions in binary form must reproduce the above copyright notice,
     96            *      this list of conditions and the following disclaimer in the documentation
     97            *      and/or other materials provided with the distribution.
     98            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     99            *      may be used to endorse or promote products derived from this software
    100            *      without specific prior written permission.
    101            *
    102            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    103            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    104            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    105            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    106            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    107            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    108            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    109            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    110            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    111            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    112            *
    113            ******************************************************************************
    114            */ 
    115          
    116          /* Includes ------------------------------------------------------------------*/
    117          #include "stm32f4xx_hal.h"
    118          
    119          /** @addtogroup STM32F4xx_HAL_Driver
    120            * @{
    121            */
    122          
    123          /** @defgroup ADCEx ADCEx
    124            * @brief ADC Extended driver modules
    125            * @{
    126            */ 
    127          
    128          #ifdef HAL_ADC_MODULE_ENABLED
    129              
    130          /* Private typedef -----------------------------------------------------------*/
    131          /* Private define ------------------------------------------------------------*/ 
    132          /* Private macro -------------------------------------------------------------*/
    133          /* Private variables ---------------------------------------------------------*/
    134          /** @addtogroup ADCEx_Private_Functions
    135            * @{
    136            */
    137          /* Private function prototypes -----------------------------------------------*/
    138          static void ADC_MultiModeDMAConvCplt(DMA_HandleTypeDef *hdma);
    139          static void ADC_MultiModeDMAError(DMA_HandleTypeDef *hdma);
    140          static void ADC_MultiModeDMAHalfConvCplt(DMA_HandleTypeDef *hdma); 
    141          /**
    142            * @}
    143            */
    144          
    145          /* Exported functions --------------------------------------------------------*/
    146          /** @defgroup ADCEx_Exported_Functions ADC Exported Functions
    147            * @{
    148            */
    149          
    150          /** @defgroup ADCEx_Exported_Functions_Group1  Extended features functions 
    151            *  @brief    Extended features functions  
    152            *
    153          @verbatim   
    154           ===============================================================================
    155                           ##### Extended features functions #####
    156           ===============================================================================  
    157              [..]  This section provides functions allowing to:
    158                (+) Start conversion of injected channel.
    159                (+) Stop conversion of injected channel.
    160                (+) Start multimode and enable DMA transfer.
    161                (+) Stop multimode and disable DMA transfer.
    162                (+) Get result of injected channel conversion.
    163                (+) Get result of multimode conversion.
    164                (+) Configure injected channels.
    165                (+) Configure multimode.
    166                         
    167          @endverbatim
    168            * @{
    169            */
    170          
    171          /**
    172            * @brief  Enables the selected ADC software start conversion of the injected channels.
    173            * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
    174            *         the configuration information for the specified ADC.
    175            * @retval HAL status
    176            */

   \                                 In section .text, align 2, keep-with-next
    177          HAL_StatusTypeDef HAL_ADCEx_InjectedStart(ADC_HandleTypeDef* hadc)
    178          {
   \                     HAL_ADCEx_InjectedStart: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    179            __IO uint32_t counter = 0U;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x9100             STR      R1,[SP, #+0]
    180            uint32_t tmp1 = 0U, tmp2 = 0U;
    181            
    182            /* Process locked */
    183            __HAL_LOCK(hadc);
   \   00000006   0xF990 0x203C      LDRSB    R2,[R0, #+60]
   \   0000000A   0x2A01             CMP      R2,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_ADCEx_InjectedStart_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE064             B.N      ??HAL_ADCEx_InjectedStart_1
   \                     ??HAL_ADCEx_InjectedStart_0: (+1)
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xF880 0x203C      STRB     R2,[R0, #+60]
    184            
    185            /* Enable the ADC peripheral */
    186            
    187            /* Check if ADC peripheral is disabled in order to enable it and wait during 
    188               Tstab time the ADC's stabilization */
    189            if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x6893             LDR      R3,[R2, #+8]
   \   0000001C   0x07DB             LSLS     R3,R3,#+31
   \   0000001E   0xD414             BMI.N    ??HAL_ADCEx_InjectedStart_2
    190            {  
    191              /* Enable the Peripheral */
    192              __HAL_ADC_ENABLE(hadc);
   \   00000020   0x6893             LDR      R3,[R2, #+8]
   \   00000022   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000026   0x6093             STR      R3,[R2, #+8]
    193              
    194              /* Delay for ADC stabilization time */
    195              /* Compute number of CPU cycles to wait for */
    196              counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable6
   \   0000002C   0x6812             LDR      R2,[R2, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R3,??DataTable6_1  ;; 0xf4240
   \   00000032   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000036   0xEB02 0x0242      ADD      R2,R2,R2, LSL #+1
   \   0000003A   0x9200             STR      R2,[SP, #+0]
   \   0000003C   0xE002             B.N      ??HAL_ADCEx_InjectedStart_3
    197              while(counter != 0U)
    198              {
    199                counter--;
   \                     ??HAL_ADCEx_InjectedStart_4: (+1)
   \   0000003E   0x9A00             LDR      R2,[SP, #+0]
   \   00000040   0x1E52             SUBS     R2,R2,#+1
   \   00000042   0x9200             STR      R2,[SP, #+0]
    200              }
   \                     ??HAL_ADCEx_InjectedStart_3: (+1)
   \   00000044   0x9A00             LDR      R2,[SP, #+0]
   \   00000046   0x2A00             CMP      R2,#+0
   \   00000048   0xD1F9             BNE.N    ??HAL_ADCEx_InjectedStart_4
    201            }
    202            
    203            /* Start conversion if ADC is effectively enabled */
    204            if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
   \                     ??HAL_ADCEx_InjectedStart_2: (+1)
   \   0000004A   0x6802             LDR      R2,[R0, #+0]
   \   0000004C   0x6892             LDR      R2,[R2, #+8]
   \   0000004E   0x07D2             LSLS     R2,R2,#+31
   \   00000050   0xD543             BPL.N    ??HAL_ADCEx_InjectedStart_5
    205            {
    206              /* Set ADC state                                                          */
    207              /* - Clear state bitfield related to injected group conversion results    */
    208              /* - Set state bitfield related to injected operation                     */
    209              ADC_STATE_CLR_SET(hadc->State,
    210                                HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
    211                                HAL_ADC_STATE_INJ_BUSY);
   \   00000052   0x6C02             LDR      R2,[R0, #+64]
   \   00000054   0x.... 0x....      LDR.W    R3,??DataTable6_2  ;; 0xffffdffe
   \   00000058   0x401A             ANDS     R2,R3,R2
   \   0000005A   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000005E   0x6402             STR      R2,[R0, #+64]
    212              
    213              /* Check if a regular conversion is ongoing */
    214              /* Note: On this device, there is no ADC error code fields related to     */
    215              /*       conversions on group injected only. In case of conversion on     */
    216              /*       going on group regular, no error code is reset.                  */
    217              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
   \   00000060   0x6C02             LDR      R2,[R0, #+64]
   \   00000062   0x05D2             LSLS     R2,R2,#+23
   \   00000064   0xD401             BMI.N    ??HAL_ADCEx_InjectedStart_6
    218              {
    219                /* Reset ADC all error code fields */
    220                ADC_CLEAR_ERRORCODE(hadc);
   \   00000066   0x460A             MOV      R2,R1
   \   00000068   0x6442             STR      R2,[R0, #+68]
    221              }
    222              
    223              /* Process unlocked */
    224              /* Unlock before starting ADC conversions: in case of potential           */
    225              /* interruption, to let the process to ADC IRQ Handler.                   */
    226              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedStart_6: (+1)
   \   0000006A   0x460A             MOV      R2,R1
   \   0000006C   0xF880 0x203C      STRB     R2,[R0, #+60]
    227              
    228              /* Clear injected group conversion flag */
    229              /* (To ensure of no unknown state from potential previous ADC operations) */
    230              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
   \   00000070   0xF06F 0x0204      MVN      R2,#+4
   \   00000074   0x6803             LDR      R3,[R0, #+0]
   \   00000076   0x601A             STR      R2,[R3, #+0]
    231              
    232              /* Check if Multimode enabled */
    233              if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x.... 0x....      LDR.W    R2,??DataTable6_3  ;; 0x40012304
   \   0000007E   0x6812             LDR      R2,[R2, #+0]
   \   00000080   0xF012 0x0F1F      TST      R2,#0x1F
   \   00000084   0x6882             LDR      R2,[R0, #+8]
   \   00000086   0xD112             BNE.N    ??HAL_ADCEx_InjectedStart_7
    234              {
    235                tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
   \   00000088   0xF412 0x1F40      TST      R2,#0x300000
   \   0000008C   0xD100             BNE.N    ??HAL_ADCEx_InjectedStart_8
   \   0000008E   0x2101             MOVS     R1,#+1
    236                tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
   \                     ??HAL_ADCEx_InjectedStart_8: (+1)
   \   00000090   0x6842             LDR      R2,[R0, #+4]
   \   00000092   0x0A92             LSRS     R2,R2,#+10
   \   00000094   0xF002 0x0201      AND      R2,R2,#0x1
   \   00000098   0xF082 0x0201      EOR      R2,R2,#0x1
    237                if(tmp1 && tmp2)
   \   0000009C   0x2900             CMP      R1,#+0
   \   0000009E   0xD01C             BEQ.N    ??HAL_ADCEx_InjectedStart_5
   \   000000A0   0x2A00             CMP      R2,#+0
   \   000000A2   0xD01A             BEQ.N    ??HAL_ADCEx_InjectedStart_5
    238                {
    239                  /* Enable the selected ADC software conversion for injected group */
    240                  hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
   \   000000A4   0x6881             LDR      R1,[R0, #+8]
   \   000000A6   0xF441 0x0180      ORR      R1,R1,#0x400000
   \   000000AA   0x6081             STR      R1,[R0, #+8]
   \   000000AC   0xE015             B.N      ??HAL_ADCEx_InjectedStart_5
    241                }
    242              }
    243              else
    244              {
    245                tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
   \                     ??HAL_ADCEx_InjectedStart_7: (+1)
   \   000000AE   0xF412 0x1F40      TST      R2,#0x300000
   \   000000B2   0xD100             BNE.N    ??HAL_ADCEx_InjectedStart_9
   \   000000B4   0x2101             MOVS     R1,#+1
    246                tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
   \                     ??HAL_ADCEx_InjectedStart_9: (+1)
   \   000000B6   0x6842             LDR      R2,[R0, #+4]
   \   000000B8   0x0A92             LSRS     R2,R2,#+10
   \   000000BA   0xF002 0x0201      AND      R2,R2,#0x1
   \   000000BE   0xF082 0x0201      EOR      R2,R2,#0x1
    247                if((hadc->Instance == ADC1) && tmp1 && tmp2)  
   \   000000C2   0x.... 0x....      LDR.W    R3,??DataTable6_4  ;; 0x40012000
   \   000000C6   0x4298             CMP      R0,R3
   \   000000C8   0xD107             BNE.N    ??HAL_ADCEx_InjectedStart_5
   \   000000CA   0x2900             CMP      R1,#+0
   \   000000CC   0xD005             BEQ.N    ??HAL_ADCEx_InjectedStart_5
   \   000000CE   0x2A00             CMP      R2,#+0
   \   000000D0   0xD003             BEQ.N    ??HAL_ADCEx_InjectedStart_5
    248                {
    249                  /* Enable the selected ADC software conversion for injected group */
    250                  hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
   \   000000D2   0x6881             LDR      R1,[R0, #+8]
   \   000000D4   0xF441 0x0180      ORR      R1,R1,#0x400000
   \   000000D8   0x6081             STR      R1,[R0, #+8]
    251                }
    252              }
    253            }
    254            
    255            /* Return function status */
    256            return HAL_OK;
   \                     ??HAL_ADCEx_InjectedStart_5: (+1)
   \   000000DA   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADCEx_InjectedStart_1: (+1)
   \   000000DC   0xB001             ADD      SP,SP,#+4
   \   000000DE   0x4770             BX       LR               ;; return
    257          }
    258          
    259          /**
    260            * @brief  Enables the interrupt and starts ADC conversion of injected channels.
    261            * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
    262            *         the configuration information for the specified ADC.
    263            *
    264            * @retval HAL status.
    265            */

   \                                 In section .text, align 2, keep-with-next
    266          HAL_StatusTypeDef HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef* hadc)
    267          {
   \                     HAL_ADCEx_InjectedStart_IT: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    268            __IO uint32_t counter = 0U;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x9100             STR      R1,[SP, #+0]
    269            uint32_t tmp1 = 0U, tmp2 = 0U;
    270            
    271            /* Process locked */
    272            __HAL_LOCK(hadc);
   \   00000006   0xF990 0x203C      LDRSB    R2,[R0, #+60]
   \   0000000A   0x2A01             CMP      R2,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_ADCEx_InjectedStart_IT_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE069             B.N      ??HAL_ADCEx_InjectedStart_IT_1
   \                     ??HAL_ADCEx_InjectedStart_IT_0: (+1)
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xF880 0x203C      STRB     R2,[R0, #+60]
    273            
    274            /* Enable the ADC peripheral */
    275            
    276            /* Check if ADC peripheral is disabled in order to enable it and wait during 
    277               Tstab time the ADC's stabilization */
    278            if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x6893             LDR      R3,[R2, #+8]
   \   0000001C   0x07DB             LSLS     R3,R3,#+31
   \   0000001E   0xD414             BMI.N    ??HAL_ADCEx_InjectedStart_IT_2
    279            {  
    280              /* Enable the Peripheral */
    281              __HAL_ADC_ENABLE(hadc);
   \   00000020   0x6893             LDR      R3,[R2, #+8]
   \   00000022   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000026   0x6093             STR      R3,[R2, #+8]
    282              
    283              /* Delay for ADC stabilization time */
    284              /* Compute number of CPU cycles to wait for */
    285              counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable6
   \   0000002C   0x6812             LDR      R2,[R2, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R3,??DataTable6_1  ;; 0xf4240
   \   00000032   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000036   0xEB02 0x0242      ADD      R2,R2,R2, LSL #+1
   \   0000003A   0x9200             STR      R2,[SP, #+0]
   \   0000003C   0xE002             B.N      ??HAL_ADCEx_InjectedStart_IT_3
    286              while(counter != 0U)
    287              {
    288                counter--;
   \                     ??HAL_ADCEx_InjectedStart_IT_4: (+1)
   \   0000003E   0x9A00             LDR      R2,[SP, #+0]
   \   00000040   0x1E52             SUBS     R2,R2,#+1
   \   00000042   0x9200             STR      R2,[SP, #+0]
    289              }
   \                     ??HAL_ADCEx_InjectedStart_IT_3: (+1)
   \   00000044   0x9A00             LDR      R2,[SP, #+0]
   \   00000046   0x2A00             CMP      R2,#+0
   \   00000048   0xD1F9             BNE.N    ??HAL_ADCEx_InjectedStart_IT_4
    290            }
    291            
    292            /* Start conversion if ADC is effectively enabled */
    293            if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
   \                     ??HAL_ADCEx_InjectedStart_IT_2: (+1)
   \   0000004A   0x6802             LDR      R2,[R0, #+0]
   \   0000004C   0x6892             LDR      R2,[R2, #+8]
   \   0000004E   0x07D2             LSLS     R2,R2,#+31
   \   00000050   0xD548             BPL.N    ??HAL_ADCEx_InjectedStart_IT_5
    294            {
    295              /* Set ADC state                                                          */
    296              /* - Clear state bitfield related to injected group conversion results    */
    297              /* - Set state bitfield related to injected operation                     */
    298              ADC_STATE_CLR_SET(hadc->State,
    299                                HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
    300                                HAL_ADC_STATE_INJ_BUSY);
   \   00000052   0x6C02             LDR      R2,[R0, #+64]
   \   00000054   0x.... 0x....      LDR.W    R3,??DataTable6_2  ;; 0xffffdffe
   \   00000058   0x401A             ANDS     R2,R3,R2
   \   0000005A   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000005E   0x6402             STR      R2,[R0, #+64]
    301              
    302              /* Check if a regular conversion is ongoing */
    303              /* Note: On this device, there is no ADC error code fields related to     */
    304              /*       conversions on group injected only. In case of conversion on     */
    305              /*       going on group regular, no error code is reset.                  */
    306              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
   \   00000060   0x6C02             LDR      R2,[R0, #+64]
   \   00000062   0x05D2             LSLS     R2,R2,#+23
   \   00000064   0xD401             BMI.N    ??HAL_ADCEx_InjectedStart_IT_6
    307              {
    308                /* Reset ADC all error code fields */
    309                ADC_CLEAR_ERRORCODE(hadc);
   \   00000066   0x460A             MOV      R2,R1
   \   00000068   0x6442             STR      R2,[R0, #+68]
    310              }
    311              
    312              /* Process unlocked */
    313              /* Unlock before starting ADC conversions: in case of potential           */
    314              /* interruption, to let the process to ADC IRQ Handler.                   */
    315              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedStart_IT_6: (+1)
   \   0000006A   0x460A             MOV      R2,R1
   \   0000006C   0xF880 0x203C      STRB     R2,[R0, #+60]
    316              
    317              /* Clear injected group conversion flag */
    318              /* (To ensure of no unknown state from potential previous ADC operations) */
    319              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
   \   00000070   0xF06F 0x0204      MVN      R2,#+4
   \   00000074   0x6803             LDR      R3,[R0, #+0]
   \   00000076   0x601A             STR      R2,[R3, #+0]
    320              
    321              /* Enable end of conversion interrupt for injected channels */
    322              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
   \   00000078   0x6802             LDR      R2,[R0, #+0]
   \   0000007A   0x6853             LDR      R3,[R2, #+4]
   \   0000007C   0xF043 0x0380      ORR      R3,R3,#0x80
   \   00000080   0x6053             STR      R3,[R2, #+4]
    323              
    324              /* Check if Multimode enabled */
    325              if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x.... 0x....      LDR.W    R2,??DataTable6_3  ;; 0x40012304
   \   00000088   0x6812             LDR      R2,[R2, #+0]
   \   0000008A   0xF012 0x0F1F      TST      R2,#0x1F
   \   0000008E   0x6882             LDR      R2,[R0, #+8]
   \   00000090   0xD112             BNE.N    ??HAL_ADCEx_InjectedStart_IT_7
    326              {
    327                tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
   \   00000092   0xF412 0x1F40      TST      R2,#0x300000
   \   00000096   0xD100             BNE.N    ??HAL_ADCEx_InjectedStart_IT_8
   \   00000098   0x2101             MOVS     R1,#+1
    328                tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
   \                     ??HAL_ADCEx_InjectedStart_IT_8: (+1)
   \   0000009A   0x6842             LDR      R2,[R0, #+4]
   \   0000009C   0x0A92             LSRS     R2,R2,#+10
   \   0000009E   0xF002 0x0201      AND      R2,R2,#0x1
   \   000000A2   0xF082 0x0201      EOR      R2,R2,#0x1
    329                if(tmp1 && tmp2)
   \   000000A6   0x2900             CMP      R1,#+0
   \   000000A8   0xD01C             BEQ.N    ??HAL_ADCEx_InjectedStart_IT_5
   \   000000AA   0x2A00             CMP      R2,#+0
   \   000000AC   0xD01A             BEQ.N    ??HAL_ADCEx_InjectedStart_IT_5
    330                {
    331                  /* Enable the selected ADC software conversion for injected group */
    332                  hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
   \   000000AE   0x6881             LDR      R1,[R0, #+8]
   \   000000B0   0xF441 0x0180      ORR      R1,R1,#0x400000
   \   000000B4   0x6081             STR      R1,[R0, #+8]
   \   000000B6   0xE015             B.N      ??HAL_ADCEx_InjectedStart_IT_5
    333                }
    334              }
    335              else
    336              {
    337                tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
   \                     ??HAL_ADCEx_InjectedStart_IT_7: (+1)
   \   000000B8   0xF412 0x1F40      TST      R2,#0x300000
   \   000000BC   0xD100             BNE.N    ??HAL_ADCEx_InjectedStart_IT_9
   \   000000BE   0x2101             MOVS     R1,#+1
    338                tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
   \                     ??HAL_ADCEx_InjectedStart_IT_9: (+1)
   \   000000C0   0x6842             LDR      R2,[R0, #+4]
   \   000000C2   0x0A92             LSRS     R2,R2,#+10
   \   000000C4   0xF002 0x0201      AND      R2,R2,#0x1
   \   000000C8   0xF082 0x0201      EOR      R2,R2,#0x1
    339                if((hadc->Instance == ADC1) && tmp1 && tmp2)  
   \   000000CC   0x.... 0x....      LDR.W    R3,??DataTable6_4  ;; 0x40012000
   \   000000D0   0x4298             CMP      R0,R3
   \   000000D2   0xD107             BNE.N    ??HAL_ADCEx_InjectedStart_IT_5
   \   000000D4   0x2900             CMP      R1,#+0
   \   000000D6   0xD005             BEQ.N    ??HAL_ADCEx_InjectedStart_IT_5
   \   000000D8   0x2A00             CMP      R2,#+0
   \   000000DA   0xD003             BEQ.N    ??HAL_ADCEx_InjectedStart_IT_5
    340                {
    341                  /* Enable the selected ADC software conversion for injected group */
    342                  hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
   \   000000DC   0x6881             LDR      R1,[R0, #+8]
   \   000000DE   0xF441 0x0180      ORR      R1,R1,#0x400000
   \   000000E2   0x6081             STR      R1,[R0, #+8]
    343                }
    344              }
    345            }
    346            
    347            /* Return function status */
    348            return HAL_OK;
   \                     ??HAL_ADCEx_InjectedStart_IT_5: (+1)
   \   000000E4   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADCEx_InjectedStart_IT_1: (+1)
   \   000000E6   0xB001             ADD      SP,SP,#+4
   \   000000E8   0x4770             BX       LR               ;; return
    349          }
    350          
    351          /**
    352            * @brief  Stop conversion of injected channels. Disable ADC peripheral if
    353            *         no regular conversion is on going.
    354            * @note   If ADC must be disabled and if conversion is on going on 
    355            *         regular group, function HAL_ADC_Stop must be used to stop both
    356            *         injected and regular groups, and disable the ADC.
    357            * @note   If injected group mode auto-injection is enabled,
    358            *         function HAL_ADC_Stop must be used.
    359            * @note   In case of auto-injection mode, HAL_ADC_Stop must be used.
    360            * @param  hadc: ADC handle
    361            * @retval None
    362            */

   \                                 In section .text, align 2, keep-with-next
    363          HAL_StatusTypeDef HAL_ADCEx_InjectedStop(ADC_HandleTypeDef* hadc)
    364          {
    365            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \                     HAL_ADCEx_InjectedStop: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    366            
    367            /* Check the parameters */
    368            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    369          
    370            /* Process locked */
    371            __HAL_LOCK(hadc);
   \   00000002   0xF990 0x203C      LDRSB    R2,[R0, #+60]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xD101             BNE.N    ??HAL_ADCEx_InjectedStop_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR
   \                     ??HAL_ADCEx_InjectedStop_0: (+1)
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0xF880 0x203C      STRB     R2,[R0, #+60]
    372              
    373            /* Stop potential conversion and disable ADC peripheral                     */
    374            /* Conditioned to:                                                          */
    375            /* - No conversion on the other group (regular group) is intended to        */
    376            /*   continue (injected and regular groups stop conversion and ADC disable  */
    377            /*   are common)                                                            */
    378            /* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */
    379            if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
    380               HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
   \   00000014   0x6C02             LDR      R2,[R0, #+64]
   \   00000016   0x05D2             LSLS     R2,R2,#+23
   \   00000018   0xD412             BMI.N    ??HAL_ADCEx_InjectedStop_1
   \   0000001A   0x6802             LDR      R2,[R0, #+0]
   \   0000001C   0x6853             LDR      R3,[R2, #+4]
   \   0000001E   0x055B             LSLS     R3,R3,#+21
   \   00000020   0xD40E             BMI.N    ??HAL_ADCEx_InjectedStop_1
    381            {
    382              /* Stop potential conversion on going, on regular and injected groups */
    383              /* Disable ADC peripheral */
    384              __HAL_ADC_DISABLE(hadc);
   \   00000022   0x6893             LDR      R3,[R2, #+8]
   \   00000024   0x085B             LSRS     R3,R3,#+1
   \   00000026   0x005B             LSLS     R3,R3,#+1
   \   00000028   0x6093             STR      R3,[R2, #+8]
    385              
    386              /* Check if ADC is effectively disabled */
    387              if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x6892             LDR      R2,[R2, #+8]
   \   0000002E   0x07D2             LSLS     R2,R2,#+31
   \   00000030   0xD40B             BMI.N    ??HAL_ADCEx_InjectedStop_2
    388              {
    389                /* Set ADC state */
    390                ADC_STATE_CLR_SET(hadc->State,
    391                                  HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    392                                  HAL_ADC_STATE_READY);
   \   00000032   0x6C02             LDR      R2,[R0, #+64]
   \   00000034   0xF422 0x5288      BIC      R2,R2,#0x1100
   \   00000038   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000003C   0x6402             STR      R2,[R0, #+64]
   \   0000003E   0xE004             B.N      ??HAL_ADCEx_InjectedStop_2
    393              }
    394            }
    395            else
    396            {
    397              /* Update ADC state machine to error */
    398              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \                     ??HAL_ADCEx_InjectedStop_1: (+1)
   \   00000040   0x6C01             LDR      R1,[R0, #+64]
   \   00000042   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000046   0x6401             STR      R1,[R0, #+64]
    399                
    400              tmp_hal_status = HAL_ERROR;
   \   00000048   0x2101             MOVS     R1,#+1
    401            }
    402            
    403            /* Process unlocked */
    404            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedStop_2: (+1)
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0xF880 0x203C      STRB     R2,[R0, #+60]
    405            
    406            /* Return function status */
    407            return tmp_hal_status;
   \   00000050   0x4608             MOV      R0,R1
   \   00000052   0x4770             BX       LR               ;; return
    408          }
    409          
    410          /**
    411            * @brief  Poll for injected conversion complete
    412            * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
    413            *         the configuration information for the specified ADC.
    414            * @param  Timeout: Timeout value in millisecond.  
    415            * @retval HAL status
    416            */

   \                                 In section .text, align 2, keep-with-next
    417          HAL_StatusTypeDef HAL_ADCEx_InjectedPollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
    418          {
   \                     HAL_ADCEx_InjectedPollForConversion: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    419            uint32_t tickstart = 0U;
    420          
    421            /* Get tick */ 
    422            tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
    423          
    424            /* Check End of conversion flag */
    425            while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC)))
   \                     ??HAL_ADCEx_InjectedPollForConversion_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x0749             LSLS     R1,R1,#+29
   \   00000012   0xD410             BMI.N    ??HAL_ADCEx_InjectedPollForConversion_1
    426            {
    427              /* Check for the Timeout */
    428              if(Timeout != HAL_MAX_DELAY)
   \   00000014   0xF115 0x0F01      CMN      R5,#+1
   \   00000018   0xD0F8             BEQ.N    ??HAL_ADCEx_InjectedPollForConversion_0
    429              {
    430                if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD004             BEQ.N    ??HAL_ADCEx_InjectedPollForConversion_2
   \   0000001E   0x.... 0x....      BL       HAL_GetTick
   \   00000022   0x1B80             SUBS     R0,R0,R6
   \   00000024   0x4285             CMP      R5,R0
   \   00000026   0xD2F1             BCS.N    ??HAL_ADCEx_InjectedPollForConversion_0
    431                {
    432                  hadc->State= HAL_ADC_STATE_TIMEOUT;
   \                     ??HAL_ADCEx_InjectedPollForConversion_2: (+1)
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0x6420             STR      R0,[R4, #+64]
    433                  /* Process unlocked */
    434                  __HAL_UNLOCK(hadc);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF884 0x003C      STRB     R0,[R4, #+60]
    435                  return HAL_TIMEOUT;
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0xBD70             POP      {R4-R6,PC}
    436                }
    437              }
    438            }
    439            
    440            /* Clear injected group conversion flag */
    441            __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JSTRT | ADC_FLAG_JEOC);
   \                     ??HAL_ADCEx_InjectedPollForConversion_1: (+1)
   \   00000036   0xF06F 0x010C      MVN      R1,#+12
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    442              
    443            /* Update ADC state machine */
    444            SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
   \   0000003C   0x6C20             LDR      R0,[R4, #+64]
   \   0000003E   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000042   0x6420             STR      R0,[R4, #+64]
    445            
    446            /* Determine whether any further conversion upcoming on group injected      */
    447            /* by external trigger, continuous mode or scan sequence on going.          */
    448            /* Note: On STM32F4, there is no independent flag of end of sequence.       */
    449            /*       The test of scan sequence on going is done either with scan        */
    450            /*       sequence disabled or with end of conversion flag set to            */
    451            /*       of end of sequence.                                                */
    452            if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                    &&
    453               (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
    454                HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
    455               (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
    456                (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
    457                (hadc->Init.ContinuousConvMode == DISABLE)   )       )   )
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6881             LDR      R1,[R0, #+8]
   \   00000048   0xF411 0x1F40      TST      R1,#0x300000
   \   0000004C   0xD11B             BNE.N    ??HAL_ADCEx_InjectedPollForConversion_3
   \   0000004E   0x6B81             LDR      R1,[R0, #+56]
   \   00000050   0xF411 0x1F40      TST      R1,#0x300000
   \   00000054   0xD002             BEQ.N    ??HAL_ADCEx_InjectedPollForConversion_4
   \   00000056   0x6881             LDR      R1,[R0, #+8]
   \   00000058   0x0549             LSLS     R1,R1,#+21
   \   0000005A   0xD414             BMI.N    ??HAL_ADCEx_InjectedPollForConversion_3
   \                     ??HAL_ADCEx_InjectedPollForConversion_4: (+1)
   \   0000005C   0x6841             LDR      R1,[R0, #+4]
   \   0000005E   0x0549             LSLS     R1,R1,#+21
   \   00000060   0xD411             BMI.N    ??HAL_ADCEx_InjectedPollForConversion_3
   \   00000062   0x6880             LDR      R0,[R0, #+8]
   \   00000064   0xF010 0x5F40      TST      R0,#0x30000000
   \   00000068   0xD10D             BNE.N    ??HAL_ADCEx_InjectedPollForConversion_3
   \   0000006A   0x69A0             LDR      R0,[R4, #+24]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD10A             BNE.N    ??HAL_ADCEx_InjectedPollForConversion_3
    458            {
    459              /* Set ADC state */
    460              CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
   \   00000070   0x6C20             LDR      R0,[R4, #+64]
   \   00000072   0xF420 0x5080      BIC      R0,R0,#0x1000
   \   00000076   0x6420             STR      R0,[R4, #+64]
    461              
    462              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
   \   00000078   0x6C20             LDR      R0,[R4, #+64]
   \   0000007A   0x05C0             LSLS     R0,R0,#+23
   \   0000007C   0xD403             BMI.N    ??HAL_ADCEx_InjectedPollForConversion_3
    463              { 
    464                SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \   0000007E   0x6C20             LDR      R0,[R4, #+64]
   \   00000080   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000084   0x6420             STR      R0,[R4, #+64]
    465              }
    466            }
    467            
    468            /* Return ADC state */
    469            return HAL_OK;
   \                     ??HAL_ADCEx_InjectedPollForConversion_3: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xBD70             POP      {R4-R6,PC}       ;; return
    470          }      
    471            
    472          /**
    473            * @brief  Stop conversion of injected channels, disable interruption of 
    474            *         end-of-conversion. Disable ADC peripheral if no regular conversion
    475            *         is on going.
    476            * @note   If ADC must be disabled and if conversion is on going on 
    477            *         regular group, function HAL_ADC_Stop must be used to stop both
    478            *         injected and regular groups, and disable the ADC.
    479            * @note   If injected group mode auto-injection is enabled,
    480            *         function HAL_ADC_Stop must be used.
    481            * @param  hadc: ADC handle
    482            * @retval None
    483            */

   \                                 In section .text, align 2, keep-with-next
    484          HAL_StatusTypeDef HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef* hadc)
    485          {
    486            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \                     HAL_ADCEx_InjectedStop_IT: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    487            
    488            /* Check the parameters */
    489            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    490          
    491            /* Process locked */
    492            __HAL_LOCK(hadc);
   \   00000002   0xF990 0x203C      LDRSB    R2,[R0, #+60]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xD101             BNE.N    ??HAL_ADCEx_InjectedStop_IT_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR
   \                     ??HAL_ADCEx_InjectedStop_IT_0: (+1)
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0xF880 0x203C      STRB     R2,[R0, #+60]
    493              
    494            /* Stop potential conversion and disable ADC peripheral                     */
    495            /* Conditioned to:                                                          */
    496            /* - No conversion on the other group (regular group) is intended to        */
    497            /*   continue (injected and regular groups stop conversion and ADC disable  */
    498            /*   are common)                                                            */
    499            /* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */ 
    500            if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
    501               HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
   \   00000014   0x6C02             LDR      R2,[R0, #+64]
   \   00000016   0x05D2             LSLS     R2,R2,#+23
   \   00000018   0xD416             BMI.N    ??HAL_ADCEx_InjectedStop_IT_1
   \   0000001A   0x6802             LDR      R2,[R0, #+0]
   \   0000001C   0x6853             LDR      R3,[R2, #+4]
   \   0000001E   0x055B             LSLS     R3,R3,#+21
   \   00000020   0xD412             BMI.N    ??HAL_ADCEx_InjectedStop_IT_1
    502            {
    503              /* Stop potential conversion on going, on regular and injected groups */
    504              /* Disable ADC peripheral */
    505              __HAL_ADC_DISABLE(hadc);
   \   00000022   0x6893             LDR      R3,[R2, #+8]
   \   00000024   0x085B             LSRS     R3,R3,#+1
   \   00000026   0x005B             LSLS     R3,R3,#+1
   \   00000028   0x6093             STR      R3,[R2, #+8]
    506              
    507              /* Check if ADC is effectively disabled */
    508              if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x6893             LDR      R3,[R2, #+8]
   \   0000002E   0x07DB             LSLS     R3,R3,#+31
   \   00000030   0xD40F             BMI.N    ??HAL_ADCEx_InjectedStop_IT_2
    509              {
    510                /* Disable ADC end of conversion interrupt for injected channels */
    511                __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
   \   00000032   0x6853             LDR      R3,[R2, #+4]
   \   00000034   0xF023 0x0380      BIC      R3,R3,#0x80
   \   00000038   0x6053             STR      R3,[R2, #+4]
    512                
    513                /* Set ADC state */
    514                ADC_STATE_CLR_SET(hadc->State,
    515                                  HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    516                                  HAL_ADC_STATE_READY);
   \   0000003A   0x6C02             LDR      R2,[R0, #+64]
   \   0000003C   0xF422 0x5288      BIC      R2,R2,#0x1100
   \   00000040   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000044   0x6402             STR      R2,[R0, #+64]
   \   00000046   0xE004             B.N      ??HAL_ADCEx_InjectedStop_IT_2
    517              }
    518            }
    519            else
    520            {
    521              /* Update ADC state machine to error */
    522              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \                     ??HAL_ADCEx_InjectedStop_IT_1: (+1)
   \   00000048   0x6C01             LDR      R1,[R0, #+64]
   \   0000004A   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000004E   0x6401             STR      R1,[R0, #+64]
    523                
    524              tmp_hal_status = HAL_ERROR;
   \   00000050   0x2101             MOVS     R1,#+1
    525            }
    526            
    527            /* Process unlocked */
    528            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedStop_IT_2: (+1)
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0xF880 0x203C      STRB     R2,[R0, #+60]
    529            
    530            /* Return function status */
    531            return tmp_hal_status;
   \   00000058   0x4608             MOV      R0,R1
   \   0000005A   0x4770             BX       LR               ;; return
    532          }
    533          
    534          /**
    535            * @brief  Gets the converted value from data register of injected channel.
    536            * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
    537            *         the configuration information for the specified ADC.
    538            * @param  InjectedRank: the ADC injected rank.
    539            *          This parameter can be one of the following values:
    540            *            @arg ADC_INJECTED_RANK_1: Injected Channel1 selected
    541            *            @arg ADC_INJECTED_RANK_2: Injected Channel2 selected
    542            *            @arg ADC_INJECTED_RANK_3: Injected Channel3 selected
    543            *            @arg ADC_INJECTED_RANK_4: Injected Channel4 selected
    544            * @retval None
    545            */

   \                                 In section .text, align 2, keep-with-next
    546          uint32_t HAL_ADCEx_InjectedGetValue(ADC_HandleTypeDef* hadc, uint32_t InjectedRank)
    547          {
   \                     HAL_ADCEx_InjectedGetValue: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    548            __IO uint32_t tmp = 0U;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x9200             STR      R2,[SP, #+0]
    549            
    550            /* Check the parameters */
    551            assert_param(IS_ADC_INJECTED_RANK(InjectedRank));
    552            
    553            /* Clear injected group conversion flag to have similar behaviour as        */
    554            /* regular group: reading data register also clears end of conversion flag. */
    555            __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
   \   00000006   0xF06F 0x0204      MVN      R2,#+4
   \   0000000A   0x6803             LDR      R3,[R0, #+0]
   \   0000000C   0x601A             STR      R2,[R3, #+0]
    556            
    557            /* Return the selected ADC converted value */ 
    558            switch(InjectedRank)
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD011             BEQ.N    ??HAL_ADCEx_InjectedGetValue_0
   \   00000012   0xD313             BCC.N    ??HAL_ADCEx_InjectedGetValue_1
   \   00000014   0x2903             CMP      R1,#+3
   \   00000016   0xD006             BEQ.N    ??HAL_ADCEx_InjectedGetValue_2
   \   00000018   0xD309             BCC.N    ??HAL_ADCEx_InjectedGetValue_3
   \   0000001A   0x2904             CMP      R1,#+4
   \   0000001C   0xD10E             BNE.N    ??HAL_ADCEx_InjectedGetValue_1
    559            {  
    560              case ADC_INJECTED_RANK_4:
    561              {
    562                tmp =  hadc->Instance->JDR4;
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x6C80             LDR      R0,[R0, #+72]
   \   00000022   0x9000             STR      R0,[SP, #+0]
    563              }  
    564              break;
   \   00000024   0xE00A             B.N      ??HAL_ADCEx_InjectedGetValue_1
    565              case ADC_INJECTED_RANK_3: 
    566              {  
    567                tmp =  hadc->Instance->JDR3;
   \                     ??HAL_ADCEx_InjectedGetValue_2: (+1)
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x6C40             LDR      R0,[R0, #+68]
   \   0000002A   0x9000             STR      R0,[SP, #+0]
    568              }  
    569              break;
   \   0000002C   0xE006             B.N      ??HAL_ADCEx_InjectedGetValue_1
    570              case ADC_INJECTED_RANK_2: 
    571              {  
    572                tmp =  hadc->Instance->JDR2;
   \                     ??HAL_ADCEx_InjectedGetValue_3: (+1)
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x6C00             LDR      R0,[R0, #+64]
   \   00000032   0x9000             STR      R0,[SP, #+0]
    573              }
    574              break;
   \   00000034   0xE002             B.N      ??HAL_ADCEx_InjectedGetValue_1
    575              case ADC_INJECTED_RANK_1:
    576              {
    577                tmp =  hadc->Instance->JDR1;
   \                     ??HAL_ADCEx_InjectedGetValue_0: (+1)
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x6BC0             LDR      R0,[R0, #+60]
   \   0000003A   0x9000             STR      R0,[SP, #+0]
    578              }
    579              break;
    580              default:
    581              break;  
    582            }
    583            return tmp;
   \                     ??HAL_ADCEx_InjectedGetValue_1: (+1)
   \   0000003C   0x9800             LDR      R0,[SP, #+0]
   \   0000003E   0xB001             ADD      SP,SP,#+4
   \   00000040   0x4770             BX       LR               ;; return
    584          }
    585          
    586          /**
    587            * @brief  Enables ADC DMA request after last transfer (Multi-ADC mode) and enables ADC peripheral
    588            * 
    589            * @note   Caution: This function must be used only with the ADC master.  
    590            *
    591            * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
    592            *         the configuration information for the specified ADC.
    593            * @param  pData:   Pointer to buffer in which transferred from ADC peripheral to memory will be stored. 
    594            * @param  Length:  The length of data to be transferred from ADC peripheral to memory.  
    595            * @retval HAL status
    596            */

   \                                 In section .text, align 2, keep-with-next
    597          HAL_StatusTypeDef HAL_ADCEx_MultiModeStart_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
    598          {
   \                     HAL_ADCEx_MultiModeStart_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    599            __IO uint32_t counter = 0U;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    600            
    601            /* Check the parameters */
    602            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    603            assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
    604            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
    605            
    606            /* Process locked */
    607            __HAL_LOCK(hadc);
   \   0000000A   0xF994 0x003C      LDRSB    R0,[R4, #+60]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD101             BNE.N    ??HAL_ADCEx_MultiModeStart_DMA_0
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xBD16             POP      {R1,R2,R4,PC}
   \                     ??HAL_ADCEx_MultiModeStart_DMA_0: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF884 0x003C      STRB     R0,[R4, #+60]
    608            
    609            /* Check if ADC peripheral is disabled in order to enable it and wait during 
    610               Tstab time the ADC's stabilization */
    611            if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6883             LDR      R3,[R0, #+8]
   \   00000020   0x07DB             LSLS     R3,R3,#+31
   \   00000022   0xD412             BMI.N    ??HAL_ADCEx_MultiModeStart_DMA_1
    612            {  
    613              /* Enable the Peripheral */
    614              __HAL_ADC_ENABLE(hadc);
   \   00000024   0x6883             LDR      R3,[R0, #+8]
   \   00000026   0xF043 0x0301      ORR      R3,R3,#0x1
   \   0000002A   0x6083             STR      R3,[R0, #+8]
    615              
    616              /* Delay for temperature sensor stabilization time */
    617              /* Compute number of CPU cycles to wait for */
    618              counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
   \   0000002C   0x....             LDR.N    R0,??DataTable6
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x....             LDR.N    R3,??DataTable6_1  ;; 0xf4240
   \   00000032   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000036   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0xE002             B.N      ??HAL_ADCEx_MultiModeStart_DMA_2
    619              while(counter != 0U)
    620              {
    621                counter--;
   \                     ??HAL_ADCEx_MultiModeStart_DMA_3: (+1)
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x1E40             SUBS     R0,R0,#+1
   \   00000042   0x9000             STR      R0,[SP, #+0]
    622              }
   \                     ??HAL_ADCEx_MultiModeStart_DMA_2: (+1)
   \   00000044   0x9800             LDR      R0,[SP, #+0]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD1F9             BNE.N    ??HAL_ADCEx_MultiModeStart_DMA_3
    623            }
    624            
    625            /* Start conversion if ADC is effectively enabled */
    626            if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
   \                     ??HAL_ADCEx_MultiModeStart_DMA_1: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6880             LDR      R0,[R0, #+8]
   \   0000004E   0x07C0             LSLS     R0,R0,#+31
   \   00000050   0xD54C             BPL.N    ??HAL_ADCEx_MultiModeStart_DMA_4
    627            {
    628              /* Set ADC state                                                          */
    629              /* - Clear state bitfield related to regular group conversion results     */
    630              /* - Set state bitfield related to regular group operation                */
    631              ADC_STATE_CLR_SET(hadc->State,
    632                                HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
    633                                HAL_ADC_STATE_REG_BUSY);
   \   00000052   0x6C20             LDR      R0,[R4, #+64]
   \   00000054   0x....             LDR.N    R3,??DataTable6_5  ;; 0xfffff9fe
   \   00000056   0x4018             ANDS     R0,R3,R0
   \   00000058   0xF440 0x7080      ORR      R0,R0,#0x100
   \   0000005C   0x6420             STR      R0,[R4, #+64]
    634              
    635              /* If conversions on group regular are also triggering group injected,    */
    636              /* update ADC state.                                                      */
    637              if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6840             LDR      R0,[R0, #+4]
   \   00000062   0x0540             LSLS     R0,R0,#+21
   \   00000064   0xD505             BPL.N    ??HAL_ADCEx_MultiModeStart_DMA_5
    638              {
    639                ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
   \   00000066   0x6C20             LDR      R0,[R4, #+64]
   \   00000068   0xF420 0x5000      BIC      R0,R0,#0x2000
   \   0000006C   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   00000070   0x6420             STR      R0,[R4, #+64]
    640              }
    641              
    642              /* State machine update: Check if an injected conversion is ongoing */
    643              if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \                     ??HAL_ADCEx_MultiModeStart_DMA_5: (+1)
   \   00000072   0x6C20             LDR      R0,[R4, #+64]
   \   00000074   0x04C0             LSLS     R0,R0,#+19
   \   00000076   0xD504             BPL.N    ??HAL_ADCEx_MultiModeStart_DMA_6
    644              {
    645                /* Reset ADC error code fields related to conversions on group regular */
    646                CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
   \   00000078   0x6C60             LDR      R0,[R4, #+68]
   \   0000007A   0xF020 0x0006      BIC      R0,R0,#0x6
   \   0000007E   0x6460             STR      R0,[R4, #+68]
   \   00000080   0xE001             B.N      ??HAL_ADCEx_MultiModeStart_DMA_7
    647              }
    648              else
    649              {
    650                /* Reset ADC all error code fields */
    651                ADC_CLEAR_ERRORCODE(hadc);
   \                     ??HAL_ADCEx_MultiModeStart_DMA_6: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x6460             STR      R0,[R4, #+68]
    652              }
    653              
    654              /* Process unlocked */
    655              /* Unlock before starting ADC conversions: in case of potential           */
    656              /* interruption, to let the process to ADC IRQ Handler.                   */
    657              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_MultiModeStart_DMA_7: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xF884 0x003C      STRB     R0,[R4, #+60]
    658              
    659              /* Set the DMA transfer complete callback */
    660              hadc->DMA_Handle->XferCpltCallback = ADC_MultiModeDMAConvCplt;
   \   0000008C   0x.... 0x....      ADR.W    R0,ADC_MultiModeDMAConvCplt
   \   00000090   0x6BA3             LDR      R3,[R4, #+56]
   \   00000092   0x63D8             STR      R0,[R3, #+60]
    661              
    662              /* Set the DMA half transfer complete callback */
    663              hadc->DMA_Handle->XferHalfCpltCallback = ADC_MultiModeDMAHalfConvCplt;
   \   00000094   0x.... 0x....      ADR.W    R0,ADC_MultiModeDMAHalfConvCplt
   \   00000098   0x6BA3             LDR      R3,[R4, #+56]
   \   0000009A   0x6418             STR      R0,[R3, #+64]
    664              
    665              /* Set the DMA error callback */
    666              hadc->DMA_Handle->XferErrorCallback = ADC_MultiModeDMAError ;
   \   0000009C   0x.... 0x....      ADR.W    R0,ADC_MultiModeDMAError
   \   000000A0   0x6BA3             LDR      R3,[R4, #+56]
   \   000000A2   0x64D8             STR      R0,[R3, #+76]
    667              
    668              /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC     */
    669              /* start (in case of SW start):                                           */
    670              
    671              /* Clear regular group conversion flag and overrun flag */
    672              /* (To ensure of no unknown state from potential previous ADC operations) */
    673              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
   \   000000A4   0xF06F 0x0002      MVN      R0,#+2
   \   000000A8   0x6823             LDR      R3,[R4, #+0]
   \   000000AA   0x6018             STR      R0,[R3, #+0]
    674          
    675              /* Enable ADC overrun interrupt */
    676              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6843             LDR      R3,[R0, #+4]
   \   000000B0   0xF043 0x6380      ORR      R3,R3,#0x4000000
   \   000000B4   0x6043             STR      R3,[R0, #+4]
    677              
    678              if (hadc->Init.DMAContinuousRequests != DISABLE)
   \   000000B6   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40012304
   \   000000B8   0x6B23             LDR      R3,[R4, #+48]
   \   000000BA   0x2B00             CMP      R3,#+0
   \   000000BC   0x6803             LDR      R3,[R0, #+0]
   \   000000BE   0xD003             BEQ.N    ??HAL_ADCEx_MultiModeStart_DMA_8
    679              {
    680                /* Enable the selected ADC DMA request after last transfer */
    681                ADC->CCR |= ADC_CCR_DDS;
   \   000000C0   0xF443 0x5300      ORR      R3,R3,#0x2000
   \   000000C4   0x6003             STR      R3,[R0, #+0]
   \   000000C6   0xE002             B.N      ??HAL_ADCEx_MultiModeStart_DMA_9
    682              }
    683              else
    684              {
    685                /* Disable the selected ADC EOC rising on each regular channel conversion */
    686                ADC->CCR &= ~ADC_CCR_DDS;
   \                     ??HAL_ADCEx_MultiModeStart_DMA_8: (+1)
   \   000000C8   0xF423 0x5300      BIC      R3,R3,#0x2000
   \   000000CC   0x6003             STR      R3,[R0, #+0]
    687              }
    688              
    689              /* Enable the DMA Stream */
    690              HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&ADC->CDR, (uint32_t)pData, Length);
   \                     ??HAL_ADCEx_MultiModeStart_DMA_9: (+1)
   \   000000CE   0x4613             MOV      R3,R2
   \   000000D0   0x460A             MOV      R2,R1
   \   000000D2   0x....             LDR.N    R1,??DataTable6_6  ;; 0x40012308
   \   000000D4   0x6BA0             LDR      R0,[R4, #+56]
   \   000000D6   0x.... 0x....      BL       HAL_DMA_Start_IT
    691              
    692              /* if no external trigger present enable software conversion of regular channels */
    693              if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x6881             LDR      R1,[R0, #+8]
   \   000000DE   0xF011 0x5F40      TST      R1,#0x30000000
   \   000000E2   0xD103             BNE.N    ??HAL_ADCEx_MultiModeStart_DMA_4
    694              {
    695                /* Enable the selected ADC software conversion for regular group */
    696                hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
   \   000000E4   0x6881             LDR      R1,[R0, #+8]
   \   000000E6   0xF041 0x4180      ORR      R1,R1,#0x40000000
   \   000000EA   0x6081             STR      R1,[R0, #+8]
    697              }
    698            }
    699            
    700            /* Return function status */
    701            return HAL_OK;
   \                     ??HAL_ADCEx_MultiModeStart_DMA_4: (+1)
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    702          }
    703          
    704          /**
    705            * @brief  Disables ADC DMA (multi-ADC mode) and disables ADC peripheral    
    706            * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
    707            *         the configuration information for the specified ADC.
    708            * @retval HAL status
    709            */

   \                                 In section .text, align 2, keep-with-next
    710          HAL_StatusTypeDef HAL_ADCEx_MultiModeStop_DMA(ADC_HandleTypeDef* hadc)
    711          {
   \                     HAL_ADCEx_MultiModeStop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    712            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \   00000004   0x2000             MOVS     R0,#+0
    713            
    714            /* Check the parameters */
    715            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    716            
    717            /* Process locked */
    718            __HAL_LOCK(hadc);
   \   00000006   0xF994 0x103C      LDRSB    R1,[R4, #+60]
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_ADCEx_MultiModeStop_DMA_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD10             POP      {R4,PC}
   \                     ??HAL_ADCEx_MultiModeStop_DMA_0: (+1)
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF884 0x103C      STRB     R1,[R4, #+60]
    719            
    720            /* Stop potential conversion on going, on regular and injected groups */
    721            /* Disable ADC peripheral */
    722            __HAL_ADC_DISABLE(hadc);
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0x688A             LDR      R2,[R1, #+8]
   \   0000001C   0x0852             LSRS     R2,R2,#+1
   \   0000001E   0x0052             LSLS     R2,R2,#+1
   \   00000020   0x608A             STR      R2,[R1, #+8]
    723            
    724            /* Check if ADC is effectively disabled */
    725            if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x6889             LDR      R1,[R1, #+8]
   \   00000026   0x07C9             LSLS     R1,R1,#+31
   \   00000028   0xD412             BMI.N    ??HAL_ADCEx_MultiModeStop_DMA_1
    726            {
    727              /* Disable the selected ADC DMA mode for multimode */
    728              ADC->CCR &= ~ADC_CCR_DDS;
   \   0000002A   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40012304
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   00000032   0x6001             STR      R1,[R0, #+0]
    729              
    730              /* Disable the DMA channel (in case of DMA in circular mode or stop while */
    731              /* DMA transfer is on going)                                              */
    732              tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
   \   00000034   0x6BA0             LDR      R0,[R4, #+56]
   \   00000036   0x.... 0x....      BL       HAL_DMA_Abort
    733              
    734              /* Disable ADC overrun interrupt */
    735              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x684A             LDR      R2,[R1, #+4]
   \   0000003E   0xF022 0x6280      BIC      R2,R2,#0x4000000
   \   00000042   0x604A             STR      R2,[R1, #+4]
    736              
    737              /* Set ADC state */
    738              ADC_STATE_CLR_SET(hadc->State,
    739                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    740                                HAL_ADC_STATE_READY);
   \   00000044   0x6C21             LDR      R1,[R4, #+64]
   \   00000046   0xF421 0x5188      BIC      R1,R1,#0x1100
   \   0000004A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000004E   0x6421             STR      R1,[R4, #+64]
    741            }
    742            
    743            /* Process unlocked */
    744            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_MultiModeStop_DMA_1: (+1)
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0xF884 0x103C      STRB     R1,[R4, #+60]
    745            
    746            /* Return function status */
    747            return tmp_hal_status;
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    748          }
    749          
    750          /**
    751            * @brief  Returns the last ADC1, ADC2 and ADC3 regular conversions results 
    752            *         data in the selected multi mode.
    753            * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
    754            *         the configuration information for the specified ADC.
    755            * @retval The converted data value.
    756            */

   \                                 In section .text, align 2, keep-with-next
    757          uint32_t HAL_ADCEx_MultiModeGetValue(ADC_HandleTypeDef* hadc)
    758          {
    759            /* Return the multi mode conversion value */
    760            return ADC->CDR;
   \                     HAL_ADCEx_MultiModeGetValue: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_6  ;; 0x40012308
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    761          }
    762          
    763          /**
    764            * @brief  Injected conversion complete callback in non blocking mode 
    765            * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
    766            *         the configuration information for the specified ADC.
    767            * @retval None
    768            */

   \                                 In section .text, align 2, keep-with-next
    769          __weak void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc)
    770          {
    771            /* Prevent unused argument(s) compilation warning */
    772            UNUSED(hadc);
    773            /* NOTE : This function Should not be modified, when the callback is needed,
    774                      the HAL_ADC_InjectedConvCpltCallback could be implemented in the user file
    775             */
    776          }
   \                     HAL_ADCEx_InjectedConvCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    777          
    778          /**
    779            * @brief  Configures for the selected ADC injected channel its corresponding
    780            *         rank in the sequencer and its sample time.
    781            * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
    782            *         the configuration information for the specified ADC.
    783            * @param  sConfigInjected: ADC configuration structure for injected channel. 
    784            * @retval None
    785            */

   \                                 In section .text, align 2, keep-with-next
    786          HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef* hadc, ADC_InjectionConfTypeDef* sConfigInjected)
    787          {
   \                     HAL_ADCEx_InjectedConfigChannel: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    788            
    789          #ifdef USE_FULL_ASSERT  
    790            uint32_t tmp = 0U;
    791          #endif /* USE_FULL_ASSERT  */
    792            
    793            /* Check the parameters */
    794            assert_param(IS_ADC_CHANNEL(sConfigInjected->InjectedChannel));
    795            assert_param(IS_ADC_INJECTED_RANK(sConfigInjected->InjectedRank));
    796            assert_param(IS_ADC_SAMPLE_TIME(sConfigInjected->InjectedSamplingTime));
    797            assert_param(IS_ADC_EXT_INJEC_TRIG(sConfigInjected->ExternalTrigInjecConv));
    798            assert_param(IS_ADC_INJECTED_LENGTH(sConfigInjected->InjectedNbrOfConversion));
    799            assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->AutoInjectedConv));
    800            assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->InjectedDiscontinuousConvMode));
    801          
    802          #ifdef USE_FULL_ASSERT
    803            tmp = ADC_GET_RESOLUTION(hadc);
    804            assert_param(IS_ADC_RANGE(tmp, sConfigInjected->InjectedOffset));
    805          #endif /* USE_FULL_ASSERT  */
    806          
    807            if(sConfigInjected->ExternalTrigInjecConvEdge != ADC_INJECTED_SOFTWARE_START)
    808            {
    809              assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(sConfigInjected->ExternalTrigInjecConvEdge));
    810            }
    811          
    812            /* Process locked */
    813            __HAL_LOCK(hadc);
   \   00000002   0xF990 0x203C      LDRSB    R2,[R0, #+60]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xD101             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE0D4             B.N      ??HAL_ADCEx_InjectedConfigChannel_1
   \                     ??HAL_ADCEx_InjectedConfigChannel_0: (+1)
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0xF880 0x203C      STRB     R2,[R0, #+60]
    814            
    815            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
    816            if (sConfigInjected->InjectedChannel > ADC_CHANNEL_9)
   \   00000014   0x6802             LDR      R2,[R0, #+0]
   \   00000016   0x680B             LDR      R3,[R1, #+0]
   \   00000018   0x2407             MOVS     R4,#+7
   \   0000001A   0x2B0A             CMP      R3,#+10
   \   0000001C   0xD313             BCC.N    ??HAL_ADCEx_InjectedConfigChannel_2
    817            {
    818              /* Clear the old sample time */
    819              hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfigInjected->InjectedChannel);
   \   0000001E   0x68D5             LDR      R5,[R2, #+12]
   \   00000020   0x3B0A             SUBS     R3,R3,#+10
   \   00000022   0xEB03 0x0343      ADD      R3,R3,R3, LSL #+1
   \   00000026   0xFA04 0xF303      LSL      R3,R4,R3
   \   0000002A   0xEA25 0x0303      BIC      R3,R5,R3
   \   0000002E   0x60D3             STR      R3,[R2, #+12]
    820              
    821              /* Set the new sample time */
    822              hadc->Instance->SMPR1 |= ADC_SMPR1(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
   \   00000030   0x6802             LDR      R2,[R0, #+0]
   \   00000032   0x68D3             LDR      R3,[R2, #+12]
   \   00000034   0x688C             LDR      R4,[R1, #+8]
   \   00000036   0x680D             LDR      R5,[R1, #+0]
   \   00000038   0x3D0A             SUBS     R5,R5,#+10
   \   0000003A   0xEB05 0x0545      ADD      R5,R5,R5, LSL #+1
   \   0000003E   0x40AC             LSLS     R4,R4,R5
   \   00000040   0x4323             ORRS     R3,R4,R3
   \   00000042   0x60D3             STR      R3,[R2, #+12]
   \   00000044   0xE010             B.N      ??HAL_ADCEx_InjectedConfigChannel_3
    823            }
    824            else /* ADC_Channel include in ADC_Channel_[0..9] */
    825            {
    826              /* Clear the old sample time */
    827              hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfigInjected->InjectedChannel);
   \                     ??HAL_ADCEx_InjectedConfigChannel_2: (+1)
   \   00000046   0x6915             LDR      R5,[R2, #+16]
   \   00000048   0xEB03 0x0343      ADD      R3,R3,R3, LSL #+1
   \   0000004C   0xFA04 0xF303      LSL      R3,R4,R3
   \   00000050   0xEA25 0x0303      BIC      R3,R5,R3
   \   00000054   0x6113             STR      R3,[R2, #+16]
    828              
    829              /* Set the new sample time */
    830              hadc->Instance->SMPR2 |= ADC_SMPR2(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
   \   00000056   0x6802             LDR      R2,[R0, #+0]
   \   00000058   0x6913             LDR      R3,[R2, #+16]
   \   0000005A   0x688C             LDR      R4,[R1, #+8]
   \   0000005C   0x680D             LDR      R5,[R1, #+0]
   \   0000005E   0xEB05 0x0545      ADD      R5,R5,R5, LSL #+1
   \   00000062   0x40AC             LSLS     R4,R4,R5
   \   00000064   0x4323             ORRS     R3,R4,R3
   \   00000066   0x6113             STR      R3,[R2, #+16]
    831            }
    832            
    833            /*---------------------------- ADCx JSQR Configuration -----------------*/
    834            hadc->Instance->JSQR &= ~(ADC_JSQR_JL);
   \                     ??HAL_ADCEx_InjectedConfigChannel_3: (+1)
   \   00000068   0x6802             LDR      R2,[R0, #+0]
   \   0000006A   0x6B93             LDR      R3,[R2, #+56]
   \   0000006C   0xF423 0x1340      BIC      R3,R3,#0x300000
   \   00000070   0x6393             STR      R3,[R2, #+56]
    835            hadc->Instance->JSQR |=  ADC_SQR1(sConfigInjected->InjectedNbrOfConversion);
   \   00000072   0x6802             LDR      R2,[R0, #+0]
   \   00000074   0x6B93             LDR      R3,[R2, #+56]
   \   00000076   0x690C             LDR      R4,[R1, #+16]
   \   00000078   0x1E64             SUBS     R4,R4,#+1
   \   0000007A   0xEA43 0x5304      ORR      R3,R3,R4, LSL #+20
   \   0000007E   0x6393             STR      R3,[R2, #+56]
    836            
    837            /* Rank configuration */
    838            
    839            /* Clear the old SQx bits for the selected rank */
    840            hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
   \   00000080   0x6802             LDR      R2,[R0, #+0]
   \   00000082   0x6B93             LDR      R3,[R2, #+56]
   \   00000084   0x241F             MOVS     R4,#+31
   \   00000086   0x684D             LDR      R5,[R1, #+4]
   \   00000088   0x1CED             ADDS     R5,R5,#+3
   \   0000008A   0x690E             LDR      R6,[R1, #+16]
   \   0000008C   0x1BAD             SUBS     R5,R5,R6
   \   0000008E   0xEB05 0x0585      ADD      R5,R5,R5, LSL #+2
   \   00000092   0x40AC             LSLS     R4,R4,R5
   \   00000094   0x43A3             BICS     R3,R3,R4
   \   00000096   0x6393             STR      R3,[R2, #+56]
    841             
    842            /* Set the SQx bits for the selected rank */
    843            hadc->Instance->JSQR |= ADC_JSQR(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
   \   00000098   0x6802             LDR      R2,[R0, #+0]
   \   0000009A   0x6B93             LDR      R3,[R2, #+56]
   \   0000009C   0x880C             LDRH     R4,[R1, #+0]
   \   0000009E   0x684D             LDR      R5,[R1, #+4]
   \   000000A0   0x1CED             ADDS     R5,R5,#+3
   \   000000A2   0x690E             LDR      R6,[R1, #+16]
   \   000000A4   0x1BAD             SUBS     R5,R5,R6
   \   000000A6   0xEB05 0x0585      ADD      R5,R5,R5, LSL #+2
   \   000000AA   0x40AC             LSLS     R4,R4,R5
   \   000000AC   0x4323             ORRS     R3,R4,R3
   \   000000AE   0x6393             STR      R3,[R2, #+56]
    844          
    845            /* Enable external trigger if trigger selection is different of software  */
    846            /* start.                                                                 */
    847            /* Note: This configuration keeps the hardware feature of parameter       */
    848            /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    849            /*       software start.                                                  */ 
    850            if(sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
   \   000000B0   0x6802             LDR      R2,[R0, #+0]
   \   000000B2   0x69CB             LDR      R3,[R1, #+28]
   \   000000B4   0x....             LDR.N    R4,??DataTable6_7  ;; 0xf0001
   \   000000B6   0x42A3             CMP      R3,R4
   \   000000B8   0x6893             LDR      R3,[R2, #+8]
   \   000000BA   0xF423 0x2370      BIC      R3,R3,#0xF0000
   \   000000BE   0x6093             STR      R3,[R2, #+8]
   \   000000C0   0x6802             LDR      R2,[R0, #+0]
   \   000000C2   0x6893             LDR      R3,[R2, #+8]
   \   000000C4   0xD00D             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_4
    851            {  
    852              /* Select external trigger to start conversion */
    853              hadc->Instance->CR2 &= ~(ADC_CR2_JEXTSEL);
    854              hadc->Instance->CR2 |=  sConfigInjected->ExternalTrigInjecConv;
   \   000000C6   0x69CC             LDR      R4,[R1, #+28]
   \   000000C8   0x4323             ORRS     R3,R4,R3
   \   000000CA   0x6093             STR      R3,[R2, #+8]
    855              
    856              /* Select external trigger polarity */
    857              hadc->Instance->CR2 &= ~(ADC_CR2_JEXTEN);
   \   000000CC   0x6802             LDR      R2,[R0, #+0]
   \   000000CE   0x6893             LDR      R3,[R2, #+8]
   \   000000D0   0xF423 0x1340      BIC      R3,R3,#0x300000
   \   000000D4   0x6093             STR      R3,[R2, #+8]
    858              hadc->Instance->CR2 |= sConfigInjected->ExternalTrigInjecConvEdge;
   \   000000D6   0x6802             LDR      R2,[R0, #+0]
   \   000000D8   0x6893             LDR      R3,[R2, #+8]
   \   000000DA   0x6A0C             LDR      R4,[R1, #+32]
   \   000000DC   0x4323             ORRS     R3,R4,R3
   \   000000DE   0x6093             STR      R3,[R2, #+8]
   \   000000E0   0xE002             B.N      ??HAL_ADCEx_InjectedConfigChannel_5
    859            }
    860            else
    861            {
    862              /* Reset the external trigger */
    863              hadc->Instance->CR2 &= ~(ADC_CR2_JEXTSEL);
    864              hadc->Instance->CR2 &= ~(ADC_CR2_JEXTEN);  
   \                     ??HAL_ADCEx_InjectedConfigChannel_4: (+1)
   \   000000E2   0xF423 0x1340      BIC      R3,R3,#0x300000
   \   000000E6   0x6093             STR      R3,[R2, #+8]
    865            }
    866            
    867            if (sConfigInjected->AutoInjectedConv != DISABLE)
   \                     ??HAL_ADCEx_InjectedConfigChannel_5: (+1)
   \   000000E8   0x6802             LDR      R2,[R0, #+0]
   \   000000EA   0x698B             LDR      R3,[R1, #+24]
   \   000000EC   0x2B00             CMP      R3,#+0
   \   000000EE   0x6853             LDR      R3,[R2, #+4]
   \   000000F0   0xD003             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_6
    868            {
    869              /* Enable the selected ADC automatic injected group conversion */
    870              hadc->Instance->CR1 |= ADC_CR1_JAUTO;
   \   000000F2   0xF443 0x6380      ORR      R3,R3,#0x400
   \   000000F6   0x6053             STR      R3,[R2, #+4]
   \   000000F8   0xE002             B.N      ??HAL_ADCEx_InjectedConfigChannel_7
    871            }
    872            else
    873            {
    874              /* Disable the selected ADC automatic injected group conversion */
    875              hadc->Instance->CR1 &= ~(ADC_CR1_JAUTO);
   \                     ??HAL_ADCEx_InjectedConfigChannel_6: (+1)
   \   000000FA   0xF423 0x6380      BIC      R3,R3,#0x400
   \   000000FE   0x6053             STR      R3,[R2, #+4]
    876            }
    877            
    878            if (sConfigInjected->InjectedDiscontinuousConvMode != DISABLE)
   \                     ??HAL_ADCEx_InjectedConfigChannel_7: (+1)
   \   00000100   0x6802             LDR      R2,[R0, #+0]
   \   00000102   0x694B             LDR      R3,[R1, #+20]
   \   00000104   0x2B00             CMP      R3,#+0
   \   00000106   0x6853             LDR      R3,[R2, #+4]
   \   00000108   0xD003             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_8
    879            {
    880              /* Enable the selected ADC injected discontinuous mode */
    881              hadc->Instance->CR1 |= ADC_CR1_JDISCEN;
   \   0000010A   0xF443 0x5380      ORR      R3,R3,#0x1000
   \   0000010E   0x6053             STR      R3,[R2, #+4]
   \   00000110   0xE002             B.N      ??HAL_ADCEx_InjectedConfigChannel_9
    882            }
    883            else
    884            {
    885              /* Disable the selected ADC injected discontinuous mode */
    886              hadc->Instance->CR1 &= ~(ADC_CR1_JDISCEN);
   \                     ??HAL_ADCEx_InjectedConfigChannel_8: (+1)
   \   00000112   0xF423 0x5380      BIC      R3,R3,#0x1000
   \   00000116   0x6053             STR      R3,[R2, #+4]
    887            }
    888            
    889            switch(sConfigInjected->InjectedRank)
   \                     ??HAL_ADCEx_InjectedConfigChannel_9: (+1)
   \   00000118   0x684A             LDR      R2,[R1, #+4]
   \   0000011A   0x2A01             CMP      R2,#+1
   \   0000011C   0xD004             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_10
   \   0000011E   0xD324             BCC.N    ??HAL_ADCEx_InjectedConfigChannel_11
   \   00000120   0x2A03             CMP      R2,#+3
   \   00000122   0xD017             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_12
   \   00000124   0xD30B             BCC.N    ??HAL_ADCEx_InjectedConfigChannel_13
   \   00000126   0xE020             B.N      ??HAL_ADCEx_InjectedConfigChannel_11
    890            {
    891              case 1U:
    892                /* Set injected channel 1 offset */
    893                hadc->Instance->JOFR1 &= ~(ADC_JOFR1_JOFFSET1);
   \                     ??HAL_ADCEx_InjectedConfigChannel_10: (+1)
   \   00000128   0x6802             LDR      R2,[R0, #+0]
   \   0000012A   0x6953             LDR      R3,[R2, #+20]
   \   0000012C   0x0B1B             LSRS     R3,R3,#+12
   \   0000012E   0x031B             LSLS     R3,R3,#+12
   \   00000130   0x6153             STR      R3,[R2, #+20]
    894                hadc->Instance->JOFR1 |= sConfigInjected->InjectedOffset;
   \   00000132   0x6802             LDR      R2,[R0, #+0]
   \   00000134   0x6953             LDR      R3,[R2, #+20]
   \   00000136   0x68CC             LDR      R4,[R1, #+12]
   \   00000138   0x4323             ORRS     R3,R4,R3
   \   0000013A   0x6153             STR      R3,[R2, #+20]
    895                break;
   \   0000013C   0xE01F             B.N      ??HAL_ADCEx_InjectedConfigChannel_14
    896              case 2U:
    897                /* Set injected channel 2 offset */
    898                hadc->Instance->JOFR2 &= ~(ADC_JOFR2_JOFFSET2);
   \                     ??HAL_ADCEx_InjectedConfigChannel_13: (+1)
   \   0000013E   0x6802             LDR      R2,[R0, #+0]
   \   00000140   0x6993             LDR      R3,[R2, #+24]
   \   00000142   0x0B1B             LSRS     R3,R3,#+12
   \   00000144   0x031B             LSLS     R3,R3,#+12
   \   00000146   0x6193             STR      R3,[R2, #+24]
    899                hadc->Instance->JOFR2 |= sConfigInjected->InjectedOffset;
   \   00000148   0x6802             LDR      R2,[R0, #+0]
   \   0000014A   0x6993             LDR      R3,[R2, #+24]
   \   0000014C   0x68CC             LDR      R4,[R1, #+12]
   \   0000014E   0x4323             ORRS     R3,R4,R3
   \   00000150   0x6193             STR      R3,[R2, #+24]
    900                break;
   \   00000152   0xE014             B.N      ??HAL_ADCEx_InjectedConfigChannel_14
    901              case 3U:
    902                /* Set injected channel 3 offset */
    903                hadc->Instance->JOFR3 &= ~(ADC_JOFR3_JOFFSET3);
   \                     ??HAL_ADCEx_InjectedConfigChannel_12: (+1)
   \   00000154   0x6802             LDR      R2,[R0, #+0]
   \   00000156   0x69D3             LDR      R3,[R2, #+28]
   \   00000158   0x0B1B             LSRS     R3,R3,#+12
   \   0000015A   0x031B             LSLS     R3,R3,#+12
   \   0000015C   0x61D3             STR      R3,[R2, #+28]
    904                hadc->Instance->JOFR3 |= sConfigInjected->InjectedOffset;
   \   0000015E   0x6802             LDR      R2,[R0, #+0]
   \   00000160   0x69D3             LDR      R3,[R2, #+28]
   \   00000162   0x68CC             LDR      R4,[R1, #+12]
   \   00000164   0x4323             ORRS     R3,R4,R3
   \   00000166   0x61D3             STR      R3,[R2, #+28]
    905                break;
   \   00000168   0xE009             B.N      ??HAL_ADCEx_InjectedConfigChannel_14
    906              default:
    907                /* Set injected channel 4 offset */
    908                hadc->Instance->JOFR4 &= ~(ADC_JOFR4_JOFFSET4);
   \                     ??HAL_ADCEx_InjectedConfigChannel_11: (+1)
   \   0000016A   0x6802             LDR      R2,[R0, #+0]
   \   0000016C   0x6A13             LDR      R3,[R2, #+32]
   \   0000016E   0x0B1B             LSRS     R3,R3,#+12
   \   00000170   0x031B             LSLS     R3,R3,#+12
   \   00000172   0x6213             STR      R3,[R2, #+32]
    909                hadc->Instance->JOFR4 |= sConfigInjected->InjectedOffset;
   \   00000174   0x6802             LDR      R2,[R0, #+0]
   \   00000176   0x6A13             LDR      R3,[R2, #+32]
   \   00000178   0x68CC             LDR      R4,[R1, #+12]
   \   0000017A   0x4323             ORRS     R3,R4,R3
   \   0000017C   0x6213             STR      R3,[R2, #+32]
    910                break;
    911            }
    912            
    913            /* if ADC1 Channel_18 is selected enable VBAT Channel */
    914            if ((hadc->Instance == ADC1) && (sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT))
   \                     ??HAL_ADCEx_InjectedConfigChannel_14: (+1)
   \   0000017E   0x....             LDR.N    R2,??DataTable6_4  ;; 0x40012000
   \   00000180   0x6803             LDR      R3,[R0, #+0]
   \   00000182   0x4293             CMP      R3,R2
   \   00000184   0xD107             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_15
   \   00000186   0x680B             LDR      R3,[R1, #+0]
   \   00000188   0x2B12             CMP      R3,#+18
   \   0000018A   0xD104             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_15
    915            {
    916              /* Enable the VBAT channel*/
    917              ADC->CCR |= ADC_CCR_VBATE;
   \   0000018C   0x....             LDR.N    R3,??DataTable6_3  ;; 0x40012304
   \   0000018E   0x681C             LDR      R4,[R3, #+0]
   \   00000190   0xF444 0x0480      ORR      R4,R4,#0x400000
   \   00000194   0x601C             STR      R4,[R3, #+0]
    918            }
    919            
    920            /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
    921            if ((hadc->Instance == ADC1) && ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) || (sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)))
   \                     ??HAL_ADCEx_InjectedConfigChannel_15: (+1)
   \   00000196   0x6803             LDR      R3,[R0, #+0]
   \   00000198   0x4293             CMP      R3,R2
   \   0000019A   0xD109             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_16
   \   0000019C   0x6809             LDR      R1,[R1, #+0]
   \   0000019E   0x2910             CMP      R1,#+16
   \   000001A0   0xD001             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_17
   \   000001A2   0x2911             CMP      R1,#+17
   \   000001A4   0xD104             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_16
    922            {
    923              /* Enable the TSVREFE channel*/
    924              ADC->CCR |= ADC_CCR_TSVREFE;
   \                     ??HAL_ADCEx_InjectedConfigChannel_17: (+1)
   \   000001A6   0x....             LDR.N    R3,??DataTable6_3  ;; 0x40012304
   \   000001A8   0x6819             LDR      R1,[R3, #+0]
   \   000001AA   0xF441 0x0100      ORR      R1,R1,#0x800000
   \   000001AE   0x6019             STR      R1,[R3, #+0]
    925            }
    926            
    927            /* Process unlocked */
    928            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedConfigChannel_16: (+1)
   \   000001B0   0x2100             MOVS     R1,#+0
   \   000001B2   0xF880 0x103C      STRB     R1,[R0, #+60]
    929            
    930            /* Return function status */
    931            return HAL_OK;
   \   000001B6   0x4608             MOV      R0,R1
   \                     ??HAL_ADCEx_InjectedConfigChannel_1: (+1)
   \   000001B8   0xBC70             POP      {R4-R6}
   \   000001BA   0x4770             BX       LR               ;; return
    932          }
    933          
    934          /**
    935            * @brief  Configures the ADC multi-mode 
    936            * @param  hadc      : pointer to a ADC_HandleTypeDef structure that contains
    937            *                     the configuration information for the specified ADC.  
    938            * @param  multimode : pointer to an ADC_MultiModeTypeDef structure that contains 
    939            *                     the configuration information for  multimode.
    940            * @retval HAL status
    941            */

   \                                 In section .text, align 2, keep-with-next
    942          HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef* hadc, ADC_MultiModeTypeDef* multimode)
    943          {
   \                     HAL_ADCEx_MultiModeConfigChannel: (+1)
   \   00000000   0xB410             PUSH     {R4}
    944            /* Check the parameters */
    945            assert_param(IS_ADC_MODE(multimode->Mode));
    946            assert_param(IS_ADC_DMA_ACCESS_MODE(multimode->DMAAccessMode));
    947            assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
    948            
    949            /* Process locked */
    950            __HAL_LOCK(hadc);
   \   00000002   0xF990 0x203C      LDRSB    R2,[R0, #+60]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xD101             BNE.N    ??HAL_ADCEx_MultiModeConfigChannel_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE01F             B.N      ??HAL_ADCEx_MultiModeConfigChannel_1
   \                     ??HAL_ADCEx_MultiModeConfigChannel_0: (+1)
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0xF880 0x203C      STRB     R2,[R0, #+60]
    951            
    952            /* Set ADC mode */
    953            ADC->CCR &= ~(ADC_CCR_MULTI);
   \   00000014   0x....             LDR.N    R2,??DataTable6_3  ;; 0x40012304
   \   00000016   0x6813             LDR      R3,[R2, #+0]
   \   00000018   0x095B             LSRS     R3,R3,#+5
   \   0000001A   0x015B             LSLS     R3,R3,#+5
   \   0000001C   0x6013             STR      R3,[R2, #+0]
    954            ADC->CCR |= multimode->Mode;
   \   0000001E   0x6813             LDR      R3,[R2, #+0]
   \   00000020   0x680C             LDR      R4,[R1, #+0]
   \   00000022   0x4323             ORRS     R3,R4,R3
   \   00000024   0x6013             STR      R3,[R2, #+0]
    955            
    956            /* Set the ADC DMA access mode */
    957            ADC->CCR &= ~(ADC_CCR_DMA);
   \   00000026   0x6813             LDR      R3,[R2, #+0]
   \   00000028   0xF423 0x4340      BIC      R3,R3,#0xC000
   \   0000002C   0x6013             STR      R3,[R2, #+0]
    958            ADC->CCR |= multimode->DMAAccessMode;
   \   0000002E   0x6813             LDR      R3,[R2, #+0]
   \   00000030   0x684C             LDR      R4,[R1, #+4]
   \   00000032   0x4323             ORRS     R3,R4,R3
   \   00000034   0x6013             STR      R3,[R2, #+0]
    959            
    960            /* Set delay between two sampling phases */
    961            ADC->CCR &= ~(ADC_CCR_DELAY);
   \   00000036   0x6813             LDR      R3,[R2, #+0]
   \   00000038   0xF423 0x6370      BIC      R3,R3,#0xF00
   \   0000003C   0x6013             STR      R3,[R2, #+0]
    962            ADC->CCR |= multimode->TwoSamplingDelay;
   \   0000003E   0x6813             LDR      R3,[R2, #+0]
   \   00000040   0x6889             LDR      R1,[R1, #+8]
   \   00000042   0x4319             ORRS     R1,R1,R3
   \   00000044   0x6011             STR      R1,[R2, #+0]
    963            
    964            /* Process unlocked */
    965            __HAL_UNLOCK(hadc);
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0xF880 0x103C      STRB     R1,[R0, #+60]
    966            
    967            /* Return function status */
    968            return HAL_OK;
   \   0000004C   0x4608             MOV      R0,R1
   \                     ??HAL_ADCEx_MultiModeConfigChannel_1: (+1)
   \   0000004E   0xBC10             POP      {R4}
   \   00000050   0x4770             BX       LR               ;; return
    969          }
    970          
    971          /**
    972            * @}
    973            */
    974          
    975          /**
    976            * @brief  DMA transfer complete callback. 
    977            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    978            *                the configuration information for the specified DMA module.
    979            * @retval None
    980            */

   \                                 In section .text, align 4, keep-with-next
    981          static void ADC_MultiModeDMAConvCplt(DMA_HandleTypeDef *hdma)   
    982          {
    983            /* Retrieve ADC handle corresponding to current DMA handle */
    984            ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \                     ADC_MultiModeDMAConvCplt: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
    985            
    986            /* Update state machine on conversion status if not in error state */
    987            if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
   \   00000002   0x6C0A             LDR      R2,[R1, #+64]
   \   00000004   0xF012 0x0F50      TST      R2,#0x50
   \   00000008   0xD124             BNE.N    ??ADC_MultiModeDMAConvCplt_0
    988            {
    989              /* Update ADC state machine */
    990              SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
   \   0000000A   0x6C08             LDR      R0,[R1, #+64]
   \   0000000C   0xF440 0x7000      ORR      R0,R0,#0x200
   \   00000010   0x6408             STR      R0,[R1, #+64]
    991              
    992              /* Determine whether any further conversion upcoming on group regular   */
    993              /* by external trigger, continuous mode or scan sequence on going.      */
    994              /* Note: On STM32F4, there is no independent flag of end of sequence.   */
    995              /*       The test of scan sequence on going is done either with scan    */
    996              /*       sequence disabled or with end of conversion flag set to        */
    997              /*       of end of sequence.                                            */
    998              if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
    999                 (hadc->Init.ContinuousConvMode == DISABLE)            &&
   1000                 (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
   1001                  HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
   \   00000012   0x6808             LDR      R0,[R1, #+0]
   \   00000014   0x6882             LDR      R2,[R0, #+8]
   \   00000016   0xF012 0x5F40      TST      R2,#0x30000000
   \   0000001A   0xD118             BNE.N    ??ADC_MultiModeDMAConvCplt_1
   \   0000001C   0x698A             LDR      R2,[R1, #+24]
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD115             BNE.N    ??ADC_MultiModeDMAConvCplt_1
   \   00000022   0x6AC2             LDR      R2,[R0, #+44]
   \   00000024   0xF412 0x0F70      TST      R2,#0xF00000
   \   00000028   0xD002             BEQ.N    ??ADC_MultiModeDMAConvCplt_2
   \   0000002A   0x6882             LDR      R2,[R0, #+8]
   \   0000002C   0x0552             LSLS     R2,R2,#+21
   \   0000002E   0xD40E             BMI.N    ??ADC_MultiModeDMAConvCplt_1
   1002              {
   1003                /* Disable ADC end of single conversion interrupt on group regular */
   1004                /* Note: Overrun interrupt was enabled with EOC interrupt in          */
   1005                /* HAL_ADC_Start_IT(), but is not disabled here because can be used   */
   1006                /* by overrun IRQ process below.                                      */
   1007                __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
   \                     ??ADC_MultiModeDMAConvCplt_2: (+1)
   \   00000030   0x6842             LDR      R2,[R0, #+4]
   \   00000032   0xF022 0x0220      BIC      R2,R2,#0x20
   \   00000036   0x6042             STR      R2,[R0, #+4]
   1008                
   1009                /* Set ADC state */
   1010                CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
   \   00000038   0x6C08             LDR      R0,[R1, #+64]
   \   0000003A   0xF420 0x7080      BIC      R0,R0,#0x100
   \   0000003E   0x6408             STR      R0,[R1, #+64]
   1011                
   1012                if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \   00000040   0x6C08             LDR      R0,[R1, #+64]
   \   00000042   0x04C0             LSLS     R0,R0,#+19
   \   00000044   0xD403             BMI.N    ??ADC_MultiModeDMAConvCplt_1
   1013                {
   1014                  SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \   00000046   0x6C08             LDR      R0,[R1, #+64]
   \   00000048   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000004C   0x6408             STR      R0,[R1, #+64]
   1015                }
   1016              }
   1017              
   1018              /* Conversion complete callback */
   1019              HAL_ADC_ConvCpltCallback(hadc);
   \                     ??ADC_MultiModeDMAConvCplt_1: (+1)
   \   0000004E   0x4608             MOV      R0,R1
   \   00000050   0x.... 0x....      B.W      HAL_ADC_ConvCpltCallback
   1020            }
   1021            else
   1022            {
   1023              /* Call DMA error callback */
   1024              hadc->DMA_Handle->XferErrorCallback(hdma);
   \                     ??ADC_MultiModeDMAConvCplt_0: (+1)
   \   00000054   0x6B89             LDR      R1,[R1, #+56]
   \   00000056   0x6CC9             LDR      R1,[R1, #+76]
   \   00000058   0x4708             BX       R1
   1025            }
   1026          }
   1027          
   1028          /**
   1029            * @brief  DMA half transfer complete callback. 
   1030            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1031            *                the configuration information for the specified DMA module.
   1032            * @retval None
   1033            */

   \                                 In section .text, align 4, keep-with-next
   1034          static void ADC_MultiModeDMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
   1035          {
   1036              ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   1037              /* Conversion complete callback */
   1038              HAL_ADC_ConvHalfCpltCallback(hadc); 
   \                     ADC_MultiModeDMAHalfConvCplt: (+1)
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   \   00000002   0x.... 0x....      B.W      HAL_ADC_ConvHalfCpltCallback
   1039          }
   1040          
   1041          /**
   1042            * @brief  DMA error callback 
   1043            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1044            *                the configuration information for the specified DMA module.
   1045            * @retval None
   1046            */

   \                                 In section .text, align 4, keep-with-next
   1047          static void ADC_MultiModeDMAError(DMA_HandleTypeDef *hdma)   
   1048          {
   1049              ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \                     ADC_MultiModeDMAError: (+1)
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   1050              hadc->State= HAL_ADC_STATE_ERROR_DMA;
   \   00000002   0x2140             MOVS     R1,#+64
   \   00000004   0x6401             STR      R1,[R0, #+64]
   1051              /* Set ADC error code to DMA error */
   1052              hadc->ErrorCode |= HAL_ADC_ERROR_DMA;
   \   00000006   0x6C41             LDR      R1,[R0, #+68]
   \   00000008   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000000C   0x6441             STR      R1,[R0, #+68]
   1053              HAL_ADC_ErrorCallback(hadc); 
   \   0000000E   0x.... 0x....      B.W      HAL_ADC_ErrorCallback
   1054          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0xFFFFDFFE         DC32     0xffffdffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x40012304         DC32     0x40012304

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x40012000         DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0xFFFFF9FE         DC32     0xfffff9fe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x40012308         DC32     0x40012308

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x000F0001         DC32     0xf0001
   1055          
   1056          /**
   1057            * @}
   1058            */
   1059          
   1060          #endif /* HAL_ADC_MODULE_ENABLED */
   1061          /**
   1062            * @}
   1063            */ 
   1064          
   1065          /**
   1066            * @}
   1067            */ 
   1068          
   1069          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ADC_MultiModeDMAConvCplt
         0   -- Indirect call
         0   -> HAL_ADC_ConvCpltCallback
       0   ADC_MultiModeDMAError
         0   -> HAL_ADC_ErrorCallback
       0   ADC_MultiModeDMAHalfConvCplt
         0   -> HAL_ADC_ConvHalfCpltCallback
      12   HAL_ADCEx_InjectedConfigChannel
       0   HAL_ADCEx_InjectedConvCpltCallback
       4   HAL_ADCEx_InjectedGetValue
      16   HAL_ADCEx_InjectedPollForConversion
        16   -> HAL_GetTick
       4   HAL_ADCEx_InjectedStart
       4   HAL_ADCEx_InjectedStart_IT
       0   HAL_ADCEx_InjectedStop
       0   HAL_ADCEx_InjectedStop_IT
       4   HAL_ADCEx_MultiModeConfigChannel
       0   HAL_ADCEx_MultiModeGetValue
      16   HAL_ADCEx_MultiModeStart_DMA
        16   -> HAL_DMA_Start_IT
       8   HAL_ADCEx_MultiModeStop_DMA
         8   -> HAL_DMA_Abort


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
      90  ADC_MultiModeDMAConvCplt
      18  ADC_MultiModeDMAError
       6  ADC_MultiModeDMAHalfConvCplt
     444  HAL_ADCEx_InjectedConfigChannel
       2  HAL_ADCEx_InjectedConvCpltCallback
      66  HAL_ADCEx_InjectedGetValue
     138  HAL_ADCEx_InjectedPollForConversion
     224  HAL_ADCEx_InjectedStart
     234  HAL_ADCEx_InjectedStart_IT
      84  HAL_ADCEx_InjectedStop
      92  HAL_ADCEx_InjectedStop_IT
      82  HAL_ADCEx_MultiModeConfigChannel
       6  HAL_ADCEx_MultiModeGetValue
     240  HAL_ADCEx_MultiModeStart_DMA
      88  HAL_ADCEx_MultiModeStop_DMA

 
 1 846 bytes in section .text
 
 1 846 bytes of CODE memory

Errors: none
Warnings: none
