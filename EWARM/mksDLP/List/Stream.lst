###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:26
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\Stream.cpp
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\Stream.cpp
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\Stream.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\Stream.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\Stream.cpp
      1          /*
      2           Stream.cpp - adds parsing methods to Stream class
      3           Copyright (c) 2008 David A. Mellis.  All right reserved.
      4          
      5           This library is free software; you can redistribute it and/or
      6           modify it under the terms of the GNU Lesser General Public
      7           License as published by the Free Software Foundation; either
      8           version 2.1 of the License, or (at your option) any later version.
      9          
     10           This library is distributed in the hope that it will be useful,
     11           but WITHOUT ANY WARRANTY; without even the implied warranty of
     12           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     13           Lesser General Public License for more details.
     14          
     15           You should have received a copy of the GNU Lesser General Public
     16           License along with this library; if not, write to the Free Software
     17           Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
     18          
     19           Created July 2011
     20           parsing functions based on TextFinder library by Michael Margolis
     21           */
     22          
     23          #include "Arduino.h"

  #define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_iwdg.h",80  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_PRESCALER" (declared at
          line 209 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_iwdg.h")

  #define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_iwdg.h",97  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_RELOAD" (declared at
          line 222 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_iwdg.h")

  #define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",272  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NORSRAM_BANK" (declared
          at line 834 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",277  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NAND_BANK" (declared at
          line 855 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",298  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MUX" (declared at line
          839 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",311  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MEMORY" (declared at
          line 842 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",336  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_BURSTMODE" (declared at
          line 894 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",347  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ASYNWAIT" (declared at
          line 915 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",358  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_POLARITY" (declared
          at line 897 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",369  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRAP_MODE" (declared at
          line 900 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",380  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_SIGNAL_ACTIVE"
          (declared at line 903 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",391  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_OPERATION"
          (declared at line 906 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",402  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAITE_SIGNAL" (declared
          at line 909 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",414  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_EXTENDED_MODE" (declared
          at line 912 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",426  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_BURST" (declared
          at line 920 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",435  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_SETUP_TIME"
          (declared at line 923 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_HOLD_TIME"
          (declared at line 925 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",451  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATASETUP_TIME"
          (declared at line 927 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",459  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TURNAROUND_TIME"
          (declared at line 929 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",467  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_CLK_DIV" (declared at
          line 934 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATA_LATENCY" (declared
          at line 918 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",487  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ACCESS_MODE" (declared
          at line 850 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",508  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_FEATURE" (declared
          at line 858 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",520  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECC_STATE" (declared at
          line 864 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",535  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECCPAGE_SIZE" (declared
          at line 867 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",548  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TCLR_TIME" (declared at
          line 874 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",556  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TAR_TIME" (declared at
          line 876 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",564  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_SETUP_TIME" (declared at
          line 878 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",572  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_TIME" (declared at
          line 880 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",580  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HOLD_TIME" (declared at
          line 882 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",588  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HIZ_TIME" (declared at
          line 884 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define FSMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",613  Warning[Pe047]: 
          incompatible redefinition of macro "FSMC_FLAG_FEMPT" (declared at
          line 530 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

    #define assert_param(expr) ((void)0)        
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\stm32f4xx_conf.h",149  Warning[Pe047]: 
          incompatible redefinition of macro "assert_param" (declared at line
          431 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\stm32f4x
          x_hal_conf.h")

   \                                 In section .text, align 2
   \   __interwork __softfp String &String::operator+=(char)
   \                     _ZN6StringpLEc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      BL       _ZN6String6concatEc
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
     24          #include "Stream.h"
     25          
     26          #define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
     27          #define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field
     28          
     29          extern unsigned long millis();
     30          
     31          // private method to read stream with timeout

   \                                 In section .text, align 2, keep-with-next
     32          int Stream::timedRead()
     33          {
   \                     _ZN6Stream9timedReadEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     34            int c;
     35            _startMillis = millis();
   \   00000004   0x.... 0x....      BL       _Z6millisv
   \   00000008   0x60E0             STR      R0,[R4, #+12]
     36            do {
     37              c = read();
   \                     ??timedRead_0: (+1)
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x68C9             LDR      R1,[R1, #+12]
   \   00000010   0x4788             BLX      R1
     38              if (c >= 0) return c;
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD508             BPL.N    ??timedRead_1
     39            } while(millis() - _startMillis < _timeout);
   \   00000016   0x.... 0x....      BL       _Z6millisv
   \   0000001A   0x68E1             LDR      R1,[R4, #+12]
   \   0000001C   0x1A40             SUBS     R0,R0,R1
   \   0000001E   0x68A1             LDR      R1,[R4, #+8]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD3F2             BCC.N    ??timedRead_0
     40            return -1;     // -1 indicates timeout
   \   00000024   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??timedRead_1: (+1)
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
     41          }
     42          
     43          // private method to peek stream with timeout

   \                                 In section .text, align 2, keep-with-next
     44          int Stream::timedPeek()
     45          {
   \                     _ZN6Stream9timedPeekEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     46            int c;
     47            _startMillis = millis();
   \   00000004   0x.... 0x....      BL       _Z6millisv
   \   00000008   0x60E0             STR      R0,[R4, #+12]
     48            do {
     49              c = peek();
   \                     ??timedPeek_0: (+1)
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x6909             LDR      R1,[R1, #+16]
   \   00000010   0x4788             BLX      R1
     50              if (c >= 0) return c;
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD508             BPL.N    ??timedPeek_1
     51            } while(millis() - _startMillis < _timeout);
   \   00000016   0x.... 0x....      BL       _Z6millisv
   \   0000001A   0x68E1             LDR      R1,[R4, #+12]
   \   0000001C   0x1A40             SUBS     R0,R0,R1
   \   0000001E   0x68A1             LDR      R1,[R4, #+8]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD3F2             BCC.N    ??timedPeek_0
     52            return -1;     // -1 indicates timeout
   \   00000024   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??timedPeek_1: (+1)
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
     53          }
     54          
     55          // returns peek of the next digit in the stream or -1 if timeout
     56          // discards non-numeric characters

   \                                 In section .text, align 2, keep-with-next
     57          int Stream::peekNextDigit()
     58          {
   \                     _ZN6Stream13peekNextDigitEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??peekNextDigit_0
     59            int c;
     60            while (1) {
     61              c = timedPeek();
     62              if (c < 0) return c;  // timeout
     63              if (c == '-') return c;
     64              if (c >= '0' && c <= '9') return c;
     65              read();  // discard non-numeric
   \                     ??peekNextDigit_1: (+1)
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x6821             LDR      R1,[R4, #+0]
   \   0000000A   0x68C9             LDR      R1,[R1, #+12]
   \   0000000C   0x4788             BLX      R1
   \                     ??peekNextDigit_0: (+1)
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       _ZN6Stream9timedPeekEv
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD405             BMI.N    ??peekNextDigit_2
   \   00000018   0x282D             CMP      R0,#+45
   \   0000001A   0xD003             BEQ.N    ??peekNextDigit_2
   \   0000001C   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   00000020   0x290A             CMP      R1,#+10
   \   00000022   0xD2F0             BCS.N    ??peekNextDigit_1
   \                     ??peekNextDigit_2: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
     66            }
     67          }
     68          
     69          // Public Methods
     70          //////////////////////////////////////////////////////////////
     71          

   \                                 In section .text, align 2, keep-with-next
     72          void Stream::setTimeout(unsigned long timeout)  // sets the maximum number of milliseconds to wait
     73          {
     74            _timeout = timeout;
   \                     _ZN6Stream10setTimeoutEm: (+1)
   \   00000000   0x6081             STR      R1,[R0, #+8]
     75          }
   \   00000002   0x4770             BX       LR               ;; return
     76          
     77           // find returns true if the target string is found

   \                                 In section .text, align 2, keep-with-next
     78          bool  Stream::find(char *target)
     79          {
     80            return findUntil(target, NULL);
   \                     _ZN6Stream4findEPc: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x....             B.N      _ZN6Stream9findUntilEPcS0_
     81          }
     82          
     83          // reads data from the stream until the target string of given length is found
     84          // returns true if target string is found, false if timed out

   \                                 In section .text, align 2, keep-with-next
     85          bool Stream::find(char *target, size_t length)
     86          {
   \                     _ZN6Stream4findEPcj: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     87            return findUntil(target, length, NULL, 0);
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x9300             STR      R3,[SP, #+0]
   \   00000006   0x.... 0x....      BL       _ZN6Stream9findUntilEPcjS0_j
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
     88          }
     89          
     90          // as find but search ends if the terminator string is found

   \                                 In section .text, align 2, keep-with-next
     91          bool  Stream::findUntil(char *target, char *terminator)
     92          {
   \                     _ZN6Stream9findUntilEPcS0_: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
     93            return findUntil(target, strlen(target), terminator, strlen(terminator));
   \   00000008   0x4630             MOV      R0,R6
   \   0000000A   0x.... 0x....      BL       strlen
   \   0000000E   0x4607             MOV      R7,R0
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       strlen
   \   00000016   0x9700             STR      R7,[SP, #+0]
   \   00000018   0x4633             MOV      R3,R6
   \   0000001A   0x4602             MOV      R2,R0
   \   0000001C   0x4629             MOV      R1,R5
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       _ZN6Stream9findUntilEPcjS0_j
   \   00000024   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     94          }
     95          
     96          // reads data from the stream until the target string of the given length is found
     97          // search terminated if the terminator string is found
     98          // returns true if target string is found, false if terminated or timed out

   \                                 In section .text, align 2, keep-with-next
     99          bool Stream::findUntil(char *target, size_t targetLen, char *terminator, size_t termLen)
    100          {
   \                     _ZN6Stream9findUntilEPcjS0_j: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    101            size_t index = 0;  // maximum target string length is 64k bytes!
   \   0000000C   0xF04F 0x0800      MOV      R8,#+0
    102            size_t termIndex = 0;
   \   00000010   0x46C1             MOV      R9,R8
    103            int c;
    104            
    105            if( *target == 0)
   \   00000012   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD017             BEQ.N    ??findUntil_0
   \   0000001A   0xF8DD 0xA020      LDR      R10,[SP, #+32]
   \   0000001E   0xE001             B.N      ??findUntil_1
    106              return true;   // return true if target is a null string
    107            while( (c = timedRead()) > 0){
    108              
    109              if(c != target[index])
    110                index = 0; // reset index if any char does not match
    111              
    112              if( c == target[index]){
    113                //////Serial.print("found "); Serial.write(c); Serial.print("index now"); Serial.println(index+1);
    114                if(++index >= targetLen){ // return true if all chars in the target match
    115                  return true;
    116                }
    117              }
    118              
    119              if(termLen > 0 && c == terminator[termIndex]){
    120                if(++termIndex >= termLen)
    121                  return false;       // return false if terminate string found before target string
    122              }
    123              else
    124                termIndex = 0;
   \                     ??findUntil_2: (+1)
   \   00000020   0xF04F 0x0900      MOV      R9,#+0
   \                     ??findUntil_1: (+1)
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _ZN6Stream9timedReadEv
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xDB1A             BLT.N    ??findUntil_3
   \   0000002E   0xF918 0x1005      LDRSB    R1,[R8, R5]
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD001             BEQ.N    ??findUntil_4
   \   00000036   0xF04F 0x0800      MOV      R8,#+0
   \                     ??findUntil_4: (+1)
   \   0000003A   0xF918 0x1005      LDRSB    R1,[R8, R5]
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD105             BNE.N    ??findUntil_5
   \   00000042   0xF108 0x0801      ADD      R8,R8,#+1
   \   00000046   0x45B0             CMP      R8,R6
   \   00000048   0xD301             BCC.N    ??findUntil_5
   \                     ??findUntil_0: (+1)
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xE00B             B.N      ??findUntil_6
   \                     ??findUntil_5: (+1)
   \   0000004E   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000052   0xD0E5             BEQ.N    ??findUntil_2
   \   00000054   0xF919 0x1007      LDRSB    R1,[R9, R7]
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD1E1             BNE.N    ??findUntil_2
   \   0000005C   0xF109 0x0901      ADD      R9,R9,#+1
   \   00000060   0x45D1             CMP      R9,R10
   \   00000062   0xD3DF             BCC.N    ??findUntil_1
    125            }
    126            return false;
   \                     ??findUntil_3: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \                     ??findUntil_6: (+1)
   \   00000066   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    127          }
    128          
    129          
    130          // returns the first valid (long) integer value from the current position.
    131          // initial characters that are not digits (or the minus sign) are skipped
    132          // function is terminated by the first character that is not a digit.

   \                                 In section .text, align 2, keep-with-next
    133          long Stream::parseInt()
    134          {
    135            return parseInt(NO_SKIP_CHAR); // terminate on first non-digit character (or timeout)
   \                     _ZN6Stream8parseIntEv: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002                      REQUIRE _ZN6Stream8parseIntEc
   \   00000002                      ;; // Fall through to label Stream::parseInt(char)
    136          }
    137          
    138          // as above but a given skipChar is ignored
    139          // this allows format characters (typically commas) in values to be ignored

   \                                 In section .text, align 2, keep-with-next
    140          long Stream::parseInt(char skipChar)
    141          {
   \                     _ZN6Stream8parseIntEc: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    142            boolean isNegative = false;
   \   00000008   0x2700             MOVS     R7,#+0
    143            long value = 0;
   \   0000000A   0x46B8             MOV      R8,R7
    144            int c;
    145          
    146            c = peekNextDigit();
   \   0000000C   0x.... 0x....      BL       _ZN6Stream13peekNextDigitEv
    147            // ignore non numeric leading characters
    148            if(c < 0)
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD501             BPL.N    ??parseInt_0
    149              return 0; // zero returned if timeout
   \   00000014   0x4638             MOV      R0,R7
   \   00000016   0xE022             B.N      ??parseInt_1
    150          
    151            do{
    152              if(c == skipChar)
   \                     ??parseInt_0: (+1)
   \   00000018   0x462E             MOV      R6,R5
   \   0000001A   0x42B0             CMP      R0,R6
   \   0000001C   0xD00D             BEQ.N    ??parseInt_2
    153                ; // ignore this charactor
    154              else if(c == '-')
   \   0000001E   0x282D             CMP      R0,#+45
   \   00000020   0xD101             BNE.N    ??parseInt_3
    155                isNegative = true;
   \   00000022   0x2701             MOVS     R7,#+1
   \   00000024   0xE009             B.N      ??parseInt_2
    156              else if(c >= '0' && c <= '9')        // is c a digit?
   \                     ??parseInt_3: (+1)
   \   00000026   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   0000002A   0x290A             CMP      R1,#+10
   \   0000002C   0xD205             BCS.N    ??parseInt_2
    157                value = value * 10 + c - '0';
   \   0000002E   0xEB08 0x0188      ADD      R1,R8,R8, LSL #+2
   \   00000032   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \   00000036   0xF1A0 0x0830      SUB      R8,R0,#+48
    158              read();  // consume the character we got with peek
   \                     ??parseInt_2: (+1)
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x6821             LDR      R1,[R4, #+0]
   \   0000003E   0x68C9             LDR      R1,[R1, #+12]
   \   00000040   0x4788             BLX      R1
    159              c = timedPeek();
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       _ZN6Stream9timedPeekEv
    160            }
    161            while( (c >= '0' && c <= '9') || c == skipChar );
   \   00000048   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   0000004C   0x290A             CMP      R1,#+10
   \   0000004E   0xD3E3             BCC.N    ??parseInt_0
   \   00000050   0x42B0             CMP      R0,R6
   \   00000052   0xD0E1             BEQ.N    ??parseInt_0
    162          
    163            if(isNegative)
   \   00000054   0x2F00             CMP      R7,#+0
   \   00000056   0xD001             BEQ.N    ??parseInt_4
    164              value = -value;
   \   00000058   0xF1C8 0x0800      RSB      R8,R8,#+0
    165            return value;
   \                     ??parseInt_4: (+1)
   \   0000005C   0x4640             MOV      R0,R8
   \                     ??parseInt_1: (+1)
   \   0000005E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    166          }
    167          
    168          
    169          // as parseInt but returns a floating point value

   \                                 In section .text, align 4, keep-with-next
    170          float Stream::parseFloat()
    171          {
    172            return parseFloat(NO_SKIP_CHAR);
   \                     _ZN6Stream10parseFloatEv: (+1)
   \   00000000   0xF05F 0x0101      MOVS.W   R1,#+1
   \   00000004                      REQUIRE _ZN6Stream10parseFloatEc
   \   00000004                      ;; // Fall through to label Stream::parseFloat(char)
    173          }
    174          
    175          // as above but the given skipChar is ignored
    176          // this allows format characters (typically commas) in values to be ignored

   \                                 In section .text, align 4, keep-with-next
    177          float Stream::parseFloat(char skipChar){
   \                     _ZN6Stream10parseFloatEc: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x4689             MOV      R9,R1
    178            boolean isNegative = false;
   \   0000000C   0x2500             MOVS     R5,#+0
    179            boolean isFraction = false;
   \   0000000E   0x462E             MOV      R6,R5
    180            long value = 0;
   \   00000010   0x462F             MOV      R7,R5
    181            signed char c;
    182            float fraction = 1.0;
   \   00000012   0xEEB7 0x8A00      VMOV.F32 S16,#1.0
    183          
    184            c = peekNextDigit();
   \   00000016   0x.... 0x....      BL       _ZN6Stream13peekNextDigitEv
   \   0000001A   0xB240             SXTB     R0,R0
    185              // ignore non numeric leading characters
    186            if(c < 0)
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0x46C8             MOV      R8,R9
   \   00000020   0xD502             BPL.N    ??parseFloat_0
    187              return 0; // zero returned if timeout
   \   00000022   0xED9F 0x....      VLDR.W   S0,??DataTable3  ;; 0x0
   \   00000026   0xE03C             B.N      ??parseFloat_1
    188          
    189            do{
    190              if(c == skipChar)
   \                     ??parseFloat_0: (+1)
   \   00000028   0x4540             CMP      R0,R8
   \   0000002A   0xD01F             BEQ.N    ??parseFloat_2
    191                ; // ignore
    192              else if(c == '-')
   \   0000002C   0x282D             CMP      R0,#+45
   \   0000002E   0xD101             BNE.N    ??parseFloat_3
    193                isNegative = true;
   \   00000030   0x2501             MOVS     R5,#+1
   \   00000032   0xE01B             B.N      ??parseFloat_2
    194              else if (c == '.')
   \                     ??parseFloat_3: (+1)
   \   00000034   0x282E             CMP      R0,#+46
   \   00000036   0xD101             BNE.N    ??parseFloat_4
    195                isFraction = true;
   \   00000038   0x2601             MOVS     R6,#+1
   \   0000003A   0xE017             B.N      ??parseFloat_2
    196              else if(c >= '0' && c <= '9')  {      // is c a digit?
   \                     ??parseFloat_4: (+1)
   \   0000003C   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   00000040   0x290A             CMP      R1,#+10
   \   00000042   0xD213             BCS.N    ??parseFloat_2
    197                value = value * 10 + c - '0';
   \   00000044   0xEB07 0x0187      ADD      R1,R7,R7, LSL #+2
   \   00000048   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \   0000004C   0xF1A0 0x0730      SUB      R7,R0,#+48
    198                if(isFraction)
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xD00B             BEQ.N    ??parseFloat_2
    199                   fraction *= 0.1;
   \   00000054   0xEE18 0x0A10      VMOV     R0,S16
   \   00000058   0x.... 0x....      BL       __aeabi_f2d
   \   0000005C   0x....             LDR.N    R2,??DataTable3_2  ;; 0x9999999a
   \   0000005E   0x....             LDR.N    R3,??DataTable3_3  ;; 0x3fb99999
   \   00000060   0x.... 0x....      BL       __aeabi_dmul
   \   00000064   0x.... 0x....      BL       __aeabi_d2f
   \   00000068   0xEE08 0x0A10      VMOV     S16,R0
    200              }
    201              read();  // consume the character we got with peek
   \                     ??parseFloat_2: (+1)
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x6821             LDR      R1,[R4, #+0]
   \   00000070   0x68C9             LDR      R1,[R1, #+12]
   \   00000072   0x4788             BLX      R1
    202              c = timedPeek();
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       _ZN6Stream9timedPeekEv
   \   0000007A   0xB240             SXTB     R0,R0
    203            }
    204            while( (c >= '0' && c <= '9')  || c == '.' || c == skipChar );
   \   0000007C   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   00000080   0x290A             CMP      R1,#+10
   \   00000082   0xD3D1             BCC.N    ??parseFloat_0
   \   00000084   0x282E             CMP      R0,#+46
   \   00000086   0xD0CF             BEQ.N    ??parseFloat_0
   \   00000088   0x4540             CMP      R0,R8
   \   0000008A   0xD0CD             BEQ.N    ??parseFloat_0
    205          
    206            if(isNegative)
   \   0000008C   0x2D00             CMP      R5,#+0
   \   0000008E   0xD000             BEQ.N    ??parseFloat_5
    207              value = -value;
   \   00000090   0x427F             RSBS     R7,R7,#+0
    208            if(isFraction)
   \                     ??parseFloat_5: (+1)
   \   00000092   0xEE00 0x7A10      VMOV     S0,R7
   \   00000096   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000009A   0x2E00             CMP      R6,#+0
   \   0000009C   0xD001             BEQ.N    ??parseFloat_1
    209              return value * fraction;
   \   0000009E   0xEE20 0x0A08      VMUL.F32 S0,S0,S16
    210            else
    211              return value;
   \                     ??parseFloat_1: (+1)
   \   000000A2   0xECBD 0x8B02      VPOP     {D8}
   \   000000A6   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    212          }
    213          
    214          // read characters from stream into buffer
    215          // terminates if length characters have been read, or timeout (see setTimeout)
    216          // returns the number of characters placed in the buffer
    217          // the buffer is NOT null terminated.
    218          //

   \                                 In section .text, align 2, keep-with-next
    219          size_t Stream::readBytes(char *buffer, size_t length)
    220          {
   \                     _ZN6Stream9readBytesEPcj: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    221            size_t count = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0xE002             B.N      ??readBytes_0
    222            while (count < length) {
    223              int c = timedRead();
    224              if (c < 0) break;
    225              *buffer++ = (char)c;
   \                     ??readBytes_1: (+1)
   \   0000000C   0xF805 0x0B01      STRB     R0,[R5], #+1
    226              count++;
   \   00000010   0x1C7F             ADDS     R7,R7,#+1
   \                     ??readBytes_0: (+1)
   \   00000012   0x42B7             CMP      R7,R6
   \   00000014   0xD204             BCS.N    ??readBytes_2
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _ZN6Stream9timedReadEv
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD5F5             BPL.N    ??readBytes_1
    227            }
    228            return count;
   \                     ??readBytes_2: (+1)
   \   00000020   0x4638             MOV      R0,R7
   \   00000022   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    229          }
    230          
    231          
    232          // as readBytes with terminator character
    233          // terminates if length characters have been read, timeout, or if the terminator character  detected
    234          // returns the number of characters placed in the buffer (0 means no valid data found)
    235          

   \                                 In section .text, align 2, keep-with-next
    236          size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
    237          {
   \                     _ZN6Stream14readBytesUntilEcPcj: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    238            if (length < 1) return 0;
   \   0000000C   0xD101             BNE.N    ??readBytesUntil_0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE010             B.N      ??readBytesUntil_1
    239            size_t index = 0;
   \                     ??readBytesUntil_0: (+1)
   \   00000012   0xF04F 0x0800      MOV      R8,#+0
   \   00000016   0xE003             B.N      ??readBytesUntil_2
    240            while (index < length) {
    241              int c = timedRead();
    242              if (c < 0 || c == terminator) break;
    243              *buffer++ = (char)c;
   \                     ??readBytesUntil_3: (+1)
   \   00000018   0xF806 0x0B01      STRB     R0,[R6], #+1
    244              index++;
   \   0000001C   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??readBytesUntil_2: (+1)
   \   00000020   0x45B8             CMP      R8,R7
   \   00000022   0xD206             BCS.N    ??readBytesUntil_4
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _ZN6Stream9timedReadEv
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD401             BMI.N    ??readBytesUntil_4
   \   0000002E   0x42A8             CMP      R0,R5
   \   00000030   0xD1F2             BNE.N    ??readBytesUntil_3
    245            }
    246            return index; // return number of characters, not including null terminator
   \                     ??readBytesUntil_4: (+1)
   \   00000032   0x4640             MOV      R0,R8
   \                     ??readBytesUntil_1: (+1)
   \   00000034   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    247          }
    248          

   \                                 In section .text, align 2, keep-with-next
    249          String Stream::readString()
    250          {
   \                     _ZN6Stream10readStringEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    251            String ret;
   \   00000006   0x....             ADR.N    R1,??DataTable3_1  ;; ""
   \   00000008   0x.... 0x....      BL       _ZN6StringC1EPKc
    252            int c = timedRead();
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       _ZN6Stream9timedReadEv
   \   00000012   0xE007             B.N      ??readString_0
    253            while (c >= 0)
    254            {
    255              ret += (char)c;
   \                     ??readString_1: (+1)
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0xB249             SXTB     R1,R1
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       _ZN6StringpLEc
    256              c = timedRead();
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       _ZN6Stream9timedReadEv
    257            }
   \                     ??readString_0: (+1)
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD5F5             BPL.N    ??readString_1
    258            return ret;
   \   00000028   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    259          }
    260          

   \                                 In section .text, align 2, keep-with-next
    261          String Stream::readStringUntil(char terminator)
    262          {
   \                     _ZN6Stream15readStringUntilEc: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    263            String ret;
   \   00000008   0x....             ADR.N    R1,??DataTable3_1  ;; ""
   \   0000000A   0x.... 0x....      BL       _ZN6StringC1EPKc
    264            int c = timedRead();
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       _ZN6Stream9timedReadEv
   \   00000014   0xE007             B.N      ??readStringUntil_0
    265            while (c >= 0 && c != terminator)
    266            {
    267              ret += (char)c;
   \                     ??readStringUntil_1: (+1)
   \   00000016   0x4601             MOV      R1,R0
   \   00000018   0xB249             SXTB     R1,R1
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       _ZN6StringpLEc
    268              c = timedRead();
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       _ZN6Stream9timedReadEv
    269            }
   \                     ??readStringUntil_0: (+1)
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD401             BMI.N    ??readStringUntil_2
   \   0000002A   0x42B0             CMP      R0,R6
   \   0000002C   0xD1F3             BNE.N    ??readStringUntil_1
    270            return ret;
   \                     ??readStringUntil_2: (+1)
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    271          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x00 0x00          DC8      "",0x0,0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x9999999A         DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x3FB99999         DC32     0x3fb99999

   \                                 In section .rodata, align 1, keep-with-next
   \                     `?<Constant "">`:
   \   00000000   0x00               DC8 ""
    272          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Stream::find(char *)
         0   -> Stream::findUntil(char *, char *)
       8   Stream::find(char *, size_t)
         8   -> Stream::findUntil(char *, size_t, char *, size_t)
      24   Stream::findUntil(char *, char *)
        24   -> Stream::findUntil(char *, size_t, char *, size_t)
        24   -> strlen
      32   Stream::findUntil(char *, size_t, char *, size_t)
        32   -> Stream::timedRead()
       0   Stream::parseFloat()
         0   -> Stream::parseFloat(char)
      40   Stream::parseFloat(char)
        40   -- Indirect call
        40   -> Stream::peekNextDigit()
        40   -> Stream::timedPeek()
        40   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
       0   Stream::parseInt()
         0   -> Stream::parseInt(char)
      24   Stream::parseInt(char)
        24   -- Indirect call
        24   -> Stream::peekNextDigit()
        24   -> Stream::timedPeek()
       8   Stream::peekNextDigit()
         8   -- Indirect call
         8   -> Stream::timedPeek()
      24   Stream::readBytes(char *, size_t)
        24   -> Stream::timedRead()
      24   Stream::readBytesUntil(char, char *, size_t)
        24   -> Stream::timedRead()
      16   Stream::readString()
        16   -> Stream::timedRead()
        16   -> String::String(char const *)
        16   -> String::operator+=(char)
      16   Stream::readStringUntil(char)
        16   -> Stream::timedRead()
        16   -> String::String(char const *)
        16   -> String::operator+=(char)
       0   Stream::setTimeout(unsigned long)
       8   Stream::timedPeek()
         8   -- Indirect call
         8   -> millis()
       8   Stream::timedRead()
         8   -- Indirect call
         8   -> millis()
       8   String::operator+=(char)
         8   -> String::concat(char)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Constant "">
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  Stream::find(char *)
      12  Stream::find(char *, size_t)
      38  Stream::findUntil(char *, char *)
     106  Stream::findUntil(char *, size_t, char *, size_t)
       4  Stream::parseFloat()
     170  Stream::parseFloat(char)
       2  Stream::parseInt()
      98  Stream::parseInt(char)
      38  Stream::peekNextDigit()
      36  Stream::readBytes(char *, size_t)
      56  Stream::readBytesUntil(char, char *, size_t)
      42  Stream::readString()
      48  Stream::readStringUntil(char)
       4  Stream::setTimeout(unsigned long)
      42  Stream::timedPeek()
      42  Stream::timedRead()
      12  String::operator+=(char)
       2  -- Other

 
   3 bytes in section .rodata
 770 bytes in section .text
 
 758 bytes of CODE  memory (+ 12 bytes shared)
   1 byte  of CONST memory (+  2 bytes shared)

Errors: none
Warnings: 33
