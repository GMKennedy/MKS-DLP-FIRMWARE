###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:33
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_bot.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_bot.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\usbh_msc_bot.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\usbh_msc_bot.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_bot.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_msc_bot.c 
      4            * @author  MCD Application Team
      5            * @version V3.2.2
      6            * @date    07-July-2015
      7            * @brief   This file includes the BOT protocol related functions
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbh_msc_bot.h"
     30          #include "usbh_msc.h"
     31          
     32          /** @addtogroup USBH_LIB
     33          * @{
     34          */
     35          
     36          /** @addtogroup USBH_CLASS
     37          * @{
     38          */
     39          
     40          /** @addtogroup USBH_MSC_CLASS
     41          * @{
     42          */
     43          
     44          /** @defgroup USBH_MSC_BOT 
     45          * @brief    This file includes the mass storage related functions
     46          * @{
     47          */ 
     48          
     49          
     50          /** @defgroup USBH_MSC_BOT_Private_TypesDefinitions
     51          * @{
     52          */ 
     53          /**
     54          * @}
     55          */ 
     56          
     57          /** @defgroup USBH_MSC_BOT_Private_Defines
     58          * @{
     59          */ 
     60          /**
     61          * @}
     62          */ 
     63          
     64          /** @defgroup USBH_MSC_BOT_Private_Macros
     65          * @{
     66          */ 
     67          /**
     68          * @}
     69          */ 
     70          
     71          
     72          /** @defgroup USBH_MSC_BOT_Private_Variables
     73          * @{
     74          */ 
     75          
     76          /**
     77          * @}
     78          */ 
     79          
     80          
     81          /** @defgroup USBH_MSC_BOT_Private_FunctionPrototypes
     82          * @{
     83          */ 
     84          static USBH_StatusTypeDef USBH_MSC_BOT_Abort(USBH_HandleTypeDef *phost, uint8_t lun, uint8_t dir);
     85          static BOT_CSWStatusTypeDef USBH_MSC_DecodeCSW(USBH_HandleTypeDef *phost);
     86          /**
     87          * @}
     88          */ 
     89          
     90          
     91          /** @defgroup USBH_MSC_BOT_Exported_Variables
     92          * @{
     93          */ 
     94          /**
     95          * @}
     96          */ 
     97          
     98          
     99          /** @defgroup USBH_MSC_BOT_Private_Functions
    100          * @{
    101          */ 
    102          
    103          /**
    104            * @brief  USBH_MSC_BOT_REQ_Reset 
    105            *         The function the MSC BOT Reset request.
    106            * @param  phost: Host handle
    107            * @retval USBH Status
    108            */

   \                                 In section .text, align 2, keep-with-next
    109          USBH_StatusTypeDef USBH_MSC_BOT_REQ_Reset(USBH_HandleTypeDef *phost)
    110          {
    111            
    112            phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_TYPE_CLASS | \
    113                                        USB_REQ_RECIPIENT_INTERFACE;
   \                     USBH_MSC_BOT_REQ_Reset: (+1)
   \   00000000   0x2121             MOVS     R1,#+33
   \   00000002   0x7401             STRB     R1,[R0, #+16]
    114            
    115            phost->Control.setup.b.bRequest = USB_REQ_BOT_RESET;
   \   00000004   0x21FF             MOVS     R1,#+255
   \   00000006   0x7441             STRB     R1,[R0, #+17]
    116            phost->Control.setup.b.wValue.w = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8241             STRH     R1,[R0, #+18]
    117            phost->Control.setup.b.wIndex.w = 0;
   \   0000000C   0x8281             STRH     R1,[R0, #+20]
    118            phost->Control.setup.b.wLength.w = 0;           
   \   0000000E   0x82C1             STRH     R1,[R0, #+22]
    119            
    120            return USBH_CtlReq(phost, 0 , 0 );  
   \   00000010   0x460A             MOV      R2,R1
   \   00000012   0x.... 0x....      B.W      USBH_CtlReq
    121          }
    122          
    123          /**
    124            * @brief  USBH_MSC_BOT_REQ_GetMaxLUN 
    125            *         The function the MSC BOT GetMaxLUN request.
    126            * @param  phost: Host handle
    127            * @param  Maxlun: pointer to Maxlun variable
    128            * @retval USBH Status
    129            */

   \                                 In section .text, align 2, keep-with-next
    130          USBH_StatusTypeDef USBH_MSC_BOT_REQ_GetMaxLUN(USBH_HandleTypeDef *phost, uint8_t *Maxlun)
    131          {
    132            phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS | \
    133                                        USB_REQ_RECIPIENT_INTERFACE;
   \                     USBH_MSC_BOT_REQ_GetMaxLUN: (+1)
   \   00000000   0x22A1             MOVS     R2,#+161
   \   00000002   0x7402             STRB     R2,[R0, #+16]
    134            
    135            phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
   \   00000004   0x22FE             MOVS     R2,#+254
   \   00000006   0x7442             STRB     R2,[R0, #+17]
    136            phost->Control.setup.b.wValue.w = 0;
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x8242             STRH     R2,[R0, #+18]
    137            phost->Control.setup.b.wIndex.w = 0;
   \   0000000C   0x8282             STRH     R2,[R0, #+20]
    138            phost->Control.setup.b.wLength.w = 1;           
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x82C2             STRH     R2,[R0, #+22]
    139            
    140            return USBH_CtlReq(phost, Maxlun , 1 ); 
   \   00000012   0x.... 0x....      B.W      USBH_CtlReq
    141          }
    142          
    143          
    144          
    145          /**
    146            * @brief  USBH_MSC_BOT_Init 
    147            *         The function Initializes the BOT protocol.
    148            * @param  phost: Host handle
    149            * @retval USBH Status
    150            */

   \                                 In section .text, align 2, keep-with-next
    151          USBH_StatusTypeDef USBH_MSC_BOT_Init(USBH_HandleTypeDef *phost)
    152          {
    153            
    154            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \                     USBH_MSC_BOT_Init: (+1)
   \   00000000   0xF8D0 0x0374      LDR      R0,[R0, #+884]
   \   00000004   0x69C0             LDR      R0,[R0, #+28]
    155            
    156            MSC_Handle->hbot.cbw.field.Signature = BOT_CBW_SIGNATURE;
   \   00000006   0xF100 0x0150      ADD      R1,R0,#+80
   \   0000000A   0x....             LDR.N    R2,??DataTable1  ;; 0x43425355
   \   0000000C   0x604A             STR      R2,[R1, #+4]
    157            MSC_Handle->hbot.cbw.field.Tag = BOT_CBW_TAG;
   \   0000000E   0x....             LDR.N    R2,??DataTable1_1  ;; 0x20304050
   \   00000010   0x608A             STR      R2,[R1, #+8]
    158            MSC_Handle->hbot.state = BOT_SEND_CBW;    
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xF880 0x2050      STRB     R2,[R0, #+80]
    159            MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;   
   \   00000018   0x4610             MOV      R0,R2
   \   0000001A   0x7088             STRB     R0,[R1, #+2]
    160            
    161            return USBH_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x4770             BX       LR               ;; return
    162          }
    163          
    164          
    165          
    166          /**
    167            * @brief  USBH_MSC_BOT_Process 
    168            *         The function handle the BOT protocol.
    169            * @param  phost: Host handle
    170            * @param  lun: Logical Unit Number
    171            * @retval USBH Status
    172            */

   \                                 In section .text, align 4, keep-with-next
    173          USBH_StatusTypeDef USBH_MSC_BOT_Process (USBH_HandleTypeDef *phost, uint8_t lun)
    174          {
   \                     USBH_MSC_BOT_Process: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
    175            USBH_StatusTypeDef   status = USBH_BUSY;
   \   00000004   0x2401             MOVS     R4,#+1
    176            USBH_StatusTypeDef   error  = USBH_BUSY;  
    177            BOT_CSWStatusTypeDef CSW_Status = BOT_CSW_CMD_FAILED;
    178            USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
    179            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000006   0xF8D5 0x0374      LDR      R0,[R5, #+884]
   \   0000000A   0x69C6             LDR      R6,[R0, #+28]
    180            uint8_t toggle = 0;
    181            
    182            switch (MSC_Handle->hbot.state)
   \   0000000C   0xF996 0x0050      LDRSB    R0,[R6, #+80]
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0x280A             CMP      R0,#+10
   \   00000014   0xF200 0x8120      BHI.W    ??USBH_MSC_BOT_Process_1
   \   00000018   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??USBH_MSC_BOT_Process_0:
   \   0000001C   0x000B 0x001C      DC16     0xB,0x1C,0x44,0x51
   \              0x0044 0x0051
   \   00000024   0x007D 0x008C      DC16     0x7D,0x8C,0xBF,0xCA
   \              0x00BF 0x00CA
   \   0000002C   0x00E5 0x00F5      DC16     0xE5,0xF5,0x116
   \              0x0116       
    183            {
    184            case BOT_SEND_CBW:
    185              MSC_Handle->hbot.cbw.field.LUN = lun;
   \                     ??USBH_MSC_BOT_Process_2: (+1)
   \   00000032   0xF106 0x0050      ADD      R0,R6,#+80
   \   00000036   0x7441             STRB     R1,[R0, #+17]
    186              MSC_Handle->hbot.state = BOT_SEND_CBW_WAIT;    
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0xF886 0x0050      STRB     R0,[R6, #+80]
    187              USBH_BulkSendData (phost,
    188                                 MSC_Handle->hbot.cbw.data, 
    189                                 BOT_CBW_LENGTH, 
    190                                 MSC_Handle->OutPipe,
    191                                 1);
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x9000             STR      R0,[SP, #+0]
   \   00000042   0x1D30             ADDS     R0,R6,#+4
   \   00000044   0x7843             LDRB     R3,[R0, #+1]
   \   00000046   0x221F             MOVS     R2,#+31
   \   00000048   0xF106 0x0154      ADD      R1,R6,#+84
   \   0000004C   0x4628             MOV      R0,R5
   \   0000004E   0x.... 0x....      BL       USBH_BulkSendData
    192              
    193              break;
   \   00000052   0xE101             B.N      ??USBH_MSC_BOT_Process_1
    194              
    195            case BOT_SEND_CBW_WAIT:
    196              
    197              URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe); 
   \                     ??USBH_MSC_BOT_Process_3: (+1)
   \   00000054   0x1D30             ADDS     R0,R6,#+4
   \   00000056   0x7841             LDRB     R1,[R0, #+1]
   \   00000058   0x4628             MOV      R0,R5
   \   0000005A   0x.... 0x....      BL       USBH_LL_GetURBState
    198              
    199              if(URB_Status == USBH_URB_DONE)
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xD113             BNE.N    ??USBH_MSC_BOT_Process_4
    200              { 
    201                if ( MSC_Handle->hbot.cbw.field.DataTransferLength != 0 )
   \   00000062   0xF106 0x0050      ADD      R0,R6,#+80
   \   00000066   0x68C1             LDR      R1,[R0, #+12]
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0xD00A             BEQ.N    ??USBH_MSC_BOT_Process_5
    202                {
    203                  /* If there is Data Transfer Stage */
    204                  if (((MSC_Handle->hbot.cbw.field.Flags) & USB_REQ_DIR_MASK) == USB_D2H)
   \   0000006C   0x7C00             LDRB     R0,[R0, #+16]
   \   0000006E   0x0600             LSLS     R0,R0,#+24
   \   00000070   0xD503             BPL.N    ??USBH_MSC_BOT_Process_6
    205                  {
    206                    /* Data Direction is IN */
    207                    MSC_Handle->hbot.state = BOT_DATA_IN;
   \   00000072   0x2003             MOVS     R0,#+3
   \   00000074   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   00000078   0xE0EE             B.N      ??USBH_MSC_BOT_Process_1
    208                  }
    209                  else
    210                  {
    211                    /* Data Direction is OUT */
    212                    MSC_Handle->hbot.state = BOT_DATA_OUT;
   \                     ??USBH_MSC_BOT_Process_6: (+1)
   \   0000007A   0x2005             MOVS     R0,#+5
   \   0000007C   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   00000080   0xE0EA             B.N      ??USBH_MSC_BOT_Process_1
    213                  } 
    214                }
    215                
    216                else
    217                {/* If there is NO Data Transfer Stage */
    218                  MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
   \                     ??USBH_MSC_BOT_Process_5: (+1)
   \   00000082   0x2007             MOVS     R0,#+7
   \   00000084   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   00000088   0xE0E6             B.N      ??USBH_MSC_BOT_Process_1
    219                }
    220          #if (USBH_USE_OS == 1)
    221              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    222          #endif   
    223              
    224              }   
    225              else if(URB_Status == USBH_URB_NOTREADY)
   \                     ??USBH_MSC_BOT_Process_4: (+1)
   \   0000008A   0x2802             CMP      R0,#+2
   \   0000008C   0xD103             BNE.N    ??USBH_MSC_BOT_Process_7
    226              {
    227                /* Re-send CBW */
    228                MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   00000094   0xE0E0             B.N      ??USBH_MSC_BOT_Process_1
    229          #if (USBH_USE_OS == 1)
    230              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    231          #endif       
    232              }     
    233              else if(URB_Status == USBH_URB_STALL)
   \                     ??USBH_MSC_BOT_Process_7: (+1)
   \   00000096   0x2805             CMP      R0,#+5
   \   00000098   0xF040 0x80DE      BNE.W    ??USBH_MSC_BOT_Process_1
    234              {
    235                MSC_Handle->hbot.state  = BOT_ERROR_OUT;
   \   0000009C   0x200A             MOVS     R0,#+10
   \   0000009E   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   000000A2   0xE0D9             B.N      ??USBH_MSC_BOT_Process_1
    236          #if (USBH_USE_OS == 1)
    237              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    238          #endif       
    239              }
    240              break;
    241              
    242            case BOT_DATA_IN:   
    243              /* Send first packet */        
    244              USBH_BulkReceiveData (phost,
    245                                    MSC_Handle->hbot.pbuf, 
    246                                    MSC_Handle->InEpSize , 
    247                                    MSC_Handle->InPipe);
   \                     ??USBH_MSC_BOT_Process_8: (+1)
   \   000000A4   0x7933             LDRB     R3,[R6, #+4]
   \   000000A6   0x1D30             ADDS     R0,R6,#+4
   \   000000A8   0x88C2             LDRH     R2,[R0, #+6]
   \   000000AA   0xF106 0x0050      ADD      R0,R6,#+80
   \   000000AE   0x6BC1             LDR      R1,[R0, #+60]
   \   000000B0   0x4628             MOV      R0,R5
   \   000000B2   0x.... 0x....      BL       USBH_BulkReceiveData
    248              
    249              MSC_Handle->hbot.state  = BOT_DATA_IN_WAIT;
   \   000000B6   0x2004             MOVS     R0,#+4
   \   000000B8   0xF886 0x0050      STRB     R0,[R6, #+80]
    250              
    251              break;   
   \   000000BC   0xE0CC             B.N      ??USBH_MSC_BOT_Process_1
    252              
    253            case BOT_DATA_IN_WAIT:  
    254              
    255              URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe); 
   \                     ??USBH_MSC_BOT_Process_9: (+1)
   \   000000BE   0x7931             LDRB     R1,[R6, #+4]
   \   000000C0   0x4628             MOV      R0,R5
   \   000000C2   0x.... 0x....      BL       USBH_LL_GetURBState
    256              
    257              if(URB_Status == USBH_URB_DONE) 
   \   000000C6   0x2801             CMP      R0,#+1
   \   000000C8   0xD11E             BNE.N    ??USBH_MSC_BOT_Process_10
    258              {
    259                /* Adjust Data pointer and data length */
    260                if(MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->InEpSize)
   \   000000CA   0x1D37             ADDS     R7,R6,#+4
   \   000000CC   0x88F9             LDRH     R1,[R7, #+6]
   \   000000CE   0xF106 0x0050      ADD      R0,R6,#+80
   \   000000D2   0x68C2             LDR      R2,[R0, #+12]
   \   000000D4   0x4291             CMP      R1,R2
   \   000000D6   0xD207             BCS.N    ??USBH_MSC_BOT_Process_11
    261                {
    262                    MSC_Handle->hbot.pbuf += MSC_Handle->InEpSize;
   \   000000D8   0x6BC2             LDR      R2,[R0, #+60]
   \   000000DA   0x1889             ADDS     R1,R1,R2
   \   000000DC   0x63C1             STR      R1,[R0, #+60]
    263                    MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->InEpSize;  
   \   000000DE   0x68C1             LDR      R1,[R0, #+12]
   \   000000E0   0x88FA             LDRH     R2,[R7, #+6]
   \   000000E2   0x1A89             SUBS     R1,R1,R2
   \   000000E4   0x60C1             STR      R1,[R0, #+12]
   \   000000E6   0xE001             B.N      ??USBH_MSC_BOT_Process_12
    264                }
    265                else
    266                {
    267                  MSC_Handle->hbot.cbw.field.DataTransferLength = 0;
   \                     ??USBH_MSC_BOT_Process_11: (+1)
   \   000000E8   0x2100             MOVS     R1,#+0
   \   000000EA   0x60C1             STR      R1,[R0, #+12]
    268                }
    269                  
    270                /* More Data To be Received */
    271                if(MSC_Handle->hbot.cbw.field.DataTransferLength > 0)
   \                     ??USBH_MSC_BOT_Process_12: (+1)
   \   000000EC   0x68C1             LDR      R1,[R0, #+12]
   \   000000EE   0x2900             CMP      R1,#+0
   \   000000F0   0xD006             BEQ.N    ??USBH_MSC_BOT_Process_13
    272                {
    273                  /* Send next packet */        
    274                  USBH_BulkReceiveData (phost,
    275                                        MSC_Handle->hbot.pbuf, 
    276                                        MSC_Handle->InEpSize , 
    277                                        MSC_Handle->InPipe);
   \   000000F2   0x7933             LDRB     R3,[R6, #+4]
   \   000000F4   0x88FA             LDRH     R2,[R7, #+6]
   \   000000F6   0x6BC1             LDR      R1,[R0, #+60]
   \   000000F8   0x4628             MOV      R0,R5
   \   000000FA   0x.... 0x....      BL       USBH_BulkReceiveData
   \   000000FE   0xE0AB             B.N      ??USBH_MSC_BOT_Process_1
    278                  
    279                }
    280                else
    281                {
    282                  /* If value was 0, and successful transfer, then change the state */
    283                  MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
   \                     ??USBH_MSC_BOT_Process_13: (+1)
   \   00000100   0x2007             MOVS     R0,#+7
   \   00000102   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   00000106   0xE0A7             B.N      ??USBH_MSC_BOT_Process_1
    284          #if (USBH_USE_OS == 1)
    285                  osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    286          #endif 
    287                }
    288              }
    289              else if(URB_Status == USBH_URB_STALL)
   \                     ??USBH_MSC_BOT_Process_10: (+1)
   \   00000108   0x2805             CMP      R0,#+5
   \   0000010A   0xF040 0x80A5      BNE.W    ??USBH_MSC_BOT_Process_1
    290              {
    291                /* This is Data IN Stage STALL Condition */
    292                MSC_Handle->hbot.state  = BOT_ERROR_IN;
   \   0000010E   0x2009             MOVS     R0,#+9
   \   00000110   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   00000114   0xE0A0             B.N      ??USBH_MSC_BOT_Process_1
    293                
    294                /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    295                6.7.2 Host expects to receive data from the device
    296                3. On a STALL condition receiving data, then:
    297                The host shall accept the data received.
    298                The host shall clear the Bulk-In pipe.
    299                4. The host shall attempt to receive a CSW.*/
    300                
    301          #if (USBH_USE_OS == 1)
    302              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    303          #endif       
    304              }     
    305              break;  
    306              
    307            case BOT_DATA_OUT:
    308              
    309              USBH_BulkSendData (phost,
    310                                 MSC_Handle->hbot.pbuf, 
    311                                 MSC_Handle->OutEpSize , 
    312                                 MSC_Handle->OutPipe,
    313                                 1);
   \                     ??USBH_MSC_BOT_Process_14: (+1)
   \   00000116   0x1D37             ADDS     R7,R6,#+4
   \   00000118   0x4620             MOV      R0,R4
   \   0000011A   0x9000             STR      R0,[SP, #+0]
   \   0000011C   0x787B             LDRB     R3,[R7, #+1]
   \   0000011E   0x88BA             LDRH     R2,[R7, #+4]
   \   00000120   0xF106 0x0050      ADD      R0,R6,#+80
   \   00000124   0x6BC1             LDR      R1,[R0, #+60]
   \   00000126   0x4628             MOV      R0,R5
   \   00000128   0x.... 0x....      BL       USBH_BulkSendData
    314              
    315              
    316              MSC_Handle->hbot.state  = BOT_DATA_OUT_WAIT;
   \   0000012C   0x2006             MOVS     R0,#+6
   \   0000012E   0xF886 0x0050      STRB     R0,[R6, #+80]
    317              break;
   \   00000132   0xE091             B.N      ??USBH_MSC_BOT_Process_1
    318              
    319            case BOT_DATA_OUT_WAIT:
    320              URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe);     
   \                     ??USBH_MSC_BOT_Process_15: (+1)
   \   00000134   0x1D37             ADDS     R7,R6,#+4
   \   00000136   0x7879             LDRB     R1,[R7, #+1]
   \   00000138   0x4628             MOV      R0,R5
   \   0000013A   0x.... 0x....      BL       USBH_LL_GetURBState
    321              
    322              if(URB_Status == USBH_URB_DONE)
   \   0000013E   0x2801             CMP      R0,#+1
   \   00000140   0xD11F             BNE.N    ??USBH_MSC_BOT_Process_16
    323              {
    324                /* Adjust Data pointer and data length */
    325                if(MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->OutEpSize)
   \   00000142   0x88B9             LDRH     R1,[R7, #+4]
   \   00000144   0xF106 0x0050      ADD      R0,R6,#+80
   \   00000148   0x68C2             LDR      R2,[R0, #+12]
   \   0000014A   0x4291             CMP      R1,R2
   \   0000014C   0xD207             BCS.N    ??USBH_MSC_BOT_Process_17
    326                {
    327                    MSC_Handle->hbot.pbuf += MSC_Handle->OutEpSize;
   \   0000014E   0x6BC2             LDR      R2,[R0, #+60]
   \   00000150   0x1889             ADDS     R1,R1,R2
   \   00000152   0x63C1             STR      R1,[R0, #+60]
    328                    MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->OutEpSize; 
   \   00000154   0x68C1             LDR      R1,[R0, #+12]
   \   00000156   0x88BA             LDRH     R2,[R7, #+4]
   \   00000158   0x1A89             SUBS     R1,R1,R2
   \   0000015A   0x60C1             STR      R1,[R0, #+12]
   \   0000015C   0xE001             B.N      ??USBH_MSC_BOT_Process_18
    329                }
    330                else
    331                {
    332                  MSC_Handle->hbot.cbw.field.DataTransferLength = 0;
   \                     ??USBH_MSC_BOT_Process_17: (+1)
   \   0000015E   0x2100             MOVS     R1,#+0
   \   00000160   0x60C1             STR      R1,[R0, #+12]
    333                } 
    334                
    335                /* More Data To be Sent */
    336                if(MSC_Handle->hbot.cbw.field.DataTransferLength > 0)
   \                     ??USBH_MSC_BOT_Process_18: (+1)
   \   00000162   0x68C1             LDR      R1,[R0, #+12]
   \   00000164   0x2900             CMP      R1,#+0
   \   00000166   0xD008             BEQ.N    ??USBH_MSC_BOT_Process_19
    337                {
    338                  USBH_BulkSendData (phost,
    339                                     MSC_Handle->hbot.pbuf, 
    340                                     MSC_Handle->OutEpSize , 
    341                                     MSC_Handle->OutPipe,
    342                                     1);
   \   00000168   0x4621             MOV      R1,R4
   \   0000016A   0x9100             STR      R1,[SP, #+0]
   \   0000016C   0x787B             LDRB     R3,[R7, #+1]
   \   0000016E   0x88BA             LDRH     R2,[R7, #+4]
   \   00000170   0x6BC1             LDR      R1,[R0, #+60]
   \   00000172   0x4628             MOV      R0,R5
   \   00000174   0x.... 0x....      BL       USBH_BulkSendData
   \   00000178   0xE06E             B.N      ??USBH_MSC_BOT_Process_1
    343                }
    344                else
    345                {
    346                  /* If value was 0, and successful transfer, then change the state */
    347                  MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
   \                     ??USBH_MSC_BOT_Process_19: (+1)
   \   0000017A   0x2007             MOVS     R0,#+7
   \   0000017C   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   00000180   0xE06A             B.N      ??USBH_MSC_BOT_Process_1
    348                }  
    349          #if (USBH_USE_OS == 1)
    350              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    351          #endif       
    352              }
    353              
    354              else if(URB_Status == USBH_URB_NOTREADY)
   \                     ??USBH_MSC_BOT_Process_16: (+1)
   \   00000182   0x2802             CMP      R0,#+2
   \   00000184   0xD103             BNE.N    ??USBH_MSC_BOT_Process_20
    355              {
    356                /* Resend same data */      
    357                MSC_Handle->hbot.state  = BOT_DATA_OUT;
   \   00000186   0x2005             MOVS     R0,#+5
   \   00000188   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   0000018C   0xE064             B.N      ??USBH_MSC_BOT_Process_1
    358          #if (USBH_USE_OS == 1)
    359              osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    360          #endif       
    361              }
    362              
    363              else if(URB_Status == USBH_URB_STALL)
   \                     ??USBH_MSC_BOT_Process_20: (+1)
   \   0000018E   0x2805             CMP      R0,#+5
   \   00000190   0xD162             BNE.N    ??USBH_MSC_BOT_Process_1
    364              {
    365                MSC_Handle->hbot.state  = BOT_ERROR_OUT;
   \   00000192   0x200A             MOVS     R0,#+10
   \   00000194   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   00000198   0xE05E             B.N      ??USBH_MSC_BOT_Process_1
    366                
    367                /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    368                6.7.3 Ho - Host expects to send data to the device
    369                3. On a STALL condition sending data, then:
    370                " The host shall clear the Bulk-Out pipe.
    371                4. The host shall attempt to receive a CSW.
    372                */      
    373          #if (USBH_USE_OS == 1)
    374                osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    375          #endif       
    376              }
    377              break;
    378              
    379            case BOT_RECEIVE_CSW:
    380              
    381              USBH_BulkReceiveData (phost,
    382                                    MSC_Handle->hbot.csw.data, 
    383                                    BOT_CSW_LENGTH , 
    384                                    MSC_Handle->InPipe);
   \                     ??USBH_MSC_BOT_Process_21: (+1)
   \   0000019A   0x7933             LDRB     R3,[R6, #+4]
   \   0000019C   0x220D             MOVS     R2,#+13
   \   0000019E   0xF106 0x0178      ADD      R1,R6,#+120
   \   000001A2   0x4628             MOV      R0,R5
   \   000001A4   0x.... 0x....      BL       USBH_BulkReceiveData
    385              
    386              MSC_Handle->hbot.state  = BOT_RECEIVE_CSW_WAIT;
   \   000001A8   0x2008             MOVS     R0,#+8
   \   000001AA   0xF886 0x0050      STRB     R0,[R6, #+80]
    387              break;
   \   000001AE   0xE053             B.N      ??USBH_MSC_BOT_Process_1
    388              
    389            case BOT_RECEIVE_CSW_WAIT:
    390              
    391              URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe); 
   \                     ??USBH_MSC_BOT_Process_22: (+1)
   \   000001B0   0x7931             LDRB     R1,[R6, #+4]
   \   000001B2   0x4628             MOV      R0,R5
   \   000001B4   0x.... 0x....      BL       USBH_LL_GetURBState
    392              
    393              /* Decode CSW */
    394              if(URB_Status == USBH_URB_DONE)
   \   000001B8   0x2801             CMP      R0,#+1
   \   000001BA   0xD10E             BNE.N    ??USBH_MSC_BOT_Process_23
    395              {
    396                MSC_Handle->hbot.state = BOT_SEND_CBW;    
   \   000001BC   0x4620             MOV      R0,R4
   \   000001BE   0xF886 0x0050      STRB     R0,[R6, #+80]
    397                MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;        
   \   000001C2   0xF106 0x0150      ADD      R1,R6,#+80
   \   000001C6   0x7088             STRB     R0,[R1, #+2]
    398                CSW_Status = USBH_MSC_DecodeCSW(phost);
    399                
    400                if(CSW_Status == BOT_CSW_CMD_PASSED)
   \   000001C8   0x4628             MOV      R0,R5
   \   000001CA   0x.... 0x....      BL       USBH_MSC_DecodeCSW
   \   000001CE   0x2800             CMP      R0,#+0
   \   000001D0   0xD101             BNE.N    ??USBH_MSC_BOT_Process_24
    401                {
    402                  status = USBH_OK;
   \   000001D2   0x2400             MOVS     R4,#+0
   \   000001D4   0xE040             B.N      ??USBH_MSC_BOT_Process_1
    403                }
    404                else
    405                {
    406                  status = USBH_FAIL;
   \                     ??USBH_MSC_BOT_Process_24: (+1)
   \   000001D6   0x2402             MOVS     R4,#+2
   \   000001D8   0xE03E             B.N      ??USBH_MSC_BOT_Process_1
    407                }
    408          #if (USBH_USE_OS == 1)
    409                osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    410          #endif       
    411              }
    412              else if(URB_Status == USBH_URB_STALL)     
   \                     ??USBH_MSC_BOT_Process_23: (+1)
   \   000001DA   0x2805             CMP      R0,#+5
   \   000001DC   0xD13C             BNE.N    ??USBH_MSC_BOT_Process_1
    413              {
    414                MSC_Handle->hbot.state  = BOT_ERROR_IN;
   \   000001DE   0x2009             MOVS     R0,#+9
   \   000001E0   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   000001E4   0xE038             B.N      ??USBH_MSC_BOT_Process_1
    415          #if (USBH_USE_OS == 1)
    416                osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    417          #endif       
    418              }
    419              break;
    420              
    421            case BOT_ERROR_IN: 
    422              error = USBH_MSC_BOT_Abort(phost, lun, BOT_DIR_IN);
   \                     ??USBH_MSC_BOT_Process_25: (+1)
   \   000001E6   0x2200             MOVS     R2,#+0
   \   000001E8   0x4628             MOV      R0,R5
   \   000001EA   0x.... 0x....      BL       USBH_MSC_BOT_Abort
    423              
    424              if (error == USBH_OK)
   \   000001EE   0x2800             CMP      R0,#+0
   \   000001F0   0xD103             BNE.N    ??USBH_MSC_BOT_Process_26
    425              {
    426                MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
   \   000001F2   0x2007             MOVS     R0,#+7
   \   000001F4   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   000001F8   0xE02E             B.N      ??USBH_MSC_BOT_Process_1
    427              }
    428              else if (error == USBH_UNRECOVERED_ERROR)
   \                     ??USBH_MSC_BOT_Process_26: (+1)
   \   000001FA   0x2804             CMP      R0,#+4
   \   000001FC   0xD12C             BNE.N    ??USBH_MSC_BOT_Process_1
    429              {
    430                /* This means that there is a STALL Error limit, Do Reset Recovery */
    431                MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
   \   000001FE   0x200B             MOVS     R0,#+11
   \   00000200   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   00000204   0xE028             B.N      ??USBH_MSC_BOT_Process_1
    432              }
    433              break;
    434              
    435            case BOT_ERROR_OUT: 
    436              error = USBH_MSC_BOT_Abort(phost, lun, BOT_DIR_OUT);
   \                     ??USBH_MSC_BOT_Process_27: (+1)
   \   00000206   0x4622             MOV      R2,R4
   \   00000208   0x4628             MOV      R0,R5
   \   0000020A   0x.... 0x....      BL       USBH_MSC_BOT_Abort
    437              
    438              if ( error == USBH_OK)
   \   0000020E   0x2800             CMP      R0,#+0
   \   00000210   0xD114             BNE.N    ??USBH_MSC_BOT_Process_28
    439              { 
    440                
    441                toggle = USBH_LL_GetToggle(phost, MSC_Handle->OutPipe); 
   \   00000212   0x1D37             ADDS     R7,R6,#+4
   \   00000214   0x7879             LDRB     R1,[R7, #+1]
   \   00000216   0x4628             MOV      R0,R5
   \   00000218   0x.... 0x....      BL       USBH_LL_GetToggle
    442                USBH_LL_SetToggle(phost, MSC_Handle->OutPipe, 1- toggle);   
   \   0000021C   0xF1C0 0x0201      RSB      R2,R0,#+1
   \   00000220   0xB2D2             UXTB     R2,R2
   \   00000222   0x7879             LDRB     R1,[R7, #+1]
   \   00000224   0x4628             MOV      R0,R5
   \   00000226   0x.... 0x....      BL       USBH_LL_SetToggle
    443                USBH_LL_SetToggle(phost, MSC_Handle->InPipe, 0);  
   \   0000022A   0x2200             MOVS     R2,#+0
   \   0000022C   0x7931             LDRB     R1,[R6, #+4]
   \   0000022E   0x4628             MOV      R0,R5
   \   00000230   0x.... 0x....      BL       USBH_LL_SetToggle
    444                MSC_Handle->hbot.state = BOT_ERROR_IN;        
   \   00000234   0x2009             MOVS     R0,#+9
   \   00000236   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   0000023A   0xE00D             B.N      ??USBH_MSC_BOT_Process_1
    445              }
    446              else if (error == USBH_UNRECOVERED_ERROR)
   \                     ??USBH_MSC_BOT_Process_28: (+1)
   \   0000023C   0x2804             CMP      R0,#+4
   \   0000023E   0xD10B             BNE.N    ??USBH_MSC_BOT_Process_1
    447              {
    448                MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
   \   00000240   0x200B             MOVS     R0,#+11
   \   00000242   0xF886 0x0050      STRB     R0,[R6, #+80]
   \   00000246   0xE007             B.N      ??USBH_MSC_BOT_Process_1
    449              }
    450              break;
    451              
    452              
    453            case BOT_UNRECOVERED_ERROR: 
    454              status = USBH_MSC_BOT_REQ_Reset(phost);
   \                     ??USBH_MSC_BOT_Process_29: (+1)
   \   00000248   0x4628             MOV      R0,R5
   \   0000024A   0x.... 0x....      BL       USBH_MSC_BOT_REQ_Reset
   \   0000024E   0x0004             MOVS     R4,R0
    455              if ( status == USBH_OK)
   \   00000250   0xD102             BNE.N    ??USBH_MSC_BOT_Process_1
    456              {
    457                MSC_Handle->hbot.state = BOT_SEND_CBW; 
   \   00000252   0x2001             MOVS     R0,#+1
   \   00000254   0xF886 0x0050      STRB     R0,[R6, #+80]
    458              }
    459              break;
    460              
    461            default:      
    462              break;
    463            }
    464            return status;
   \                     ??USBH_MSC_BOT_Process_1: (+1)
   \   00000258   0x4620             MOV      R0,R4
   \   0000025A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    465          }
    466          
    467          /**
    468            * @brief  USBH_MSC_BOT_Abort 
    469            *         The function handle the BOT Abort process.
    470            * @param  phost: Host handle
    471            * @param  lun: Logical Unit Number
    472            * @param  dir: direction (0: out / 1 : in)
    473            * @retval USBH Status
    474            */

   \                                 In section .text, align 2, keep-with-next
    475          static USBH_StatusTypeDef USBH_MSC_BOT_Abort(USBH_HandleTypeDef *phost, uint8_t lun, uint8_t dir)
    476          {
   \                     USBH_MSC_BOT_Abort: (+1)
   \   00000000   0x4603             MOV      R3,R0
    477            USBH_StatusTypeDef status = USBH_FAIL;
   \   00000002   0x2002             MOVS     R0,#+2
    478            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000004   0xF8D3 0x1374      LDR      R1,[R3, #+884]
   \   00000008   0x69C9             LDR      R1,[R1, #+28]
    479            
    480            switch (dir)
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD002             BEQ.N    ??USBH_MSC_BOT_Abort_0
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xD004             BEQ.N    ??USBH_MSC_BOT_Abort_1
   \   00000012   0x4770             BX       LR
    481            {
    482            case BOT_DIR_IN :
    483              /* send ClrFeture on Bulk IN endpoint */
    484              status = USBH_ClrFeature(phost, MSC_Handle->InEp);
   \                     ??USBH_MSC_BOT_Abort_0: (+1)
   \   00000014   0x79C9             LDRB     R1,[R1, #+7]
   \   00000016   0x4618             MOV      R0,R3
   \   00000018   0x.... 0x....      B.W      USBH_ClrFeature
    485              
    486              break;
    487              
    488            case BOT_DIR_OUT :
    489              /*send ClrFeature on Bulk OUT endpoint */
    490              status = USBH_ClrFeature(phost, MSC_Handle->OutEp);
   \                     ??USBH_MSC_BOT_Abort_1: (+1)
   \   0000001C   0x7989             LDRB     R1,[R1, #+6]
   \   0000001E   0x4618             MOV      R0,R3
   \   00000020   0x.... 0x....      B.W      USBH_ClrFeature
    491              break;
    492              
    493            default:
    494              break;
    495            }
    496            return status;
    497          }
    498          
    499          /**
    500            * @brief  USBH_MSC_BOT_DecodeCSW
    501            *         This function decodes the CSW received by the device and updates the
    502            *         same to upper layer.
    503            * @param  phost: Host handle
    504            * @retval USBH Status
    505            * @notes
    506            *     Refer to USB Mass-Storage Class : BOT (www.usb.org)
    507            *    6.3.1 Valid CSW Conditions :
    508            *     The host shall consider the CSW valid when:
    509            *     1. dCSWSignature is equal to 53425355h
    510            *     2. the CSW is 13 (Dh) bytes in length,
    511            *     3. dCSWTag matches the dCBWTag from the corresponding CBW.
    512            */
    513          

   \                                 In section .text, align 2, keep-with-next
    514          static BOT_CSWStatusTypeDef USBH_MSC_DecodeCSW(USBH_HandleTypeDef *phost)
    515          {
   \                     USBH_MSC_DecodeCSW: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    516            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000002   0xF8D0 0x1374      LDR      R1,[R0, #+884]
   \   00000006   0x69CC             LDR      R4,[R1, #+28]
    517            BOT_CSWStatusTypeDef status = BOT_CSW_CMD_FAILED;
   \   00000008   0x2501             MOVS     R5,#+1
    518            
    519              /*Checking if the transfer length is different than 13*/    
    520              if(USBH_LL_GetLastXferSize(phost, MSC_Handle->InPipe) != BOT_CSW_LENGTH)
   \   0000000A   0x7921             LDRB     R1,[R4, #+4]
   \   0000000C   0x.... 0x....      BL       USBH_LL_GetLastXferSize
   \   00000010   0x280D             CMP      R0,#+13
   \   00000012   0xD001             BEQ.N    ??USBH_MSC_DecodeCSW_0
    521              {
    522                /*(4) Hi > Dn (Host expects to receive data from the device,
    523                Device intends to transfer no data)
    524                (5) Hi > Di (Host expects to receive data from the device,
    525                Device intends to send data to the host)
    526                (9) Ho > Dn (Host expects to send data to the device,
    527                Device intends to transfer no data)
    528                (11) Ho > Do  (Host expects to send data to the device,
    529                Device intends to receive data from the host)*/
    530                
    531                
    532                status = BOT_CSW_PHASE_ERROR;
   \   00000014   0x2502             MOVS     R5,#+2
   \   00000016   0xE015             B.N      ??USBH_MSC_DecodeCSW_1
    533              }
    534              else
    535              { /* CSW length is Correct */
    536                
    537                /* Check validity of the CSW Signature and CSWStatus */
    538                if(MSC_Handle->hbot.csw.field.Signature == BOT_CSW_SIGNATURE)
   \                     ??USBH_MSC_DecodeCSW_0: (+1)
   \   00000018   0x1D20             ADDS     R0,R4,#+4
   \   0000001A   0x6F41             LDR      R1,[R0, #+116]
   \   0000001C   0x....             LDR.N    R2,??DataTable1_2  ;; 0x53425355
   \   0000001E   0x4291             CMP      R1,R2
   \   00000020   0xD10F             BNE.N    ??USBH_MSC_DecodeCSW_2
    539                {/* Check Condition 1. dCSWSignature is equal to 53425355h */
    540                  
    541                  if(MSC_Handle->hbot.csw.field.Tag == MSC_Handle->hbot.cbw.field.Tag)
   \   00000022   0x6F81             LDR      R1,[R0, #+120]
   \   00000024   0x6D40             LDR      R0,[R0, #+84]
   \   00000026   0x4281             CMP      R1,R0
   \   00000028   0xD10C             BNE.N    ??USBH_MSC_DecodeCSW_1
    542                  {
    543                    /* Check Condition 3. dCSWTag matches the dCBWTag from the 
    544                    corresponding CBW */
    545          
    546                    if(MSC_Handle->hbot.csw.field.Status == 0) 
   \   0000002A   0xF894 0x0084      LDRB     R0,[R4, #+132]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD101             BNE.N    ??USBH_MSC_DecodeCSW_3
    547                    {
    548                      /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    549                      
    550                      Hn Host expects no data transfers
    551                      Hi Host expects to receive data from the device
    552                      Ho Host expects to send data to the device
    553                      
    554                      Dn Device intends to transfer no data
    555                      Di Device intends to send data to the host
    556                      Do Device intends to receive data from the host
    557                      
    558                      Section 6.7 
    559                      (1) Hn = Dn (Host expects no data transfers,
    560                      Device intends to transfer no data)
    561                      (6) Hi = Di (Host expects to receive data from the device,
    562                      Device intends to send data to the host)
    563                      (12) Ho = Do (Host expects to send data to the device, 
    564                      Device intends to receive data from the host)
    565                      
    566                      */
    567                      
    568                      status = BOT_CSW_CMD_PASSED;
   \   00000032   0x2500             MOVS     R5,#+0
   \   00000034   0xE006             B.N      ??USBH_MSC_DecodeCSW_1
    569                    }
    570                    else if(MSC_Handle->hbot.csw.field.Status == 1)
   \                     ??USBH_MSC_DecodeCSW_3: (+1)
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD004             BEQ.N    ??USBH_MSC_DecodeCSW_1
    571                    {
    572                      status = BOT_CSW_CMD_FAILED;
    573                    }
    574                    
    575                    else if(MSC_Handle->hbot.csw.field.Status == 2)
   \   0000003A   0x2802             CMP      R0,#+2
   \   0000003C   0xD102             BNE.N    ??USBH_MSC_DecodeCSW_1
    576                    { 
    577                      /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
    578                      Section 6.7 
    579                      (2) Hn < Di ( Host expects no data transfers, 
    580                      Device intends to send data to the host)
    581                      (3) Hn < Do ( Host expects no data transfers, 
    582                      Device intends to receive data from the host)
    583                      (7) Hi < Di ( Host expects to receive data from the device, 
    584                      Device intends to send data to the host)
    585                      (8) Hi <> Do ( Host expects to receive data from the device, 
    586                      Device intends to receive data from the host)
    587                      (10) Ho <> Di (Host expects to send data to the device,
    588                      Di Device intends to send data to the host)
    589                      (13) Ho < Do (Host expects to send data to the device, 
    590                      Device intends to receive data from the host)
    591                      */
    592                      
    593                      status = BOT_CSW_PHASE_ERROR;
   \   0000003E   0x2502             MOVS     R5,#+2
   \   00000040   0xE000             B.N      ??USBH_MSC_DecodeCSW_1
    594                    }
    595                  } /* CSW Tag Matching is Checked  */
    596                } /* CSW Signature Correct Checking */
    597                else
    598                {
    599                  /* If the CSW Signature is not valid, We sall return the Phase Error to
    600                  Upper Layers for Reset Recovery */
    601                  
    602                  status = BOT_CSW_PHASE_ERROR;
   \                     ??USBH_MSC_DecodeCSW_2: (+1)
   \   00000042   0x2502             MOVS     R5,#+2
    603                }
    604              } /* CSW Length Check*/
    605              
    606            return status;
   \                     ??USBH_MSC_DecodeCSW_1: (+1)
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    607          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x43425355         DC32     0x43425355

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x20304050         DC32     0x20304050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x53425355         DC32     0x53425355
    608          
    609          
    610          /**
    611          * @}
    612          */ 
    613          
    614          /**
    615          * @}
    616          */ 
    617          
    618          /**
    619          * @}
    620          */
    621          
    622          /**
    623          * @}
    624          */ 
    625          
    626          /**
    627          * @}
    628          */
    629          
    630          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    631          
    632          
    633          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USBH_MSC_BOT_Abort
         0   -> USBH_ClrFeature
       0   USBH_MSC_BOT_Init
      24   USBH_MSC_BOT_Process
        24   -> USBH_BulkReceiveData
        24   -> USBH_BulkSendData
        24   -> USBH_LL_GetToggle
        24   -> USBH_LL_GetURBState
        24   -> USBH_LL_SetToggle
        24   -> USBH_MSC_BOT_Abort
        24   -> USBH_MSC_BOT_REQ_Reset
        24   -> USBH_MSC_DecodeCSW
       0   USBH_MSC_BOT_REQ_GetMaxLUN
         0   -> USBH_CtlReq
       0   USBH_MSC_BOT_REQ_Reset
         0   -> USBH_CtlReq
      16   USBH_MSC_DecodeCSW
        16   -> USBH_LL_GetLastXferSize


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
      36  USBH_MSC_BOT_Abort
      32  USBH_MSC_BOT_Init
     604  USBH_MSC_BOT_Process
      22  USBH_MSC_BOT_REQ_GetMaxLUN
      22  USBH_MSC_BOT_REQ_Reset
      72  USBH_MSC_DecodeCSW

 
 800 bytes in section .text
 
 800 bytes of CODE memory

Errors: none
Warnings: none
