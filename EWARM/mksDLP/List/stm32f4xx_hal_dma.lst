###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:11
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_dma.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_dma.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\stm32f4xx_hal_dma.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\stm32f4xx_hal_dma.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_dma.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_dma.c
      4            * @author  MCD Application Team
      5            * @version V1.5.2
      6            * @date    22-September-2016
      7            * @brief   DMA HAL module driver.
      8            *    
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities of the Direct Memory Access (DMA) peripheral:
     11            *           + Initialization and de-initialization functions
     12            *           + IO operation functions
     13            *           + Peripheral State and errors functions
     14            @verbatim     
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18            [..]
     19             (#) Enable and configure the peripheral to be connected to the DMA Stream
     20                 (except for internal SRAM/FLASH memories: no initialization is 
     21                 necessary) please refer to Reference manual for connection between peripherals
     22                 and DMA requests.
     23          
     24             (#) For a given Stream, program the required configuration through the following parameters:
     25                 Transfer Direction, Source and Destination data formats, 
     26                 Circular, Normal or peripheral flow control mode, Stream Priority level, 
     27                 Source and Destination Increment mode, FIFO mode and its Threshold (if needed), 
     28                 Burst mode for Source and/or Destination (if needed) using HAL_DMA_Init() function.
     29          
     30             -@-   Prior to HAL_DMA_Init() the clock must be enabled for DMA through the following macros:
     31                   __HAL_RCC_DMA1_CLK_ENABLE() or __HAL_RCC_DMA2_CLK_ENABLE().
     32          
     33               *** Polling mode IO operation ***
     34               =================================
     35              [..]
     36                    (+) Use HAL_DMA_Start() to start DMA transfer after the configuration of Source 
     37                        address and destination address and the Length of data to be transferred.
     38                    (+) Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this  
     39                        case a fixed Timeout can be configured by User depending from his application.
     40                    (+) Use HAL_DMA_Abort() function to abort the current transfer.
     41          
     42               *** Interrupt mode IO operation ***
     43               ===================================
     44              [..]
     45                    (+) Configure the DMA interrupt priority using HAL_NVIC_SetPriority()
     46                    (+) Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ() 
     47                    (+) Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of  
     48                        Source address and destination address and the Length of data to be transferred. In this 
     49                        case the DMA interrupt is configured 
     50                    (+) Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine
     51                    (+) At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can 
     52                        add his own function by customization of function pointer XferCpltCallback and 
     53                        XferErrorCallback (i.e a member of DMA handle structure).
     54              [..]
     55               (#) Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error 
     56                   detection.
     57          
     58               (#) Use HAL_DMA_Abort_IT() function to abort the current transfer
     59          
     60               -@-   In Memory-to-Memory transfer mode, Circular mode is not allowed.
     61          
     62               -@-   The FIFO is used mainly to reduce bus usage and to allow data packing/unpacking: it is
     63                     possible to set different Data Sizes for the Peripheral and the Memory (ie. you can set
     64                     Half-Word data size for the peripheral to access its data register and set Word data size
     65                     for the Memory to gain in access time. Each two half words will be packed and written in
     66                     a single access to a Word in the Memory).
     67          
     68               -@-   When FIFO is disabled, it is not allowed to configure different Data Sizes for Source
     69                     and Destination. In this case the Peripheral Data Size will be applied to both Source
     70                     and Destination.
     71          
     72               *** DMA HAL driver macros list ***
     73               =============================================
     74               [..]
     75                 Below the list of most used macros in DMA HAL driver.
     76                 
     77                (+) __HAL_DMA_ENABLE: Enable the specified DMA Stream.
     78                (+) __HAL_DMA_DISABLE: Disable the specified DMA Stream.
     79                (+) __HAL_DMA_GET_FS: Return the current DMA Stream FIFO filled level.
     80                (+) __HAL_DMA_ENABLE_IT: Enable the specified DMA Stream interrupts.
     81                (+) __HAL_DMA_DISABLE_IT: Disable the specified DMA Stream interrupts.
     82                (+) __HAL_DMA_GET_IT_SOURCE: Check whether the specified DMA Stream interrupt has occurred or not. 
     83          
     84               [..]
     85                (@) You can refer to the DMA HAL driver header file for more useful macros
     86          
     87            @endverbatim
     88            ******************************************************************************
     89            * @attention
     90            *
     91            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     92            *
     93            * Redistribution and use in source and binary forms, with or without modification,
     94            * are permitted provided that the following conditions are met:
     95            *   1. Redistributions of source code must retain the above copyright notice,
     96            *      this list of conditions and the following disclaimer.
     97            *   2. Redistributions in binary form must reproduce the above copyright notice,
     98            *      this list of conditions and the following disclaimer in the documentation
     99            *      and/or other materials provided with the distribution.
    100            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    101            *      may be used to endorse or promote products derived from this software
    102            *      without specific prior written permission.
    103            *
    104            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    105            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    106            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    107            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    108            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    109            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    110            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    111            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    112            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    113            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    114            *
    115            ******************************************************************************
    116            */ 
    117          
    118          /* Includes ------------------------------------------------------------------*/
    119          #include "stm32f4xx_hal.h"
    120          
    121          /** @addtogroup STM32F4xx_HAL_Driver
    122            * @{
    123            */
    124          
    125          /** @defgroup DMA DMA
    126            * @brief DMA HAL module driver
    127            * @{
    128            */
    129          
    130          #ifdef HAL_DMA_MODULE_ENABLED
    131          
    132          /* Private types -------------------------------------------------------------*/
    133          typedef struct
    134          {
    135            __IO uint32_t ISR;   /*!< DMA interrupt status register */
    136            __IO uint32_t Reserved0;
    137            __IO uint32_t IFCR;  /*!< DMA interrupt flag clear register */
    138          } DMA_Base_Registers;
    139          
    140          /* Private variables ---------------------------------------------------------*/
    141          /* Private constants ---------------------------------------------------------*/
    142          /** @addtogroup DMA_Private_Constants
    143           * @{
    144           */
    145           #define HAL_TIMEOUT_DMA_ABORT    ((uint32_t)5)  /* 5 ms */
    146          /**
    147            * @}
    148            */
    149          /* Private macros ------------------------------------------------------------*/
    150          /* Private functions ---------------------------------------------------------*/
    151          /** @addtogroup DMA_Private_Functions
    152            * @{
    153            */
    154          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
    155          static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma);
    156          static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma);
    157          
    158          /**
    159            * @}
    160            */  
    161            
    162          /* Exported functions --------------------------------------------------------*/
    163          /** @addtogroup DMA_Exported_Functions
    164            * @{
    165            */
    166          
    167          /** @addtogroup DMA_Exported_Functions_Group1
    168            *
    169          @verbatim
    170           ===============================================================================
    171                       ##### Initialization and de-initialization functions  #####
    172           ===============================================================================
    173              [..]
    174              This section provides functions allowing to initialize the DMA Stream source
    175              and destination addresses, incrementation and data sizes, transfer direction, 
    176              circular/normal mode selection, memory-to-memory mode selection and Stream priority value.
    177              [..]
    178              The HAL_DMA_Init() function follows the DMA configuration procedures as described in
    179              reference manual.
    180          
    181          @endverbatim
    182            * @{
    183            */
    184            
    185          /**
    186            * @brief  Initializes the DMA according to the specified
    187            *         parameters in the DMA_InitTypeDef and create the associated handle.
    188            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
    189            *               the configuration information for the specified DMA Stream.  
    190            * @retval HAL status
    191            */

   \                                 In section .text, align 2, keep-with-next
    192          HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
    193          {
   \                     HAL_DMA_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    194            uint32_t tmp = 0U;
    195            uint32_t tickstart = HAL_GetTick();
   \   00000004   0x.... 0x....      BL       HAL_GetTick
   \   00000008   0x4605             MOV      R5,R0
    196            DMA_Base_Registers *regs;
    197          
    198            /* Check the DMA peripheral state */
    199            if(hdma == NULL)
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE.N    ??HAL_DMA_Init_0
    200            {
    201              return HAL_ERROR;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
    202            }
    203          
    204            /* Check the parameters */
    205            assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
    206            assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
    207            assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
    208            assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    209            assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    210            assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    211            assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
    212            assert_param(IS_DMA_MODE(hdma->Init.Mode));
    213            assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
    214            assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
    215            /* Check the memory burst, peripheral burst and FIFO threshold parameters only
    216               when FIFO mode is enabled */
    217            if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
    218            {
    219              assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
    220              assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    221              assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    222            }
    223            
    224            /* Allocate lock resource */
    225            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_Init_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF884 0x0034      STRB     R0,[R4, #+52]
    226          
    227            /* Change DMA peripheral state */
    228            hdma->State = HAL_DMA_STATE_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x0035      STRB     R0,[R4, #+53]
    229            
    230            /* Disable the peripheral */
    231            __HAL_DMA_DISABLE(hdma);
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
    232            
    233            /* Check if the DMA Stream is effectively disabled */
    234            while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
   \                     ??HAL_DMA_Init_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0x07C9             LSLS     R1,R1,#+31
   \   0000002E   0xD50A             BPL.N    ??HAL_DMA_Init_2
    235            {
    236              /* Check for the Timeout */
    237              if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
   \   00000030   0x.... 0x....      BL       HAL_GetTick
   \   00000034   0x1B40             SUBS     R0,R0,R5
   \   00000036   0x2806             CMP      R0,#+6
   \   00000038   0xD3F6             BCC.N    ??HAL_DMA_Init_1
    238              {
    239                /* Update error code */
    240                hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
   \   0000003A   0x2020             MOVS     R0,#+32
   \   0000003C   0x6560             STR      R0,[R4, #+84]
    241                
    242                /* Change the DMA state */
    243                hdma->State = HAL_DMA_STATE_TIMEOUT;
   \   0000003E   0x2003             MOVS     R0,#+3
   \   00000040   0xF884 0x0035      STRB     R0,[R4, #+53]
    244                
    245                return HAL_TIMEOUT;
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}
    246              }
    247            }
    248            
    249            /* Get the CR register value */
    250            tmp = hdma->Instance->CR;
   \                     ??HAL_DMA_Init_2: (+1)
   \   00000046   0x6801             LDR      R1,[R0, #+0]
    251          
    252            /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
    253            tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
    254                                DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
    255                                DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
    256                                DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
    257          
    258            /* Prepare the DMA Stream configuration */
    259            tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
    260                    hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    261                    hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    262                    hdma->Init.Mode                | hdma->Init.Priority;
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable3  ;; 0xf010803f
   \   0000004C   0x4011             ANDS     R1,R2,R1
   \   0000004E   0x6862             LDR      R2,[R4, #+4]
   \   00000050   0x4311             ORRS     R1,R2,R1
   \   00000052   0x68A2             LDR      R2,[R4, #+8]
   \   00000054   0x4311             ORRS     R1,R2,R1
   \   00000056   0x68E2             LDR      R2,[R4, #+12]
   \   00000058   0x4311             ORRS     R1,R2,R1
   \   0000005A   0x6922             LDR      R2,[R4, #+16]
   \   0000005C   0x4311             ORRS     R1,R2,R1
   \   0000005E   0x6962             LDR      R2,[R4, #+20]
   \   00000060   0x4311             ORRS     R1,R2,R1
   \   00000062   0x69A2             LDR      R2,[R4, #+24]
   \   00000064   0x4311             ORRS     R1,R2,R1
   \   00000066   0x69E2             LDR      R2,[R4, #+28]
   \   00000068   0x4311             ORRS     R1,R2,R1
   \   0000006A   0x6A22             LDR      R2,[R4, #+32]
   \   0000006C   0x4311             ORRS     R1,R2,R1
    263          
    264            /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
    265            if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
   \   0000006E   0x6A62             LDR      R2,[R4, #+36]
   \   00000070   0x2A04             CMP      R2,#+4
   \   00000072   0xD103             BNE.N    ??HAL_DMA_Init_3
    266            {
    267              /* Get memory burst and peripheral burst */
    268              tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
   \   00000074   0x6AE2             LDR      R2,[R4, #+44]
   \   00000076   0x6B23             LDR      R3,[R4, #+48]
   \   00000078   0x431A             ORRS     R2,R3,R2
   \   0000007A   0x4311             ORRS     R1,R2,R1
    269            }
    270            
    271            /* Write to DMA Stream CR register */
    272            hdma->Instance->CR = tmp;  
   \                     ??HAL_DMA_Init_3: (+1)
   \   0000007C   0x6001             STR      R1,[R0, #+0]
    273          
    274            /* Get the FCR register value */
    275            tmp = hdma->Instance->FCR;
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6940             LDR      R0,[R0, #+20]
    276          
    277            /* Clear Direct mode and FIFO threshold bits */
    278            tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
    279          
    280            /* Prepare the DMA Stream FIFO configuration */
    281            tmp |= hdma->Init.FIFOMode;
   \   00000082   0x6A61             LDR      R1,[R4, #+36]
   \   00000084   0x08C0             LSRS     R0,R0,#+3
   \   00000086   0xEA41 0x05C0      ORR      R5,R1,R0, LSL #+3
    282          
    283            /* the FIFO threshold is not used when the FIFO mode is disabled */
    284            if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
   \   0000008A   0x2904             CMP      R1,#+4
   \   0000008C   0xD10C             BNE.N    ??HAL_DMA_Init_4
    285            {
    286              /* Get the FIFO threshold */
    287              tmp |= hdma->Init.FIFOThreshold;
   \   0000008E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000090   0x4305             ORRS     R5,R0,R5
    288              
    289              if(DMA_CheckFifoParam(hdma) != HAL_OK)
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0x.... 0x....      BL       DMA_CheckFifoParam
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD005             BEQ.N    ??HAL_DMA_Init_4
    290              {
    291                /* Update error code */
    292                hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
   \   0000009C   0x2040             MOVS     R0,#+64
   \   0000009E   0x6560             STR      R0,[R4, #+84]
    293                
    294                /* Change the DMA state */
    295                hdma->State = HAL_DMA_STATE_READY;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xF884 0x0035      STRB     R0,[R4, #+53]
    296                
    297                return HAL_ERROR; 
   \   000000A6   0xBD32             POP      {R1,R4,R5,PC}
    298              }
    299            }
    300            
    301            /* Write to DMA Stream FCR */
    302            hdma->Instance->FCR = tmp;
   \                     ??HAL_DMA_Init_4: (+1)
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6145             STR      R5,[R0, #+20]
    303          
    304            /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
    305               DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    306            regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0x.... 0x....      BL       DMA_CalcBaseAndBitshift
    307            
    308            /* Clear all interrupt flags */
    309            regs->IFCR = 0x3FU << hdma->StreamIndex;
   \   000000B2   0x213F             MOVS     R1,#+63
   \   000000B4   0x6DE2             LDR      R2,[R4, #+92]
   \   000000B6   0x4091             LSLS     R1,R1,R2
   \   000000B8   0x6081             STR      R1,[R0, #+8]
    310          
    311            /* Initialize the error code */
    312            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x6560             STR      R0,[R4, #+84]
    313                                                                                               
    314            /* Initialize the DMA state */
    315            hdma->State = HAL_DMA_STATE_READY;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xF884 0x0035      STRB     R0,[R4, #+53]
    316          
    317            return HAL_OK;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    318          }
    319          
    320          /**
    321            * @brief  DeInitializes the DMA peripheral 
    322            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    323            *               the configuration information for the specified DMA Stream.  
    324            * @retval HAL status
    325            */

   \                                 In section .text, align 2, keep-with-next
    326          HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
    327          {
   \                     HAL_DMA_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    328            DMA_Base_Registers *regs;
    329          
    330            /* Check the DMA peripheral state */
    331            if(hdma == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_DMA_DeInit_0
    332            {
    333              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    334            }
    335            
    336            /* Check the DMA peripheral state */
    337            if(hdma->State == HAL_DMA_STATE_BUSY)
   \                     ??HAL_DMA_DeInit_0: (+1)
   \   0000000A   0xF994 0x0035      LDRSB    R0,[R4, #+53]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD101             BNE.N    ??HAL_DMA_DeInit_1
    338            {
    339              /* Return error status */
    340              return HAL_BUSY;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xBD10             POP      {R4,PC}
    341            }
    342          
    343            /* Disable the selected DMA Streamx */
    344            __HAL_DMA_DISABLE(hdma);
   \                     ??HAL_DMA_DeInit_1: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x0849             LSRS     R1,R1,#+1
   \   0000001C   0x0049             LSLS     R1,R1,#+1
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    345          
    346            /* Reset DMA Streamx control register */
    347            hdma->Instance->CR   = 0U;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x6008             STR      R0,[R1, #+0]
    348          
    349            /* Reset DMA Streamx number of data to transfer register */
    350            hdma->Instance->NDTR = 0U;
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x6048             STR      R0,[R1, #+4]
    351          
    352            /* Reset DMA Streamx peripheral address register */
    353            hdma->Instance->PAR  = 0U;
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6088             STR      R0,[R1, #+8]
    354          
    355            /* Reset DMA Streamx memory 0 address register */
    356            hdma->Instance->M0AR = 0U;
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x60C8             STR      R0,[R1, #+12]
    357            
    358            /* Reset DMA Streamx memory 1 address register */
    359            hdma->Instance->M1AR = 0U;
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x6108             STR      R0,[R1, #+16]
    360            
    361            /* Reset DMA Streamx FIFO control register */
    362            hdma->Instance->FCR  = (uint32_t)0x00000021U;
   \   00000036   0x2021             MOVS     R0,#+33
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6148             STR      R0,[R1, #+20]
    363            
    364            /* Get DMA steam Base Address */  
    365            regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       DMA_CalcBaseAndBitshift
    366            
    367            /* Clear all interrupt flags at correct offset within the register */
    368            regs->IFCR = 0x3FU << hdma->StreamIndex;
   \   00000042   0x213F             MOVS     R1,#+63
   \   00000044   0x6DE2             LDR      R2,[R4, #+92]
   \   00000046   0x4091             LSLS     R1,R1,R2
   \   00000048   0x6081             STR      R1,[R0, #+8]
    369          
    370            /* Initialize the error code */
    371            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6560             STR      R0,[R4, #+84]
    372          
    373            /* Initialize the DMA state */
    374            hdma->State = HAL_DMA_STATE_RESET;
   \   0000004E   0xF884 0x0035      STRB     R0,[R4, #+53]
    375          
    376            /* Release Lock */
    377            __HAL_UNLOCK(hdma);
   \   00000052   0xF884 0x0034      STRB     R0,[R4, #+52]
    378          
    379            return HAL_OK;
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    380          }
    381          
    382          /**
    383            * @}
    384            */
    385          
    386          /** @addtogroup DMA_Exported_Functions_Group2
    387            *
    388          @verbatim   
    389           ===============================================================================
    390                                #####  IO operation functions  #####
    391           ===============================================================================
    392              [..]  This section provides functions allowing to:
    393                (+) Configure the source, destination address and data length and Start DMA transfer
    394                (+) Configure the source, destination address and data length and 
    395                    Start DMA transfer with interrupt
    396                (+) Abort DMA transfer
    397                (+) Poll for transfer complete
    398                (+) Handle DMA interrupt request  
    399          
    400          @endverbatim
    401            * @{
    402            */
    403          
    404          /**
    405            * @brief  Starts the DMA Transfer.
    406            * @param  hdma      : pointer to a DMA_HandleTypeDef structure that contains
    407            *                     the configuration information for the specified DMA Stream.
    408            * @param  SrcAddress: The source memory Buffer address
    409            * @param  DstAddress: The destination memory Buffer address
    410            * @param  DataLength: The length of data to be transferred from source to destination
    411            * @retval HAL status
    412            */

   \                                 In section .text, align 2, keep-with-next
    413          HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    414          {
   \                     HAL_DMA_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
    415            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2400             MOVS     R4,#+0
    416            
    417            /* Check the parameters */
    418            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    419          
    420            /* Process locked */
    421            __HAL_LOCK(hdma);
   \   00000006   0xF995 0x0034      LDRSB    R0,[R5, #+52]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_DMA_Start_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_DMA_Start_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF885 0x0034      STRB     R0,[R5, #+52]
    422          
    423            if(HAL_DMA_STATE_READY == hdma->State)
   \   00000018   0xF995 0x0035      LDRSB    R0,[R5, #+53]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD10D             BNE.N    ??HAL_DMA_Start_1
    424            {
    425              /* Change DMA peripheral state */
    426              hdma->State = HAL_DMA_STATE_BUSY;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF885 0x0035      STRB     R0,[R5, #+53]
    427              
    428              /* Initialize the error code */
    429              hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x6568             STR      R0,[R5, #+84]
    430              
    431              /* Configure the source, destination address and the data length */
    432              DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       DMA_SetConfig
    433          
    434              /* Enable the Peripheral */
    435              __HAL_DMA_ENABLE(hdma);
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000038   0x6001             STR      R1,[R0, #+0]
   \   0000003A   0xE003             B.N      ??HAL_DMA_Start_2
    436            }
    437            else
    438            {
    439              /* Process unlocked */
    440              __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_Start_1: (+1)
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0xF885 0x0034      STRB     R0,[R5, #+52]
    441              
    442              /* Return error status */
    443              status = HAL_BUSY;
   \   00000042   0x2402             MOVS     R4,#+2
    444            } 
    445            return status; 
   \                     ??HAL_DMA_Start_2: (+1)
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    446          }
    447          
    448          /**
    449            * @brief  Starts the DMA Transfer with interrupt enabled.
    450            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
    451            *                     the configuration information for the specified DMA Stream.  
    452            * @param  SrcAddress: The source memory Buffer address
    453            * @param  DstAddress: The destination memory Buffer address
    454            * @param  DataLength: The length of data to be transferred from source to destination
    455            * @retval HAL status
    456            */

   \                                 In section .text, align 2, keep-with-next
    457          HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    458          {
   \                     HAL_DMA_Start_IT: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
    459            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2400             MOVS     R4,#+0
    460          
    461            /* calculate DMA base and stream number */
    462            DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
   \   00000006   0x6DAE             LDR      R6,[R5, #+88]
    463            
    464            /* Check the parameters */
    465            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    466           
    467            /* Process locked */
    468            __HAL_LOCK(hdma);
   \   00000008   0xF995 0x0034      LDRSB    R0,[R5, #+52]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_DMA_Start_IT_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_DMA_Start_IT_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF885 0x0034      STRB     R0,[R5, #+52]
    469            
    470            if(HAL_DMA_STATE_READY == hdma->State)
   \   0000001A   0xF995 0x0035      LDRSB    R0,[R5, #+53]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD11B             BNE.N    ??HAL_DMA_Start_IT_1
    471            {
    472              /* Change DMA peripheral state */
    473              hdma->State = HAL_DMA_STATE_BUSY;
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF885 0x0035      STRB     R0,[R5, #+53]
    474              
    475              /* Initialize the error code */
    476              hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x6568             STR      R0,[R5, #+84]
    477              
    478              /* Configure the source, destination address and the data length */
    479              DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0x.... 0x....      BL       DMA_SetConfig
    480              
    481              /* Clear all interrupt flags at correct offset within the register */
    482              regs->IFCR = 0x3FU << hdma->StreamIndex;
   \   00000032   0x203F             MOVS     R0,#+63
   \   00000034   0x6DE9             LDR      R1,[R5, #+92]
   \   00000036   0x4088             LSLS     R0,R0,R1
   \   00000038   0x60B0             STR      R0,[R6, #+8]
    483              
    484              /* Enable Common interrupts*/
    485              hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_HT | DMA_IT_DME;
   \   0000003A   0x6828             LDR      R0,[R5, #+0]
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0xF041 0x011E      ORR      R1,R1,#0x1E
   \   00000042   0x6001             STR      R1,[R0, #+0]
    486              hdma->Instance->FCR |= DMA_IT_FE;
   \   00000044   0x6828             LDR      R0,[R5, #+0]
   \   00000046   0x6941             LDR      R1,[R0, #+20]
   \   00000048   0xF041 0x0180      ORR      R1,R1,#0x80
   \   0000004C   0x6141             STR      R1,[R0, #+20]
    487              
    488             /* if(hdma->XferHalfCpltCallback != NULL)
    489              {
    490                hdma->Instance->CR  |= DMA_IT_HT;
    491              }
    492              */
    493              
    494              /* Enable the Peripheral */
    495              __HAL_DMA_ENABLE(hdma);
   \   0000004E   0x6828             LDR      R0,[R5, #+0]
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000056   0x6001             STR      R1,[R0, #+0]
   \   00000058   0xE003             B.N      ??HAL_DMA_Start_IT_2
    496            }
    497            else
    498            {
    499              /* Process unlocked */
    500              __HAL_UNLOCK(hdma);	  
   \                     ??HAL_DMA_Start_IT_1: (+1)
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0xF885 0x0034      STRB     R0,[R5, #+52]
    501              
    502              /* Return error status */
    503              status = HAL_BUSY;
   \   00000060   0x2402             MOVS     R4,#+2
    504            }
    505            
    506            return status;
   \                     ??HAL_DMA_Start_IT_2: (+1)
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    507          }
    508          
    509          /**
    510            * @brief  Aborts the DMA Transfer.
    511            * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains
    512            *                 the configuration information for the specified DMA Stream.
    513            *                   
    514            * @note  After disabling a DMA Stream, a check for wait until the DMA Stream is 
    515            *        effectively disabled is added. If a Stream is disabled 
    516            *        while a data transfer is ongoing, the current data will be transferred
    517            *        and the Stream will be effectively disabled only after the transfer of
    518            *        this single data is finished.  
    519            * @retval HAL status
    520            */

   \                                 In section .text, align 2, keep-with-next
    521          HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
    522          {
   \                     HAL_DMA_Abort: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    523            /* calculate DMA base and stream number */
    524            DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
   \   00000004   0x6DA5             LDR      R5,[R4, #+88]
    525            
    526            uint32_t tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
    527            
    528            if(hdma->State != HAL_DMA_STATE_BUSY)
   \   0000000C   0xF994 0x0035      LDRSB    R0,[R4, #+53]
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD006             BEQ.N    ??HAL_DMA_Abort_0
    529            {
    530              hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
   \   00000014   0x2080             MOVS     R0,#+128
   \   00000016   0x6560             STR      R0,[R4, #+84]
    531              
    532              /* Process Unlocked */
    533              __HAL_UNLOCK(hdma);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x0034      STRB     R0,[R4, #+52]
    534              
    535              return HAL_ERROR;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD70             POP      {R4-R6,PC}
    536            }
    537            else
    538            {
    539              /* Disable all the transfer interrupts */
    540              hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
   \                     ??HAL_DMA_Abort_0: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xF021 0x0116      BIC      R1,R1,#0x16
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    541              hdma->Instance->FCR &= ~(DMA_IT_FE);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6941             LDR      R1,[R0, #+20]
   \   00000030   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000034   0x6141             STR      R1,[R0, #+20]
    542              
    543              if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
   \   00000036   0x6C20             LDR      R0,[R4, #+64]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD102             BNE.N    ??HAL_DMA_Abort_1
   \   0000003C   0x6CA0             LDR      R0,[R4, #+72]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD004             BEQ.N    ??HAL_DMA_Abort_2
    544              {
    545                hdma->Instance->CR  &= ~(DMA_IT_HT);
   \                     ??HAL_DMA_Abort_1: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF021 0x0108      BIC      R1,R1,#0x8
   \   0000004A   0x6001             STR      R1,[R0, #+0]
    546              }
    547              
    548              /* Disable the stream */
    549              __HAL_DMA_DISABLE(hdma);
   \                     ??HAL_DMA_Abort_2: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0x0849             LSRS     R1,R1,#+1
   \   00000052   0x0049             LSLS     R1,R1,#+1
   \   00000054   0x6001             STR      R1,[R0, #+0]
    550              
    551              /* Check if the DMA Stream is effectively disabled */
    552              while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
   \                     ??HAL_DMA_Abort_3: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x07C0             LSLS     R0,R0,#+31
   \   0000005C   0xD50D             BPL.N    ??HAL_DMA_Abort_4
    553              {
    554                /* Check for the Timeout */
    555                if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
   \   0000005E   0x.... 0x....      BL       HAL_GetTick
   \   00000062   0x1B80             SUBS     R0,R0,R6
   \   00000064   0x2806             CMP      R0,#+6
   \   00000066   0xD3F6             BCC.N    ??HAL_DMA_Abort_3
    556                {
    557                  /* Update error code */
    558                  hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
   \   00000068   0x2020             MOVS     R0,#+32
   \   0000006A   0x6560             STR      R0,[R4, #+84]
    559                  
    560                  /* Process Unlocked */
    561                  __HAL_UNLOCK(hdma);
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF884 0x0034      STRB     R0,[R4, #+52]
    562                  
    563                  /* Change the DMA state */
    564                  hdma->State = HAL_DMA_STATE_TIMEOUT;
   \   00000072   0x2003             MOVS     R0,#+3
   \   00000074   0xF884 0x0035      STRB     R0,[R4, #+53]
    565                  
    566                  return HAL_TIMEOUT;
   \   00000078   0xBD70             POP      {R4-R6,PC}
    567                }
    568              }
    569              
    570              /* Clear all interrupt flags at correct offset within the register */
    571              regs->IFCR = 0x3FU << hdma->StreamIndex;
   \                     ??HAL_DMA_Abort_4: (+1)
   \   0000007A   0x203F             MOVS     R0,#+63
   \   0000007C   0x6DE1             LDR      R1,[R4, #+92]
   \   0000007E   0x4088             LSLS     R0,R0,R1
   \   00000080   0x60A8             STR      R0,[R5, #+8]
    572              
    573              /* Process Unlocked */
    574              __HAL_UNLOCK(hdma);
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF884 0x0034      STRB     R0,[R4, #+52]
    575              
    576              /* Change the DMA state*/
    577              hdma->State = HAL_DMA_STATE_READY;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xF884 0x0035      STRB     R0,[R4, #+53]
    578            }
    579            return HAL_OK;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xBD70             POP      {R4-R6,PC}       ;; return
    580          }
    581          
    582          /**
    583            * @brief  Aborts the DMA Transfer in Interrupt mode.
    584            * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains
    585            *                 the configuration information for the specified DMA Stream.
    586            * @retval HAL status
    587            */

   \                                 In section .text, align 2, keep-with-next
    588          HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
    589          {
    590            if(hdma->State != HAL_DMA_STATE_BUSY)
   \                     HAL_DMA_Abort_IT: (+1)
   \   00000000   0xF990 0x1035      LDRSB    R1,[R0, #+53]
   \   00000004   0x2902             CMP      R1,#+2
   \   00000006   0xD003             BEQ.N    ??HAL_DMA_Abort_IT_0
    591            {
    592              hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
   \   00000008   0x2180             MOVS     R1,#+128
   \   0000000A   0x6541             STR      R1,[R0, #+84]
    593              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR
    594            }
    595            else
    596            {
    597              /* Set Abort State  */
    598              hdma->State = HAL_DMA_STATE_ABORT;
   \                     ??HAL_DMA_Abort_IT_0: (+1)
   \   00000010   0x2105             MOVS     R1,#+5
   \   00000012   0xF880 0x1035      STRB     R1,[R0, #+53]
    599              
    600              /* Disable the stream */
    601              __HAL_DMA_DISABLE(hdma);
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x0849             LSRS     R1,R1,#+1
   \   0000001C   0x0049             LSLS     R1,R1,#+1
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    602            }
    603          
    604            return HAL_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4770             BX       LR               ;; return
    605          }
    606          
    607          /**
    608            * @brief  Polling for transfer complete.
    609            * @param  hdma:          pointer to a DMA_HandleTypeDef structure that contains
    610            *                        the configuration information for the specified DMA Stream.
    611            * @param  CompleteLevel: Specifies the DMA level complete.
    612            * @note   The polling mode is kept in this version for legacy. it is recommanded to use the IT model instead.
    613            *         This model could be used for debug purpose.
    614            * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode). 
    615            * @param  Timeout:       Timeout duration.
    616            * @retval HAL status
    617            */

   \                                 In section .text, align 2, keep-with-next
    618          HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
    619          {
   \                     HAL_DMA_PollForTransfer: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    620            HAL_StatusTypeDef status = HAL_OK; 
    621            uint32_t mask_cpltlevel;
    622            uint32_t tickstart = HAL_GetTick(); 
   \   0000000A   0x.... 0x....      BL       HAL_GetTick
   \   0000000E   0x4607             MOV      R7,R0
    623            uint32_t tmpisr;
    624            
    625            /* calculate DMA base and stream number */
    626            DMA_Base_Registers *regs;
    627          
    628            if(HAL_DMA_STATE_BUSY != hdma->State)
   \   00000010   0xF994 0x0035      LDRSB    R0,[R4, #+53]
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD006             BEQ.N    ??HAL_DMA_PollForTransfer_0
    629            {
    630              /* No transfer ongoing */
    631              hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
   \   00000018   0x2080             MOVS     R0,#+128
   \   0000001A   0x6560             STR      R0,[R4, #+84]
    632              __HAL_UNLOCK(hdma);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x0034      STRB     R0,[R4, #+52]
    633              return HAL_ERROR;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE087             B.N      ??HAL_DMA_PollForTransfer_1
    634            }
    635          
    636            /* Polling mode not supported in circular mode and double buffering mode */
    637            if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)
   \                     ??HAL_DMA_PollForTransfer_0: (+1)
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x05C0             LSLS     R0,R0,#+23
   \   0000002C   0xD504             BPL.N    ??HAL_DMA_PollForTransfer_2
    638            {
    639              hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
   \   0000002E   0xF44F 0x7080      MOV      R0,#+256
   \   00000032   0x6560             STR      R0,[R4, #+84]
    640              return HAL_ERROR;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE07E             B.N      ??HAL_DMA_PollForTransfer_1
    641            }
    642            
    643            /* Get the level transfer complete flag */
    644            if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
   \                     ??HAL_DMA_PollForTransfer_2: (+1)
   \   00000038   0x6DE0             LDR      R0,[R4, #+92]
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD103             BNE.N    ??HAL_DMA_PollForTransfer_3
    645            {
    646              /* Transfer Complete flag */
    647              mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
   \   0000003E   0x2120             MOVS     R1,#+32
   \   00000040   0xFA01 0xF800      LSL      R8,R1,R0
   \   00000044   0xE002             B.N      ??HAL_DMA_PollForTransfer_4
    648            }
    649            else
    650            {
    651              /* Half Transfer Complete flag */
    652              mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
   \                     ??HAL_DMA_PollForTransfer_3: (+1)
   \   00000046   0x2110             MOVS     R1,#+16
   \   00000048   0xFA01 0xF800      LSL      R8,R1,R0
    653            }
    654            
    655            regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
   \                     ??HAL_DMA_PollForTransfer_4: (+1)
   \   0000004C   0xF8D4 0x9058      LDR      R9,[R4, #+88]
    656            tmpisr = regs->ISR;
   \   00000050   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000054   0xE02B             B.N      ??HAL_DMA_PollForTransfer_5
    657            
    658            while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))
    659            {
    660              /* Check for the Timeout (Not applicable in circular mode)*/
    661              if(Timeout != HAL_MAX_DELAY)
    662              {
    663                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
    664                {
    665                  /* Update error code */
    666                  hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
    667          
    668                  /* Process Unlocked */
    669                  __HAL_UNLOCK(hdma);
    670                  
    671                  /* Change the DMA state */
    672                  hdma->State = HAL_DMA_STATE_READY;
    673                  
    674                  return HAL_TIMEOUT;
    675                }
    676              }
    677          
    678              /* Get the ISR register value */
    679              tmpisr = regs->ISR;
   \                     ??HAL_DMA_PollForTransfer_6: (+1)
   \   00000056   0xF8D9 0x0000      LDR      R0,[R9, #+0]
    680          
    681              if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
   \   0000005A   0x2108             MOVS     R1,#+8
   \   0000005C   0x6DE2             LDR      R2,[R4, #+92]
   \   0000005E   0xFA01 0xF202      LSL      R2,R1,R2
   \   00000062   0x4210             TST      R0,R2
   \   00000064   0xD007             BEQ.N    ??HAL_DMA_PollForTransfer_7
    682              {
    683                /* Update error code */
    684                hdma->ErrorCode |= HAL_DMA_ERROR_TE;
   \   00000066   0x6D62             LDR      R2,[R4, #+84]
   \   00000068   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000006C   0x6562             STR      R2,[R4, #+84]
    685                
    686                /* Clear the transfer error flag */
    687                regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
   \   0000006E   0x6DE2             LDR      R2,[R4, #+92]
   \   00000070   0x4091             LSLS     R1,R1,R2
   \   00000072   0xF8C9 0x1008      STR      R1,[R9, #+8]
    688              }
    689              
    690              if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
   \                     ??HAL_DMA_PollForTransfer_7: (+1)
   \   00000076   0x....             LDR.N    R1,??DataTable3_1  ;; 0x800001
   \   00000078   0x6DE2             LDR      R2,[R4, #+92]
   \   0000007A   0xFA01 0xF202      LSL      R2,R1,R2
   \   0000007E   0x4210             TST      R0,R2
   \   00000080   0xD007             BEQ.N    ??HAL_DMA_PollForTransfer_8
    691              {
    692                /* Update error code */
    693                hdma->ErrorCode |= HAL_DMA_ERROR_FE;
   \   00000082   0x6D62             LDR      R2,[R4, #+84]
   \   00000084   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000088   0x6562             STR      R2,[R4, #+84]
    694                
    695                /* Clear the FIFO error flag */
    696                regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
   \   0000008A   0x6DE2             LDR      R2,[R4, #+92]
   \   0000008C   0x4091             LSLS     R1,R1,R2
   \   0000008E   0xF8C9 0x1008      STR      R1,[R9, #+8]
    697              }
    698              
    699              if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
   \                     ??HAL_DMA_PollForTransfer_8: (+1)
   \   00000092   0x....             LDR.N    R1,??DataTable3_2  ;; 0x800004
   \   00000094   0x6DE2             LDR      R2,[R4, #+92]
   \   00000096   0xFA01 0xF202      LSL      R2,R1,R2
   \   0000009A   0x4210             TST      R0,R2
   \   0000009C   0xD007             BEQ.N    ??HAL_DMA_PollForTransfer_5
    700              {
    701                /* Update error code */
    702                hdma->ErrorCode |= HAL_DMA_ERROR_DME;
   \   0000009E   0x6D62             LDR      R2,[R4, #+84]
   \   000000A0   0xF042 0x0204      ORR      R2,R2,#0x4
   \   000000A4   0x6562             STR      R2,[R4, #+84]
    703                
    704                /* Clear the Direct Mode error flag */
    705                regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
   \   000000A6   0x6DE2             LDR      R2,[R4, #+92]
   \   000000A8   0x4091             LSLS     R1,R1,R2
   \   000000AA   0xF8C9 0x1008      STR      R1,[R9, #+8]
    706              }
   \                     ??HAL_DMA_PollForTransfer_5: (+1)
   \   000000AE   0xEA10 0x0F08      TST      R0,R8
   \   000000B2   0xD116             BNE.N    ??HAL_DMA_PollForTransfer_9
   \   000000B4   0x6D60             LDR      R0,[R4, #+84]
   \   000000B6   0x07C0             LSLS     R0,R0,#+31
   \   000000B8   0xD413             BMI.N    ??HAL_DMA_PollForTransfer_9
   \   000000BA   0xF116 0x0F01      CMN      R6,#+1
   \   000000BE   0xD0CA             BEQ.N    ??HAL_DMA_PollForTransfer_6
   \   000000C0   0x2E00             CMP      R6,#+0
   \   000000C2   0xD004             BEQ.N    ??HAL_DMA_PollForTransfer_10
   \   000000C4   0x.... 0x....      BL       HAL_GetTick
   \   000000C8   0x1BC0             SUBS     R0,R0,R7
   \   000000CA   0x4286             CMP      R6,R0
   \   000000CC   0xD2C3             BCS.N    ??HAL_DMA_PollForTransfer_6
   \                     ??HAL_DMA_PollForTransfer_10: (+1)
   \   000000CE   0x2020             MOVS     R0,#+32
   \   000000D0   0x6560             STR      R0,[R4, #+84]
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000DE   0x2003             MOVS     R0,#+3
   \   000000E0   0xE029             B.N      ??HAL_DMA_PollForTransfer_1
    707            }
    708            
    709            if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
   \                     ??HAL_DMA_PollForTransfer_9: (+1)
   \   000000E2   0x6D60             LDR      R0,[R4, #+84]
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD011             BEQ.N    ??HAL_DMA_PollForTransfer_11
    710            {
    711              if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
   \   000000E8   0x6D60             LDR      R0,[R4, #+84]
   \   000000EA   0x07C0             LSLS     R0,R0,#+31
   \   000000EC   0xD50E             BPL.N    ??HAL_DMA_PollForTransfer_11
    712              {
    713                HAL_DMA_Abort(hdma);
   \   000000EE   0x4620             MOV      R0,R4
   \   000000F0   0x.... 0x....      BL       HAL_DMA_Abort
    714              
    715                /* Clear the half transfer and transfer complete flags */
    716                regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
   \   000000F4   0x2030             MOVS     R0,#+48
   \   000000F6   0x6DE1             LDR      R1,[R4, #+92]
   \   000000F8   0x4088             LSLS     R0,R0,R1
   \   000000FA   0xF8C9 0x0008      STR      R0,[R9, #+8]
    717              
    718                /* Process Unlocked */
    719                __HAL_UNLOCK(hdma);
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0xF884 0x0034      STRB     R0,[R4, #+52]
    720          
    721                /* Change the DMA state */
    722                hdma->State= HAL_DMA_STATE_READY;
   \   00000104   0x2001             MOVS     R0,#+1
   \   00000106   0xF884 0x0035      STRB     R0,[R4, #+53]
    723          
    724                return HAL_ERROR;
   \   0000010A   0xE014             B.N      ??HAL_DMA_PollForTransfer_1
    725             }
    726          
    727            }
    728          
    729            /* Get the level transfer complete flag */
    730            if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
   \                     ??HAL_DMA_PollForTransfer_11: (+1)
   \   0000010C   0x6DE0             LDR      R0,[R4, #+92]
   \   0000010E   0x2D00             CMP      R5,#+0
   \   00000110   0xD10B             BNE.N    ??HAL_DMA_PollForTransfer_12
    731            {
    732              /* Clear the half transfer and transfer complete flags */
    733              regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
   \   00000112   0x2130             MOVS     R1,#+48
   \   00000114   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000118   0xF8C9 0x0008      STR      R0,[R9, #+8]
    734              
    735              /* Process Unlocked */
    736              __HAL_UNLOCK(hdma);
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0xF884 0x0034      STRB     R0,[R4, #+52]
    737          
    738              hdma->State = HAL_DMA_STATE_READY;
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000128   0xE004             B.N      ??HAL_DMA_PollForTransfer_13
    739            }
    740            else
    741            {
    742              /* Clear the half transfer and transfer complete flags */
    743              regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;
   \                     ??HAL_DMA_PollForTransfer_12: (+1)
   \   0000012A   0x2110             MOVS     R1,#+16
   \   0000012C   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000130   0xF8C9 0x0008      STR      R0,[R9, #+8]
    744            }
    745            
    746            return status;
   \                     ??HAL_DMA_PollForTransfer_13: (+1)
   \   00000134   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA_PollForTransfer_1: (+1)
   \   00000136   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    747          }
    748          
    749          /**
    750            * @brief  Handles DMA interrupt request.
    751            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    752            *               the configuration information for the specified DMA Stream.  
    753            * @retval None
    754            */

   \                                 In section .text, align 2, keep-with-next
    755          void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
    756          {
   \                     HAL_DMA_IRQHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    757            uint32_t tmpisr;
    758            __IO uint32_t count = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
    759            uint32_t timeout = SystemCoreClock / 9600;
   \   00000008   0x....             LDR.N    R0,??DataTable3_3
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF44F 0x5116      MOV      R1,#+9600
   \   00000010   0xFBB0 0xF5F1      UDIV     R5,R0,R1
    760          
    761            /* calculate DMA base and stream number */
    762            DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
   \   00000014   0x6DA6             LDR      R6,[R4, #+88]
    763          
    764            tmpisr = regs->ISR;
   \   00000016   0x6837             LDR      R7,[R6, #+0]
    765          
    766            /* Transfer Error Interrupt management ***************************************/
    767            if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
   \   00000018   0x2008             MOVS     R0,#+8
   \   0000001A   0x6DE1             LDR      R1,[R4, #+92]
   \   0000001C   0xFA00 0xF101      LSL      R1,R0,R1
   \   00000020   0x420F             TST      R7,R1
   \   00000022   0xD00E             BEQ.N    ??HAL_DMA_IRQHandler_0
    768            {
    769              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x680A             LDR      R2,[R1, #+0]
   \   00000028   0x0752             LSLS     R2,R2,#+29
   \   0000002A   0xD50A             BPL.N    ??HAL_DMA_IRQHandler_0
    770              {
    771                /* Disable the transfer error interrupt */
    772                hdma->Instance->CR  &= ~(DMA_IT_TE);
   \   0000002C   0x680A             LDR      R2,[R1, #+0]
   \   0000002E   0xF022 0x0204      BIC      R2,R2,#0x4
   \   00000032   0x600A             STR      R2,[R1, #+0]
    773                
    774                /* Clear the transfer error flag */
    775                regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
   \   00000034   0x6DE1             LDR      R1,[R4, #+92]
   \   00000036   0x4088             LSLS     R0,R0,R1
   \   00000038   0x60B0             STR      R0,[R6, #+8]
    776                
    777                /* Update error code */
    778                hdma->ErrorCode |= HAL_DMA_ERROR_TE;
   \   0000003A   0x6D60             LDR      R0,[R4, #+84]
   \   0000003C   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000040   0x6560             STR      R0,[R4, #+84]
   \                     ??HAL_DMA_IRQHandler_0: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable3_1  ;; 0x800001
   \   00000044   0x6DE1             LDR      R1,[R4, #+92]
   \   00000046   0x4088             LSLS     R0,R0,R1
   \   00000048   0x4207             TST      R7,R0
   \   0000004A   0xD008             BEQ.N    ??HAL_DMA_IRQHandler_1
    779              }
    780            }
    781            /* FIFO Error Interrupt management ******************************************/
    782            if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
    783            {
    784              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x6949             LDR      R1,[R1, #+20]
   \   00000050   0x0609             LSLS     R1,R1,#+24
   \   00000052   0xD504             BPL.N    ??HAL_DMA_IRQHandler_1
    785              {
    786                /* Clear the FIFO error flag */
    787                regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
   \   00000054   0x60B0             STR      R0,[R6, #+8]
    788          
    789                /* Update error code */
    790                hdma->ErrorCode |= HAL_DMA_ERROR_FE;
   \   00000056   0x6D60             LDR      R0,[R4, #+84]
   \   00000058   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000005C   0x6560             STR      R0,[R4, #+84]
   \                     ??HAL_DMA_IRQHandler_1: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable3_2  ;; 0x800004
   \   00000060   0x6DE1             LDR      R1,[R4, #+92]
   \   00000062   0x4088             LSLS     R0,R0,R1
   \   00000064   0x4207             TST      R7,R0
   \   00000066   0xD008             BEQ.N    ??HAL_DMA_IRQHandler_2
    791              }
    792            }
    793            /* Direct Mode Error Interrupt management ***********************************/
    794            if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
    795            {
    796              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6809             LDR      R1,[R1, #+0]
   \   0000006C   0x0789             LSLS     R1,R1,#+30
   \   0000006E   0xD504             BPL.N    ??HAL_DMA_IRQHandler_2
    797              {
    798                /* Clear the direct mode error flag */
    799                regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
   \   00000070   0x60B0             STR      R0,[R6, #+8]
    800          
    801                /* Update error code */
    802                hdma->ErrorCode |= HAL_DMA_ERROR_DME;
   \   00000072   0x6D60             LDR      R0,[R4, #+84]
   \   00000074   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000078   0x6560             STR      R0,[R4, #+84]
   \                     ??HAL_DMA_IRQHandler_2: (+1)
   \   0000007A   0x2010             MOVS     R0,#+16
   \   0000007C   0x6DE1             LDR      R1,[R4, #+92]
   \   0000007E   0x4088             LSLS     R0,R0,R1
   \   00000080   0x4207             TST      R7,R0
   \   00000082   0xD023             BEQ.N    ??HAL_DMA_IRQHandler_3
    803              }
    804            }
    805            /* Half Transfer Complete Interrupt management ******************************/
    806            if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
    807            {
    808              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x6809             LDR      R1,[R1, #+0]
   \   00000088   0x0709             LSLS     R1,R1,#+28
   \   0000008A   0xD51F             BPL.N    ??HAL_DMA_IRQHandler_3
    809              {
    810                /* Clear the half transfer complete flag */
    811                regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
   \   0000008C   0x60B0             STR      R0,[R6, #+8]
    812                
    813                /* Multi_Buffering mode enabled */
    814                if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x6801             LDR      R1,[R0, #+0]
   \   00000092   0x0349             LSLS     R1,R1,#+13
   \   00000094   0xD50E             BPL.N    ??HAL_DMA_IRQHandler_4
    815                {
    816                  /* Current memory buffer used is Memory 0 */
    817                  if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x0300             LSLS     R0,R0,#+12
   \   0000009A   0xD405             BMI.N    ??HAL_DMA_IRQHandler_5
    818                  {
    819                    if(hdma->XferHalfCpltCallback != NULL)
   \   0000009C   0x6C21             LDR      R1,[R4, #+64]
   \   0000009E   0x0008             MOVS     R0,R1
   \   000000A0   0xD014             BEQ.N    ??HAL_DMA_IRQHandler_3
    820                    {
    821                      /* Half transfer callback */
    822                      hdma->XferHalfCpltCallback(hdma);
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0x4788             BLX      R1
   \   000000A6   0xE011             B.N      ??HAL_DMA_IRQHandler_3
    823                    }
    824                  }
    825                  /* Current memory buffer used is Memory 1 */
    826                  else
    827                  {
    828                    if(hdma->XferM1HalfCpltCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_5: (+1)
   \   000000A8   0x6CA1             LDR      R1,[R4, #+72]
   \   000000AA   0x0008             MOVS     R0,R1
   \   000000AC   0xD00E             BEQ.N    ??HAL_DMA_IRQHandler_3
    829                    {
    830                      /* Half transfer callback */
    831                      hdma->XferM1HalfCpltCallback(hdma);
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x4788             BLX      R1
   \   000000B2   0xE00B             B.N      ??HAL_DMA_IRQHandler_3
    832                    }
    833                  }
    834                }
    835                else
    836                {
    837                  /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    838                  if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
   \                     ??HAL_DMA_IRQHandler_4: (+1)
   \   000000B4   0x6801             LDR      R1,[R0, #+0]
   \   000000B6   0x05C9             LSLS     R1,R1,#+23
   \   000000B8   0xD403             BMI.N    ??HAL_DMA_IRQHandler_6
    839                  {
    840                    /* Disable the half transfer interrupt */
    841                    hdma->Instance->CR  &= ~(DMA_IT_HT);
   \   000000BA   0x6801             LDR      R1,[R0, #+0]
   \   000000BC   0xF021 0x0108      BIC      R1,R1,#0x8
   \   000000C0   0x6001             STR      R1,[R0, #+0]
    842                  }
    843                  
    844                  if(hdma->XferHalfCpltCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_6: (+1)
   \   000000C2   0x6C21             LDR      R1,[R4, #+64]
   \   000000C4   0x0008             MOVS     R0,R1
   \   000000C6   0xD001             BEQ.N    ??HAL_DMA_IRQHandler_3
    845                  {
    846                    /* Half transfer callback */
    847                    hdma->XferHalfCpltCallback(hdma);
   \   000000C8   0x4620             MOV      R0,R4
   \   000000CA   0x4788             BLX      R1
   \                     ??HAL_DMA_IRQHandler_3: (+1)
   \   000000CC   0x2020             MOVS     R0,#+32
   \   000000CE   0x6DE1             LDR      R1,[R4, #+92]
   \   000000D0   0x4088             LSLS     R0,R0,R1
   \   000000D2   0x4207             TST      R7,R0
   \   000000D4   0xD051             BEQ.N    ??HAL_DMA_IRQHandler_7
    848                  }
    849                }
    850              }
    851            }
    852            /* Transfer Complete Interrupt management ***********************************/
    853            if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
    854            {
    855              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
   \   000000D6   0x6821             LDR      R1,[R4, #+0]
   \   000000D8   0x6809             LDR      R1,[R1, #+0]
   \   000000DA   0x06C9             LSLS     R1,R1,#+27
   \   000000DC   0xD54D             BPL.N    ??HAL_DMA_IRQHandler_7
    856              {
    857                /* Clear the transfer complete flag */
    858                regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
   \   000000DE   0x60B0             STR      R0,[R6, #+8]
    859                
    860                if(HAL_DMA_STATE_ABORT == hdma->State)
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0xF994 0x1035      LDRSB    R1,[R4, #+53]
   \   000000E6   0x2905             CMP      R1,#+5
   \   000000E8   0x6801             LDR      R1,[R0, #+0]
   \   000000EA   0xD123             BNE.N    ??HAL_DMA_IRQHandler_8
    861                {
    862                  /* Disable all the transfer interrupts */
    863                  hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
   \   000000EC   0xF021 0x0116      BIC      R1,R1,#0x16
   \   000000F0   0x6001             STR      R1,[R0, #+0]
    864                  hdma->Instance->FCR &= ~(DMA_IT_FE);
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x6941             LDR      R1,[R0, #+20]
   \   000000F6   0xF021 0x0180      BIC      R1,R1,#0x80
   \   000000FA   0x6141             STR      R1,[R0, #+20]
    865                  
    866                  if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
   \   000000FC   0x6C20             LDR      R0,[R4, #+64]
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD102             BNE.N    ??HAL_DMA_IRQHandler_9
   \   00000102   0x6CA0             LDR      R0,[R4, #+72]
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD004             BEQ.N    ??HAL_DMA_IRQHandler_10
    867                  {
    868                    hdma->Instance->CR  &= ~(DMA_IT_HT);
   \                     ??HAL_DMA_IRQHandler_9: (+1)
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x6801             LDR      R1,[R0, #+0]
   \   0000010C   0xF021 0x0108      BIC      R1,R1,#0x8
   \   00000110   0x6001             STR      R1,[R0, #+0]
    869                  }
    870          
    871                  /* Clear all interrupt flags at correct offset within the register */
    872                  regs->IFCR = 0x3FU << hdma->StreamIndex;
   \                     ??HAL_DMA_IRQHandler_10: (+1)
   \   00000112   0x203F             MOVS     R0,#+63
   \   00000114   0x6DE1             LDR      R1,[R4, #+92]
   \   00000116   0x4088             LSLS     R0,R0,R1
   \   00000118   0x60B0             STR      R0,[R6, #+8]
    873          
    874                  /* Process Unlocked */
    875                  __HAL_UNLOCK(hdma);
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0xF884 0x0034      STRB     R0,[R4, #+52]
    876          
    877                  /* Change the DMA state */
    878                  hdma->State = HAL_DMA_STATE_READY;
   \   00000120   0x2001             MOVS     R0,#+1
   \   00000122   0xF884 0x0035      STRB     R0,[R4, #+53]
    879          
    880                  if(hdma->XferAbortCallback != NULL)
   \   00000126   0x6D21             LDR      R1,[R4, #+80]
   \   00000128   0x0008             MOVS     R0,R1
   \   0000012A   0xD04A             BEQ.N    ??HAL_DMA_IRQHandler_11
    881                  {
    882                    hdma->XferAbortCallback(hdma);
   \   0000012C   0x4620             MOV      R0,R4
   \   0000012E   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   00000132   0x4708             BX       R1
    883                  }
    884                  return;
    885                }
    886          
    887                if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
   \                     ??HAL_DMA_IRQHandler_8: (+1)
   \   00000134   0x0349             LSLS     R1,R1,#+13
   \   00000136   0xD50E             BPL.N    ??HAL_DMA_IRQHandler_12
    888                {
    889                  /* Current memory buffer used is Memory 0 */
    890                  if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
   \   00000138   0x6800             LDR      R0,[R0, #+0]
   \   0000013A   0x0300             LSLS     R0,R0,#+12
   \   0000013C   0xD405             BMI.N    ??HAL_DMA_IRQHandler_13
    891                  {
    892                    if(hdma->XferM1CpltCallback != NULL)
   \   0000013E   0x6C61             LDR      R1,[R4, #+68]
   \   00000140   0x0008             MOVS     R0,R1
   \   00000142   0xD01A             BEQ.N    ??HAL_DMA_IRQHandler_7
    893                    {
    894                      /* Transfer complete Callback for memory1 */
    895                      hdma->XferM1CpltCallback(hdma);
   \   00000144   0x4620             MOV      R0,R4
   \   00000146   0x4788             BLX      R1
   \   00000148   0xE017             B.N      ??HAL_DMA_IRQHandler_7
    896                    }
    897                  }
    898                  /* Current memory buffer used is Memory 1 */
    899                  else
    900                  {
    901                    if(hdma->XferCpltCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_13: (+1)
   \   0000014A   0x6BE1             LDR      R1,[R4, #+60]
   \   0000014C   0x0008             MOVS     R0,R1
   \   0000014E   0xD014             BEQ.N    ??HAL_DMA_IRQHandler_7
    902                    {
    903                      /* Transfer complete Callback for memory0 */
    904                      hdma->XferCpltCallback(hdma);
   \   00000150   0x4620             MOV      R0,R4
   \   00000152   0x4788             BLX      R1
   \   00000154   0xE011             B.N      ??HAL_DMA_IRQHandler_7
    905                    }
    906                  }
    907                }
    908                /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
    909                else
    910                {
    911                  if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
   \                     ??HAL_DMA_IRQHandler_12: (+1)
   \   00000156   0x6801             LDR      R1,[R0, #+0]
   \   00000158   0x05C9             LSLS     R1,R1,#+23
   \   0000015A   0xD409             BMI.N    ??HAL_DMA_IRQHandler_14
    912                  {
    913                    /* Disable the transfer complete interrupt */
    914                    hdma->Instance->CR  &= ~(DMA_IT_TC);
   \   0000015C   0x6801             LDR      R1,[R0, #+0]
   \   0000015E   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000162   0x6001             STR      R1,[R0, #+0]
    915          
    916                    /* Process Unlocked */
    917                    __HAL_UNLOCK(hdma);
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0xF884 0x0034      STRB     R0,[R4, #+52]
    918          
    919                    /* Change the DMA state */
    920                    hdma->State = HAL_DMA_STATE_READY;
   \   0000016A   0x2001             MOVS     R0,#+1
   \   0000016C   0xF884 0x0035      STRB     R0,[R4, #+53]
    921                  }
    922          
    923                  if(hdma->XferCpltCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_14: (+1)
   \   00000170   0x6BE1             LDR      R1,[R4, #+60]
   \   00000172   0x0008             MOVS     R0,R1
   \   00000174   0xD001             BEQ.N    ??HAL_DMA_IRQHandler_7
    924                  {
    925                    /* Transfer complete callback */
    926                    hdma->XferCpltCallback(hdma);
   \   00000176   0x4620             MOV      R0,R4
   \   00000178   0x4788             BLX      R1
    927                  }
    928                }
    929              }
    930            }
    931            
    932            /* manage error case */
    933            if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
   \                     ??HAL_DMA_IRQHandler_7: (+1)
   \   0000017A   0x6D60             LDR      R0,[R4, #+84]
   \   0000017C   0x2800             CMP      R0,#+0
   \   0000017E   0xD020             BEQ.N    ??HAL_DMA_IRQHandler_11
    934            {
    935              if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
   \   00000180   0x6D60             LDR      R0,[R4, #+84]
   \   00000182   0x07C0             LSLS     R0,R0,#+31
   \   00000184   0xD516             BPL.N    ??HAL_DMA_IRQHandler_15
    936              {
    937                hdma->State = HAL_DMA_STATE_ABORT;
   \   00000186   0x2005             MOVS     R0,#+5
   \   00000188   0xF884 0x0035      STRB     R0,[R4, #+53]
    938          
    939                /* Disable the stream */
    940                __HAL_DMA_DISABLE(hdma);
   \   0000018C   0x6820             LDR      R0,[R4, #+0]
   \   0000018E   0x6801             LDR      R1,[R0, #+0]
   \   00000190   0x0849             LSRS     R1,R1,#+1
   \   00000192   0x0049             LSLS     R1,R1,#+1
   \   00000194   0x6001             STR      R1,[R0, #+0]
    941          
    942                do
    943                {
    944                  if (++count > timeout)
   \                     ??HAL_DMA_IRQHandler_16: (+1)
   \   00000196   0x9800             LDR      R0,[SP, #+0]
   \   00000198   0x1C40             ADDS     R0,R0,#+1
   \   0000019A   0x9000             STR      R0,[SP, #+0]
   \   0000019C   0x4285             CMP      R5,R0
   \   0000019E   0xD303             BCC.N    ??HAL_DMA_IRQHandler_17
    945                  {
    946                    break;
    947                  }
    948                }
    949                while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
   \   000001A0   0x6820             LDR      R0,[R4, #+0]
   \   000001A2   0x6800             LDR      R0,[R0, #+0]
   \   000001A4   0x07C0             LSLS     R0,R0,#+31
   \   000001A6   0xD4F6             BMI.N    ??HAL_DMA_IRQHandler_16
    950          
    951                /* Process Unlocked */
    952                __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_IRQHandler_17: (+1)
   \   000001A8   0x2000             MOVS     R0,#+0
   \   000001AA   0xF884 0x0034      STRB     R0,[R4, #+52]
    953          
    954                /* Change the DMA state */
    955                hdma->State = HAL_DMA_STATE_READY;
   \   000001AE   0x2001             MOVS     R0,#+1
   \   000001B0   0xF884 0x0035      STRB     R0,[R4, #+53]
    956              }
    957          
    958              if(hdma->XferErrorCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_15: (+1)
   \   000001B4   0x6CE1             LDR      R1,[R4, #+76]
   \   000001B6   0x0008             MOVS     R0,R1
   \   000001B8   0xD003             BEQ.N    ??HAL_DMA_IRQHandler_11
    959              {
    960                /* Transfer error callback */
    961                hdma->XferErrorCallback(hdma);
   \   000001BA   0x4620             MOV      R0,R4
   \   000001BC   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   000001C0   0x4708             BX       R1
    962              }
    963            }
    964          }
   \                     ??HAL_DMA_IRQHandler_11: (+1)
   \   000001C2   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    965          
    966          /**
    967            * @brief  Register callbacks
    968            * @param  hdma:                 pointer to a DMA_HandleTypeDef structure that contains
    969            *                               the configuration information for the specified DMA Stream.
    970            * @param  CallbackID:           User Callback identifer
    971            *                               a DMA_HandleTypeDef structure as parameter.
    972            * @param  pCallback:            pointer to private callbacsk function which has pointer to 
    973            *                               a DMA_HandleTypeDef structure as parameter.
    974            * @retval HAL status
    975            */                      

   \                                 In section .text, align 4, keep-with-next
    976          HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
    977          {
   \                     HAL_DMA_RegisterCallback: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    978          
    979            HAL_StatusTypeDef status = HAL_OK;
   \   00000002   0x2300             MOVS     R3,#+0
    980          
    981            /* Process locked */
    982            __HAL_LOCK(hdma);
   \   00000004   0xF990 0x4034      LDRSB    R4,[R0, #+52]
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_DMA_RegisterCallback_1
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE020             B.N      ??HAL_DMA_RegisterCallback_2
   \                     ??HAL_DMA_RegisterCallback_1: (+1)
   \   00000010   0x2401             MOVS     R4,#+1
   \   00000012   0xF880 0x4034      STRB     R4,[R0, #+52]
    983          
    984            if(HAL_DMA_STATE_READY == hdma->State)
   \   00000016   0xF100 0x0434      ADD      R4,R0,#+52
   \   0000001A   0xF994 0x5001      LDRSB    R5,[R4, #+1]
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD112             BNE.N    ??HAL_DMA_RegisterCallback_3
    985            {
    986              switch (CallbackID)
   \   00000022   0x2905             CMP      R1,#+5
   \   00000024   0xD811             BHI.N    ??HAL_DMA_RegisterCallback_4
   \   00000026   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_DMA_RegisterCallback_0:
   \   0000002A   0x03 0x05          DC8      0x3,0x5,0x7,0x9
   \              0x07 0x09    
   \   0000002E   0x0B 0x0D          DC8      0xB,0xD
    987              {
    988              case  HAL_DMA_XFER_CPLT_CB_ID:
    989                hdma->XferCpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_5: (+1)
   \   00000030   0x60A2             STR      R2,[R4, #+8]
    990                break;
   \   00000032   0xE00A             B.N      ??HAL_DMA_RegisterCallback_4
    991          
    992              case  HAL_DMA_XFER_HALFCPLT_CB_ID:
    993                hdma->XferHalfCpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_6: (+1)
   \   00000034   0x60E2             STR      R2,[R4, #+12]
    994                break;
   \   00000036   0xE008             B.N      ??HAL_DMA_RegisterCallback_4
    995          
    996              case  HAL_DMA_XFER_M1CPLT_CB_ID:
    997                hdma->XferM1CpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_7: (+1)
   \   00000038   0x6122             STR      R2,[R4, #+16]
    998                break;
   \   0000003A   0xE006             B.N      ??HAL_DMA_RegisterCallback_4
    999          
   1000              case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
   1001                hdma->XferM1HalfCpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_8: (+1)
   \   0000003C   0x6162             STR      R2,[R4, #+20]
   1002                break;
   \   0000003E   0xE004             B.N      ??HAL_DMA_RegisterCallback_4
   1003          
   1004              case  HAL_DMA_XFER_ERROR_CB_ID:
   1005                hdma->XferErrorCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_9: (+1)
   \   00000040   0x61A2             STR      R2,[R4, #+24]
   1006                break;
   \   00000042   0xE002             B.N      ??HAL_DMA_RegisterCallback_4
   1007          
   1008              case  HAL_DMA_XFER_ABORT_CB_ID:
   1009                hdma->XferAbortCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_10: (+1)
   \   00000044   0x61E2             STR      R2,[R4, #+28]
   1010                break;
   \   00000046   0xE000             B.N      ??HAL_DMA_RegisterCallback_4
   1011          
   1012              default:
   1013                break;
   1014              }
   1015            }
   1016            else
   1017            {
   1018              /* Return error status */
   1019              status =  HAL_ERROR;
   \                     ??HAL_DMA_RegisterCallback_3: (+1)
   \   00000048   0x2301             MOVS     R3,#+1
   1020            }
   1021          
   1022            /* Release Lock */
   1023            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_RegisterCallback_4: (+1)
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0xF880 0x1034      STRB     R1,[R0, #+52]
   1024            
   1025            return status;
   \   00000050   0x4618             MOV      R0,R3
   \                     ??HAL_DMA_RegisterCallback_2: (+1)
   \   00000052   0xBC30             POP      {R4,R5}
   \   00000054   0x4770             BX       LR               ;; return
   1026          }
   1027          
   1028          /**
   1029            * @brief  UnRegister callbacks
   1030            * @param  hdma:                 pointer to a DMA_HandleTypeDef structure that contains
   1031            *                               the configuration information for the specified DMA Stream.
   1032            * @param  CallbackID:           User Callback identifer
   1033            *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
   1034            * @retval HAL status
   1035            */              

   \                                 In section .text, align 4, keep-with-next
   1036          HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
   1037          {
   \                     HAL_DMA_UnRegisterCallback: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x460A             MOV      R2,R1
   1038            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2100             MOVS     R1,#+0
   1039            
   1040            /* Process locked */
   1041            __HAL_LOCK(hdma);
   \   00000006   0xF990 0x3034      LDRSB    R3,[R0, #+52]
   \   0000000A   0x2B01             CMP      R3,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_DMA_UnRegisterCallback_1
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE02F             B.N      ??HAL_DMA_UnRegisterCallback_2
   \                     ??HAL_DMA_UnRegisterCallback_1: (+1)
   \   00000012   0x2301             MOVS     R3,#+1
   \   00000014   0xF880 0x3034      STRB     R3,[R0, #+52]
   1042            
   1043            if(HAL_DMA_STATE_READY == hdma->State)
   \   00000018   0xF100 0x0334      ADD      R3,R0,#+52
   \   0000001C   0xF993 0x4001      LDRSB    R4,[R3, #+1]
   \   00000020   0x2C01             CMP      R4,#+1
   \   00000022   0xD121             BNE.N    ??HAL_DMA_UnRegisterCallback_3
   1044            {
   1045              switch (CallbackID)
   \   00000024   0x2A06             CMP      R2,#+6
   \   00000026   0xD81F             BHI.N    ??HAL_DMA_UnRegisterCallback_3
   \   00000028   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??HAL_DMA_UnRegisterCallback_0:
   \   0000002C   0x04 0x07          DC8      0x4,0x7,0xA,0xD
   \              0x0A 0x0D    
   \   00000030   0x10 0x13          DC8      0x10,0x13,0x16,0x0
   \              0x16 0x00    
   1046              {
   1047              case  HAL_DMA_XFER_CPLT_CB_ID:
   1048                hdma->XferCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_4: (+1)
   \   00000034   0x460A             MOV      R2,R1
   \   00000036   0x609A             STR      R2,[R3, #+8]
   1049                break;
   \   00000038   0xE017             B.N      ??HAL_DMA_UnRegisterCallback_5
   1050                
   1051              case  HAL_DMA_XFER_HALFCPLT_CB_ID:
   1052                hdma->XferHalfCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_6: (+1)
   \   0000003A   0x460A             MOV      R2,R1
   \   0000003C   0x60DA             STR      R2,[R3, #+12]
   1053                break;
   \   0000003E   0xE014             B.N      ??HAL_DMA_UnRegisterCallback_5
   1054                
   1055              case  HAL_DMA_XFER_M1CPLT_CB_ID:
   1056                hdma->XferM1CpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_7: (+1)
   \   00000040   0x460A             MOV      R2,R1
   \   00000042   0x611A             STR      R2,[R3, #+16]
   1057                break;
   \   00000044   0xE011             B.N      ??HAL_DMA_UnRegisterCallback_5
   1058                
   1059              case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
   1060                hdma->XferM1HalfCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_8: (+1)
   \   00000046   0x460A             MOV      R2,R1
   \   00000048   0x615A             STR      R2,[R3, #+20]
   1061                break;
   \   0000004A   0xE00E             B.N      ??HAL_DMA_UnRegisterCallback_5
   1062                
   1063              case  HAL_DMA_XFER_ERROR_CB_ID:
   1064                hdma->XferErrorCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_9: (+1)
   \   0000004C   0x460A             MOV      R2,R1
   \   0000004E   0x619A             STR      R2,[R3, #+24]
   1065                break;
   \   00000050   0xE00B             B.N      ??HAL_DMA_UnRegisterCallback_5
   1066                
   1067              case  HAL_DMA_XFER_ABORT_CB_ID:
   1068                hdma->XferAbortCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_10: (+1)
   \   00000052   0x460A             MOV      R2,R1
   \   00000054   0x61DA             STR      R2,[R3, #+28]
   1069                break; 
   \   00000056   0xE008             B.N      ??HAL_DMA_UnRegisterCallback_5
   1070                
   1071              case   HAL_DMA_XFER_ALL_CB_ID:
   1072                hdma->XferCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_11: (+1)
   \   00000058   0x460A             MOV      R2,R1
   \   0000005A   0x609A             STR      R2,[R3, #+8]
   1073                hdma->XferHalfCpltCallback = NULL;
   \   0000005C   0x60DA             STR      R2,[R3, #+12]
   1074                hdma->XferM1CpltCallback = NULL;
   \   0000005E   0x611A             STR      R2,[R3, #+16]
   1075                hdma->XferM1HalfCpltCallback = NULL;
   \   00000060   0x615A             STR      R2,[R3, #+20]
   1076                hdma->XferErrorCallback = NULL;
   \   00000062   0x619A             STR      R2,[R3, #+24]
   1077                hdma->XferAbortCallback = NULL;
   \   00000064   0x61DA             STR      R2,[R3, #+28]
   1078                break; 
   \   00000066   0xE000             B.N      ??HAL_DMA_UnRegisterCallback_5
   1079                
   1080              default:
   1081                status = HAL_ERROR;
   1082                break;
   1083              }
   1084            }
   1085            else
   1086            {
   1087              status = HAL_ERROR;
   \                     ??HAL_DMA_UnRegisterCallback_3: (+1)
   \   00000068   0x2101             MOVS     R1,#+1
   1088            }
   1089            
   1090            /* Release Lock */
   1091            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_UnRegisterCallback_5: (+1)
   \   0000006A   0x2200             MOVS     R2,#+0
   \   0000006C   0xF880 0x2034      STRB     R2,[R0, #+52]
   1092            
   1093            return status;
   \   00000070   0x4608             MOV      R0,R1
   \                     ??HAL_DMA_UnRegisterCallback_2: (+1)
   \   00000072   0xBC10             POP      {R4}
   \   00000074   0x4770             BX       LR               ;; return
   1094          }
   1095          
   1096          /**
   1097            * @}
   1098            */
   1099          
   1100          /** @addtogroup DMA_Exported_Functions_Group3
   1101            *
   1102          @verbatim
   1103           ===============================================================================
   1104                              ##### State and Errors functions #####
   1105           ===============================================================================
   1106              [..]
   1107              This subsection provides functions allowing to
   1108                (+) Check the DMA state
   1109                (+) Get error code
   1110          
   1111          @endverbatim
   1112            * @{
   1113            */
   1114          
   1115          /**
   1116            * @brief  Returns the DMA state.
   1117            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1118            *               the configuration information for the specified DMA Stream.
   1119            * @retval HAL state
   1120            */

   \                                 In section .text, align 2, keep-with-next
   1121          HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
   1122          {
   1123            return hdma->State;
   \                     HAL_DMA_GetState: (+1)
   \   00000000   0xF990 0x0035      LDRSB    R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
   1124          }
   1125          
   1126          /**
   1127            * @brief  Return the DMA error code
   1128            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
   1129            *              the configuration information for the specified DMA Stream.
   1130            * @retval DMA Error Code
   1131            */

   \                                 In section .text, align 2, keep-with-next
   1132          uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
   1133          {
   1134            return hdma->ErrorCode;
   \                     HAL_DMA_GetError: (+1)
   \   00000000   0x6D40             LDR      R0,[R0, #+84]
   \   00000002   0x4770             BX       LR               ;; return
   1135          }
   1136          
   1137          /**
   1138            * @}
   1139            */
   1140          
   1141          /**
   1142            * @}
   1143            */
   1144          
   1145          /** @addtogroup DMA_Private_Functions
   1146            * @{
   1147            */
   1148          
   1149          /**
   1150            * @brief  Sets the DMA Transfer parameter.
   1151            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
   1152            *                     the configuration information for the specified DMA Stream.
   1153            * @param  SrcAddress: The source memory Buffer address
   1154            * @param  DstAddress: The destination memory Buffer address
   1155            * @param  DataLength: The length of data to be transferred from source to destination
   1156            * @retval HAL status
   1157            */

   \                                 In section .text, align 2, keep-with-next
   1158          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
   1159          {
   \                     DMA_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1160            /* Clear DBM bit */
   1161            hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
   \   00000002   0x6804             LDR      R4,[R0, #+0]
   \   00000004   0x6825             LDR      R5,[R4, #+0]
   \   00000006   0xF425 0x2580      BIC      R5,R5,#0x40000
   \   0000000A   0x6025             STR      R5,[R4, #+0]
   1162          
   1163            /* Configure DMA Stream data length */
   1164            hdma->Instance->NDTR = DataLength;
   \   0000000C   0x6804             LDR      R4,[R0, #+0]
   \   0000000E   0x6063             STR      R3,[R4, #+4]
   1165          
   1166            /* Peripheral to Memory */
   1167            if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
   \   00000010   0x6803             LDR      R3,[R0, #+0]
   \   00000012   0x6884             LDR      R4,[R0, #+8]
   \   00000014   0x2C40             CMP      R4,#+64
   \   00000016   0xD103             BNE.N    ??DMA_SetConfig_0
   1168            {
   1169              /* Configure DMA Stream destination address */
   1170              hdma->Instance->PAR = DstAddress;
   \   00000018   0x609A             STR      R2,[R3, #+8]
   1171          
   1172              /* Configure DMA Stream source address */
   1173              hdma->Instance->M0AR = SrcAddress;
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x60C1             STR      R1,[R0, #+12]
   \   0000001E   0xE002             B.N      ??DMA_SetConfig_1
   1174            }
   1175            /* Memory to Peripheral */
   1176            else
   1177            {
   1178              /* Configure DMA Stream source address */
   1179              hdma->Instance->PAR = SrcAddress;
   \                     ??DMA_SetConfig_0: (+1)
   \   00000020   0x6099             STR      R1,[R3, #+8]
   1180          
   1181              /* Configure DMA Stream destination address */
   1182              hdma->Instance->M0AR = DstAddress;
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x60C2             STR      R2,[R0, #+12]
   1183            }
   1184          }
   \                     ??DMA_SetConfig_1: (+1)
   \   00000026   0xBC30             POP      {R4,R5}
   \   00000028   0x4770             BX       LR               ;; return
   1185          
   1186          /**
   1187            * @brief  Returns the DMA Stream base address depending on stream number
   1188            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
   1189            *                     the configuration information for the specified DMA Stream. 
   1190            * @retval Stream base address
   1191            */

   \                                 In section .text, align 2, keep-with-next
   1192          static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
   1193          {
   1194            uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
   \                     DMA_CalcBaseAndBitshift: (+1)
   \   00000000   0x7801             LDRB     R1,[R0, #+0]
   \   00000002   0x3910             SUBS     R1,R1,#+16
   \   00000004   0x2218             MOVS     R2,#+24
   \   00000006   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   1195            
   1196            /* lookup table for necessary bitshift of flags within status registers */
   1197            static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
   1198            hdma->StreamIndex = flagBitshiftOffset[stream_number];
   \   0000000A   0x.... 0x....      ADR.W    R2,??flagBitshiftOffset
   \   0000000E   0x5C8A             LDRB     R2,[R1, R2]
   \   00000010   0x65C2             STR      R2,[R0, #+92]
   1199            
   1200            if (stream_number > 3U)
   \   00000012   0x6802             LDR      R2,[R0, #+0]
   \   00000014   0x0A92             LSRS     R2,R2,#+10
   \   00000016   0x0292             LSLS     R2,R2,#+10
   \   00000018   0x2904             CMP      R1,#+4
   \   0000001A   0xD302             BCC.N    ??DMA_CalcBaseAndBitshift_0
   1201            {
   1202              /* return pointer to HISR and HIFCR */
   1203              hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
   \   0000001C   0x1D11             ADDS     R1,R2,#+4
   \   0000001E   0x6581             STR      R1,[R0, #+88]
   \   00000020   0xE000             B.N      ??DMA_CalcBaseAndBitshift_1
   1204            }
   1205            else
   1206            {
   1207              /* return pointer to LISR and LIFCR */
   1208              hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
   \                     ??DMA_CalcBaseAndBitshift_0: (+1)
   \   00000022   0x6582             STR      R2,[R0, #+88]
   1209            }
   1210            
   1211            return hdma->StreamBaseAddress;
   \                     ??DMA_CalcBaseAndBitshift_1: (+1)
   \   00000024   0x6D80             LDR      R0,[R0, #+88]
   \   00000026   0x4770             BX       LR               ;; return
   1212          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??flagBitshiftOffset:
   \   00000000   0x00 0x06          DC8 0, 6, 16, 22, 0, 6, 16, 22
   \              0x10 0x16    
   \              0x00 0x06    
   \              0x10 0x16    
   1213          
   1214          /**
   1215            * @brief  Checks compatibility between FIFO threshold level and size of the memory burst
   1216            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
   1217            *                     the configuration information for the specified DMA Stream. 
   1218            * @retval HAL status
   1219            */

   \                                 In section .text, align 2, keep-with-next
   1220          static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
   1221          {
   \                     DMA_CheckFifoParam: (+1)
   \   00000000   0x4601             MOV      R1,R0
   1222            HAL_StatusTypeDef status = HAL_OK;
   \   00000002   0x2000             MOVS     R0,#+0
   1223            uint32_t tmp = hdma->Init.FIFOThreshold;
   \   00000004   0x6A8A             LDR      R2,[R1, #+40]
   1224            
   1225            /* Memory Data size equal to Byte */
   1226            if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
   \   00000006   0x698B             LDR      R3,[R1, #+24]
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD115             BNE.N    ??DMA_CheckFifoParam_0
   1227            {
   1228              switch (tmp)
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD003             BEQ.N    ??DMA_CheckFifoParam_1
   \   00000010   0x2A02             CMP      R2,#+2
   \   00000012   0xD00C             BEQ.N    ??DMA_CheckFifoParam_2
   \   00000014   0xD305             BCC.N    ??DMA_CheckFifoParam_3
   \   00000016   0x4770             BX       LR
   1229              {
   1230                case DMA_FIFO_THRESHOLD_1QUARTERFULL:
   1231                  if((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
   \                     ??DMA_CheckFifoParam_1: (+1)
   \   00000018   0x6AC9             LDR      R1,[R1, #+44]
   \   0000001A   0x01C9             LSLS     R1,R1,#+7
   \   0000001C   0xD531             BPL.N    ??DMA_CheckFifoParam_4
   1232                  {
   1233                    status = HAL_ERROR;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x4770             BX       LR
   1234                  }
   1235                  break;
   1236                case DMA_FIFO_THRESHOLD_HALFFULL:
   1237                  if(hdma->Init.MemBurst == DMA_MBURST_INC16)
   \                     ??DMA_CheckFifoParam_3: (+1)
   \   00000022   0x6AC9             LDR      R1,[R1, #+44]
   \   00000024   0xF1B1 0x7FC0      CMP      R1,#+25165824
   \   00000028   0xD12B             BNE.N    ??DMA_CheckFifoParam_4
   1238                  {
   1239                    status = HAL_ERROR;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x4770             BX       LR
   1240                  }
   1241                  break;
   1242                case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
   1243                  if((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
   \                     ??DMA_CheckFifoParam_2: (+1)
   \   0000002E   0x6AC9             LDR      R1,[R1, #+44]
   \   00000030   0x01C9             LSLS     R1,R1,#+7
   \   00000032   0xD526             BPL.N    ??DMA_CheckFifoParam_4
   1244                  {
   1245                    status = HAL_ERROR;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x4770             BX       LR
   1246                  }
   1247                  break;
   1248                case DMA_FIFO_THRESHOLD_FULL:
   1249                  break;
   1250                default:
   1251                  break;
   1252              }
   1253            }
   1254            
   1255            /* Memory Data size equal to Half-Word */
   1256            else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
   \                     ??DMA_CheckFifoParam_0: (+1)
   \   00000038   0xF5B3 0x5F00      CMP      R3,#+8192
   \   0000003C   0xD116             BNE.N    ??DMA_CheckFifoParam_5
   1257            {
   1258              switch (tmp)
   \   0000003E   0x2A00             CMP      R2,#+0
   \   00000040   0xD005             BEQ.N    ??DMA_CheckFifoParam_6
   \   00000042   0x2A02             CMP      R2,#+2
   \   00000044   0xD00A             BEQ.N    ??DMA_CheckFifoParam_7
   \   00000046   0xD304             BCC.N    ??DMA_CheckFifoParam_8
   \   00000048   0x2A03             CMP      R2,#+3
   \   0000004A   0xD009             BEQ.N    ??DMA_CheckFifoParam_9
   \   0000004C   0x4770             BX       LR
   1259              {
   1260                case DMA_FIFO_THRESHOLD_1QUARTERFULL:
   1261                  status = HAL_ERROR;
   \                     ??DMA_CheckFifoParam_6: (+1)
   \   0000004E   0x2001             MOVS     R0,#+1
   1262                  break;
   \   00000050   0x4770             BX       LR
   1263                case DMA_FIFO_THRESHOLD_HALFFULL:
   1264                  if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
   \                     ??DMA_CheckFifoParam_8: (+1)
   \   00000052   0x6AC9             LDR      R1,[R1, #+44]
   \   00000054   0x01C9             LSLS     R1,R1,#+7
   \   00000056   0xD514             BPL.N    ??DMA_CheckFifoParam_4
   1265                  {
   1266                    status = HAL_ERROR;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x4770             BX       LR
   1267                  }
   1268                  break;
   1269                case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
   1270                  status = HAL_ERROR;
   \                     ??DMA_CheckFifoParam_7: (+1)
   \   0000005C   0x2001             MOVS     R0,#+1
   1271                  break;
   \   0000005E   0x4770             BX       LR
   1272                case DMA_FIFO_THRESHOLD_FULL:
   1273                  if (hdma->Init.MemBurst == DMA_MBURST_INC16)
   \                     ??DMA_CheckFifoParam_9: (+1)
   \   00000060   0x6AC9             LDR      R1,[R1, #+44]
   \   00000062   0xF1B1 0x7FC0      CMP      R1,#+25165824
   \   00000066   0xD10C             BNE.N    ??DMA_CheckFifoParam_4
   1274                  {
   1275                    status = HAL_ERROR;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x4770             BX       LR
   1276                  }
   1277                  break;   
   1278                default:
   1279                  break;
   1280              }
   1281            }
   1282            
   1283            /* Memory Data size equal to Word */
   1284            else
   1285            {
   1286              switch (tmp)
   \                     ??DMA_CheckFifoParam_5: (+1)
   \   0000006C   0x2A02             CMP      R2,#+2
   \   0000006E   0xD902             BLS.N    ??DMA_CheckFifoParam_10
   \   00000070   0x1ED2             SUBS     R2,R2,#+3
   \   00000072   0xD002             BEQ.N    ??DMA_CheckFifoParam_11
   \   00000074   0x4770             BX       LR
   1287              {
   1288                case DMA_FIFO_THRESHOLD_1QUARTERFULL:
   1289                case DMA_FIFO_THRESHOLD_HALFFULL:
   1290                case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
   1291                  status = HAL_ERROR;
   \                     ??DMA_CheckFifoParam_10: (+1)
   \   00000076   0x2001             MOVS     R0,#+1
   1292                  break;
   \   00000078   0x4770             BX       LR
   1293                case DMA_FIFO_THRESHOLD_FULL:
   1294                  if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
   \                     ??DMA_CheckFifoParam_11: (+1)
   \   0000007A   0x6AC9             LDR      R1,[R1, #+44]
   \   0000007C   0x01C9             LSLS     R1,R1,#+7
   \   0000007E   0xD500             BPL.N    ??DMA_CheckFifoParam_4
   1295                  {
   1296                    status = HAL_ERROR;
   \   00000080   0x2001             MOVS     R0,#+1
   1297                  }
   1298          		break;
   1299                default:
   1300                  break;
   1301              }
   1302            } 
   1303            
   1304            return status; 
   \                     ??DMA_CheckFifoParam_4: (+1)
   \   00000082   0x4770             BX       LR               ;; return
   1305          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0xF010803F         DC32     0xf010803f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x00800001         DC32     0x800001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x00800004         DC32     0x800004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     SystemCoreClock
   1306          
   1307          /**
   1308            * @}
   1309            */
   1310          
   1311          #endif /* HAL_DMA_MODULE_ENABLED */
   1312          /**
   1313            * @}
   1314            */
   1315          
   1316          /**
   1317            * @}
   1318            */
   1319          
   1320          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DMA_CalcBaseAndBitshift
       0   DMA_CheckFifoParam
       8   DMA_SetConfig
      16   HAL_DMA_Abort
        16   -> HAL_GetTick
       0   HAL_DMA_Abort_IT
       8   HAL_DMA_DeInit
         8   -> DMA_CalcBaseAndBitshift
       0   HAL_DMA_GetError
       0   HAL_DMA_GetState
      24   HAL_DMA_IRQHandler
         0   -- Indirect call
        24   -- Indirect call
      16   HAL_DMA_Init
        16   -> DMA_CalcBaseAndBitshift
        16   -> DMA_CheckFifoParam
        16   -> HAL_GetTick
      32   HAL_DMA_PollForTransfer
        32   -> HAL_DMA_Abort
        32   -> HAL_GetTick
       8   HAL_DMA_RegisterCallback
      16   HAL_DMA_Start
        16   -> DMA_SetConfig
      16   HAL_DMA_Start_IT
        16   -> DMA_SetConfig
       4   HAL_DMA_UnRegisterCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
      40  DMA_CalcBaseAndBitshift
     132  DMA_CheckFifoParam
      42  DMA_SetConfig
     146  HAL_DMA_Abort
      36  HAL_DMA_Abort_IT
      88  HAL_DMA_DeInit
       4  HAL_DMA_GetError
       6  HAL_DMA_GetState
     452  HAL_DMA_IRQHandler
     200  HAL_DMA_Init
     314  HAL_DMA_PollForTransfer
      86  HAL_DMA_RegisterCallback
      72  HAL_DMA_Start
     102  HAL_DMA_Start_IT
     118  HAL_DMA_UnRegisterCallback
       8  flagBitshiftOffset

 
 1 862 bytes in section .text
 
 1 862 bytes of CODE memory

Errors: none
Warnings: none
