###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:57:43
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\BUTTON.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\BUTTON.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\BUTTON.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\BUTTON.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Widget\BUTTON.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              ÂµC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : BUTTON.c
     16          Purpose     : Implementation of button widget
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include <stdlib.h>
     21          #include <string.h>
     22          #include "BUTTON_Private.h"
     23          
     24          //#include "Printer.h"
     25          #include "mks_cfg.h"

  #define UNUSED(x) ((void)(x))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/
          Third_Party/Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Inc\mks_cfg.h",351  Warning[Pe083]: 
          type qualifier specified more than once
     26          
     27          #include "pic.h"
     28          
     29          #if GUI_WINSUPPORT
     30          #include "fastio_dlp_board.h"
     31          #include "mks_cfg.h"
     32          
     33          extern uint8_t btn_flg;
     34          extern uint32_t btn_beep_cnt;
     35          

   \                                 In section .text, align 2, keep-with-next
     36          void btn_beeper(uint32_t beeper)
     37          {
     38              btn_flg = 1;
   \                     btn_beeper: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             LDR.N    R2,??DataTable3
   \   00000004   0x7011             STRB     R1,[R2, #+0]
     39              btn_beep_cnt = beeper;
   \   00000006   0x....             LDR.N    R1,??DataTable3_1
   \   00000008   0x6008             STR      R0,[R1, #+0]
     40              BEEPER_OP=1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x....             LDR.N    R1,??DataTable3_2  ;; 0x42430288
   \   0000000E   0x6008             STR      R0,[R1, #+0]
     41              //GPIO_SetBits(GPIOG, GPIO_Pin_2);
     42          		//GPIO_SetBits(GPIOC, GPIO_Pin_13);
     43          }
   \   00000010   0x4770             BX       LR               ;; return
     44          
     45          extern uint8_t disp_in_file_dir;
     46          
     47          /*********************************************************************
     48          *
     49          *       Private config defaults
     50          *
     51          **********************************************************************
     52          */
     53          
     54          /* Define default fonts */
     55          #ifndef   BUTTON_FONT_DEFAULT
     56            #define BUTTON_FONT_DEFAULT &GUI_Font13_1
     57          #endif
     58          
     59          /* Support for 3D effects */
     60          #ifndef   BUTTON_USE_3D
     61            #define BUTTON_USE_3D 1
     62          #endif
     63          
     64          #ifndef   BUTTON_3D_MOVE_X
     65            #define BUTTON_3D_MOVE_X 1
     66          #endif
     67          #ifndef   BUTTON_3D_MOVE_Y
     68            #define BUTTON_3D_MOVE_Y 1
     69          #endif
     70          
     71          /* Define colors */
     72          #ifndef   BUTTON_BKCOLOR0_DEFAULT
     73            #define BUTTON_BKCOLOR0_DEFAULT   0xAAAAAA
     74          #endif
     75          
     76          #ifndef   BUTTON_BKCOLOR1_DEFAULT
     77            #define BUTTON_BKCOLOR1_DEFAULT   GUI_WHITE
     78          #endif
     79          
     80          #ifndef   BUTTON_BKCOLOR2_DEFAULT
     81            #define BUTTON_BKCOLOR2_DEFAULT   GUI_LIGHTGRAY
     82          #endif
     83          
     84          #ifndef   BUTTON_TEXTCOLOR0_DEFAULT
     85            #define BUTTON_TEXTCOLOR0_DEFAULT GUI_BLACK
     86          #endif
     87          
     88          #ifndef   BUTTON_TEXTCOLOR1_DEFAULT
     89            #define BUTTON_TEXTCOLOR1_DEFAULT GUI_BLACK
     90          #endif
     91          
     92          #ifndef   BUTTON_TEXTCOLOR2_DEFAULT
     93            #define BUTTON_TEXTCOLOR2_DEFAULT GUI_DARKGRAY
     94          #endif
     95          
     96          #ifndef   BUTTON_REACT_ON_LEVEL
     97            #define BUTTON_REACT_ON_LEVEL 0
     98          #endif
     99          
    100          #ifndef   BUTTON_ALIGN_DEFAULT
    101            #define BUTTON_ALIGN_DEFAULT GUI_TA_HCENTER | GUI_TA_VCENTER
    102          #endif
    103          
    104          //extern unsigned char bmp_public_buf[16 * 1024];
    105          
    106          /*********************************************************************
    107          *
    108          *       Static data
    109          *
    110          **********************************************************************
    111          */

   \                                 In section .data, align 4
    112          BUTTON_PROPS BUTTON__DefaultProps = {
   \                     BUTTON__DefaultProps:
   \   00000000   0x00AAAAAA         DC32 11184810, 16777215, 13882323, 0, 0, 4210752, GUI_Font13_1
   \              0x00FFFFFF   
   \              0x00D3D3D3   
   \              0x00000000   
   \              0x00000000   
   \              0x00404040   
   \              0x........   
   \   0000001C   0x000E             DC16 14
   \   0000001E   0x00 0x00          DC8 0, 0
    113            BUTTON_BKCOLOR0_DEFAULT,
    114            BUTTON_BKCOLOR1_DEFAULT,
    115            BUTTON_BKCOLOR2_DEFAULT,
    116            BUTTON_TEXTCOLOR0_DEFAULT,
    117            BUTTON_TEXTCOLOR1_DEFAULT,
    118            BUTTON_TEXTCOLOR2_DEFAULT,
    119            BUTTON_FONT_DEFAULT,
    120            BUTTON_ALIGN_DEFAULT
    121          };
    122          
    123          /*********************************************************************
    124          *
    125          *       Static routines
    126          *
    127          **********************************************************************
    128          */
    129          /*********************************************************************
    130          *
    131          *       _Paint
    132          */

   \                                 In section .text, align 2, keep-with-next
    133          static void _Paint(BUTTON_Obj* pObj, BUTTON_Handle hObj) {
   \                     _Paint: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4608             MOV      R0,R1
    134            const char* s = NULL;
   \   0000000A   0x2600             MOVS     R6,#+0
    135            unsigned int Index;
    136            int State, PressedState, ColorIndex;
    137            GUI_RECT rClient, rInside;
    138            State = pObj->Widget.State;
    139            PressedState = (State & BUTTON_STATE_PRESSED) ? 1 : 0;
   \   0000000C   0x8CE1             LDRH     R1,[R4, #+38]
   \   0000000E   0x0A09             LSRS     R1,R1,#+8
   \   00000010   0xF001 0x0501      AND      R5,R1,#0x1
    140            ColorIndex   = (WM__IsEnabled(hObj)) ? PressedState : 2;
   \   00000014   0x.... 0x....      BL       WM__IsEnabled
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ.N    ??_Paint_0
   \   0000001C   0x46A8             MOV      R8,R5
   \   0000001E   0xE001             B.N      ??_Paint_1
   \                     ??_Paint_0: (+1)
   \   00000020   0xF04F 0x0802      MOV      R8,#+2
    141            GUI_SetFont(pObj->Props.pFont);
   \                     ??_Paint_1: (+1)
   \   00000024   0x6C20             LDR      R0,[R4, #+64]
   \   00000026   0x.... 0x....      BL       GUI_SetFont
    142            GUI_DEBUG_LOG("BUTTON: Paint(..)\n");
    143            if (pObj->hpText) {
   \   0000002A   0xF9B4 0x0048      LDRSH    R0,[R4, #+72]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD002             BEQ.N    ??_Paint_2
    144              s = (const char*) GUI_ALLOC_h2p(pObj->hpText);
   \   00000032   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000036   0x4606             MOV      R6,R0
    145            }
    146            GUI_GetClientRect(&rClient);
   \                     ??_Paint_2: (+1)
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0x.... 0x....      BL       GUI_GetClientRect
    147          
    148            /* Start drawing */
    149            rInside = rClient;
   \   0000003E   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   00000042   0xE9CD 0x0102      STRD     R0,R1,[SP, #+8]
    150          /* Draw the 3D effect (if configured) */
    151          	if(gCfgItems.button_3d_effect_flag == 1)
   \   00000046   0x....             LDR.N    R7,??DataTable3_3
   \   00000048   0xF897 0x00EC      LDRB     R0,[R7, #+236]
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD119             BNE.N    ??_Paint_3
    152          	{
    153          	  #if BUTTON_USE_3D
    154          	  {
    155          	    int EffectSize;
    156          	    if ((PressedState) == 0) {
   \   00000050   0x2D00             CMP      R5,#+0
   \   00000052   0xD105             BNE.N    ??_Paint_4
    157          	      pObj->Widget.pEffect->pfDrawUp();  /* _WIDGET_EFFECT_3D_DrawUp(); */
   \   00000054   0x6A20             LDR      R0,[R4, #+32]
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x4780             BLX      R0
    158          	      EffectSize = pObj->Widget.pEffect->EffectSize;
   \   0000005A   0x6A20             LDR      R0,[R4, #+32]
   \   0000005C   0x6942             LDR      R2,[R0, #+20]
   \   0000005E   0xE00D             B.N      ??_Paint_5
    159          	    } else {
    160          	      LCD_SetColor(0x000000);
   \                     ??_Paint_4: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      BL       LCD_SetColor
    161          	      GUI_DrawRect(rClient.y0, rClient.x0, rClient.x1, rClient.y1);
   \   00000066   0xF9BD 0x3006      LDRSH    R3,[SP, #+6]
   \   0000006A   0xF9BD 0x2004      LDRSH    R2,[SP, #+4]
   \   0000006E   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   00000072   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   00000076   0x.... 0x....      BL       GUI_DrawRect
    162          	      EffectSize = 1;
   \   0000007A   0x2201             MOVS     R2,#+1
    163          	    }
    164          	    GUI__ReduceRect(&rInside, &rInside, EffectSize); 
   \                     ??_Paint_5: (+1)
   \   0000007C   0xA902             ADD      R1,SP,#+8
   \   0000007E   0xA802             ADD      R0,SP,#+8
   \   00000080   0x.... 0x....      BL       GUI__ReduceRect
    165          	  }
    166          	  #endif
    167          	}
    168            /* Draw background */
    169            LCD_SetBkColor (pObj->Props.aBkColor[ColorIndex]);
   \                     ??_Paint_3: (+1)
   \   00000084   0xEB04 0x0988      ADD      R9,R4,R8, LSL #+2
   \   00000088   0xF8D9 0x0028      LDR      R0,[R9, #+40]
   \   0000008C   0x.... 0x....      BL       LCD_SetBkColor
    170            LCD_SetColor   (pObj->Props.aTextColor[ColorIndex]);
   \   00000090   0xF8D9 0x0034      LDR      R0,[R9, #+52]
   \   00000094   0x.... 0x....      BL       LCD_SetColor
    171            WM_SetUserClipRect(&rInside);
   \   00000098   0xA802             ADD      R0,SP,#+8
   \   0000009A   0x.... 0x....      BL       WM_SetUserClipRect
    172          	if(pObj->clear_flag)
   \   0000009E   0xF994 0x0058      LDRSB    R0,[R4, #+88]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD001             BEQ.N    ??_Paint_6
    173            	GUI_Clear();
   \   000000A6   0x.... 0x....      BL       GUI_Clear
    174            /* Draw bitmap.
    175               If we have only one, we will use it.
    176               If we have to we will use the second one (Index 1) for the pressed state
    177            */
    178            if (ColorIndex < 2) {
   \                     ??_Paint_6: (+1)
   \   000000AA   0xF1B8 0x0F02      CMP      R8,#+2
   \   000000AE   0xDA10             BGE.N    ??_Paint_7
    179              Index = (pObj->ahDrawObj[BUTTON_BI_PRESSED] && PressedState) ? BUTTON_BI_PRESSED : BUTTON_BI_UNPRESSED;
   \   000000B0   0xF9B4 0x004C      LDRSH    R0,[R4, #+76]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD009             BEQ.N    ??_Paint_8
   \   000000B8   0x46A9             MOV      R9,R5
   \   000000BA   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   000000BE   0xEB69 0x0909      SBC      R9,R9,R9
   \   000000C2   0xEA6F 0x0909      MVN      R9,R9
   \   000000C6   0xEA4F 0x79D9      LSR      R9,R9,#+31
   \   000000CA   0xE00B             B.N      ??_Paint_9
   \                     ??_Paint_8: (+1)
   \   000000CC   0xF04F 0x0900      MOV      R9,#+0
   \   000000D0   0xE008             B.N      ??_Paint_9
    180            } else {
    181              Index = pObj->ahDrawObj[BUTTON_BI_DISABLED] ? BUTTON_BI_DISABLED : BUTTON_BI_UNPRESSED;
   \                     ??_Paint_7: (+1)
   \   000000D2   0xF9B4 0x004E      LDRSH    R0,[R4, #+78]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD002             BEQ.N    ??_Paint_10
   \   000000DA   0xF04F 0x0902      MOV      R9,#+2
   \   000000DE   0xE001             B.N      ??_Paint_9
   \                     ??_Paint_10: (+1)
   \   000000E0   0xF04F 0x0900      MOV      R9,#+0
    182            }
    183          
    184          	if(disp_in_file_dir == 1)
   \                     ??_Paint_9: (+1)
   \   000000E4   0x.... 0x....      LDR.W    R8,??DataTable3_4
   \   000000E8   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000EC   0x2801             CMP      R0,#+1
   \   000000EE   0xD101             BNE.N    ??_Paint_11
    185          	{
    186          		GUI_UC_SetEncodeNone();
   \   000000F0   0x.... 0x....      BL       GUI_UC_SetEncodeNone
    187          	}
    188            if(pObj->BmpFileName != 0)
   \                     ??_Paint_11: (+1)
   \   000000F4   0x6D20             LDR      R0,[R4, #+80]
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD002             BEQ.N    ??_Paint_12
    189            {
    190            	Pic_Read(pObj->BmpFileName,bmp_public_buf);
                   	^
Warning[Pe223]: function "Pic_Read" declared implicitly
   \   000000FA   0x....             LDR.N    R1,??DataTable3_5
   \   000000FC   0x.... 0x....      BL       Pic_Read
    191          	}
    192          	if(pObj->gcode_path != 0)
   \                     ??_Paint_12: (+1)
   \   00000100   0x6D60             LDR      R0,[R4, #+84]
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD003             BEQ.N    ??_Paint_13
    193          	{
    194          		//Pic_Read(pObj->BmpFileName,bmp_public_buf);
    195          		drawicon_preview(pObj->gcode_path,100,100);
   \   00000106   0x2264             MOVS     R2,#+100
   \   00000108   0x4611             MOV      R1,R2
   \   0000010A   0x.... 0x....      BL       drawicon_preview
    196          	}
    197            	GUI_DRAW__Draw(pObj->ahDrawObj[Index], 0, 0);
   \                     ??_Paint_13: (+1)
   \   0000010E   0x2200             MOVS     R2,#+0
   \   00000110   0x4611             MOV      R1,R2
   \   00000112   0xEB04 0x0049      ADD      R0,R4,R9, LSL #+1
   \   00000116   0xF9B0 0x004A      LDRSH    R0,[R0, #+74]
   \   0000011A   0x.... 0x....      BL       GUI_DRAW__Draw
    198           
    199          /* Draw the actual button (background and text) */  
    200            {
    201              GUI_RECT r;
    202              r = rInside;
   \   0000011E   0xE9DD 0x0102      LDRD     R0,R1,[SP, #+8]
   \   00000122   0xE9CD 0x0104      STRD     R0,R1,[SP, #+16]
    203          	if(gCfgItems.button_3d_effect_flag == 1)
   \   00000126   0xF897 0x00EC      LDRB     R0,[R7, #+236]
   \   0000012A   0x2801             CMP      R0,#+1
   \   0000012C   0xD106             BNE.N    ??_Paint_14
    204          	{
    205          	    #if BUTTON_USE_3D
    206          	      if (PressedState) {
   \   0000012E   0x2D00             CMP      R5,#+0
   \   00000130   0xD004             BEQ.N    ??_Paint_14
    207          	        GUI_MoveRect(&r, BUTTON_3D_MOVE_X,BUTTON_3D_MOVE_Y);
   \   00000132   0x2201             MOVS     R2,#+1
   \   00000134   0x4611             MOV      R1,R2
   \   00000136   0xA804             ADD      R0,SP,#+16
   \   00000138   0x.... 0x....      BL       GUI_MoveRect
    208          	      }
    209          	    #endif
    210          	}
    211              GUI_SetTextMode(GUI_TM_TRANS);
   \                     ??_Paint_14: (+1)
   \   0000013C   0x2002             MOVS     R0,#+2
   \   0000013E   0x.... 0x....      BL       GUI_SetTextMode
    212              GUI_DispStringInRect(s, &r, pObj->Props.Align);
   \   00000142   0xF9B4 0x2044      LDRSH    R2,[R4, #+68]
   \   00000146   0xA904             ADD      R1,SP,#+16
   \   00000148   0x4630             MOV      R0,R6
   \   0000014A   0x.... 0x....      BL       GUI_DispStringInRect
    213            }
    214            /* Draw focus */
    215            if (State & BUTTON_STATE_FOCUS) {
    216           //   LCD_SetColor(GUI_BLACK);
    217          //    GUI_DrawFocusRect(&rClient, 2);
    218            }
    219            WM_SetUserClipRect(NULL);
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0x.... 0x....      BL       WM_SetUserClipRect
    220          	
    221          	if(disp_in_file_dir == 1)
   \   00000154   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000158   0x2801             CMP      R0,#+1
   \   0000015A   0xD101             BNE.N    ??_Paint_15
    222          	{
    223          		GUI_UC_SetEncodeUTF8();
   \   0000015C   0x.... 0x....      BL       GUI_UC_SetEncodeUTF8
    224          	}
    225          }
   \                     ??_Paint_15: (+1)
   \   00000160   0xB007             ADD      SP,SP,#+28
   \   00000162   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    226          
    227          /*********************************************************************
    228          *
    229          *       _Delete
    230          *
    231          * Delete attached objects (if any)
    232          */

   \                                 In section .text, align 2, keep-with-next
    233          static void _Delete(BUTTON_Obj* pObj) {
   \                     _Delete: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    234            GUI_ALLOC_FreePtr(&pObj->hpText);
   \   00000004   0xF104 0x0048      ADD      R0,R4,#+72
   \   00000008   0x.... 0x....      BL       GUI_ALLOC_FreePtr
    235            GUI_ALLOC_FreePtr(&pObj->ahDrawObj[0]);
   \   0000000C   0xF104 0x004A      ADD      R0,R4,#+74
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_FreePtr
    236            GUI_ALLOC_FreePtr(&pObj->ahDrawObj[1]);
   \   00000014   0xF104 0x004C      ADD      R0,R4,#+76
   \   00000018   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001C   0x.... 0x....      B.W      GUI_ALLOC_FreePtr
    237          }
    238          
    239          /*********************************************************************
    240          *
    241          *       _ButtonPressed
    242          */

   \                                 In section .text, align 2, keep-with-next
    243          static void _ButtonPressed(BUTTON_Handle hObj, BUTTON_Obj* pObj) {
   \                     _ButtonPressed: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    244            WIDGET_OrState(hObj, BUTTON_STATE_PRESSED);
   \   00000006   0xF44F 0x7180      MOV      R1,#+256
   \   0000000A   0x.... 0x....      BL       WIDGET_OrState
    245            if (pObj->Widget.Win.Status & WM_SF_ISVIS) {
   \   0000000E   0x7F28             LDRB     R0,[R5, #+28]
   \   00000010   0x0780             LSLS     R0,R0,#+30
   \   00000012   0xD505             BPL.N    ??_ButtonPressed_0
    246              WM_NotifyParent(hObj, WM_NOTIFICATION_CLICKED);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000001C   0x.... 0x....      B.W      WM_NotifyParent
    247            }
    248          }
   \                     ??_ButtonPressed_0: (+1)
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    249          
    250          /*********************************************************************
    251          *
    252          *       _ButtonReleased
    253          */

   \                                 In section .text, align 2, keep-with-next
    254          static void _ButtonReleased(BUTTON_Handle hObj, BUTTON_Obj* pObj, int Notification) {
   \                     _ButtonReleased: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    255            WIDGET_AndState(hObj, BUTTON_STATE_PRESSED);
   \   00000008   0xF44F 0x7180      MOV      R1,#+256
   \   0000000C   0x.... 0x....      BL       WIDGET_AndState
    256            if (pObj->Widget.Win.Status & WM_SF_ISVIS) {
   \   00000010   0x7F28             LDRB     R0,[R5, #+28]
   \   00000012   0x0780             LSLS     R0,R0,#+30
   \   00000014   0xD503             BPL.N    ??_ButtonReleased_0
    257              WM_NotifyParent(hObj, Notification);
   \   00000016   0x4631             MOV      R1,R6
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       WM_NotifyParent
    258            }
    259            if (Notification == WM_NOTIFICATION_RELEASED) {
   \                     ??_ButtonReleased_0: (+1)
   \   0000001E   0x2E02             CMP      R6,#+2
   \   00000020   0xD105             BNE.N    ??_ButtonReleased_1
    260              GUI_DEBUG_LOG("BUTTON: Hit\n");
    261              GUI_StoreKey(pObj->Widget.Id);
   \   00000022   0xF9B5 0x0024      LDRSH    R0,[R5, #+36]
   \   00000026   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000002A   0x.... 0x....      B.W      GUI_StoreKey
    262            }
    263          }
   \                     ??_ButtonReleased_1: (+1)
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    264          
    265          /*********************************************************************
    266          *
    267          *       _OnTouch
    268          */

   \                                 In section .text, align 2, keep-with-next
    269          static void _OnTouch(BUTTON_Handle hObj, BUTTON_Obj* pObj, WM_MESSAGE*pMsg) {
   \                     _OnTouch: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    270            const GUI_PID_STATE* pState = (const GUI_PID_STATE*)pMsg->Data.p;
    271          #if BUTTON_REACT_ON_LEVEL
    272            if (!pMsg->Data.p) {  /* Mouse moved out */
    273              _ButtonReleased(hObj, pObj, WM_NOTIFICATION_MOVED_OUT);
    274            }
    275          #else
    276            if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
   \   00000002   0x6892             LDR      R2,[R2, #+8]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD016             BEQ.N    ??_OnTouch_0
    277              if (pState->Pressed) {
   \   00000008   0x8CCB             LDRH     R3,[R1, #+38]
   \   0000000A   0x7A12             LDRB     R2,[R2, #+8]
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD004             BEQ.N    ??_OnTouch_1
    278                if ((pObj->Widget.State & BUTTON_STATE_PRESSED) == 0){   
   \   00000010   0x05DA             LSLS     R2,R3,#+23
   \   00000012   0xD414             BMI.N    ??_OnTouch_2
    279                 _ButtonPressed(hObj, pObj);
   \   00000014   0xE8BD 0x4004      POP      {R2,LR}
   \   00000018   0x....             B.N      _ButtonPressed
    280                }
    281              } else {
    282                /* React only if button was pressed before ... avoid problems with moving / hiding windows above (such as dropdown) */
    283                if (pObj->Widget.State & BUTTON_STATE_PRESSED) {   
   \                     ??_OnTouch_1: (+1)
   \   0000001A   0x05DA             LSLS     R2,R3,#+23
   \   0000001C   0xD50F             BPL.N    ??_OnTouch_2
    284                  _ButtonReleased(hObj, pObj, WM_NOTIFICATION_RELEASED);
   \   0000001E   0x2202             MOVS     R2,#+2
   \   00000020   0x.... 0x....      BL       _ButtonReleased
    285          
    286          				if(gCfgItems.beeper_on)
   \   00000024   0x....             LDR.N    R0,??DataTable3_3
   \   00000026   0xF890 0x01B0      LDRB     R0,[R0, #+432]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD007             BEQ.N    ??_OnTouch_2
    287          					btn_beeper(30);
   \   0000002E   0x201E             MOVS     R0,#+30
   \   00000030   0xE8BD 0x4002      POP      {R1,LR}
   \   00000034   0x....             B.N      btn_beeper
    288                }
    289              }
    290            } else {
    291              _ButtonReleased(hObj, pObj, WM_NOTIFICATION_MOVED_OUT);
   \                     ??_OnTouch_0: (+1)
   \   00000036   0x2203             MOVS     R2,#+3
   \   00000038   0xE8BD 0x4008      POP      {R3,LR}
   \   0000003C   0x....             B.N      _ButtonReleased
    292            }
    293          
    294          #endif
    295          }
   \                     ??_OnTouch_2: (+1)
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return
    296          
    297          /*********************************************************************
    298          *
    299          *       _OnPidStateChange
    300          */
    301          #if BUTTON_REACT_ON_LEVEL
    302          static void _OnPidStateChange(BUTTON_Handle hObj, BUTTON_Obj * pObj, WM_MESSAGE * pMsg) {
    303            const WM_PID_STATE_CHANGED_INFO * pState = (const WM_PID_STATE_CHANGED_INFO *)pMsg->Data.p;
    304            if ((pState->StatePrev == 0) && (pState->State == 1)) {
    305              if ((pObj->Widget.State & BUTTON_STATE_PRESSED) == 0){   
    306                _ButtonPressed(hObj, pObj);
    307              }
    308            } else if ((pState->StatePrev == 1) && (pState->State == 0)) {
    309              if (pObj->Widget.State & BUTTON_STATE_PRESSED) {   
    310                _ButtonReleased(hObj, pObj, WM_NOTIFICATION_RELEASED);
    311              }
    312            }
    313          }
    314          #endif
    315          
    316          /*********************************************************************
    317          *
    318          *       BUTTON_Callback
    319          */

   \                                 In section .text, align 2, keep-with-next
    320          void BUTTON_Callback(WM_MESSAGE *pMsg) {
   \                     BUTTON_Callback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    321            BUTTON_Handle hObj = pMsg->hWin;
   \   00000004   0xF9B4 0x5004      LDRSH    R5,[R4, #+4]
    322            BUTTON_Obj* pObj = BUTTON_H2P(hObj);
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   0000000E   0x4606             MOV      R6,R0
    323            /* Let widget handle the standard messages */
    324            if (WIDGET_HandleActive(hObj, pMsg) == 0) {
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       WIDGET_HandleActive
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD01A             BEQ.N    ??BUTTON_Callback_0
    325              return;
    326            }
    327            switch (pMsg->MsgId) {
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x280B             CMP      R0,#+11
   \   00000020   0xD00F             BEQ.N    ??BUTTON_Callback_1
   \   00000022   0x280C             CMP      R0,#+12
   \   00000024   0xD002             BEQ.N    ??BUTTON_Callback_2
   \   00000026   0x280F             CMP      R0,#+15
   \   00000028   0xD006             BEQ.N    ??BUTTON_Callback_3
   \   0000002A   0xE00D             B.N      ??BUTTON_Callback_4
    328          #if BUTTON_REACT_ON_LEVEL
    329            case WM_PID_STATE_CHANGED:
    330              _OnPidStateChange(hObj, pObj, pMsg);
    331              return;      /* Message handled. Do not call WM_DefaultProc, because the window may have been destroyed */
    332          #endif
    333            case WM_TOUCH:
    334              _OnTouch(hObj, pObj, pMsg);
   \                     ??BUTTON_Callback_2: (+1)
   \   0000002C   0x4622             MOV      R2,R4
   \   0000002E   0x4631             MOV      R1,R6
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000036   0x....             B.N      _OnTouch
    335              return;      /* Message handled. Do not call WM_DefaultProc, because the window may have been destroyed */
    336            case WM_PAINT:
    337              GUI_DEBUG_LOG("BUTTON: _BUTTON_Callback(WM_PAINT)\n");
    338              _Paint(pObj, hObj);
   \                     ??BUTTON_Callback_3: (+1)
   \   00000038   0x4629             MOV      R1,R5
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000040   0x....             B.N      _Paint
    339              return;
    340            case WM_DELETE:
    341              GUI_DEBUG_LOG("BUTTON: _BUTTON_Callback(WM_DELETE)\n");
    342              _Delete(pObj);
   \                     ??BUTTON_Callback_1: (+1)
   \   00000042   0x4630             MOV      R0,R6
   \   00000044   0x.... 0x....      BL       _Delete
    343              break;       /* No return here ... WM_DefaultProc needs to be called */
    344            #if 0     /* TBD: Button should react to space & Enter */
    345            case WM_KEY:
    346              {
    347                int PressedCnt = ((WM_KEY_INFO*)(pMsg->Data.p))->PressedCnt;
    348                int Key = ((WM_KEY_INFO*)(pMsg->Data.p))->Key;
    349                if (PressedCnt > 0) {   /* Key pressed? */
    350                  switch (Key) {
    351                  case ' ':
    352                    _ButtonPressed(hObj, pObj);
    353                    return;
    354                  }
    355                } else {
    356                  switch (Key) {
    357                  case ' ':
    358                    _ButtonReleased(hObj, pObj, WM_NOTIFICATION_RELEASED);
    359                    return;
    360                  }
    361                }
    362              }
    363              break;
    364            #endif
    365            }
    366            WM_DefaultProc(pMsg);
   \                     ??BUTTON_Callback_4: (+1)
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000004E   0x.... 0x....      B.W      WM_DefaultProc
   \                     ??BUTTON_Callback_0: (+1)
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
    367          }
    368          
    369          /*********************************************************************
    370          *
    371          *       Exported routines:  Create
    372          *
    373          **********************************************************************
    374          */
    375          /*********************************************************************
    376          *
    377          *       BUTTON_CreateEx
    378          */

   \                                 In section .text, align 2, keep-with-next
    379          BUTTON_Handle BUTTON_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id) {
   \                     BUTTON_CreateEx: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    380            BUTTON_Handle hObj;
    381            GUI_USE_PARA(ExFlags);
    382            /* Create the window */
    383            WM_LOCK();
    384            hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, BUTTON_Callback,
    385                                          sizeof(BUTTON_Obj) - sizeof(WM_Obj));
   \   00000004   0x243C             MOVS     R4,#+60
   \   00000006   0x9403             STR      R4,[SP, #+12]
   \   00000008   0x....             LDR.N    R4,??DataTable3_6
   \   0000000A   0x9402             STR      R4,[SP, #+8]
   \   0000000C   0x9C09             LDR      R4,[SP, #+36]
   \   0000000E   0xB2A4             UXTH     R4,R4
   \   00000010   0x9401             STR      R4,[SP, #+4]
   \   00000012   0xF9BD 0x4020      LDRSH    R4,[SP, #+32]
   \   00000016   0x9400             STR      R4,[SP, #+0]
   \   00000018   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   0000001C   0x0004             MOVS     R4,R0
    386            if (hObj) {
   \   0000001E   0xD00C             BEQ.N    ??BUTTON_CreateEx_0
    387              BUTTON_Obj* pObj = BUTTON_H2P(hObj);
   \   00000020   0x.... 0x....      BL       GUI_ALLOC_h2p
   \   00000024   0x4605             MOV      R5,R0
    388              /* init widget specific variables */
    389              WIDGET__Init(&pObj->Widget, Id, WIDGET_STATE_FOCUSSABLE);
   \   00000026   0x2210             MOVS     R2,#+16
   \   00000028   0x990B             LDR      R1,[SP, #+44]
   \   0000002A   0x.... 0x....      BL       WIDGET__Init
    390              /* init member variables */
    391              BUTTON_INIT_ID(pObj);
    392              pObj->Props = BUTTON__DefaultProps;
   \   0000002E   0xF105 0x0028      ADD      R0,R5,#+40
   \   00000032   0x....             LDR.N    R1,??DataTable3_7
   \   00000034   0x2220             MOVS     R2,#+32
   \   00000036   0x.... 0x....      BL       __aeabi_memcpy4
    393            } else {
    394              GUI_DEBUG_ERROROUT_IF(hObj==0, "BUTTON_Create failed")
    395            }
    396            WM_UNLOCK();
    397            return hObj;
   \                     ??BUTTON_CreateEx_0: (+1)
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0xB005             ADD      SP,SP,#+20
   \   0000003E   0xBD30             POP      {R4,R5,PC}       ;; return
    398          }
    399          
    400          /*********************************************************************
    401          *
    402          *       Exported routines:  Various methods
    403          *
    404          **********************************************************************
    405          */
    406          
    407          /*********************************************************************
    408          *
    409          *       BUTTON_SetText
    410          */

   \                                 In section .text, align 2, keep-with-next
    411          void BUTTON_SetText(BUTTON_Handle hObj, const char* s) {
   \                     BUTTON_SetText: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    412            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00C             BEQ.N    ??BUTTON_SetText_0
    413              BUTTON_Obj* pObj;
    414              WM_LOCK();
    415              pObj = BUTTON_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    416              if (GUI__SetText(&pObj->hpText, s)) {
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x3048             ADDS     R0,R0,#+72
   \   00000012   0x.... 0x....      BL       GUI__SetText
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??BUTTON_SetText_0
    417                BUTTON_Invalidate(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000020   0x.... 0x....      B.W      WM_InvalidateWindow
    418              }
    419              WM_UNLOCK();
    420            }
    421          }
   \                     ??BUTTON_SetText_0: (+1)
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    422          
    423          /*********************************************************************
    424          *
    425          *       BUTTON_SetFont
    426          */

   \                                 In section .text, align 2, keep-with-next
    427          void BUTTON_SetFont(BUTTON_Handle hObj, const GUI_FONT GUI_UNI_PTR * pfont) {
   \                     BUTTON_SetFont: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    428            if (hObj) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??BUTTON_SetFont_0
    429              BUTTON_Obj* pObj;
    430              WM_LOCK();
    431              pObj = BUTTON_H2P(hObj);
   \   0000000A   0x.... 0x....      BL       GUI_ALLOC_h2p
    432              BUTTON_ASSERT_IS_VALID_PTR(pObj);
    433              pObj->Props.pFont = pfont;
   \   0000000E   0x6405             STR      R5,[R0, #+64]
    434              BUTTON_Invalidate(hObj);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000016   0x.... 0x....      B.W      WM_InvalidateWindow
    435              WM_UNLOCK();
    436            }
    437          }
   \                     ??BUTTON_SetFont_0: (+1)
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    438          
    439          /*********************************************************************
    440          *
    441          *       BUTTON_SetBkColor
    442          */

   \                                 In section .text, align 2, keep-with-next
    443          void BUTTON_SetBkColor(BUTTON_Handle hObj,unsigned int Index, GUI_COLOR Color) {
   \                     BUTTON_SetBkColor: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    444            if (hObj && (Index <= 2)) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00B             BEQ.N    ??BUTTON_SetBkColor_0
   \   0000000C   0x2D03             CMP      R5,#+3
   \   0000000E   0xD209             BCS.N    ??BUTTON_SetBkColor_0
    445              BUTTON_Obj* pObj;
    446              WM_LOCK();
    447              pObj = BUTTON_H2P(hObj);
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
    448              BUTTON_ASSERT_IS_VALID_PTR(pObj);
    449              pObj->Props.aBkColor[Index] = Color;
   \   00000014   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   00000018   0x6286             STR      R6,[R0, #+40]
    450              BUTTON_Invalidate(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000020   0x.... 0x....      B.W      WM_InvalidateWindow
    451              WM_UNLOCK();
    452            }
    453          }
   \                     ??BUTTON_SetBkColor_0: (+1)
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    454          
    455          /*********************************************************************
    456          *
    457          *       BUTTON_SetTextColor
    458          */

   \                                 In section .text, align 2, keep-with-next
    459          void BUTTON_SetTextColor(BUTTON_Handle hObj,unsigned int Index, GUI_COLOR Color) {
   \                     BUTTON_SetTextColor: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    460            if (hObj && (Index <= 2)) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD00B             BEQ.N    ??BUTTON_SetTextColor_0
   \   0000000C   0x2D03             CMP      R5,#+3
   \   0000000E   0xD209             BCS.N    ??BUTTON_SetTextColor_0
    461              BUTTON_Obj* pObj;
    462              WM_LOCK();
    463              pObj = BUTTON_H2P(hObj);
   \   00000010   0x.... 0x....      BL       GUI_ALLOC_h2p
    464              BUTTON_ASSERT_IS_VALID_PTR(pObj);
    465              pObj->Props.aTextColor[Index] = Color;
   \   00000014   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   00000018   0x6346             STR      R6,[R0, #+52]
    466              BUTTON_Invalidate(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000020   0x.... 0x....      B.W      WM_InvalidateWindow
    467              WM_UNLOCK();
    468            }
    469          }
   \                     ??BUTTON_SetTextColor_0: (+1)
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    470          
    471          /*********************************************************************
    472          *
    473          *       BUTTON_SetState
    474          */

   \                                 In section .text, align 2, keep-with-next
    475          void BUTTON_SetState(BUTTON_Handle hObj, int State) {
    476            WIDGET_SetState(hObj, State);
   \                     BUTTON_SetState: (+1)
   \   00000000   0x.... 0x....      B.W      WIDGET_SetState
    477          }
    478          
    479          /*********************************************************************
    480          *
    481          *       BUTTON_SetPressed
    482          */

   \                                 In section .text, align 2, keep-with-next
    483          void BUTTON_SetPressed(BUTTON_Handle hObj, int State) {
    484            if (State) {
   \                     BUTTON_SetPressed: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xF44F 0x7180      MOV      R1,#+256
   \   00000006   0xD001             BEQ.N    ??BUTTON_SetPressed_0
    485              WIDGET_OrState(hObj, BUTTON_STATE_PRESSED);
   \   00000008   0x.... 0x....      B.W      WIDGET_OrState
    486            } else {
    487              WIDGET_AndState(hObj, BUTTON_STATE_PRESSED);
   \                     ??BUTTON_SetPressed_0: (+1)
   \   0000000C   0x.... 0x....      B.W      WIDGET_AndState
    488            }
    489          }
    490          
    491          /*********************************************************************
    492          *
    493          *       BUTTON_SetFocussable
    494          */

   \                                 In section .text, align 2, keep-with-next
    495          void BUTTON_SetFocussable(BUTTON_Handle hObj, int State) {
    496            if (State) {
   \                     BUTTON_SetFocussable: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD002             BEQ.N    ??BUTTON_SetFocussable_0
    497              WIDGET_OrState(hObj, WIDGET_STATE_FOCUSSABLE);
   \   00000004   0x2110             MOVS     R1,#+16
   \   00000006   0x.... 0x....      B.W      WIDGET_OrState
    498            } else {
    499              WIDGET_AndState(hObj, WIDGET_STATE_FOCUSSABLE);
   \                     ??BUTTON_SetFocussable_0: (+1)
   \   0000000A   0x2110             MOVS     R1,#+16
   \   0000000C   0x.... 0x....      B.W      WIDGET_AndState
    500            }
    501          }
    502          
    503          
    504          
    505          /*
    506          void BUTTON_SetBmpFileName(BUTTON_Handle hObj, char *pFile)
    507          {
    508          	if (hObj && pFile) {
    509          	    BUTTON_Obj* pObj;
    510          	    WM_LOCK();
    511          	    pObj = BUTTON_H2P(hObj);
    512          	    BUTTON_ASSERT_IS_VALID_PTR(pObj);
    513          	    pObj->BmpFileName = pFile;
    514          	    BUTTON_Invalidate(hObj);
    515          	    WM_UNLOCK();
    516          	}
    517          }
    518          */

   \                                 In section .text, align 2, keep-with-next
    519          void BUTTON_SetBmpFileName(BUTTON_Handle hObj,char *pFile, char flag)
    520          {
   \                     BUTTON_SetBmpFileName: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    521          	if (hObj) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD009             BEQ.N    ??BUTTON_SetBmpFileName_0
    522          	    BUTTON_Obj* pObj;
    523          	    WM_LOCK();
    524          	    pObj = BUTTON_H2P(hObj);
   \   0000000C   0x.... 0x....      BL       GUI_ALLOC_h2p
    525          	    BUTTON_ASSERT_IS_VALID_PTR(pObj);
    526          			pObj->BmpFileName = pFile;
   \   00000010   0x6505             STR      R5,[R0, #+80]
    527          	    pObj->clear_flag= flag;
   \   00000012   0xF880 0x6058      STRB     R6,[R0, #+88]
    528          	    BUTTON_Invalidate(hObj);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000001C   0x.... 0x....      B.W      WM_InvalidateWindow
    529          	    WM_UNLOCK();
    530          	}
    531          }
   \                     ??BUTTON_SetBmpFileName_0: (+1)
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    532          

   \                                 In section .text, align 2, keep-with-next
    533          void BUTTON_SetBmpFileNamePath(BUTTON_Handle hObj,char *pFile,char *g_path, char flag)
    534          {
   \                     BUTTON_SetBmpFileNamePath: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
    535          	if (hObj) {
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD00A             BEQ.N    ??BUTTON_SetBmpFileNamePath_0
    536          	    BUTTON_Obj* pObj;
    537          	    WM_LOCK();
    538          	    pObj = BUTTON_H2P(hObj);
   \   0000000E   0x.... 0x....      BL       GUI_ALLOC_h2p
    539          	    BUTTON_ASSERT_IS_VALID_PTR(pObj);
    540          			pObj->BmpFileName = pFile;
   \   00000012   0x6505             STR      R5,[R0, #+80]
    541          			pObj->gcode_path = g_path;
   \   00000014   0x3050             ADDS     R0,R0,#+80
   \   00000016   0x6046             STR      R6,[R0, #+4]
    542          	    pObj->clear_flag= flag;
   \   00000018   0x7207             STRB     R7,[R0, #+8]
    543          	    BUTTON_Invalidate(hObj);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000020   0x.... 0x....      B.W      WM_InvalidateWindow
    544          	    WM_UNLOCK();
    545          	}
    546          }
   \                     ??BUTTON_SetBmpFileNamePath_0: (+1)
   \   00000024   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     btn_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     btn_beep_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x42430288         DC32     0x42430288

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     disp_in_file_dir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     bmp_public_buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     BUTTON_Callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     BUTTON__DefaultProps
    547          
    548          
    549          #else                            /* Avoid problems with empty object modules */
    550            void BUTTON_C(void) {}
    551          #endif /* GUI_WINSUPPORT */
    552          
    553          
    554          
    555          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   BUTTON_Callback
        16   -> GUI_ALLOC_h2p
        16   -> WIDGET_HandleActive
         0   -> WM_DefaultProc
        16   -> _Delete
         0   -> _OnTouch
         0   -> _Paint
      32   BUTTON_CreateEx
        32   -> GUI_ALLOC_h2p
        32   -> WIDGET__Init
        32   -> WM_CreateWindowAsChild
        32   -> __aeabi_memcpy4
      16   BUTTON_SetBkColor
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   BUTTON_SetBmpFileName
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      24   BUTTON_SetBmpFileNamePath
        24   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
       0   BUTTON_SetFocussable
         0   -> WIDGET_AndState
         0   -> WIDGET_OrState
      16   BUTTON_SetFont
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
       0   BUTTON_SetPressed
         0   -> WIDGET_AndState
         0   -> WIDGET_OrState
       0   BUTTON_SetState
         0   -> WIDGET_SetState
      16   BUTTON_SetText
        16   -> GUI_ALLOC_h2p
        16   -> GUI__SetText
         0   -> WM_InvalidateWindow
      16   BUTTON_SetTextColor
        16   -> GUI_ALLOC_h2p
         0   -> WM_InvalidateWindow
      16   _ButtonPressed
        16   -> WIDGET_OrState
         0   -> WM_NotifyParent
      16   _ButtonReleased
         0   -> GUI_StoreKey
        16   -> WIDGET_AndState
        16   -> WM_NotifyParent
       8   _Delete
         0   -> GUI_ALLOC_FreePtr
         8   -> GUI_ALLOC_FreePtr
       8   _OnTouch
         0   -> _ButtonPressed
         0   -> _ButtonReleased
         8   -> _ButtonReleased
         0   -> btn_beeper
      56   _Paint
        56   -- Indirect call
        56   -> GUI_ALLOC_h2p
        56   -> GUI_Clear
        56   -> GUI_DRAW__Draw
        56   -> GUI_DispStringInRect
        56   -> GUI_DrawRect
        56   -> GUI_GetClientRect
        56   -> GUI_MoveRect
        56   -> GUI_SetFont
        56   -> GUI_SetTextMode
        56   -> GUI_UC_SetEncodeNone
        56   -> GUI_UC_SetEncodeUTF8
        56   -> GUI__ReduceRect
        56   -> LCD_SetBkColor
        56   -> LCD_SetColor
        56   -> Pic_Read
        56   -> WM_SetUserClipRect
        56   -> WM__IsEnabled
        56   -> drawicon_preview
       0   btn_beeper


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
      84  BUTTON_Callback
      64  BUTTON_CreateEx
      38  BUTTON_SetBkColor
      34  BUTTON_SetBmpFileName
      38  BUTTON_SetBmpFileNamePath
      16  BUTTON_SetFocussable
      28  BUTTON_SetFont
      16  BUTTON_SetPressed
       4  BUTTON_SetState
      38  BUTTON_SetText
      38  BUTTON_SetTextColor
      32  BUTTON__DefaultProps
      34  _ButtonPressed
      48  _ButtonReleased
      32  _Delete
      64  _OnTouch
     358  _Paint
      18  btn_beeper

 
  32 bytes in section .data
 984 bytes in section .text
 
 984 bytes of CODE memory
  32 bytes of DATA memory

Errors: none
Warnings: 3
