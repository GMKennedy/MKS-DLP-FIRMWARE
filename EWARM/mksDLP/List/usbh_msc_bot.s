///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM       18/Jul/2019  11:15:33
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_bot.c
//    Command line =  
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_bot.c
//        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
//        MKS_DLP_BOARD -D TFT35 -lC
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
//        --diag_suppress Pa050 -o
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
//        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
//        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Full.h" -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
//        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
//        -I
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
//        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 7.0\arm\CMSIS\Include\"
//    List file    =  
//        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\usbh_msc_bot.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        AAPCS BASE,INTERWORK,VFP
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        EXTERN USBH_BulkReceiveData
        EXTERN USBH_BulkSendData
        EXTERN USBH_ClrFeature
        EXTERN USBH_CtlReq
        EXTERN USBH_LL_GetLastXferSize
        EXTERN USBH_LL_GetToggle
        EXTERN USBH_LL_GetURBState
        EXTERN USBH_LL_SetToggle

        PUBLIC USBH_MSC_BOT_Init
        PUBLIC USBH_MSC_BOT_Process
        PUBLIC USBH_MSC_BOT_REQ_GetMaxLUN
        PUBLIC USBH_MSC_BOT_REQ_Reset
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI Resource D0:64, D1:64, D2:64, D3:64, D4:64, D5:64, D6:64, D7:64
          CFI Resource D8:64, D9:64, D10:64, D11:64, D12:64, D13:64, D14:64
          CFI Resource D15:64
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI D0 Undefined
          CFI D1 Undefined
          CFI D2 Undefined
          CFI D3 Undefined
          CFI D4 Undefined
          CFI D5 Undefined
          CFI D6 Undefined
          CFI D7 Undefined
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI D13 SameValue
          CFI D14 SameValue
          CFI D15 SameValue
          CFI EndCommon cfiCommon0
        
// E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_bot.c
//    1 /**
//    2   ******************************************************************************
//    3   * @file    usbh_msc_bot.c 
//    4   * @author  MCD Application Team
//    5   * @version V3.2.2
//    6   * @date    07-July-2015
//    7   * @brief   This file includes the BOT protocol related functions
//    8   ******************************************************************************
//    9   * @attention
//   10   *
//   11   * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
//   12   *
//   13   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
//   14   * You may not use this file except in compliance with the License.
//   15   * You may obtain a copy of the License at:
//   16   *
//   17   *        http://www.st.com/software_license_agreement_liberty_v2
//   18   *
//   19   * Unless required by applicable law or agreed to in writing, software 
//   20   * distributed under the License is distributed on an "AS IS" BASIS, 
//   21   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   22   * See the License for the specific language governing permissions and
//   23   * limitations under the License.
//   24   *
//   25   ******************************************************************************
//   26   */ 
//   27 
//   28 /* Includes ------------------------------------------------------------------*/
//   29 #include "usbh_msc_bot.h"
//   30 #include "usbh_msc.h"
//   31 
//   32 /** @addtogroup USBH_LIB
//   33 * @{
//   34 */
//   35 
//   36 /** @addtogroup USBH_CLASS
//   37 * @{
//   38 */
//   39 
//   40 /** @addtogroup USBH_MSC_CLASS
//   41 * @{
//   42 */
//   43 
//   44 /** @defgroup USBH_MSC_BOT 
//   45 * @brief    This file includes the mass storage related functions
//   46 * @{
//   47 */ 
//   48 
//   49 
//   50 /** @defgroup USBH_MSC_BOT_Private_TypesDefinitions
//   51 * @{
//   52 */ 
//   53 /**
//   54 * @}
//   55 */ 
//   56 
//   57 /** @defgroup USBH_MSC_BOT_Private_Defines
//   58 * @{
//   59 */ 
//   60 /**
//   61 * @}
//   62 */ 
//   63 
//   64 /** @defgroup USBH_MSC_BOT_Private_Macros
//   65 * @{
//   66 */ 
//   67 /**
//   68 * @}
//   69 */ 
//   70 
//   71 
//   72 /** @defgroup USBH_MSC_BOT_Private_Variables
//   73 * @{
//   74 */ 
//   75 
//   76 /**
//   77 * @}
//   78 */ 
//   79 
//   80 
//   81 /** @defgroup USBH_MSC_BOT_Private_FunctionPrototypes
//   82 * @{
//   83 */ 
//   84 static USBH_StatusTypeDef USBH_MSC_BOT_Abort(USBH_HandleTypeDef *phost, uint8_t lun, uint8_t dir);
//   85 static BOT_CSWStatusTypeDef USBH_MSC_DecodeCSW(USBH_HandleTypeDef *phost);
//   86 /**
//   87 * @}
//   88 */ 
//   89 
//   90 
//   91 /** @defgroup USBH_MSC_BOT_Exported_Variables
//   92 * @{
//   93 */ 
//   94 /**
//   95 * @}
//   96 */ 
//   97 
//   98 
//   99 /** @defgroup USBH_MSC_BOT_Private_Functions
//  100 * @{
//  101 */ 
//  102 
//  103 /**
//  104   * @brief  USBH_MSC_BOT_REQ_Reset 
//  105   *         The function the MSC BOT Reset request.
//  106   * @param  phost: Host handle
//  107   * @retval USBH Status
//  108   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function USBH_MSC_BOT_REQ_Reset
        THUMB
//  109 USBH_StatusTypeDef USBH_MSC_BOT_REQ_Reset(USBH_HandleTypeDef *phost)
//  110 {
//  111   
//  112   phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_TYPE_CLASS | \ 
//  113                               USB_REQ_RECIPIENT_INTERFACE;
USBH_MSC_BOT_REQ_Reset:
        MOVS     R1,#+33
        STRB     R1,[R0, #+16]
//  114   
//  115   phost->Control.setup.b.bRequest = USB_REQ_BOT_RESET;
        MOVS     R1,#+255
        STRB     R1,[R0, #+17]
//  116   phost->Control.setup.b.wValue.w = 0;
        MOVS     R1,#+0
        STRH     R1,[R0, #+18]
//  117   phost->Control.setup.b.wIndex.w = 0;
        STRH     R1,[R0, #+20]
//  118   phost->Control.setup.b.wLength.w = 0;           
        STRH     R1,[R0, #+22]
//  119   
//  120   return USBH_CtlReq(phost, 0 , 0 );  
        MOV      R2,R1
          CFI FunCall USBH_CtlReq
        B.W      USBH_CtlReq
          CFI EndBlock cfiBlock0
//  121 }
//  122 
//  123 /**
//  124   * @brief  USBH_MSC_BOT_REQ_GetMaxLUN 
//  125   *         The function the MSC BOT GetMaxLUN request.
//  126   * @param  phost: Host handle
//  127   * @param  Maxlun: pointer to Maxlun variable
//  128   * @retval USBH Status
//  129   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function USBH_MSC_BOT_REQ_GetMaxLUN
        THUMB
//  130 USBH_StatusTypeDef USBH_MSC_BOT_REQ_GetMaxLUN(USBH_HandleTypeDef *phost, uint8_t *Maxlun)
//  131 {
//  132   phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS | \ 
//  133                               USB_REQ_RECIPIENT_INTERFACE;
USBH_MSC_BOT_REQ_GetMaxLUN:
        MOVS     R2,#+161
        STRB     R2,[R0, #+16]
//  134   
//  135   phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
        MOVS     R2,#+254
        STRB     R2,[R0, #+17]
//  136   phost->Control.setup.b.wValue.w = 0;
        MOVS     R2,#+0
        STRH     R2,[R0, #+18]
//  137   phost->Control.setup.b.wIndex.w = 0;
        STRH     R2,[R0, #+20]
//  138   phost->Control.setup.b.wLength.w = 1;           
        MOVS     R2,#+1
        STRH     R2,[R0, #+22]
//  139   
//  140   return USBH_CtlReq(phost, Maxlun , 1 ); 
          CFI FunCall USBH_CtlReq
        B.W      USBH_CtlReq
          CFI EndBlock cfiBlock1
//  141 }
//  142 
//  143 
//  144 
//  145 /**
//  146   * @brief  USBH_MSC_BOT_Init 
//  147   *         The function Initializes the BOT protocol.
//  148   * @param  phost: Host handle
//  149   * @retval USBH Status
//  150   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function USBH_MSC_BOT_Init
          CFI NoCalls
        THUMB
//  151 USBH_StatusTypeDef USBH_MSC_BOT_Init(USBH_HandleTypeDef *phost)
//  152 {
//  153   
//  154   MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
USBH_MSC_BOT_Init:
        LDR      R0,[R0, #+884]
        LDR      R0,[R0, #+28]
//  155   
//  156   MSC_Handle->hbot.cbw.field.Signature = BOT_CBW_SIGNATURE;
        ADD      R1,R0,#+80
        LDR.N    R2,??DataTable1  ;; 0x43425355
        STR      R2,[R1, #+4]
//  157   MSC_Handle->hbot.cbw.field.Tag = BOT_CBW_TAG;
        LDR.N    R2,??DataTable1_1  ;; 0x20304050
        STR      R2,[R1, #+8]
//  158   MSC_Handle->hbot.state = BOT_SEND_CBW;    
        MOVS     R2,#+1
        STRB     R2,[R0, #+80]
//  159   MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;   
        MOV      R0,R2
        STRB     R0,[R1, #+2]
//  160   
//  161   return USBH_OK;
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock2
//  162 }
//  163 
//  164 
//  165 
//  166 /**
//  167   * @brief  USBH_MSC_BOT_Process 
//  168   *         The function handle the BOT protocol.
//  169   * @param  phost: Host handle
//  170   * @param  lun: Logical Unit Number
//  171   * @retval USBH Status
//  172   */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function USBH_MSC_BOT_Process
        THUMB
//  173 USBH_StatusTypeDef USBH_MSC_BOT_Process (USBH_HandleTypeDef *phost, uint8_t lun)
//  174 {
USBH_MSC_BOT_Process:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R5,R0
//  175   USBH_StatusTypeDef   status = USBH_BUSY;
        MOVS     R4,#+1
//  176   USBH_StatusTypeDef   error  = USBH_BUSY;  
//  177   BOT_CSWStatusTypeDef CSW_Status = BOT_CSW_CMD_FAILED;
//  178   USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
//  179   MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
        LDR      R0,[R5, #+884]
        LDR      R6,[R0, #+28]
//  180   uint8_t toggle = 0;
//  181   
//  182   switch (MSC_Handle->hbot.state)
        LDRSB    R0,[R6, #+80]
        SUBS     R0,R0,#+1
        CMP      R0,#+10
        BHI.W    ??USBH_MSC_BOT_Process_1
        TBH      [PC, R0, LSL #+1]
        DATA
??USBH_MSC_BOT_Process_0:
        DC16     0xB,0x1C,0x44,0x51
        DC16     0x7D,0x8C,0xBF,0xCA
        DC16     0xE5,0xF5,0x116
        THUMB
//  183   {
//  184   case BOT_SEND_CBW:
//  185     MSC_Handle->hbot.cbw.field.LUN = lun;
??USBH_MSC_BOT_Process_2:
        ADD      R0,R6,#+80
        STRB     R1,[R0, #+17]
//  186     MSC_Handle->hbot.state = BOT_SEND_CBW_WAIT;    
        MOVS     R0,#+2
        STRB     R0,[R6, #+80]
//  187     USBH_BulkSendData (phost,
//  188                        MSC_Handle->hbot.cbw.data, 
//  189                        BOT_CBW_LENGTH, 
//  190                        MSC_Handle->OutPipe,
//  191                        1);
        MOV      R0,R4
        STR      R0,[SP, #+0]
        ADDS     R0,R6,#+4
        LDRB     R3,[R0, #+1]
        MOVS     R2,#+31
        ADD      R1,R6,#+84
        MOV      R0,R5
          CFI FunCall USBH_BulkSendData
        BL       USBH_BulkSendData
//  192     
//  193     break;
        B.N      ??USBH_MSC_BOT_Process_1
//  194     
//  195   case BOT_SEND_CBW_WAIT:
//  196     
//  197     URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe); 
??USBH_MSC_BOT_Process_3:
        ADDS     R0,R6,#+4
        LDRB     R1,[R0, #+1]
        MOV      R0,R5
          CFI FunCall USBH_LL_GetURBState
        BL       USBH_LL_GetURBState
//  198     
//  199     if(URB_Status == USBH_URB_DONE)
        CMP      R0,#+1
        BNE.N    ??USBH_MSC_BOT_Process_4
//  200     { 
//  201       if ( MSC_Handle->hbot.cbw.field.DataTransferLength != 0 )
        ADD      R0,R6,#+80
        LDR      R1,[R0, #+12]
        CMP      R1,#+0
        BEQ.N    ??USBH_MSC_BOT_Process_5
//  202       {
//  203         /* If there is Data Transfer Stage */
//  204         if (((MSC_Handle->hbot.cbw.field.Flags) & USB_REQ_DIR_MASK) == USB_D2H)
        LDRB     R0,[R0, #+16]
        LSLS     R0,R0,#+24
        BPL.N    ??USBH_MSC_BOT_Process_6
//  205         {
//  206           /* Data Direction is IN */
//  207           MSC_Handle->hbot.state = BOT_DATA_IN;
        MOVS     R0,#+3
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  208         }
//  209         else
//  210         {
//  211           /* Data Direction is OUT */
//  212           MSC_Handle->hbot.state = BOT_DATA_OUT;
??USBH_MSC_BOT_Process_6:
        MOVS     R0,#+5
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  213         } 
//  214       }
//  215       
//  216       else
//  217       {/* If there is NO Data Transfer Stage */
//  218         MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
??USBH_MSC_BOT_Process_5:
        MOVS     R0,#+7
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  219       }
//  220 #if (USBH_USE_OS == 1)
//  221     osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
//  222 #endif   
//  223     
//  224     }   
//  225     else if(URB_Status == USBH_URB_NOTREADY)
??USBH_MSC_BOT_Process_4:
        CMP      R0,#+2
        BNE.N    ??USBH_MSC_BOT_Process_7
//  226     {
//  227       /* Re-send CBW */
//  228       MSC_Handle->hbot.state = BOT_SEND_CBW;
        MOV      R0,R4
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  229 #if (USBH_USE_OS == 1)
//  230     osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
//  231 #endif       
//  232     }     
//  233     else if(URB_Status == USBH_URB_STALL)
??USBH_MSC_BOT_Process_7:
        CMP      R0,#+5
        BNE.W    ??USBH_MSC_BOT_Process_1
//  234     {
//  235       MSC_Handle->hbot.state  = BOT_ERROR_OUT;
        MOVS     R0,#+10
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  236 #if (USBH_USE_OS == 1)
//  237     osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
//  238 #endif       
//  239     }
//  240     break;
//  241     
//  242   case BOT_DATA_IN:   
//  243     /* Send first packet */        
//  244     USBH_BulkReceiveData (phost,
//  245                           MSC_Handle->hbot.pbuf, 
//  246                           MSC_Handle->InEpSize , 
//  247                           MSC_Handle->InPipe);
??USBH_MSC_BOT_Process_8:
        LDRB     R3,[R6, #+4]
        ADDS     R0,R6,#+4
        LDRH     R2,[R0, #+6]
        ADD      R0,R6,#+80
        LDR      R1,[R0, #+60]
        MOV      R0,R5
          CFI FunCall USBH_BulkReceiveData
        BL       USBH_BulkReceiveData
//  248     
//  249     MSC_Handle->hbot.state  = BOT_DATA_IN_WAIT;
        MOVS     R0,#+4
        STRB     R0,[R6, #+80]
//  250     
//  251     break;   
        B.N      ??USBH_MSC_BOT_Process_1
//  252     
//  253   case BOT_DATA_IN_WAIT:  
//  254     
//  255     URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe); 
??USBH_MSC_BOT_Process_9:
        LDRB     R1,[R6, #+4]
        MOV      R0,R5
          CFI FunCall USBH_LL_GetURBState
        BL       USBH_LL_GetURBState
//  256     
//  257     if(URB_Status == USBH_URB_DONE) 
        CMP      R0,#+1
        BNE.N    ??USBH_MSC_BOT_Process_10
//  258     {
//  259       /* Adjust Data pointer and data length */
//  260       if(MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->InEpSize)
        ADDS     R7,R6,#+4
        LDRH     R1,[R7, #+6]
        ADD      R0,R6,#+80
        LDR      R2,[R0, #+12]
        CMP      R1,R2
        BCS.N    ??USBH_MSC_BOT_Process_11
//  261       {
//  262           MSC_Handle->hbot.pbuf += MSC_Handle->InEpSize;
        LDR      R2,[R0, #+60]
        ADDS     R1,R1,R2
        STR      R1,[R0, #+60]
//  263           MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->InEpSize;  
        LDR      R1,[R0, #+12]
        LDRH     R2,[R7, #+6]
        SUBS     R1,R1,R2
        STR      R1,[R0, #+12]
        B.N      ??USBH_MSC_BOT_Process_12
//  264       }
//  265       else
//  266       {
//  267         MSC_Handle->hbot.cbw.field.DataTransferLength = 0;
??USBH_MSC_BOT_Process_11:
        MOVS     R1,#+0
        STR      R1,[R0, #+12]
//  268       }
//  269         
//  270       /* More Data To be Received */
//  271       if(MSC_Handle->hbot.cbw.field.DataTransferLength > 0)
??USBH_MSC_BOT_Process_12:
        LDR      R1,[R0, #+12]
        CMP      R1,#+0
        BEQ.N    ??USBH_MSC_BOT_Process_13
//  272       {
//  273         /* Send next packet */        
//  274         USBH_BulkReceiveData (phost,
//  275                               MSC_Handle->hbot.pbuf, 
//  276                               MSC_Handle->InEpSize , 
//  277                               MSC_Handle->InPipe);
        LDRB     R3,[R6, #+4]
        LDRH     R2,[R7, #+6]
        LDR      R1,[R0, #+60]
        MOV      R0,R5
          CFI FunCall USBH_BulkReceiveData
        BL       USBH_BulkReceiveData
        B.N      ??USBH_MSC_BOT_Process_1
//  278         
//  279       }
//  280       else
//  281       {
//  282         /* If value was 0, and successful transfer, then change the state */
//  283         MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
??USBH_MSC_BOT_Process_13:
        MOVS     R0,#+7
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  284 #if (USBH_USE_OS == 1)
//  285         osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
//  286 #endif 
//  287       }
//  288     }
//  289     else if(URB_Status == USBH_URB_STALL)
??USBH_MSC_BOT_Process_10:
        CMP      R0,#+5
        BNE.W    ??USBH_MSC_BOT_Process_1
//  290     {
//  291       /* This is Data IN Stage STALL Condition */
//  292       MSC_Handle->hbot.state  = BOT_ERROR_IN;
        MOVS     R0,#+9
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  293       
//  294       /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
//  295       6.7.2 Host expects to receive data from the device
//  296       3. On a STALL condition receiving data, then:
//  297       The host shall accept the data received.
//  298       The host shall clear the Bulk-In pipe.
//  299       4. The host shall attempt to receive a CSW.*/
//  300       
//  301 #if (USBH_USE_OS == 1)
//  302     osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
//  303 #endif       
//  304     }     
//  305     break;  
//  306     
//  307   case BOT_DATA_OUT:
//  308     
//  309     USBH_BulkSendData (phost,
//  310                        MSC_Handle->hbot.pbuf, 
//  311                        MSC_Handle->OutEpSize , 
//  312                        MSC_Handle->OutPipe,
//  313                        1);
??USBH_MSC_BOT_Process_14:
        ADDS     R7,R6,#+4
        MOV      R0,R4
        STR      R0,[SP, #+0]
        LDRB     R3,[R7, #+1]
        LDRH     R2,[R7, #+4]
        ADD      R0,R6,#+80
        LDR      R1,[R0, #+60]
        MOV      R0,R5
          CFI FunCall USBH_BulkSendData
        BL       USBH_BulkSendData
//  314     
//  315     
//  316     MSC_Handle->hbot.state  = BOT_DATA_OUT_WAIT;
        MOVS     R0,#+6
        STRB     R0,[R6, #+80]
//  317     break;
        B.N      ??USBH_MSC_BOT_Process_1
//  318     
//  319   case BOT_DATA_OUT_WAIT:
//  320     URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->OutPipe);     
??USBH_MSC_BOT_Process_15:
        ADDS     R7,R6,#+4
        LDRB     R1,[R7, #+1]
        MOV      R0,R5
          CFI FunCall USBH_LL_GetURBState
        BL       USBH_LL_GetURBState
//  321     
//  322     if(URB_Status == USBH_URB_DONE)
        CMP      R0,#+1
        BNE.N    ??USBH_MSC_BOT_Process_16
//  323     {
//  324       /* Adjust Data pointer and data length */
//  325       if(MSC_Handle->hbot.cbw.field.DataTransferLength > MSC_Handle->OutEpSize)
        LDRH     R1,[R7, #+4]
        ADD      R0,R6,#+80
        LDR      R2,[R0, #+12]
        CMP      R1,R2
        BCS.N    ??USBH_MSC_BOT_Process_17
//  326       {
//  327           MSC_Handle->hbot.pbuf += MSC_Handle->OutEpSize;
        LDR      R2,[R0, #+60]
        ADDS     R1,R1,R2
        STR      R1,[R0, #+60]
//  328           MSC_Handle->hbot.cbw.field.DataTransferLength -= MSC_Handle->OutEpSize; 
        LDR      R1,[R0, #+12]
        LDRH     R2,[R7, #+4]
        SUBS     R1,R1,R2
        STR      R1,[R0, #+12]
        B.N      ??USBH_MSC_BOT_Process_18
//  329       }
//  330       else
//  331       {
//  332         MSC_Handle->hbot.cbw.field.DataTransferLength = 0;
??USBH_MSC_BOT_Process_17:
        MOVS     R1,#+0
        STR      R1,[R0, #+12]
//  333       } 
//  334       
//  335       /* More Data To be Sent */
//  336       if(MSC_Handle->hbot.cbw.field.DataTransferLength > 0)
??USBH_MSC_BOT_Process_18:
        LDR      R1,[R0, #+12]
        CMP      R1,#+0
        BEQ.N    ??USBH_MSC_BOT_Process_19
//  337       {
//  338         USBH_BulkSendData (phost,
//  339                            MSC_Handle->hbot.pbuf, 
//  340                            MSC_Handle->OutEpSize , 
//  341                            MSC_Handle->OutPipe,
//  342                            1);
        MOV      R1,R4
        STR      R1,[SP, #+0]
        LDRB     R3,[R7, #+1]
        LDRH     R2,[R7, #+4]
        LDR      R1,[R0, #+60]
        MOV      R0,R5
          CFI FunCall USBH_BulkSendData
        BL       USBH_BulkSendData
        B.N      ??USBH_MSC_BOT_Process_1
//  343       }
//  344       else
//  345       {
//  346         /* If value was 0, and successful transfer, then change the state */
//  347         MSC_Handle->hbot.state  = BOT_RECEIVE_CSW;
??USBH_MSC_BOT_Process_19:
        MOVS     R0,#+7
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  348       }  
//  349 #if (USBH_USE_OS == 1)
//  350     osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
//  351 #endif       
//  352     }
//  353     
//  354     else if(URB_Status == USBH_URB_NOTREADY)
??USBH_MSC_BOT_Process_16:
        CMP      R0,#+2
        BNE.N    ??USBH_MSC_BOT_Process_20
//  355     {
//  356       /* Resend same data */      
//  357       MSC_Handle->hbot.state  = BOT_DATA_OUT;
        MOVS     R0,#+5
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  358 #if (USBH_USE_OS == 1)
//  359     osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
//  360 #endif       
//  361     }
//  362     
//  363     else if(URB_Status == USBH_URB_STALL)
??USBH_MSC_BOT_Process_20:
        CMP      R0,#+5
        BNE.N    ??USBH_MSC_BOT_Process_1
//  364     {
//  365       MSC_Handle->hbot.state  = BOT_ERROR_OUT;
        MOVS     R0,#+10
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  366       
//  367       /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
//  368       6.7.3 Ho - Host expects to send data to the device
//  369       3. On a STALL condition sending data, then:
//  370       " The host shall clear the Bulk-Out pipe.
//  371       4. The host shall attempt to receive a CSW.
//  372       */      
//  373 #if (USBH_USE_OS == 1)
//  374       osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
//  375 #endif       
//  376     }
//  377     break;
//  378     
//  379   case BOT_RECEIVE_CSW:
//  380     
//  381     USBH_BulkReceiveData (phost,
//  382                           MSC_Handle->hbot.csw.data, 
//  383                           BOT_CSW_LENGTH , 
//  384                           MSC_Handle->InPipe);
??USBH_MSC_BOT_Process_21:
        LDRB     R3,[R6, #+4]
        MOVS     R2,#+13
        ADD      R1,R6,#+120
        MOV      R0,R5
          CFI FunCall USBH_BulkReceiveData
        BL       USBH_BulkReceiveData
//  385     
//  386     MSC_Handle->hbot.state  = BOT_RECEIVE_CSW_WAIT;
        MOVS     R0,#+8
        STRB     R0,[R6, #+80]
//  387     break;
        B.N      ??USBH_MSC_BOT_Process_1
//  388     
//  389   case BOT_RECEIVE_CSW_WAIT:
//  390     
//  391     URB_Status = USBH_LL_GetURBState(phost, MSC_Handle->InPipe); 
??USBH_MSC_BOT_Process_22:
        LDRB     R1,[R6, #+4]
        MOV      R0,R5
          CFI FunCall USBH_LL_GetURBState
        BL       USBH_LL_GetURBState
//  392     
//  393     /* Decode CSW */
//  394     if(URB_Status == USBH_URB_DONE)
        CMP      R0,#+1
        BNE.N    ??USBH_MSC_BOT_Process_23
//  395     {
//  396       MSC_Handle->hbot.state = BOT_SEND_CBW;    
        MOV      R0,R4
        STRB     R0,[R6, #+80]
//  397       MSC_Handle->hbot.cmd_state = BOT_CMD_SEND;        
        ADD      R1,R6,#+80
        STRB     R0,[R1, #+2]
//  398       CSW_Status = USBH_MSC_DecodeCSW(phost);
//  399       
//  400       if(CSW_Status == BOT_CSW_CMD_PASSED)
        MOV      R0,R5
          CFI FunCall USBH_MSC_DecodeCSW
        BL       USBH_MSC_DecodeCSW
        CMP      R0,#+0
        BNE.N    ??USBH_MSC_BOT_Process_24
//  401       {
//  402         status = USBH_OK;
        MOVS     R4,#+0
        B.N      ??USBH_MSC_BOT_Process_1
//  403       }
//  404       else
//  405       {
//  406         status = USBH_FAIL;
??USBH_MSC_BOT_Process_24:
        MOVS     R4,#+2
        B.N      ??USBH_MSC_BOT_Process_1
//  407       }
//  408 #if (USBH_USE_OS == 1)
//  409       osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
//  410 #endif       
//  411     }
//  412     else if(URB_Status == USBH_URB_STALL)     
??USBH_MSC_BOT_Process_23:
        CMP      R0,#+5
        BNE.N    ??USBH_MSC_BOT_Process_1
//  413     {
//  414       MSC_Handle->hbot.state  = BOT_ERROR_IN;
        MOVS     R0,#+9
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  415 #if (USBH_USE_OS == 1)
//  416       osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
//  417 #endif       
//  418     }
//  419     break;
//  420     
//  421   case BOT_ERROR_IN: 
//  422     error = USBH_MSC_BOT_Abort(phost, lun, BOT_DIR_IN);
??USBH_MSC_BOT_Process_25:
        MOVS     R2,#+0
        MOV      R0,R5
          CFI FunCall USBH_MSC_BOT_Abort
        BL       USBH_MSC_BOT_Abort
//  423     
//  424     if (error == USBH_OK)
        CMP      R0,#+0
        BNE.N    ??USBH_MSC_BOT_Process_26
//  425     {
//  426       MSC_Handle->hbot.state = BOT_RECEIVE_CSW;
        MOVS     R0,#+7
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  427     }
//  428     else if (error == USBH_UNRECOVERED_ERROR)
??USBH_MSC_BOT_Process_26:
        CMP      R0,#+4
        BNE.N    ??USBH_MSC_BOT_Process_1
//  429     {
//  430       /* This means that there is a STALL Error limit, Do Reset Recovery */
//  431       MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
        MOVS     R0,#+11
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  432     }
//  433     break;
//  434     
//  435   case BOT_ERROR_OUT: 
//  436     error = USBH_MSC_BOT_Abort(phost, lun, BOT_DIR_OUT);
??USBH_MSC_BOT_Process_27:
        MOV      R2,R4
        MOV      R0,R5
          CFI FunCall USBH_MSC_BOT_Abort
        BL       USBH_MSC_BOT_Abort
//  437     
//  438     if ( error == USBH_OK)
        CMP      R0,#+0
        BNE.N    ??USBH_MSC_BOT_Process_28
//  439     { 
//  440       
//  441       toggle = USBH_LL_GetToggle(phost, MSC_Handle->OutPipe); 
        ADDS     R7,R6,#+4
        LDRB     R1,[R7, #+1]
        MOV      R0,R5
          CFI FunCall USBH_LL_GetToggle
        BL       USBH_LL_GetToggle
//  442       USBH_LL_SetToggle(phost, MSC_Handle->OutPipe, 1- toggle);   
        RSB      R2,R0,#+1
        UXTB     R2,R2
        LDRB     R1,[R7, #+1]
        MOV      R0,R5
          CFI FunCall USBH_LL_SetToggle
        BL       USBH_LL_SetToggle
//  443       USBH_LL_SetToggle(phost, MSC_Handle->InPipe, 0);  
        MOVS     R2,#+0
        LDRB     R1,[R6, #+4]
        MOV      R0,R5
          CFI FunCall USBH_LL_SetToggle
        BL       USBH_LL_SetToggle
//  444       MSC_Handle->hbot.state = BOT_ERROR_IN;        
        MOVS     R0,#+9
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  445     }
//  446     else if (error == USBH_UNRECOVERED_ERROR)
??USBH_MSC_BOT_Process_28:
        CMP      R0,#+4
        BNE.N    ??USBH_MSC_BOT_Process_1
//  447     {
//  448       MSC_Handle->hbot.state = BOT_UNRECOVERED_ERROR;
        MOVS     R0,#+11
        STRB     R0,[R6, #+80]
        B.N      ??USBH_MSC_BOT_Process_1
//  449     }
//  450     break;
//  451     
//  452     
//  453   case BOT_UNRECOVERED_ERROR: 
//  454     status = USBH_MSC_BOT_REQ_Reset(phost);
??USBH_MSC_BOT_Process_29:
        MOV      R0,R5
          CFI FunCall USBH_MSC_BOT_REQ_Reset
        BL       USBH_MSC_BOT_REQ_Reset
        MOVS     R4,R0
//  455     if ( status == USBH_OK)
        BNE.N    ??USBH_MSC_BOT_Process_1
//  456     {
//  457       MSC_Handle->hbot.state = BOT_SEND_CBW; 
        MOVS     R0,#+1
        STRB     R0,[R6, #+80]
//  458     }
//  459     break;
//  460     
//  461   default:      
//  462     break;
//  463   }
//  464   return status;
??USBH_MSC_BOT_Process_1:
        MOV      R0,R4
        POP      {R1,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock3
//  465 }
//  466 
//  467 /**
//  468   * @brief  USBH_MSC_BOT_Abort 
//  469   *         The function handle the BOT Abort process.
//  470   * @param  phost: Host handle
//  471   * @param  lun: Logical Unit Number
//  472   * @param  dir: direction (0: out / 1 : in)
//  473   * @retval USBH Status
//  474   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function USBH_MSC_BOT_Abort
        THUMB
//  475 static USBH_StatusTypeDef USBH_MSC_BOT_Abort(USBH_HandleTypeDef *phost, uint8_t lun, uint8_t dir)
//  476 {
USBH_MSC_BOT_Abort:
        MOV      R3,R0
//  477   USBH_StatusTypeDef status = USBH_FAIL;
        MOVS     R0,#+2
//  478   MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
        LDR      R1,[R3, #+884]
        LDR      R1,[R1, #+28]
//  479   
//  480   switch (dir)
        CMP      R2,#+0
        BEQ.N    ??USBH_MSC_BOT_Abort_0
        CMP      R2,#+1
        BEQ.N    ??USBH_MSC_BOT_Abort_1
        BX       LR
//  481   {
//  482   case BOT_DIR_IN :
//  483     /* send ClrFeture on Bulk IN endpoint */
//  484     status = USBH_ClrFeature(phost, MSC_Handle->InEp);
??USBH_MSC_BOT_Abort_0:
        LDRB     R1,[R1, #+7]
        MOV      R0,R3
          CFI FunCall USBH_ClrFeature
        B.W      USBH_ClrFeature
//  485     
//  486     break;
//  487     
//  488   case BOT_DIR_OUT :
//  489     /*send ClrFeature on Bulk OUT endpoint */
//  490     status = USBH_ClrFeature(phost, MSC_Handle->OutEp);
??USBH_MSC_BOT_Abort_1:
        LDRB     R1,[R1, #+6]
        MOV      R0,R3
          CFI FunCall USBH_ClrFeature
        B.W      USBH_ClrFeature
          CFI EndBlock cfiBlock4
//  491     break;
//  492     
//  493   default:
//  494     break;
//  495   }
//  496   return status;
//  497 }
//  498 
//  499 /**
//  500   * @brief  USBH_MSC_BOT_DecodeCSW
//  501   *         This function decodes the CSW received by the device and updates the
//  502   *         same to upper layer.
//  503   * @param  phost: Host handle
//  504   * @retval USBH Status
//  505   * @notes
//  506   *     Refer to USB Mass-Storage Class : BOT (www.usb.org)
//  507   *    6.3.1 Valid CSW Conditions :
//  508   *     The host shall consider the CSW valid when:
//  509   *     1. dCSWSignature is equal to 53425355h
//  510   *     2. the CSW is 13 (Dh) bytes in length,
//  511   *     3. dCSWTag matches the dCBWTag from the corresponding CBW.
//  512   */
//  513 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function USBH_MSC_DecodeCSW
        THUMB
//  514 static BOT_CSWStatusTypeDef USBH_MSC_DecodeCSW(USBH_HandleTypeDef *phost)
//  515 {
USBH_MSC_DecodeCSW:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
//  516   MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
        LDR      R1,[R0, #+884]
        LDR      R4,[R1, #+28]
//  517   BOT_CSWStatusTypeDef status = BOT_CSW_CMD_FAILED;
        MOVS     R5,#+1
//  518   
//  519     /*Checking if the transfer length is different than 13*/    
//  520     if(USBH_LL_GetLastXferSize(phost, MSC_Handle->InPipe) != BOT_CSW_LENGTH)
        LDRB     R1,[R4, #+4]
          CFI FunCall USBH_LL_GetLastXferSize
        BL       USBH_LL_GetLastXferSize
        CMP      R0,#+13
        BEQ.N    ??USBH_MSC_DecodeCSW_0
//  521     {
//  522       /*(4) Hi > Dn (Host expects to receive data from the device,
//  523       Device intends to transfer no data)
//  524       (5) Hi > Di (Host expects to receive data from the device,
//  525       Device intends to send data to the host)
//  526       (9) Ho > Dn (Host expects to send data to the device,
//  527       Device intends to transfer no data)
//  528       (11) Ho > Do  (Host expects to send data to the device,
//  529       Device intends to receive data from the host)*/
//  530       
//  531       
//  532       status = BOT_CSW_PHASE_ERROR;
        MOVS     R5,#+2
        B.N      ??USBH_MSC_DecodeCSW_1
//  533     }
//  534     else
//  535     { /* CSW length is Correct */
//  536       
//  537       /* Check validity of the CSW Signature and CSWStatus */
//  538       if(MSC_Handle->hbot.csw.field.Signature == BOT_CSW_SIGNATURE)
??USBH_MSC_DecodeCSW_0:
        ADDS     R0,R4,#+4
        LDR      R1,[R0, #+116]
        LDR.N    R2,??DataTable1_2  ;; 0x53425355
        CMP      R1,R2
        BNE.N    ??USBH_MSC_DecodeCSW_2
//  539       {/* Check Condition 1. dCSWSignature is equal to 53425355h */
//  540         
//  541         if(MSC_Handle->hbot.csw.field.Tag == MSC_Handle->hbot.cbw.field.Tag)
        LDR      R1,[R0, #+120]
        LDR      R0,[R0, #+84]
        CMP      R1,R0
        BNE.N    ??USBH_MSC_DecodeCSW_1
//  542         {
//  543           /* Check Condition 3. dCSWTag matches the dCBWTag from the 
//  544           corresponding CBW */
//  545 
//  546           if(MSC_Handle->hbot.csw.field.Status == 0) 
        LDRB     R0,[R4, #+132]
        CMP      R0,#+0
        BNE.N    ??USBH_MSC_DecodeCSW_3
//  547           {
//  548             /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
//  549             
//  550             Hn Host expects no data transfers
//  551             Hi Host expects to receive data from the device
//  552             Ho Host expects to send data to the device
//  553             
//  554             Dn Device intends to transfer no data
//  555             Di Device intends to send data to the host
//  556             Do Device intends to receive data from the host
//  557             
//  558             Section 6.7 
//  559             (1) Hn = Dn (Host expects no data transfers,
//  560             Device intends to transfer no data)
//  561             (6) Hi = Di (Host expects to receive data from the device,
//  562             Device intends to send data to the host)
//  563             (12) Ho = Do (Host expects to send data to the device, 
//  564             Device intends to receive data from the host)
//  565             
//  566             */
//  567             
//  568             status = BOT_CSW_CMD_PASSED;
        MOVS     R5,#+0
        B.N      ??USBH_MSC_DecodeCSW_1
//  569           }
//  570           else if(MSC_Handle->hbot.csw.field.Status == 1)
??USBH_MSC_DecodeCSW_3:
        CMP      R0,#+1
        BEQ.N    ??USBH_MSC_DecodeCSW_1
//  571           {
//  572             status = BOT_CSW_CMD_FAILED;
//  573           }
//  574           
//  575           else if(MSC_Handle->hbot.csw.field.Status == 2)
        CMP      R0,#+2
        BNE.N    ??USBH_MSC_DecodeCSW_1
//  576           { 
//  577             /* Refer to USB Mass-Storage Class : BOT (www.usb.org) 
//  578             Section 6.7 
//  579             (2) Hn < Di ( Host expects no data transfers, 
//  580             Device intends to send data to the host)
//  581             (3) Hn < Do ( Host expects no data transfers, 
//  582             Device intends to receive data from the host)
//  583             (7) Hi < Di ( Host expects to receive data from the device, 
//  584             Device intends to send data to the host)
//  585             (8) Hi <> Do ( Host expects to receive data from the device, 
//  586             Device intends to receive data from the host)
//  587             (10) Ho <> Di (Host expects to send data to the device,
//  588             Di Device intends to send data to the host)
//  589             (13) Ho < Do (Host expects to send data to the device, 
//  590             Device intends to receive data from the host)
//  591             */
//  592             
//  593             status = BOT_CSW_PHASE_ERROR;
        MOVS     R5,#+2
        B.N      ??USBH_MSC_DecodeCSW_1
//  594           }
//  595         } /* CSW Tag Matching is Checked  */
//  596       } /* CSW Signature Correct Checking */
//  597       else
//  598       {
//  599         /* If the CSW Signature is not valid, We sall return the Phase Error to
//  600         Upper Layers for Reset Recovery */
//  601         
//  602         status = BOT_CSW_PHASE_ERROR;
??USBH_MSC_DecodeCSW_2:
        MOVS     R5,#+2
//  603       }
//  604     } /* CSW Length Check*/
//  605     
//  606   return status;
??USBH_MSC_DecodeCSW_1:
        MOV      R0,R5
        POP      {R1,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock5
//  607 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable1:
        DC32     0x43425355

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable1_1:
        DC32     0x20304050

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable1_2:
        DC32     0x53425355

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
//  608 
//  609 
//  610 /**
//  611 * @}
//  612 */ 
//  613 
//  614 /**
//  615 * @}
//  616 */ 
//  617 
//  618 /**
//  619 * @}
//  620 */
//  621 
//  622 /**
//  623 * @}
//  624 */ 
//  625 
//  626 /**
//  627 * @}
//  628 */
//  629 
//  630 /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
//  631 
//  632 
//  633 
// 
// 800 bytes in section .text
// 
// 800 bytes of CODE memory
//
//Errors: none
//Warnings: none
