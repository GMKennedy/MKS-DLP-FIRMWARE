###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:23
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_ll_sdmmc.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_ll_sdmmc.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\stm32f4xx_ll_sdmmc.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\stm32f4xx_ll_sdmmc.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_ll_sdmmc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_ll_sdmmc.c
      4            * @author  MCD Application Team
      5            * @version V1.5.2
      6            * @date    22-September-2016
      7            * @brief   SDMMC Low Layer HAL module driver.
      8            *    
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities of the SDMMC peripheral:
     11            *           + Initialization/de-initialization functions
     12            *           + I/O operation functions
     13            *           + Peripheral Control functions 
     14            *           + Peripheral State functions
     15            *         
     16            @verbatim
     17            ==============================================================================
     18                                 ##### SDMMC peripheral features #####
     19            ==============================================================================        
     20              [..] The SD/SDIO MMC card host interface (SDIO) provides an interface between the APB2
     21                   peripheral bus and MultiMedia cards (MMCs), SD memory cards, SDIO cards and CE-ATA
     22                   devices.
     23          
     24              [..] The SDIO features include the following:
     25                   (+) Full compliance with MultiMedia Card System Specification Version 4.2. Card support
     26                       for three different databus modes: 1-bit (default), 4-bit and 8-bit
     27                   (+) Full compatibility with previous versions of MultiMedia Cards (forward compatibility)
     28                   (+) Full compliance with SD Memory Card Specifications Version 2.0
     29                   (+) Full compliance with SD I/O Card Specification Version 2.0: card support for two
     30                       different data bus modes: 1-bit (default) and 4-bit
     31                   (+) Full support of the CE-ATA features (full compliance with CE-ATA digital protocol
     32                       Rev1.1)
     33                   (+) Data transfer up to 48 MHz for the 8 bit mode
     34                   (+) Data and command output enable signals to control external bidirectional drivers.
     35                           
     36             
     37                                     ##### How to use this driver #####
     38            ==============================================================================
     39              [..]
     40                This driver is a considered as a driver of service for external devices drivers 
     41                that interfaces with the SDIO peripheral.
     42                According to the device used (SD card/ MMC card / SDIO card ...), a set of APIs 
     43                is used in the device's driver to perform SDIO operations and functionalities.
     44             
     45                This driver is almost transparent for the final user, it is only used to implement other
     46                functionalities of the external device.
     47             
     48              [..]
     49                (+) The SDIO clock (SDIOCLK = 48 MHz) is coming from a specific output of PLL 
     50                    (PLL48CLK). Before start working with SDIO peripheral make sure that the
     51                    PLL is well configured.
     52                    The SDIO peripheral uses two clock signals:
     53                    (++) SDIO adapter clock (SDIOCLK = 48 MHz)
     54                    (++) APB2 bus clock (PCLK2)
     55                 
     56                    -@@- PCLK2 and SDIO_CK clock frequencies must respect the following condition:
     57                         Frequency(PCLK2) >= (3 / 8 x Frequency(SDIO_CK))
     58            
     59                (+) Enable/Disable peripheral clock using RCC peripheral macros related to SDIO
     60                    peripheral.
     61          
     62                (+) Enable the Power ON State using the SDIO_PowerState_ON(SDIOx) 
     63                    function and disable it using the function SDIO_PowerState_OFF(SDIOx).
     64                          
     65                (+) Enable/Disable the clock using the __SDIO_ENABLE()/__SDIO_DISABLE() macros.
     66            
     67                (+) Enable/Disable the peripheral interrupts using the macros __SDIO_ENABLE_IT(hsdio, IT) 
     68                    and __SDIO_DISABLE_IT(hsdio, IT) if you need to use interrupt mode. 
     69            
     70                (+) When using the DMA mode 
     71                    (++) Configure the DMA in the MSP layer of the external device
     72                    (++) Active the needed channel Request 
     73                    (++) Enable the DMA using __SDIO_DMA_ENABLE() macro or Disable it using the macro
     74                         __SDIO_DMA_DISABLE().
     75            
     76                (+) To control the CPSM (Command Path State Machine) and send 
     77                    commands to the card use the SDIO_SendCommand(SDIOx), 
     78                    SDIO_GetCommandResponse() and SDIO_GetResponse() functions. First, user has
     79                    to fill the command structure (pointer to SDIO_CmdInitTypeDef) according 
     80                    to the selected command to be sent.
     81                    The parameters that should be filled are:
     82                     (++) Command Argument
     83                     (++) Command Index
     84                     (++) Command Response type
     85                     (++) Command Wait
     86                     (++) CPSM Status (Enable or Disable).
     87            
     88                    -@@- To check if the command is well received, read the SDIO_CMDRESP
     89                        register using the SDIO_GetCommandResponse().
     90                        The SDIO responses registers (SDIO_RESP1 to SDIO_RESP2), use the
     91                        SDIO_GetResponse() function.
     92            
     93                (+) To control the DPSM (Data Path State Machine) and send/receive 
     94                     data to/from the card use the SDIO_DataConfig(), SDIO_GetDataCounter(), 
     95                    SDIO_ReadFIFO(), DIO_WriteFIFO() and SDIO_GetFIFOCount() functions.
     96            
     97              *** Read Operations ***
     98              =======================
     99              [..]
    100                (#) First, user has to fill the data structure (pointer to
    101                    SDIO_DataInitTypeDef) according to the selected data type to be received.
    102                    The parameters that should be filled are:
    103                     (++) Data Timeout
    104                     (++) Data Length
    105                     (++) Data Block size
    106                     (++) Data Transfer direction: should be from card (To SDIO)
    107                     (++) Data Transfer mode
    108                     (++) DPSM Status (Enable or Disable)
    109                                               
    110                (#) Configure the SDIO resources to receive the data from the card
    111                    according to selected transfer mode (Refer to Step 8, 9 and 10).
    112            
    113                (#) Send the selected Read command (refer to step 11).
    114                              
    115                (#) Use the SDIO flags/interrupts to check the transfer status.
    116            
    117              *** Write Operations ***
    118              ========================
    119              [..]
    120               (#) First, user has to fill the data structure (pointer to
    121                   SDIO_DataInitTypeDef) according to the selected data type to be received.
    122                   The parameters that should be filled are:
    123                    (++) Data Timeout
    124                    (++) Data Length
    125                    (++) Data Block size
    126                    (++) Data Transfer direction:  should be to card (To CARD)
    127                    (++) Data Transfer mode
    128                    (++) DPSM Status (Enable or Disable)
    129            
    130               (#) Configure the SDIO resources to send the data to the card according to 
    131                   selected transfer mode.
    132                               
    133               (#) Send the selected Write command.
    134                              
    135               (#) Use the SDIO flags/interrupts to check the transfer status.
    136            
    137            @endverbatim
    138            ******************************************************************************
    139            * @attention
    140            *
    141            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    142            *
    143            * Redistribution and use in source and binary forms, with or without modification,
    144            * are permitted provided that the following conditions are met:
    145            *   1. Redistributions of source code must retain the above copyright notice,
    146            *      this list of conditions and the following disclaimer.
    147            *   2. Redistributions in binary form must reproduce the above copyright notice,
    148            *      this list of conditions and the following disclaimer in the documentation
    149            *      and/or other materials provided with the distribution.
    150            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    151            *      may be used to endorse or promote products derived from this software
    152            *      without specific prior written permission.
    153            *
    154            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    155            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    156            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    157            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    158            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    159            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    160            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    161            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    162            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    163            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    164            *
    165            ******************************************************************************
    166            */ 
    167          
    168          /* Includes ------------------------------------------------------------------*/
    169          #include "stm32f4xx_hal.h"
    170          
    171          /** @addtogroup STM32F4xx_HAL_Driver
    172            * @{
    173            */
    174          
    175          /** @defgroup SDMMC_LL SDMMC Low Layer
    176            * @brief Low layer module for SD and MMC driver
    177            * @{
    178            */
    179          
    180          #if defined(HAL_SD_MODULE_ENABLED) || defined(HAL_MMC_MODULE_ENABLED)
    181          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
    182              defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
    183              defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || \
    184              defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
    185              defined(STM32F412Rx) || defined(STM32F412Cx)
    186          /* Private typedef -----------------------------------------------------------*/
    187          /* Private define ------------------------------------------------------------*/
    188          /* Private macro -------------------------------------------------------------*/
    189          /* Private variables ---------------------------------------------------------*/
    190          /* Private function prototypes -----------------------------------------------*/
    191          /* Private functions ---------------------------------------------------------*/
    192          
    193          /** @defgroup SDMMC_LL_Exported_Functions SDMMC_LL Exported Functions
    194            * @{
    195            */
    196          
    197          /** @defgroup HAL_SDMMC_LL_Group1 Initialization/de-initialization functions 
    198           *  @brief    Initialization and Configuration functions 
    199           *
    200          @verbatim    
    201           ===============================================================================
    202                        ##### Initialization/de-initialization functions #####
    203           ===============================================================================
    204              [..]  This section provides functions allowing to:
    205           
    206          @endverbatim
    207            * @{
    208            */
    209          
    210          /**
    211            * @brief  Initializes the SDIO according to the specified
    212            *         parameters in the SDIO_InitTypeDef and create the associated handle.
    213            * @param  SDIOx: Pointer to SDIO register base
    214            * @param  Init: SDIO initialization structure   
    215            * @retval HAL status
    216            */

   \                                 In section .text, align 2, keep-with-next
    217          HAL_StatusTypeDef SDIO_Init(SDIO_TypeDef *SDIOx, SDIO_InitTypeDef Init)
    218          {
   \                     SDIO_Init: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
    219            uint32_t tmpreg = 0U; 
    220          
    221            /* Check the parameters */
    222            assert_param(IS_SDIO_ALL_INSTANCE(SDIOx));
    223            assert_param(IS_SDIO_CLOCK_EDGE(Init.ClockEdge)); 
    224            assert_param(IS_SDIO_CLOCK_BYPASS(Init.ClockBypass));
    225            assert_param(IS_SDIO_CLOCK_POWER_SAVE(Init.ClockPowerSave));
    226            assert_param(IS_SDIO_BUS_WIDE(Init.BusWide));
    227            assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
    228            assert_param(IS_SDIO_CLKDIV(Init.ClockDiv));
    229            
    230            /* Set SDIO configuration parameters */
    231            tmpreg |= (Init.ClockEdge           |\
    232                       Init.ClockBypass         |\
    233                       Init.ClockPowerSave      |\
    234                       Init.BusWide             |\
    235                       Init.HardwareFlowControl |\
    236                       Init.ClockDiv
    237                       ); 
    238            
    239            /* Write to SDIO CLKCR */
    240            MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0x....             LDR.N    R2,??DataTable2  ;; 0xffff8100
   \   00000006   0x4011             ANDS     R1,R2,R1
   \   00000008   0x9A00             LDR      R2,[SP, #+0]
   \   0000000A   0x4311             ORRS     R1,R2,R1
   \   0000000C   0x9A01             LDR      R2,[SP, #+4]
   \   0000000E   0x4311             ORRS     R1,R2,R1
   \   00000010   0x461A             MOV      R2,R3
   \   00000012   0x4311             ORRS     R1,R2,R1
   \   00000014   0x9A03             LDR      R2,[SP, #+12]
   \   00000016   0x4311             ORRS     R1,R2,R1
   \   00000018   0x9A04             LDR      R2,[SP, #+16]
   \   0000001A   0x4311             ORRS     R1,R2,R1
   \   0000001C   0x9A05             LDR      R2,[SP, #+20]
   \   0000001E   0x4311             ORRS     R1,R2,R1
   \   00000020   0x6041             STR      R1,[R0, #+4]
    241          
    242            return HAL_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xB003             ADD      SP,SP,#+12
   \   00000026   0x4770             BX       LR               ;; return
    243          }
    244          
    245          /**
    246            * @}
    247            */
    248          
    249          /** @defgroup HAL_SDMMC_LL_Group2 I/O operation functions 
    250           *  @brief   Data transfers functions 
    251           *
    252          @verbatim   
    253           ===============================================================================
    254                                ##### I/O operation functions #####
    255           ===============================================================================  
    256              [..]
    257              This subsection provides a set of functions allowing to manage the SDIO data 
    258              transfers.
    259          
    260          @endverbatim
    261            * @{
    262            */
    263          
    264          /**
    265            * @brief  Read data (word) from Rx FIFO in blocking mode (polling) 
    266            * @param  SDIOx: Pointer to SDIO register base
    267            * @retval HAL status
    268            */

   \                                 In section .text, align 2, keep-with-next
    269          uint32_t SDIO_ReadFIFO(SDIO_TypeDef *SDIOx)
    270          {
    271            /* Read data from Rx FIFO */ 
    272            return (SDIOx->FIFO);
   \                     SDIO_ReadFIFO: (+1)
   \   00000000   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   00000004   0x4770             BX       LR               ;; return
    273          }
    274          
    275          /**
    276            * @brief  Write data (word) to Tx FIFO in blocking mode (polling) 
    277            * @param  SDIOx: Pointer to SDIO register base
    278            * @param  pWriteData: pointer to data to write
    279            * @retval HAL status
    280            */

   \                                 In section .text, align 2, keep-with-next
    281          HAL_StatusTypeDef SDIO_WriteFIFO(SDIO_TypeDef *SDIOx, uint32_t *pWriteData)
    282          { 
    283            /* Write data to FIFO */ 
    284            SDIOx->FIFO = *pWriteData;
   \                     SDIO_WriteFIFO: (+1)
   \   00000000   0x6809             LDR      R1,[R1, #+0]
   \   00000002   0xF8C0 0x1080      STR      R1,[R0, #+128]
    285          
    286            return HAL_OK;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4770             BX       LR               ;; return
    287          }
    288          
    289          /**
    290            * @}
    291            */
    292          
    293          /** @defgroup HAL_SDMMC_LL_Group3 Peripheral Control functions 
    294           *  @brief   management functions 
    295           *
    296          @verbatim   
    297           ===============================================================================
    298                                ##### Peripheral Control functions #####
    299           ===============================================================================  
    300              [..]
    301              This subsection provides a set of functions allowing to control the SDIO data 
    302              transfers.
    303          
    304          @endverbatim
    305            * @{
    306            */
    307          
    308          /**
    309            * @brief  Set SDIO Power state to ON. 
    310            * @param  SDIOx: Pointer to SDIO register base
    311            * @retval HAL status
    312            */

   \                                 In section .text, align 2, keep-with-next
    313          HAL_StatusTypeDef SDIO_PowerState_ON(SDIO_TypeDef *SDIOx)
    314          {  
    315            /* Set power state to ON */ 
    316            SDIOx->POWER = SDIO_POWER_PWRCTRL;
   \                     SDIO_PowerState_ON: (+1)
   \   00000000   0x2103             MOVS     R1,#+3
   \   00000002   0x6001             STR      R1,[R0, #+0]
    317            
    318            return HAL_OK; 
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x4770             BX       LR               ;; return
    319          }
    320          
    321          /**
    322            * @brief  Set SDIO Power state to OFF. 
    323            * @param  SDIOx: Pointer to SDIO register base
    324            * @retval HAL status
    325            */

   \                                 In section .text, align 2, keep-with-next
    326          HAL_StatusTypeDef SDIO_PowerState_OFF(SDIO_TypeDef *SDIOx)
    327          {
    328            /* Set power state to OFF */
    329            SDIOx->POWER = (uint32_t)0x00000000U;
   \                     SDIO_PowerState_OFF: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    330            
    331            return HAL_OK;
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x4770             BX       LR               ;; return
    332          }
    333          
    334          /**
    335            * @brief  Get SDIO Power state. 
    336            * @param  SDIOx: Pointer to SDIO register base
    337            * @retval Power status of the controller. The returned value can be one of the 
    338            *         following values:
    339            *            - 0x00: Power OFF
    340            *            - 0x02: Power UP
    341            *            - 0x03: Power ON 
    342            */

   \                                 In section .text, align 2, keep-with-next
    343          uint32_t SDIO_GetPowerState(SDIO_TypeDef *SDIOx)  
    344          {
    345            return (SDIOx->POWER & SDIO_POWER_PWRCTRL);
   \                     SDIO_GetPowerState: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000006   0x4770             BX       LR               ;; return
    346          }
    347          
    348          /**
    349            * @brief  Configure the SDIO command path according to the specified parameters in
    350            *         SDIO_CmdInitTypeDef structure and send the command 
    351            * @param  SDIOx: Pointer to SDIO register base
    352            * @param  SDIO_CmdInitStruct: pointer to a SDIO_CmdInitTypeDef structure that contains 
    353            *         the configuration information for the SDIO command
    354            * @retval HAL status
    355            */

   \                                 In section .text, align 2, keep-with-next
    356          HAL_StatusTypeDef SDIO_SendCommand(SDIO_TypeDef *SDIOx, SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
    357          {
   \                     SDIO_SendCommand: (+1)
   \   00000000   0xB410             PUSH     {R4}
    358            uint32_t tmpreg = 0U;
    359            
    360            /* Check the parameters */
    361            assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct->CmdIndex));
    362            assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->Response));
    363            assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->WaitForInterrupt));
    364            assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->CPSM));
    365          
    366            /* Set the SDIO Argument value */
    367            SDIOx->ARG = SDIO_CmdInitStruct->Argument;
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x6082             STR      R2,[R0, #+8]
    368          
    369            /* Set SDIO command parameters */
    370            tmpreg |= (uint32_t)(SDIO_CmdInitStruct->CmdIndex         |\
    371                                 SDIO_CmdInitStruct->Response         |\
    372                                 SDIO_CmdInitStruct->WaitForInterrupt |\
    373                                 SDIO_CmdInitStruct->CPSM);
    374            
    375            /* Write to SDIO CMD register */
    376            MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
   \   00000006   0x68C2             LDR      R2,[R0, #+12]
   \   00000008   0x0B12             LSRS     R2,R2,#+12
   \   0000000A   0x690B             LDR      R3,[R1, #+16]
   \   0000000C   0x684C             LDR      R4,[R1, #+4]
   \   0000000E   0x4323             ORRS     R3,R4,R3
   \   00000010   0x688C             LDR      R4,[R1, #+8]
   \   00000012   0x4323             ORRS     R3,R4,R3
   \   00000014   0x68C9             LDR      R1,[R1, #+12]
   \   00000016   0x4319             ORRS     R1,R1,R3
   \   00000018   0xEA51 0x3102      ORRS     R1,R1,R2, LSL #+12
   \   0000001C   0x60C1             STR      R1,[R0, #+12]
    377            
    378            return HAL_OK;  
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
    379          }
    380          
    381          /**
    382            * @brief  Return the command index of last command for which response received
    383            * @param  SDIOx: Pointer to SDIO register base
    384            * @retval Command index of the last command response received
    385            */

   \                                 In section .text, align 2, keep-with-next
    386          uint8_t SDIO_GetCommandResponse(SDIO_TypeDef *SDIOx)
    387          {
    388            return (uint8_t)(SDIOx->RESPCMD);
   \                     SDIO_GetCommandResponse: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x4770             BX       LR               ;; return
    389          }
    390          
    391          
    392          /**
    393            * @brief  Return the response received from the card for the last command
    394            * @param  SDIO_RESP: Specifies the SDIO response register. 
    395            *          This parameter can be one of the following values:
    396            *            @arg SDIO_RESP1: Response Register 1
    397            *            @arg SDIO_RESP2: Response Register 2
    398            *            @arg SDIO_RESP3: Response Register 3
    399            *            @arg SDIO_RESP4: Response Register 4  
    400            * @retval The Corresponding response register value
    401            */

   \                                 In section .text, align 2, keep-with-next
    402          uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
    403          {
   \                     SDIO_GetResponse: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    404            __IO uint32_t tmp = 0U;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x9100             STR      R1,[SP, #+0]
    405          
    406            /* Check the parameters */
    407            assert_param(IS_SDIO_RESP(SDIO_RESP));
    408          
    409            /* Get the response */
    410            tmp = SDIO_RESP_ADDR + SDIO_RESP;
   \   00000006   0x....             LDR.N    R1,??DataTable2_1  ;; 0x40012c14
   \   00000008   0x1808             ADDS     R0,R1,R0
   \   0000000A   0x9000             STR      R0,[SP, #+0]
    411            
    412            return (*(__IO uint32_t *) tmp);
   \   0000000C   0x9800             LDR      R0,[SP, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0x4770             BX       LR               ;; return
    413          }  
    414          
    415          /**
    416            * @brief  Configure the SDIO data path according to the specified 
    417            *         parameters in the SDIO_DataInitTypeDef.
    418            * @param  SDIOx: Pointer to SDIO register base  
    419            * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure 
    420            *         that contains the configuration information for the SDIO command.
    421            * @retval HAL status
    422            */

   \                                 In section .text, align 2, keep-with-next
    423          HAL_StatusTypeDef SDIO_DataConfig(SDIO_TypeDef *SDIOx, SDIO_DataInitTypeDef* SDIO_DataInitStruct)
    424          {
    425            uint32_t tmpreg = 0U;
    426            
    427            /* Check the parameters */
    428            assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct->DataLength));
    429            assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct->DataBlockSize));
    430            assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->TransferDir));
    431            assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->TransferMode));
    432            assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->DPSM));
    433          
    434            /* Set the SDIO Data Timeout value */
    435            SDIOx->DTIMER = SDIO_DataInitStruct->DataTimeOut;
   \                     SDIO_DataConfig: (+1)
   \   00000000   0x680A             LDR      R2,[R1, #+0]
   \   00000002   0x6242             STR      R2,[R0, #+36]
    436          
    437            /* Set the SDIO DataLength value */
    438            SDIOx->DLEN = SDIO_DataInitStruct->DataLength;
   \   00000004   0x684A             LDR      R2,[R1, #+4]
   \   00000006   0x6282             STR      R2,[R0, #+40]
    439          
    440            /* Set the SDIO data configuration parameters */
    441            tmpreg |= (uint32_t)(SDIO_DataInitStruct->DataBlockSize |\
    442                                 SDIO_DataInitStruct->TransferDir   |\
    443                                 SDIO_DataInitStruct->TransferMode  |\
    444                                 SDIO_DataInitStruct->DPSM);
    445            
    446            /* Write to SDIO DCTRL */
    447            MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
   \   00000008   0x6AC2             LDR      R2,[R0, #+44]
   \   0000000A   0xF022 0x02F7      BIC      R2,R2,#0xF7
   \   0000000E   0x688B             LDR      R3,[R1, #+8]
   \   00000010   0x431A             ORRS     R2,R3,R2
   \   00000012   0x68CB             LDR      R3,[R1, #+12]
   \   00000014   0x431A             ORRS     R2,R3,R2
   \   00000016   0x690B             LDR      R3,[R1, #+16]
   \   00000018   0x431A             ORRS     R2,R3,R2
   \   0000001A   0x6949             LDR      R1,[R1, #+20]
   \   0000001C   0x4311             ORRS     R1,R1,R2
   \   0000001E   0x62C1             STR      R1,[R0, #+44]
    448          
    449            return HAL_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4770             BX       LR               ;; return
    450          
    451          }
    452          
    453          /**
    454            * @brief  Returns number of remaining data bytes to be transferred.
    455            * @param  SDIOx: Pointer to SDIO register base
    456            * @retval Number of remaining data bytes to be transferred
    457            */

   \                                 In section .text, align 2, keep-with-next
    458          uint32_t SDIO_GetDataCounter(SDIO_TypeDef *SDIOx)
    459          {
    460            return (SDIOx->DCOUNT);
   \                     SDIO_GetDataCounter: (+1)
   \   00000000   0x6B00             LDR      R0,[R0, #+48]
   \   00000002   0x4770             BX       LR               ;; return
    461          }
    462          
    463          /**
    464            * @brief  Get the FIFO data
    465            * @param  SDIOx: Pointer to SDIO register base 
    466            * @retval Data received
    467            */

   \                                 In section .text, align 2, keep-with-next
    468          uint32_t SDIO_GetFIFOCount(SDIO_TypeDef *SDIOx)
    469          {
    470            return (SDIOx->FIFO);
   \                     SDIO_GetFIFOCount: (+1)
   \   00000000   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   00000004   0x4770             BX       LR               ;; return
    471          }
    472          
    473          
    474          /**
    475            * @brief  Sets one of the two options of inserting read wait interval.
    476            * @param  SDIO_ReadWaitMode: SD I/O Read Wait operation mode.
    477            *          This parameter can be:
    478            *            @arg SDIO_READ_WAIT_MODE_CLK: Read Wait control by stopping SDIOCLK
    479            *            @arg SDIO_READ_WAIT_MODE_DATA2: Read Wait control using SDIO_DATA2
    480            * @retval None
    481            */

   \                                 In section .text, align 2, keep-with-next
    482          HAL_StatusTypeDef SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)
    483          {
    484            /* Check the parameters */
    485            assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
    486            
    487            *(__IO uint32_t *)DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
   \                     SDIO_SetSDIOReadWaitMode: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable2_2  ;; 0x422585a8
   \   00000002   0x6008             STR      R0,[R1, #+0]
    488            
    489            return HAL_OK;  
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x4770             BX       LR               ;; return
    490          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0xFFFF8100         DC32     0xffff8100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40012C14         DC32     0x40012c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x422585A8         DC32     0x422585a8
    491          
    492          /**
    493            * @}
    494            */
    495          
    496          /**
    497            * @}
    498            */
    499          #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
    500                    STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx ||
    501                    STM32F412Rx || STM32F412Cx */
    502          #endif /* (HAL_SD_MODULE_ENABLED) || (HAL_MMC_MODULE_ENABLED) */
    503          /**
    504            * @}
    505            */
    506          
    507          /**
    508            * @}
    509            */
    510          
    511          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   SDIO_DataConfig
       0   SDIO_GetCommandResponse
       0   SDIO_GetDataCounter
       0   SDIO_GetFIFOCount
       0   SDIO_GetPowerState
       4   SDIO_GetResponse
      12   SDIO_Init
       0   SDIO_PowerState_OFF
       0   SDIO_PowerState_ON
       0   SDIO_ReadFIFO
       4   SDIO_SendCommand
       0   SDIO_SetSDIOReadWaitMode
       0   SDIO_WriteFIFO


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
      36  SDIO_DataConfig
       6  SDIO_GetCommandResponse
       4  SDIO_GetDataCounter
       6  SDIO_GetFIFOCount
       8  SDIO_GetPowerState
      20  SDIO_GetResponse
      40  SDIO_Init
       8  SDIO_PowerState_OFF
       8  SDIO_PowerState_ON
       6  SDIO_ReadFIFO
      36  SDIO_SendCommand
       8  SDIO_SetSDIOReadWaitMode
      10  SDIO_WriteFIFO

 
 208 bytes in section .text
 
 208 bytes of CODE memory

Errors: none
Warnings: none
