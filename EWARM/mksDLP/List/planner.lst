###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:56:59
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.cpp
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.cpp
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\planner.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\planner.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * planner.cpp
     25           *
     26           * Buffer movement commands and manage the acceleration profile plan
     27           *
     28           * Derived from Grbl
     29           * Copyright (c) 2009-2011 Simen Svale Skogsrud
     30           *
     31           * The ring buffer implementation gleaned from the wiring_serial library by David A. Mellis.
     32           *
     33           *
     34           * Reasoning behind the mathematics in this module (in the key of 'Mathematica'):
     35           *
     36           * s == speed, a == acceleration, t == time, d == distance
     37           *
     38           * Basic definitions:
     39           *   Speed[s_, a_, t_] := s + (a*t)
     40           *   Travel[s_, a_, t_] := Integrate[Speed[s, a, t], t]
     41           *
     42           * Distance to reach a specific speed with a constant acceleration:
     43           *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, d, t]
     44           *   d -> (m^2 - s^2)/(2 a) --> estimate_acceleration_distance()
     45           *
     46           * Speed after a given distance of travel with constant acceleration:
     47           *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, m, t]
     48           *   m -> Sqrt[2 a d + s^2]
     49           *
     50           * DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]
     51           *
     52           * When to start braking (di) to reach a specified destination speed (s2) after accelerating
     53           * from initial speed s1 without ever stopping at a plateau:
     54           *   Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]
     55           *   di -> (2 a d - s1^2 + s2^2)/(4 a) --> intersection_distance()
     56           *
     57           * IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
     58           *
     59           */
     60          #include "Marlin.h"

    #define MIN_SOFTWARE_ENDSTOPS mksCfg.min_software_endstops	/*--mks cfg--*/
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\Configuration.h",824  Warning[Pe047]: 
          incompatible redefinition of macro "MIN_SOFTWARE_ENDSTOPS" (declared
          at line 819)

    #define MAX_SOFTWARE_ENDSTOPS mksCfg.max_software_endstops	/*--mks cfg--*/
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\Configuration.h",834  Warning[Pe047]: 
          incompatible redefinition of macro "MAX_SOFTWARE_ENDSTOPS" (declared
          at line 829)

  #define UNUSED(x) ((void)(x))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Inc\mks_cfg.h",351  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_iwdg.h",80  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_PRESCALER" (declared at
          line 209 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_iwdg.h")

  #define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_iwdg.h",97  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_RELOAD" (declared at
          line 222 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_iwdg.h")

  #define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",272  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NORSRAM_BANK" (declared
          at line 834 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",277  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NAND_BANK" (declared at
          line 855 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",298  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MUX" (declared at line
          839 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",311  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MEMORY" (declared at
          line 842 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",336  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_BURSTMODE" (declared at
          line 894 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",347  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ASYNWAIT" (declared at
          line 915 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",358  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_POLARITY" (declared
          at line 897 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",369  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRAP_MODE" (declared at
          line 900 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",380  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_SIGNAL_ACTIVE"
          (declared at line 903 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",391  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_OPERATION"
          (declared at line 906 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",402  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAITE_SIGNAL" (declared
          at line 909 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",414  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_EXTENDED_MODE" (declared
          at line 912 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",426  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_BURST" (declared
          at line 920 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",435  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_SETUP_TIME"
          (declared at line 923 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_HOLD_TIME"
          (declared at line 925 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",451  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATASETUP_TIME"
          (declared at line 927 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",459  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TURNAROUND_TIME"
          (declared at line 929 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",467  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_CLK_DIV" (declared at
          line 934 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATA_LATENCY" (declared
          at line 918 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",487  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ACCESS_MODE" (declared
          at line 850 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",508  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_FEATURE" (declared
          at line 858 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",520  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECC_STATE" (declared at
          line 864 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",535  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECCPAGE_SIZE" (declared
          at line 867 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",548  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TCLR_TIME" (declared at
          line 874 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",556  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TAR_TIME" (declared at
          line 876 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",564  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_SETUP_TIME" (declared at
          line 878 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",572  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_TIME" (declared at
          line 880 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",580  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HOLD_TIME" (declared at
          line 882 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",588  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HIZ_TIME" (declared at
          line 884 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define FSMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",613  Warning[Pe047]: 
          incompatible redefinition of macro "FSMC_FLAG_FEMPT" (declared at
          line 530 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

    #define assert_param(expr) ((void)0)        
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\stm32f4xx_conf.h",149  Warning[Pe047]: 
          incompatible redefinition of macro "assert_param" (declared at line
          431 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\stm32f4x
          x_hal_conf.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial6
     61          
     62          #include "MarlinConfig.h"
     63          #include "planner.h"

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::refresh_e_factor(uint8_t)
   \                     _ZN7Planner16refresh_e_factorEh: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x4F0D             LDR.N    R7,??refresh_e_factor_0
   \   00000006   0xF937 0x0016      LDRSH    R0,[R7, R6, LSL #+1]
   \   0000000A   0x.... 0x....      BL       __aeabi_i2d
   \   0000000E   0x4A0C             LDR.N    R2,??refresh_e_factor_0+0x4  ;; 0x47ae147b
   \   00000010   0x4B0C             LDR.N    R3,??refresh_e_factor_0+0x8  ;; 0x3f847ae1
   \   00000012   0x.... 0x....      BL       __aeabi_dmul
   \   00000016   0x4604             MOV      R4,R0
   \   00000018   0x460D             MOV      R5,R1
   \   0000001A   0xEB07 0x0086      ADD      R0,R7,R6, LSL #+2
   \   0000001E   0x6840             LDR      R0,[R0, #+4]
   \   00000020   0x.... 0x....      BL       __aeabi_f2d
   \   00000024   0x4622             MOV      R2,R4
   \   00000026   0x462B             MOV      R3,R5
   \   00000028   0x.... 0x....      BL       __aeabi_dmul
   \   0000002C   0x.... 0x....      BL       __aeabi_d2f
   \   00000030   0x4905             LDR.N    R1,??refresh_e_factor_0+0xC
   \   00000032   0xEB01 0x0186      ADD      R1,R1,R6, LSL #+2
   \   00000036   0x6448             STR      R0,[R1, #+68]
   \   00000038   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \   0000003A   0xBF00             Nop      
   \                     ??refresh_e_factor_0:
   \   0000003C   0x........         DC32     _ZN7Planner15flow_percentageE
   \   00000040   0x47AE147B         DC32     0x47ae147b
   \   00000044   0x3F847AE1         DC32     0x3f847ae1
   \   00000048   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4
   \   __interwork __softfp uint8_t Planner::movesplanned()
   \                     _ZN7Planner12movesplannedEv: (+1)
   \   00000000   0x4803             LDR.N    R0,??movesplanned_0
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x7840             LDRB     R0,[R0, #+1]
   \   00000006   0x1A08             SUBS     R0,R1,R0
   \   00000008   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000000C   0x4770             BX       LR               ;; return
   \   0000000E   0xBF00             Nop      
   \                     ??movesplanned_0:
   \   00000010   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4
   \   __interwork __softfp bool Planner::blocks_queued()
   \                     _ZN7Planner13blocks_queuedEv: (+1)
   \   00000000   0x4804             LDR.N    R0,??blocks_queued_0
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x7840             LDRB     R0,[R0, #+1]
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xD001             BEQ.N    ??blocks_queued_1
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x4770             BX       LR
   \                     ??blocks_queued_1: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR               ;; return
   \   00000012   0xBF00             Nop      
   \                     ??blocks_queued_0:
   \   00000014   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 2

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.h",582  Warning[Pe815]: 
          type qualifier on return type is meaningless
   \   __interwork __softfp signed char const Planner::next_block_index(int8_t)
   \                     _ZN7Planner16next_block_indexEa: (+1)
   \   00000000   0x1C40             ADDS     R0,R0,#+1
   \   00000002   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.h",583  Warning[Pe815]: 
          type qualifier on return type is meaningless
   \   __interwork __softfp signed char const Planner::prev_block_index(int8_t)
   \                     _ZN7Planner16prev_block_indexEa: (+1)
   \   00000000   0x1E40             SUBS     R0,R0,#+1
   \   00000002   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __vfp float Planner::estimate_acceleration_distance(float const &, float const &, float const &)
   \                     _ZN7Planner30estimate_acceleration_distanceERKfS1_S1_: (+1)
   \   00000000   0xED92 0x0A00      VLDR     S0,[R2, #0]
   \   00000004   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000008   0xEEF1 0xFA10      FMSTAT   
   \   0000000C   0xD102             BNE.N    ??estimate_acceleration_distance_0
   \   0000000E   0xED9F 0x0A15      VLDR.W   S0,??estimate_acceleration_distance_1  ;; 0x0
   \   00000012   0x4770             BX       LR
   \                     ??estimate_acceleration_distance_0: (+1)
   \   00000014   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   0000001E   0xEEB0 0x1A60      VMOV.F32 S2,S1
   \   00000022   0xE001             B.N      ??estimate_acceleration_distance_2
   \                     ??estimate_acceleration_distance_3: (+1)
   \   00000024   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \                     ??estimate_acceleration_distance_2: (+1)
   \   00000028   0x07CB             LSLS     R3,R1,#+31
   \   0000002A   0xD501             BPL.N    ??estimate_acceleration_distance_4
   \   0000002C   0xEE21 0x1A00      VMUL.F32 S2,S2,S0
   \                     ??estimate_acceleration_distance_4: (+1)
   \   00000030   0x0849             LSRS     R1,R1,#+1
   \   00000032   0xD1F7             BNE.N    ??estimate_acceleration_distance_3
   \   00000034   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0xE001             B.N      ??estimate_acceleration_distance_5
   \                     ??estimate_acceleration_distance_6: (+1)
   \   0000003C   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \                     ??estimate_acceleration_distance_5: (+1)
   \   00000040   0x07C1             LSLS     R1,R0,#+31
   \   00000042   0xD501             BPL.N    ??estimate_acceleration_distance_7
   \   00000044   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \                     ??estimate_acceleration_distance_7: (+1)
   \   00000048   0x0840             LSRS     R0,R0,#+1
   \   0000004A   0xD1F7             BNE.N    ??estimate_acceleration_distance_6
   \   0000004C   0xEE31 0x0A60      VSUB.F32 S0,S2,S1
   \   00000050   0xEDD2 0x0A00      VLDR     S1,[R2, #0]
   \   00000054   0xEEB0 0x1A00      VMOV.F32 S2,#2.0
   \   00000058   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   0000005C   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000060   0x4770             BX       LR               ;; return
   \   00000062   0xBF00             Nop      
   \                     ??estimate_acceleration_distance_1:
   \   00000064   0x00000000         DC32     0x0

   \                                 In section .text, align 4
   \   __interwork __vfp float Planner::intersection_distance(float const &, float const &, float const &, float const &)
   \                     _ZN7Planner21intersection_distanceERKfS1_S1_S1_: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xED92 0x0A00      VLDR     S0,[R2, #0]
   \   00000006   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000000A   0xEEF1 0xFA10      FMSTAT   
   \   0000000E   0xD102             BNE.N    ??intersection_distance_0
   \   00000010   0xED9F 0x0A1A      VLDR.W   S0,??intersection_distance_1  ;; 0x0
   \   00000014   0xE02F             B.N      ??intersection_distance_2
   \                     ??intersection_distance_0: (+1)
   \   00000016   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   00000020   0xEEB0 0x1A60      VMOV.F32 S2,S1
   \   00000024   0xE001             B.N      ??intersection_distance_3
   \                     ??intersection_distance_4: (+1)
   \   00000026   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \                     ??intersection_distance_3: (+1)
   \   0000002A   0x07C4             LSLS     R4,R0,#+31
   \   0000002C   0xD501             BPL.N    ??intersection_distance_5
   \   0000002E   0xEE21 0x1A00      VMUL.F32 S2,S2,S0
   \                     ??intersection_distance_5: (+1)
   \   00000032   0x0840             LSRS     R0,R0,#+1
   \   00000034   0xD1F7             BNE.N    ??intersection_distance_4
   \   00000036   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0xE001             B.N      ??intersection_distance_6
   \                     ??intersection_distance_7: (+1)
   \   0000003E   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \                     ??intersection_distance_6: (+1)
   \   00000042   0x07C1             LSLS     R1,R0,#+31
   \   00000044   0xD501             BPL.N    ??intersection_distance_8
   \   00000046   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \                     ??intersection_distance_8: (+1)
   \   0000004A   0x0840             LSRS     R0,R0,#+1
   \   0000004C   0xD1F7             BNE.N    ??intersection_distance_7
   \   0000004E   0xED92 0x0A00      VLDR     S0,[R2, #0]
   \   00000052   0xEEF0 0x1A00      VMOV.F32 S3,#2.0
   \   00000056   0xEE60 0x1A21      VMUL.F32 S3,S0,S3
   \   0000005A   0xED93 0x2A00      VLDR     S4,[R3, #0]
   \   0000005E   0xEE61 0x1A82      VMUL.F32 S3,S3,S4
   \   00000062   0xEE31 0x1AC1      VSUB.F32 S2,S3,S2
   \   00000066   0xEE71 0x0A20      VADD.F32 S1,S2,S1
   \   0000006A   0xEEB1 0x1A00      VMOV.F32 S2,#4.0
   \   0000006E   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
   \   00000072   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \                     ??intersection_distance_2: (+1)
   \   00000076   0xBC10             POP      {R4}
   \   00000078   0x4770             BX       LR               ;; return
   \   0000007A   0xBF00             Nop      
   \                     ??intersection_distance_1:
   \   0000007C   0x00000000         DC32     0x0

   \                                 In section .text, align 2
   \   __interwork __vfp float Planner::max_allowable_speed(float const &, float const &, float const &)
   \                     _ZN7Planner19max_allowable_speedERKfS1_S1_: (+1)
   \   00000000   0xEDD1 0x0A00      VLDR     S1,[R1, #0]
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   0000000A   0xE001             B.N      ??max_allowable_speed_0
   \                     ??max_allowable_speed_1: (+1)
   \   0000000C   0xEE60 0x0AA0      VMUL.F32 S1,S1,S1
   \                     ??max_allowable_speed_0: (+1)
   \   00000010   0x07CB             LSLS     R3,R1,#+31
   \   00000012   0xD501             BPL.N    ??max_allowable_speed_2
   \   00000014   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \                     ??max_allowable_speed_2: (+1)
   \   00000018   0x0849             LSRS     R1,R1,#+1
   \   0000001A   0xD1F7             BNE.N    ??max_allowable_speed_1
   \   0000001C   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000020   0xEEB0 0x1A00      VMOV.F32 S2,#2.0
   \   00000024   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   00000028   0xED92 0x1A00      VLDR     S2,[R2, #0]
   \   0000002C   0xEE00 0x0AC1      VMLS.F32 S0,S1,S2
   \   00000030   0x.... 0x....      B.W      sqrtf
     64          #include "stepper.h"
     65          #include "temperature.h"

   \                                 In section .text, align 4
   \   __interwork __vfp float Temperature::degTargetHotend(uint8_t)
   \                     _ZN11Temperature15degTargetHotendEh: (+1)
   \   00000000   0x4802             LDR.N    R0,??degTargetHotend_0
   \   00000002   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000006   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000000A   0x4770             BX       LR               ;; return
   \                     ??degTargetHotend_0:
   \   0000000C   0x........         DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\temperature.h",397  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   __interwork __vfp void Temperature::setTargetHotend(float, uint8_t)
   \                     _ZN11Temperature15setTargetHotendEfh: (+1)
   \   00000000   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000004   0x4802             LDR.N    R0,??setTargetHotend_0
   \   00000006   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      B.W      _ZN11Temperature21start_watching_heaterEh
   \                     ??setTargetHotend_0:
   \   00000010   0x........         DC32     _ZN11Temperature18target_temperatureE
     66          #include "ultralcd.h"
     67          #include "language.h"
     68          #include "ubl.h"
     69          #include "gcode.h"

   \                                 In section .text, align 4
   \   __interwork __softfp bool GCodeParser::seen(char)
   \                     _ZN11GCodeParser4seenEc: (+1)
   \   00000000   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   00000004   0xB2C9             UXTB     R1,R1
   \   00000006   0x291A             CMP      R1,#+26
   \   00000008   0xD301             BCC.N    ??seen_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
   \                     ??seen_0: (+1)
   \   0000000E   0x10C8             ASRS     R0,R1,#+3
   \   00000010   0x4A0A             LDR.N    R2,??seen_1
   \   00000012   0x5C80             LDRB     R0,[R0, R2]
   \   00000014   0xF001 0x0207      AND      R2,R1,#0x7
   \   00000018   0x40D0             LSRS     R0,R0,R2
   \   0000001A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000001E   0xD00B             BEQ.N    ??seen_2
   \   00000020   0x4A07             LDR.N    R2,??seen_1+0x4
   \   00000022   0x5C89             LDRB     R1,[R1, R2]
   \   00000024   0x4A07             LDR.N    R2,??seen_1+0x8
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD004             BEQ.N    ??seen_3
   \   0000002A   0x4B07             LDR.N    R3,??seen_1+0xC
   \   0000002C   0x681B             LDR      R3,[R3, #+0]
   \   0000002E   0x18C9             ADDS     R1,R1,R3
   \   00000030   0x6011             STR      R1,[R2, #+0]
   \   00000032   0x4770             BX       LR
   \                     ??seen_3: (+1)
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x6011             STR      R1,[R2, #+0]
   \                     ??seen_2: (+1)
   \   00000038   0x4770             BX       LR               ;; return
   \   0000003A   0xBF00             Nop      
   \                     ??seen_1:
   \   0000003C   0x........         DC32     _ZN11GCodeParser8codebitsE
   \   00000040   0x........         DC32     _ZN11GCodeParser5paramE
   \   00000044   0x........         DC32     _ZN11GCodeParser9value_ptrE
   \   00000048   0x........         DC32     _ZN11GCodeParser11command_ptrE

   \                                 In section .text, align 4
   \   __interwork __vfp float GCodeParser::value_float()
   \                     _ZN11GCodeParser11value_floatEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4A17             LDR.N    R2,??value_float_0+0x4
   \   00000004   0x6810             LDR      R0,[R2, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD024             BEQ.N    ??value_float_1
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0xE000             B.N      ??value_float_2
   \                     ??value_float_3: (+1)
   \   0000000E   0x1C64             ADDS     R4,R4,#+1
   \                     ??value_float_2: (+1)
   \   00000010   0xF994 0x5000      LDRSB    R5,[R4, #+0]
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD001             BEQ.N    ??value_float_4
   \   00000018   0x2D20             CMP      R5,#+32
   \   0000001A   0xD109             BNE.N    ??value_float_5
   \                     ??value_float_4: (+1)
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x.... 0x....      BL       strtod
   \   00000022   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   00000026   0x.... 0x....      BL       __aeabi_d2f
   \   0000002A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}
   \                     ??value_float_5: (+1)
   \   00000030   0x2D45             CMP      R5,#+69
   \   00000032   0xD001             BEQ.N    ??value_float_6
   \   00000034   0x2D65             CMP      R5,#+101
   \   00000036   0xD1EA             BNE.N    ??value_float_3
   \                     ??value_float_6: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
   \   0000003C   0x4601             MOV      R1,R0
   \   0000003E   0x6810             LDR      R0,[R2, #+0]
   \   00000040   0x.... 0x....      BL       strtod
   \   00000044   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   00000048   0x.... 0x....      BL       __aeabi_d2f
   \   0000004C   0xEE00 0x0A10      VMOV     S0,R0
   \   00000050   0x7025             STRB     R5,[R4, #+0]
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}
   \                     ??value_float_1: (+1)
   \   00000054   0xED9F 0x0A01      VLDR.W   S0,??value_float_0  ;; 0x0
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   0000005A   0xBF00             Nop      
   \                     ??value_float_0:
   \   0000005C   0x00000000         DC32     0x0
   \   00000060   0x........         DC32     _ZN11GCodeParser9value_ptrE

    FORCE_INLINE static millis_t value_millis_from_seconds() { return value_float() * 1000UL; }
                                                                      ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\gcode.h",207  Warning[Pa093]: 
          implicit conversion from floating point to integer

   \                                 In section .text, align 2
   \   __interwork __vfp float GCodeParser::value_celsius()
   \                     _ZN11GCodeParser13value_celsiusEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv

   \                                 In section .text, align 2
   \   __interwork __vfp float GCodeParser::value_celsius_diff()
   \                     _ZN11GCodeParser18value_celsius_diffEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv
     70          
     71          
     72          
     73          #if ENABLED(MESH_BED_LEVELING)
     74            #include "mesh_bed_leveling.h"
     75          #endif
     76          

   \                                 In section .text, align 4, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xED2D 0x8B04      VPUSH    {D8-D9}
     77          Planner planner;
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable9_1
   \   0000000A   0x1D20             ADDS     R0,R4,#+4
   \   0000000C   0x.... 0x....      BL       _ZN7PlannerC1Ev
     78          
     79            // public:
     80          
     81          /**
     82           * A ring buffer of moves described in steps
     83           */
     84          block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
     85          volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next block to be pushed
     86                           Planner::block_buffer_tail = 0;
     87          
     88          float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
     89                Planner::axis_steps_per_mm[XYZE_N],
     90                Planner::steps_to_mm[XYZE_N];
     91          
     92          #if ENABLED(DISTINCT_E_FACTORS)
     93            uint8_t Planner::last_extruder = 0;     // Respond to extruder change
     94          #endif
     95          
     96          int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
     97          
     98          float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0); // The flow percentage and volumetric multiplier combine to scale E movement
     99          
    100          #if DISABLED(NO_VOLUMETRICS)
    101            float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
    102                  Planner::volumetric_area_nominal = CIRCLE_AREA((DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5), // Nominal cross-sectional area
   \   00000010   0xED9F 0x....      VLDR.W   D8,??DataTable4
   \   00000014   0x2502             MOVS     R5,#+2
   \   00000016   0xED9F 0x....      VLDR.W   D9,??DataTable5
   \   0000001A   0xE007             B.N      ??__sti__routine_0
   \                     ??__sti__routine_1: (+1)
   \   0000001C   0xEC53 0x2B18      VMOV     R2,R3,D8
   \   00000020   0xEC51 0x0B18      VMOV     R0,R1,D8
   \   00000024   0x.... 0x....      BL       __aeabi_dmul
   \   00000028   0xEC41 0x0B18      VMOV     D8,R0,R1
   \                     ??__sti__routine_0: (+1)
   \   0000002C   0x07E8             LSLS     R0,R5,#+31
   \   0000002E   0xD507             BPL.N    ??__sti__routine_2
   \   00000030   0xEC53 0x2B19      VMOV     R2,R3,D9
   \   00000034   0xEC51 0x0B18      VMOV     R0,R1,D8
   \   00000038   0x.... 0x....      BL       __aeabi_dmul
   \   0000003C   0xEC41 0x0B19      VMOV     D9,R0,R1
   \                     ??__sti__routine_2: (+1)
   \   00000040   0x086D             LSRS     R5,R5,#+1
   \   00000042   0xD1EB             BNE.N    ??__sti__routine_1
   \   00000044   0xEC53 0x2B19      VMOV     R2,R3,D9
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x54442d18
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable10_1  ;; 0x400921fb
   \   00000050   0x.... 0x....      BL       __aeabi_dmul
   \   00000054   0x.... 0x....      BL       __aeabi_d2f
   \   00000058   0x6020             STR      R0,[R4, #+0]
   \   0000005A   0xECBD 0x8B04      VPOP     {D8-D9}
   \   0000005E   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .bss, align 4
   \                     _ZN7Planner23volumetric_area_nominalE:
   \   00000000                      DS8 4
   \                     planner:
   \   00000004                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZN7Planner12block_bufferE:
   \   00000000                      DS8 1344
    103                  Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
    104          #endif
    105          
    106          unsigned long Planner::max_acceleration_steps_per_s2[XYZE_N],
    107                   Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
    108          
    109          uint32_t Planner::min_segment_time_us;
    110          
    111          // Initialized by settings.load()
    112          float Planner::min_feedrate_mm_s,
    113                Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
    114                Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
    115                Planner::travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
    116                Planner::max_jerk[XYZE],       // The largest speed change requiring no acceleration
    117                Planner::min_travel_feedrate_mm_s;
    118          
    119          #if HAS_LEVELING
    120            bool Planner::leveling_active = false; // Flag that auto bed leveling is enabled
    121            #if ABL_PLANAR
    122              matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
    123            #endif
    124            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    125              float Planner::z_fade_height,      // Initialized by settings.load()
    126                    Planner::inverse_z_fade_height,
    127                    Planner::last_fade_z;
    128            #endif
    129          #else

   \                                 In section .rodata, align 1, keep-with-next
    130            constexpr bool Planner::leveling_active;
   \                     _ZN7Planner15leveling_activeE:
   \   00000000   0x00               DC8 0
    131          #endif
    132          
    133          #if ENABLED(SKEW_CORRECTION)
    134            #if ENABLED(SKEW_CORRECTION_GCODE)
    135              float Planner::xy_skew_factor;
    136            #else
    137              constexpr float Planner::xy_skew_factor;
    138            #endif
    139            #if ENABLED(SKEW_CORRECTION_FOR_Z) && ENABLED(SKEW_CORRECTION_GCODE)
    140              float Planner::xz_skew_factor, Planner::yz_skew_factor;
    141            #else
    142              constexpr float Planner::xz_skew_factor, Planner::yz_skew_factor;
    143            #endif
    144          #endif
    145          
    146          #if ENABLED(AUTOTEMP)
    147            float Planner::autotemp_max = 250,
    148                  Planner::autotemp_min = 210,
    149                  Planner::autotemp_factor = 0.1;
    150            bool Planner::autotemp_enabled = false;
    151          #endif
    152          
    153          // private:
    154          
    155          int32_t Planner::position[NUM_AXIS] = { 0 };
    156          
    157          uint32_t Planner::cutoff_long;
    158          
    159          float Planner::previous_speed[NUM_AXIS],
    160                Planner::previous_nominal_speed;
    161          
    162          #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
    163            uint8_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
    164          #endif
    165          
    166          #ifdef XY_FREQUENCY_LIMIT
    167            // Old direction bits. Used for speed calculations
    168            unsigned char Planner::old_direction_bits = 0;
    169            // Segment times (in µs). Used for speed calculations
    170            uint32_t Planner::axis_segment_time_us[2][3] = { { MAX_FREQ_TIME_US + 1, 0, 0 }, { MAX_FREQ_TIME_US + 1, 0, 0 } };
    171          #endif
    172          
    173          #if ENABLED(LIN_ADVANCE)
    174            float Planner::extruder_advance_k, // Initialized by settings.load()
    175                  Planner::advance_ed_ratio,   // Initialized by settings.load()
    176                  Planner::position_float[XYZE], // Needed for accurate maths. Steps cannot be used!
    177                  Planner::lin_dist_xy,
    178                  Planner::lin_dist_e;
    179          #endif
    180          
    181          #if ENABLED(ULTRA_LCD)
    182            volatile uint32_t Planner::block_buffer_runtime_us = 0;
    183          #endif
    184          
    185          /**
    186           * Class and Instance Methods
    187           */
    188          

   \                                 In section .text, align 2, keep-with-next
    189          Planner::Planner() { init(); }
   \                     _ZN7PlannerC1Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      BL       _ZN7Planner4initEv
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    190          

   \                                 In section .text, align 2, keep-with-next
    191          void Planner::init() {
   \                     _ZN7Planner4initEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    192            block_buffer_head = block_buffer_tail = 0;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable10_2
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7060             STRB     R0,[R4, #+1]
   \   0000000A   0x7020             STRB     R0,[R4, #+0]
    193            ZERO(position);
   \   0000000C   0x2210             MOVS     R2,#+16
   \   0000000E   0x4601             MOV      R1,R0
   \   00000010   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000014   0x.... 0x....      BL       memset
    194            #if ENABLED(LIN_ADVANCE)
    195              ZERO(position_float);
    196            #endif
    197            ZERO(previous_speed);
   \   00000018   0x2210             MOVS     R2,#+16
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xF104 0x0068      ADD      R0,R4,#+104
   \   00000020   0x.... 0x....      BL       memset
    198            previous_nominal_speed = 0.0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x67A0             STR      R0,[R4, #+120]
    199            #if ABL_PLANAR
    200              bed_level_matrix.set_to_identity();
    201            #endif
    202          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    203          
    204          #define MINIMAL_STEP_RATE 120
    205          
    206          /**
    207           * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
    208           * by the provided factors.
    209           */

   \                                 In section .text, align 4, keep-with-next
    210          void Planner::calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor) {
   \                     _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000008   0xB086             SUB      SP,SP,#+24
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0x4616             MOV      R6,R2
    211            uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
                                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000000E   0xED94 0x0A0F      VLDR     S0,[R4, #+60]
   \   00000012   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000016   0xEDD1 0x0A00      VLDR     S1,[R1, #0]
   \   0000001A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000001E   0x.... 0x....      BL       ceilf
   \   00000022   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   00000026   0xEE10 0x5A10      VMOV     R5,S0
    212                     final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000002A   0xED94 0x0A0F      VLDR     S0,[R4, #+60]
   \   0000002E   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000032   0xEDD6 0x0A00      VLDR     S1,[R6, #0]
   \   00000036   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000003A   0x.... 0x....      BL       ceilf
   \   0000003E   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   00000042   0xEE10 0x6A10      VMOV     R6,S0
    213          
    214            // Limit minimal step rate (Otherwise the timer will overflow.)
    215            NOLESS(initial_rate, MINIMAL_STEP_RATE);
   \   00000046   0x2D78             CMP      R5,#+120
   \   00000048   0xD200             BCS.N    ??calculate_trapezoid_for_block_0
   \   0000004A   0x2578             MOVS     R5,#+120
    216            NOLESS(final_rate, MINIMAL_STEP_RATE);
   \                     ??calculate_trapezoid_for_block_0: (+1)
   \   0000004C   0x2E78             CMP      R6,#+120
   \   0000004E   0xD200             BCS.N    ??calculate_trapezoid_for_block_1
   \   00000050   0x2678             MOVS     R6,#+120
    217          
    218            const int32_t accel = block->acceleration_steps_per_s2;
   \                     ??calculate_trapezoid_for_block_1: (+1)
   \   00000052   0xF8D4 0x8048      LDR      R8,[R4, #+72]
    219          
    220                    // Steps required for acceleration, deceleration to/from nominal rate
    221            int32_t accelerate_steps = CEIL(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel)),
                                              ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000056   0xEE00 0x5A10      VMOV     S0,R5
   \   0000005A   0xEEB8 0x8A40      VCVT.F32.U32 S16,S0
   \   0000005E   0xED8D 0x8A05      VSTR     S16,[SP, #+20]
   \   00000062   0xED94 0x0A0F      VLDR     S0,[R4, #+60]
   \   00000066   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   0000006A   0xED8D 0x0A01      VSTR     S0,[SP, #+4]
   \   0000006E   0xEE00 0x8A10      VMOV     S0,R8
   \   00000072   0xEEF8 0x8AC0      VCVT.F32.S32 S17,S0
   \   00000076   0xEDCD 0x8A04      VSTR     S17,[SP, #+16]
   \   0000007A   0xAA04             ADD      R2,SP,#+16
   \   0000007C   0xA901             ADD      R1,SP,#+4
   \   0000007E   0xA805             ADD      R0,SP,#+20
   \   00000080   0x.... 0x....      BL       _ZN7Planner30estimate_acceleration_distanceERKfS1_S1_
   \   00000084   0x.... 0x....      BL       ceilf
   \   00000088   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000008C   0xEE10 0x7A10      VMOV     R7,S0
    222                    decelerate_steps = FLOOR(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel)),
                                              ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000090   0xED94 0x0A0F      VLDR     S0,[R4, #+60]
   \   00000094   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000098   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   0000009C   0xEE00 0x6A10      VMOV     S0,R6
   \   000000A0   0xEEB8 0x9A40      VCVT.F32.U32 S18,S0
   \   000000A4   0xED8D 0x9A03      VSTR     S18,[SP, #+12]
   \   000000A8   0xF1C8 0x0000      RSB      R0,R8,#+0
   \   000000AC   0xEE00 0x0A10      VMOV     S0,R0
   \   000000B0   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000B4   0xED8D 0x0A02      VSTR     S0,[SP, #+8]
   \   000000B8   0xAA02             ADD      R2,SP,#+8
   \   000000BA   0xA903             ADD      R1,SP,#+12
   \   000000BC   0xA800             ADD      R0,SP,#+0
   \   000000BE   0x.... 0x....      BL       _ZN7Planner30estimate_acceleration_distanceERKfS1_S1_
   \   000000C2   0x.... 0x....      BL       floorf
   \   000000C6   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   000000CA   0xEE10 0x0A10      VMOV     R0,S0
    223                    // Steps between acceleration and deceleration, if any
    224                    plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
   \   000000CE   0x6961             LDR      R1,[R4, #+20]
   \   000000D0   0x1BC9             SUBS     R1,R1,R7
   \   000000D2   0x1A08             SUBS     R0,R1,R0
    225          
    226            // Does accelerate_steps + decelerate_steps exceed step_event_count?
    227            // Then we can't possibly reach the nominal rate, there will be no cruising.
    228            // Use intersection_distance() to calculate accel / braking time in order to
    229            // reach the final_rate exactly at the end of this block.
    230            if (plateau_steps < 0) {
   \   000000D4   0xD51F             BPL.N    ??calculate_trapezoid_for_block_2
    231              accelerate_steps = CEIL(intersection_distance(initial_rate, final_rate, accel, block->step_event_count));
                                      ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000000D6   0xED8D 0x8A03      VSTR     S16,[SP, #+12]
   \   000000DA   0xED8D 0x9A02      VSTR     S18,[SP, #+8]
   \   000000DE   0xEDCD 0x8A01      VSTR     S17,[SP, #+4]
   \   000000E2   0xED94 0x0A05      VLDR     S0,[R4, #+20]
   \   000000E6   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   000000EA   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   000000EE   0xAB00             ADD      R3,SP,#+0
   \   000000F0   0xAA01             ADD      R2,SP,#+4
   \   000000F2   0xA902             ADD      R1,SP,#+8
   \   000000F4   0xA803             ADD      R0,SP,#+12
   \   000000F6   0x.... 0x....      BL       _ZN7Planner21intersection_distanceERKfS1_S1_S1_
   \   000000FA   0x.... 0x....      BL       ceilf
   \   000000FE   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000102   0xEE10 0x7A10      VMOV     R7,S0
    232              NOLESS(accelerate_steps, 0); // Check limits due to numerical round-off
   \   00000106   0x2F00             CMP      R7,#+0
   \   00000108   0xD500             BPL.N    ??calculate_trapezoid_for_block_3
   \   0000010A   0x2700             MOVS     R7,#+0
    233              accelerate_steps = min((uint32_t)accelerate_steps, block->step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)
   \                     ??calculate_trapezoid_for_block_3: (+1)
   \   0000010C   0x6960             LDR      R0,[R4, #+20]
   \   0000010E   0x4287             CMP      R7,R0
   \   00000110   0xD300             BCC.N    ??calculate_trapezoid_for_block_4
   \   00000112   0x4607             MOV      R7,R0
    234              plateau_steps = 0;
   \                     ??calculate_trapezoid_for_block_4: (+1)
   \   00000114   0x2000             MOVS     R0,#+0
    235            }
    236          
    237            // block->accelerate_until = accelerate_steps;
    238            // block->decelerate_after = accelerate_steps+plateau_steps;
    239          
    240            CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
   \                     ??calculate_trapezoid_for_block_2: (+1)
   \   00000116   0xB672             cpsid i
    241            if (!TEST(block->flag, BLOCK_BIT_BUSY)) { // Don't update variables if block is busy.
   \   00000118   0x7821             LDRB     R1,[R4, #+0]
   \   0000011A   0x0709             LSLS     R1,R1,#+28
   \   0000011C   0xD404             BMI.N    ??calculate_trapezoid_for_block_5
    242              block->accelerate_until = accelerate_steps;
   \   0000011E   0x61A7             STR      R7,[R4, #+24]
    243              block->decelerate_after = accelerate_steps + plateau_steps;
   \   00000120   0x19C0             ADDS     R0,R0,R7
   \   00000122   0x61E0             STR      R0,[R4, #+28]
    244              block->initial_rate = initial_rate;
   \   00000124   0x6425             STR      R5,[R4, #+64]
    245              block->final_rate = final_rate;
   \   00000126   0x6466             STR      R6,[R4, #+68]
    246            }
    247            CRITICAL_SECTION_END;
   \                     ??calculate_trapezoid_for_block_5: (+1)
   \   00000128   0xB662             cpsie i
    248          }
   \   0000012A   0xB006             ADD      SP,SP,#+24
   \   0000012C   0xECBD 0x8B04      VPOP     {D8-D9}
   \   00000130   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    249          
    250          // "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
    251          // This method will calculate the junction jerk as the euclidean distance between the nominal
    252          // velocities of the respective blocks.
    253          //inline float junction_jerk(block_t *before, block_t *after) {
    254          //  return SQRT(
    255          //    POW((before->speed_x-after->speed_x), 2)+POW((before->speed_y-after->speed_y), 2));
    256          //}
    257          
    258          
    259          // The kernel called by recalculate() when scanning the plan from last to first entry.

   \                                 In section .text, align 2, keep-with-next
    260          void Planner::reverse_pass_kernel(block_t* const current, const block_t * const next) {
   \                     _ZN7Planner19reverse_pass_kernelEP7block_tPKS0_: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x460D             MOV      R5,R1
    261            if (!current || !next) return;
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD03B             BEQ.N    ??reverse_pass_kernel_0
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD039             BEQ.N    ??reverse_pass_kernel_0
    262            // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
    263            // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
    264            // check for maximum allowable speed reductions to ensure maximum possible planned speed.
    265            float max_entry_speed = current->max_entry_speed;
   \   00000014   0xED94 0x8A0C      VLDR     S16,[R4, #+48]
    266            if (current->entry_speed != max_entry_speed) {
   \   00000018   0xED94 0x0A0B      VLDR     S0,[R4, #+44]
   \   0000001C   0xEEB4 0x0A48      VCMP.F32 S0,S16
   \   00000020   0xEEF1 0xFA10      FMSTAT   
   \   00000024   0xD030             BEQ.N    ??reverse_pass_kernel_0
    267              // If nominal length true, max junction speed is guaranteed to be reached. Only compute
    268              // for max allowable speed if block is decelerating and nominal length is false.
    269              current->entry_speed = (TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH) || max_entry_speed <= next->entry_speed)
    270                ? max_entry_speed
    271                : min(max_entry_speed, max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x0780             LSLS     R0,R0,#+30
   \   0000002A   0xD427             BMI.N    ??reverse_pass_kernel_1
   \   0000002C   0xED95 0x0A0B      VLDR     S0,[R5, #+44]
   \   00000030   0xEEB4 0x0A48      VCMP.F32 S0,S16
   \   00000034   0xEEF1 0xFA10      FMSTAT   
   \   00000038   0xDA20             BGE.N    ??reverse_pass_kernel_1
   \   0000003A   0xED94 0x0A0E      VLDR     S0,[R4, #+56]
   \   0000003E   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000042   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   00000046   0xF104 0x0234      ADD      R2,R4,#+52
   \   0000004A   0xF105 0x012C      ADD      R1,R5,#+44
   \   0000004E   0xA800             ADD      R0,SP,#+0
   \   00000050   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   \   00000054   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   00000058   0xEEF1 0xFA10      FMSTAT   
   \   0000005C   0xD40E             BMI.N    ??reverse_pass_kernel_1
   \   0000005E   0xED94 0x0A0E      VLDR     S0,[R4, #+56]
   \   00000062   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000066   0xED8D 0x0A01      VSTR     S0,[SP, #+4]
   \   0000006A   0xF104 0x0234      ADD      R2,R4,#+52
   \   0000006E   0xF105 0x012C      ADD      R1,R5,#+44
   \   00000072   0xA801             ADD      R0,SP,#+4
   \   00000074   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   \   00000078   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \                     ??reverse_pass_kernel_1: (+1)
   \   0000007C   0xED84 0x8A0B      VSTR     S16,[R4, #+44]
    272              SBI(current->flag, BLOCK_BIT_RECALCULATE);
   \   00000080   0x7820             LDRB     R0,[R4, #+0]
   \   00000082   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000086   0x7020             STRB     R0,[R4, #+0]
    273            }
    274          }
   \                     ??reverse_pass_kernel_0: (+1)
   \   00000088   0xB002             ADD      SP,SP,#+8
   \   0000008A   0xECBD 0x8B02      VPOP     {D8}
   \   0000008E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    275          
    276          /**
    277           * recalculate() needs to go over the current plan twice.
    278           * Once in reverse and once forward. This implements the reverse pass.
    279           */

   \                                 In section .text, align 2, keep-with-next
    280          void Planner::reverse_pass() {
   \                     _ZN7Planner12reverse_passEv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    281            if (movesplanned() > 3) {
   \   00000004   0x.... 0x....      BL       _ZN7Planner12movesplannedEv
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xDB24             BLT.N    ??reverse_pass_0
    282              const uint8_t endnr = BLOCK_MOD(block_buffer_tail + 2); // tail is running. tail+1 shouldn't be altered because it's connected to the running block.
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000010   0x7841             LDRB     R1,[R0, #+1]
   \   00000012   0x1C89             ADDS     R1,R1,#+2
   \   00000014   0xF001 0x040F      AND      R4,R1,#0xF
    283                                                                      // tail+2 because the index is not yet advanced when checked
    284              uint8_t blocknr = prev_block_index(block_buffer_head);
   \   00000018   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000001C   0x.... 0x....      BL       _ZN7Planner16prev_block_indexEa
   \   00000020   0x4607             MOV      R7,R0
   \   00000022   0xB2FF             UXTB     R7,R7
    285              block_t* current = &block_buffer[blocknr];
   \   00000024   0x2554             MOVS     R5,#+84
   \   00000026   0x.... 0x....      LDR.W    R6,??DataTable16
   \   0000002A   0x4638             MOV      R0,R7
   \   0000002C   0xFB15 0x6800      SMLABB   R8,R5,R0,R6
    286          
    287              do {
    288                const block_t * const next = current;
   \                     ??reverse_pass_1: (+1)
   \   00000030   0x46C1             MOV      R9,R8
    289                blocknr = prev_block_index(blocknr);
   \   00000032   0x4638             MOV      R0,R7
   \   00000034   0xB240             SXTB     R0,R0
   \   00000036   0x.... 0x....      BL       _ZN7Planner16prev_block_indexEa
   \   0000003A   0x4607             MOV      R7,R0
   \   0000003C   0xB2FF             UXTB     R7,R7
    290                current = &block_buffer[blocknr];
   \   0000003E   0xFB15 0x6807      SMLABB   R8,R5,R7,R6
    291                if (TEST(current->flag, BLOCK_BIT_START_FROM_FULL_HALT)) // Up to this every block is already optimized.
   \   00000042   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000046   0x0740             LSLS     R0,R0,#+29
   \   00000048   0xD405             BMI.N    ??reverse_pass_0
    292                  break;
    293                reverse_pass_kernel(current, next);
   \   0000004A   0x4649             MOV      R1,R9
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0x.... 0x....      BL       _ZN7Planner19reverse_pass_kernelEP7block_tPKS0_
    294              } while (blocknr != endnr);
   \   00000052   0x42A7             CMP      R7,R4
   \   00000054   0xD1EC             BNE.N    ??reverse_pass_1
    295            }
    296          }
   \                     ??reverse_pass_0: (+1)
   \   00000056   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    297          
    298          // The kernel called by recalculate() when scanning the plan from first to last entry.

   \                                 In section .text, align 2, keep-with-next
    299          void Planner::forward_pass_kernel(const block_t * const previous, block_t* const current) {
   \                     _ZN7Planner19forward_pass_kernelEPK7block_tPS0_: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    300            if (!previous) return;
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD03B             BEQ.N    ??forward_pass_kernel_0
    301          
    302            // If the previous block is an acceleration block, but it is not long enough to complete the
    303            // full speed change within the block, we need to adjust the entry speed accordingly. Entry
    304            // speeds have already been reset, maximized, and reverse planned by reverse planner.
    305            // If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.
    306            if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH)) {
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x0780             LSLS     R0,R0,#+30
   \   00000010   0xD438             BMI.N    ??forward_pass_kernel_0
    307              if (previous->entry_speed < current->entry_speed) {
   \   00000012   0xED94 0x0A0B      VLDR     S0,[R4, #+44]
   \   00000016   0xEDD5 0x0A0B      VLDR     S1,[R5, #+44]
   \   0000001A   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000001E   0xEEF1 0xFA10      FMSTAT   
   \   00000022   0xD52F             BPL.N    ??forward_pass_kernel_0
    308                float entry_speed = min(current->entry_speed,
    309                                         max_allowable_speed(-previous->acceleration, previous->entry_speed, previous->millimeters));
   \   00000024   0xED94 0x0A0E      VLDR     S0,[R4, #+56]
   \   00000028   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   0000002C   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   00000030   0xF104 0x0234      ADD      R2,R4,#+52
   \   00000034   0xF104 0x012C      ADD      R1,R4,#+44
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   \   0000003E   0xEDD5 0x0A0B      VLDR     S1,[R5, #+44]
   \   00000042   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000046   0xEEF1 0xFA10      FMSTAT   
   \   0000004A   0xD40E             BMI.N    ??forward_pass_kernel_1
   \   0000004C   0xED94 0x0A0E      VLDR     S0,[R4, #+56]
   \   00000050   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000054   0xED8D 0x0A01      VSTR     S0,[SP, #+4]
   \   00000058   0xF104 0x0234      ADD      R2,R4,#+52
   \   0000005C   0xF104 0x012C      ADD      R1,R4,#+44
   \   00000060   0xA801             ADD      R0,SP,#+4
   \   00000062   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   \   00000066   0xEEF0 0x0A40      VMOV.F32 S1,S0
    310                // Check for junction speed change
    311                if (current->entry_speed != entry_speed) {
   \                     ??forward_pass_kernel_1: (+1)
   \   0000006A   0xED95 0x0A0B      VLDR     S0,[R5, #+44]
   \   0000006E   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000072   0xEEF1 0xFA10      FMSTAT   
   \   00000076   0xD005             BEQ.N    ??forward_pass_kernel_0
    312                  current->entry_speed = entry_speed;
   \   00000078   0xEDC5 0x0A0B      VSTR     S1,[R5, #+44]
    313                  SBI(current->flag, BLOCK_BIT_RECALCULATE);
   \   0000007C   0x7828             LDRB     R0,[R5, #+0]
   \   0000007E   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000082   0x7028             STRB     R0,[R5, #+0]
    314                }
    315              }
    316            }
    317          }
   \                     ??forward_pass_kernel_0: (+1)
   \   00000084   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    318          
    319          /**
    320           * recalculate() needs to go over the current plan twice.
    321           * Once in reverse and once forward. This implements the forward pass.
    322           */

   \                                 In section .text, align 2, keep-with-next
    323          void Planner::forward_pass() {
   \                     _ZN7Planner12forward_passEv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    324            block_t* block[3] = { NULL, NULL, NULL };
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x4625             MOV      R5,R4
    325          
    326            for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable10_2
   \   0000000A   0x7877             LDRB     R7,[R6, #+1]
   \   0000000C   0xE00F             B.N      ??forward_pass_0
    327              block[0] = block[1];
   \                     ??forward_pass_1: (+1)
   \   0000000E   0x4620             MOV      R0,R4
    328              block[1] = block[2];
   \   00000010   0x462C             MOV      R4,R5
    329              block[2] = &block_buffer[b];
   \   00000012   0x2154             MOVS     R1,#+84
   \   00000014   0x.... 0x....      LDR.W    R2,??DataTable17
   \   00000018   0xFB11 0x2507      SMLABB   R5,R1,R7,R2
    330              forward_pass_kernel(block[0], block[1]);
   \   0000001C   0x4621             MOV      R1,R4
   \   0000001E   0x.... 0x....      BL       _ZN7Planner19forward_pass_kernelEPK7block_tPS0_
    331            }
   \   00000022   0x4638             MOV      R0,R7
   \   00000024   0xB240             SXTB     R0,R0
   \   00000026   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \   0000002A   0x4607             MOV      R7,R0
   \   0000002C   0xB2FF             UXTB     R7,R7
   \                     ??forward_pass_0: (+1)
   \   0000002E   0x7830             LDRB     R0,[R6, #+0]
   \   00000030   0x4287             CMP      R7,R0
   \   00000032   0xD1EC             BNE.N    ??forward_pass_1
    332            forward_pass_kernel(block[1], block[2]);
   \   00000034   0x4629             MOV      R1,R5
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   0000003C   0x....             B.N      _ZN7Planner19forward_pass_kernelEPK7block_tPS0_
    333          }
    334          
    335          /**
    336           * Recalculate the trapezoid speed profiles for all blocks in the plan
    337           * according to the entry_factor for each junction. Must be called by
    338           * recalculate() after updating the blocks.
    339           */

   \                                 In section .text, align 2, keep-with-next
    340          void Planner::recalculate_trapezoids() {
   \                     _ZN7Planner22recalculate_trapezoidsEv: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    341            int8_t block_index = block_buffer_tail;
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable10_2
   \   00000008   0xF995 0x6001      LDRSB    R6,[R5, #+1]
    342            block_t *current, *next = NULL;
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xE02C             B.N      ??recalculate_trapezoids_0
    343          
    344            while (block_index != block_buffer_head) {
    345              current = next;
   \                     ??recalculate_trapezoids_1: (+1)
   \   00000010   0x4627             MOV      R7,R4
    346              next = &block_buffer[block_index];
   \   00000012   0x2054             MOVS     R0,#+84
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000018   0xFB16 0x1400      SMLABB   R4,R6,R0,R1
    347              if (current) {
   \   0000001C   0x2F00             CMP      R7,#+0
   \   0000001E   0xD020             BEQ.N    ??recalculate_trapezoids_2
    348                // Recalculate if current block entry or exit junction speed has changed.
    349                if (TEST(current->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
   \   00000020   0x7838             LDRB     R0,[R7, #+0]
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD402             BMI.N    ??recalculate_trapezoids_3
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD51A             BPL.N    ??recalculate_trapezoids_2
    350                  // NOTE: Entry and exit factors always > 0 by all previous logic operations.
    351                  const float nomr = 1.0 / current->nominal_speed;
   \                     ??recalculate_trapezoids_3: (+1)
   \   0000002C   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   00000030   0xEDD7 0x0A0A      VLDR     S1,[R7, #+40]
   \   00000034   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
    352                  calculate_trapezoid_for_block(current, current->entry_speed * nomr, next->entry_speed * nomr);
   \   00000038   0xEDD7 0x0A0B      VLDR     S1,[R7, #+44]
   \   0000003C   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000040   0xEDCD 0x0A01      VSTR     S1,[SP, #+4]
   \   00000044   0xEDD4 0x0A0B      VLDR     S1,[R4, #+44]
   \   00000048   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   0000004C   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   00000050   0xAA00             ADD      R2,SP,#+0
   \   00000052   0xA901             ADD      R1,SP,#+4
   \   00000054   0x4638             MOV      R0,R7
   \   00000056   0x.... 0x....      BL       _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_
    353                  CBI(current->flag, BLOCK_BIT_RECALCULATE); // Reset current only to ensure next trapezoid is computed
   \   0000005A   0x7838             LDRB     R0,[R7, #+0]
   \   0000005C   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   00000060   0x7038             STRB     R0,[R7, #+0]
    354                }
    355              }
    356              block_index = next_block_index(block_index);
   \                     ??recalculate_trapezoids_2: (+1)
   \   00000062   0x4630             MOV      R0,R6
   \   00000064   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \   00000068   0x4606             MOV      R6,R0
    357            }
   \                     ??recalculate_trapezoids_0: (+1)
   \   0000006A   0x4630             MOV      R0,R6
   \   0000006C   0x7829             LDRB     R1,[R5, #+0]
   \   0000006E   0x4288             CMP      R0,R1
   \   00000070   0xD1CE             BNE.N    ??recalculate_trapezoids_1
    358            // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
    359            if (next) {
   \   00000072   0x2C00             CMP      R4,#+0
   \   00000074   0xD021             BEQ.N    ??recalculate_trapezoids_4
    360              const float nomr = 1.0 / next->nominal_speed;
   \   00000076   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   0000007A   0xEDD4 0x0A0A      VLDR     S1,[R4, #+40]
   \   0000007E   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
    361              calculate_trapezoid_for_block(next, next->entry_speed * nomr, (MINIMUM_PLANNER_SPEED) * nomr);
   \   00000082   0xEDD4 0x0A0B      VLDR     S1,[R4, #+44]
   \   00000086   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   0000008A   0xEDCD 0x0A00      VSTR     S1,[SP, #+0]
   \   0000008E   0xEE10 0x0A10      VMOV     R0,S0
   \   00000092   0x.... 0x....      BL       __aeabi_f2d
   \   00000096   0x.... 0x....      LDR.W    R2,??DataTable17_1  ;; 0x9999999a
   \   0000009A   0x.... 0x....      LDR.W    R3,??DataTable17_2  ;; 0x3fa99999
   \   0000009E   0x.... 0x....      BL       __aeabi_dmul
   \   000000A2   0x.... 0x....      BL       __aeabi_d2f
   \   000000A6   0x9001             STR      R0,[SP, #+4]
   \   000000A8   0xAA01             ADD      R2,SP,#+4
   \   000000AA   0xA900             ADD      R1,SP,#+0
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0x.... 0x....      BL       _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_
    362              CBI(next->flag, BLOCK_BIT_RECALCULATE);
   \   000000B2   0x7820             LDRB     R0,[R4, #+0]
   \   000000B4   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   000000B8   0x7020             STRB     R0,[R4, #+0]
    363            }
    364          }
   \                     ??recalculate_trapezoids_4: (+1)
   \   000000BA   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    365          
    366          /*
    367           * Recalculate the motion plan according to the following algorithm:
    368           *
    369           *   1. Go over every block in reverse order...
    370           *
    371           *      Calculate a junction speed reduction (block_t.entry_factor) so:
    372           *
    373           *      a. The junction jerk is within the set limit, and
    374           *
    375           *      b. No speed reduction within one block requires faster
    376           *         deceleration than the one, true constant acceleration.
    377           *
    378           *   2. Go over every block in chronological order...
    379           *
    380           *      Dial down junction speed reduction values if:
    381           *      a. The speed increase within one block would require faster
    382           *         acceleration than the one, true constant acceleration.
    383           *
    384           * After that, all blocks will have an entry_factor allowing all speed changes to
    385           * be performed using only the one, true constant acceleration, and where no junction
    386           * jerk is jerkier than the set limit, Jerky. Finally it will:
    387           *
    388           *   3. Recalculate "trapezoids" for all blocks.
    389           */

   \                                 In section .text, align 2, keep-with-next
    390          void Planner::recalculate() {
   \                     _ZN7Planner11recalculateEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    391            reverse_pass();
   \   00000002   0x.... 0x....      BL       _ZN7Planner12reverse_passEv
    392            forward_pass();
   \   00000006   0x.... 0x....      BL       _ZN7Planner12forward_passEv
    393            recalculate_trapezoids();
   \   0000000A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000E   0x....             B.N      _ZN7Planner22recalculate_trapezoidsEv
    394          }
    395          
    396          
    397          #if ENABLED(AUTOTEMP)
    398          

   \                                 In section .text, align 4, keep-with-next
    399            void Planner::getHighESpeed() {
   \                     _ZN7Planner13getHighESpeedEv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
    400              static float oldt = 0;
    401          
    402              if (!autotemp_enabled) return;
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable10_2
   \   0000000A   0x78B0             LDRB     R0,[R6, #+2]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xF000 0x8081      BEQ.W    ??getHighESpeed_0
    403              if (thermalManager.degTargetHotend(0) + 2 < autotemp_min) return; // probably temperature set to zero.
   \   00000012   0xED96 0x8A17      VLDR     S16,[R6, #+92]
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \   0000001C   0xEEF0 0x0A00      VMOV.F32 S1,#2.0
   \   00000020   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000024   0xEEB4 0x0A48      VCMP.F32 S0,S16
   \   00000028   0xEEF1 0xFA10      FMSTAT   
   \   0000002C   0xD472             BMI.N    ??getHighESpeed_0
    404          
    405              float high = 0.0;
   \   0000002E   0xEDDF 0x....      VLDR.W   S17,??DataTable9  ;; 0x0
    406              for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
   \   00000032   0x7870             LDRB     R0,[R6, #+1]
   \   00000034   0xE026             B.N      ??getHighESpeed_1
    407                block_t* block = &block_buffer[b];
   \                     ??getHighESpeed_2: (+1)
   \   00000036   0x2154             MOVS     R1,#+84
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable16
   \   0000003C   0xFB11 0x2100      SMLABB   R1,R1,R0,R2
    408                if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS]) {
   \   00000040   0x684A             LDR      R2,[R1, #+4]
   \   00000042   0x2A00             CMP      R2,#+0
   \   00000044   0xD105             BNE.N    ??getHighESpeed_3
   \   00000046   0x688A             LDR      R2,[R1, #+8]
   \   00000048   0x2A00             CMP      R2,#+0
   \   0000004A   0xD102             BNE.N    ??getHighESpeed_3
   \   0000004C   0x68CA             LDR      R2,[R1, #+12]
   \   0000004E   0x2A00             CMP      R2,#+0
   \   00000050   0xD014             BEQ.N    ??getHighESpeed_4
    409                  float se = (float)block->steps[E_AXIS] / block->step_event_count * block->nominal_speed; // mm/sec;
   \                     ??getHighESpeed_3: (+1)
   \   00000052   0xED91 0x0A04      VLDR     S0,[R1, #+16]
   \   00000056   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000005A   0xEDD1 0x0A05      VLDR     S1,[R1, #+20]
   \   0000005E   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   00000062   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000066   0xEDD1 0x0A0A      VLDR     S1,[R1, #+40]
   \   0000006A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
    410                  NOLESS(high, se);
   \   0000006E   0xEEF4 0x8A40      VCMP.F32 S17,S0
   \   00000072   0xEEF1 0xFA10      FMSTAT   
   \   00000076   0xD501             BPL.N    ??getHighESpeed_4
   \   00000078   0xEEF0 0x8A40      VMOV.F32 S17,S0
    411                }
    412              }
   \                     ??getHighESpeed_4: (+1)
   \   0000007C   0xB240             SXTB     R0,R0
   \   0000007E   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \   00000082   0xB2C0             UXTB     R0,R0
   \                     ??getHighESpeed_1: (+1)
   \   00000084   0x7831             LDRB     R1,[R6, #+0]
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD1D5             BNE.N    ??getHighESpeed_2
    413          
    414              float t = autotemp_min + high * autotemp_factor;
   \   0000008A   0xEDD6 0x0A18      VLDR     S1,[R6, #+96]
   \   0000008E   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000092   0xEE08 0x0AA0      VMLA.F32 S0,S17,S1
    415              t = constrain(t, autotemp_min, autotemp_max);
   \   00000096   0xEEB4 0x0A48      VCMP.F32 S0,S16
   \   0000009A   0xEEF1 0xFA10      FMSTAT   
   \   0000009E   0xD502             BPL.N    ??getHighESpeed_5
   \   000000A0   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000A4   0xE008             B.N      ??getHighESpeed_6
   \                     ??getHighESpeed_5: (+1)
   \   000000A6   0xEDD6 0x0A16      VLDR     S1,[R6, #+88]
   \   000000AA   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   000000AE   0xEEF1 0xFA10      FMSTAT   
   \   000000B2   0xD501             BPL.N    ??getHighESpeed_6
   \   000000B4   0xEEB0 0x0A60      VMOV.F32 S0,S1
    416              if (t < oldt) t = t * (1 - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
   \                     ??getHighESpeed_6: (+1)
   \   000000B8   0xED96 0x8A1F      VLDR     S16,[R6, #+124]
   \   000000BC   0xEEB4 0x0A48      VCMP.F32 S0,S16
   \   000000C0   0xEEF1 0xFA10      FMSTAT   
   \   000000C4   0xD51D             BPL.N    ??getHighESpeed_7
   \   000000C6   0xEE10 0x0A10      VMOV     R0,S0
   \   000000CA   0x.... 0x....      BL       __aeabi_f2d
   \   000000CE   0x.... 0x....      LDR.W    R2,??DataTable17_3  ;; 0x47ae1480
   \   000000D2   0x.... 0x....      LDR.W    R3,??DataTable17_4  ;; 0x3f947ae1
   \   000000D6   0x.... 0x....      BL       __aeabi_dmul
   \   000000DA   0x4604             MOV      R4,R0
   \   000000DC   0x460D             MOV      R5,R1
   \   000000DE   0xEE18 0x0A10      VMOV     R0,S16
   \   000000E2   0x.... 0x....      BL       __aeabi_f2d
   \   000000E6   0x.... 0x....      LDR.W    R2,??DataTable17_5  ;; 0xf5c28f5c
   \   000000EA   0x.... 0x....      LDR.W    R3,??DataTable17_6  ;; 0x3fef5c28
   \   000000EE   0x.... 0x....      BL       __aeabi_dmul
   \   000000F2   0x4622             MOV      R2,R4
   \   000000F4   0x462B             MOV      R3,R5
   \   000000F6   0x.... 0x....      BL       __aeabi_dadd
   \   000000FA   0x.... 0x....      BL       __aeabi_d2f
   \   000000FE   0xEE00 0x0A10      VMOV     S0,R0
    417              oldt = t;
   \                     ??getHighESpeed_7: (+1)
   \   00000102   0xED86 0x0A1F      VSTR     S0,[R6, #+124]
    418              thermalManager.setTargetHotend(t, 0);
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0xECBD 0x8B02      VPOP     {D8}
   \   0000010C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000110   0x.... 0x....      B.W      _ZN11Temperature15setTargetHotendEfh
   \                     ??getHighESpeed_0: (+1)
   \   00000114   0xECBD 0x8B02      VPOP     {D8}
   \   00000118   0xBD70             POP      {R4-R6,PC}       ;; return
    419            }

   \                                 In section .data, align 4
   \                     _ZN7Planner17block_buffer_headE:
   \   00000000   0x00               DC8 0
   \                     _ZN7Planner17block_buffer_tailE:
   \   00000001   0x00               DC8 0
   \                     _ZN7Planner16autotemp_enabledE:
   \   00000002   0x00               DC8 0
   \   00000003   0x00               DC8 0
   \                     _ZN7Planner17axis_steps_per_mmE:
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner11steps_to_mmE:
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner29max_acceleration_steps_per_s2E:
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner8positionE:
   \   00000034   0x00000000         DC32 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \                     _ZN7Planner8e_factorE:
   \   00000044   0x3F800000         DC32 3F800000H
   \                     _ZN7Planner26max_acceleration_mm_per_s2E:
   \   00000048   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner12autotemp_maxE:
   \   00000058   0x437A0000         DC32 437A0000H
   \                     _ZN7Planner12autotemp_minE:
   \   0000005C   0x43520000         DC32 43520000H
   \                     _ZN7Planner15autotemp_factorE:
   \   00000060   0x3DCCCCCD         DC32 3DCCCCCDH
   \                     _ZN7Planner11cutoff_longE:
   \   00000064   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN7Planner14previous_speedE:
   \   00000068   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner22previous_nominal_speedE:
   \   00000078   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000007C   0x00000000         DC32 0H

   \                                 In section .data, align 4
   \                     _ZN7Planner15flow_percentageE:
   \   00000000   0x0064             DC16 100
   \   00000002   0x00 0x00          DC8 0, 0
   \                     _ZN7Planner21volumetric_multiplierE:
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN7Planner13filament_sizeE:
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    420          
    421          #endif // AUTOTEMP
    422          
    423          /**
    424           * Maintain fans, paste extruder pressure,
    425           */

   \                                 In section .text, align 2, keep-with-next
    426          void Planner::check_axes_activity() {
   \                     _ZN7Planner19check_axes_activityEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    427            unsigned char axis_active[NUM_AXIS] = { 0 },
    428                          tail_fan_speed[FAN_COUNT];
                                 ^
Warning[Pe550]: variable "tail_fan_speed" was set but never used
    429          
    430            #if ENABLED(BARICUDA)
    431              #if HAS_HEATER_1
    432                uint8_t tail_valve_pressure;
    433              #endif
    434              #if HAS_HEATER_2
    435                uint8_t tail_e_to_p_pressure;
    436              #endif
    437            #endif
    438          
    439            if (blocks_queued()) {
   \   00000002   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD014             BEQ.N    ??check_axes_activity_0
    440          
    441              #if FAN_COUNT > 0
    442                for (uint8_t i = 0; i < FAN_COUNT; i++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable17_7
   \   00000010   0xE000             B.N      ??check_axes_activity_1
    443                  tail_fan_speed[i] = block_buffer[block_buffer_tail].fan_speed[i];
   \                     ??check_axes_activity_2: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \                     ??check_axes_activity_1: (+1)
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0x7860             LDRB     R0,[R4, #+1]
   \   00000018   0xD0FB             BEQ.N    ??check_axes_activity_2
    444              #endif
    445          
    446              block_t* block;
    447          
    448              #if ENABLED(BARICUDA)
    449                block = &block_buffer[block_buffer_tail];
    450                #if HAS_HEATER_1
    451                  tail_valve_pressure = block->valve_pressure;
    452                #endif
    453                #if HAS_HEATER_2
    454                  tail_e_to_p_pressure = block->e_to_p_pressure;
    455                #endif
    456              #endif
    457          
    458              for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
   \   0000001A   0xE006             B.N      ??check_axes_activity_3
    459                block = &block_buffer[b];
    460                LOOP_XYZE(i) if (block->steps[i]) axis_active[i]++;
   \                     ??check_axes_activity_4: (+1)
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
   \                     ??check_axes_activity_5: (+1)
   \   0000001E   0x2904             CMP      R1,#+4
   \   00000020   0xDBFC             BLT.N    ??check_axes_activity_4
   \   00000022   0xB240             SXTB     R0,R0
   \   00000024   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \   00000028   0xB2C0             UXTB     R0,R0
   \                     ??check_axes_activity_3: (+1)
   \   0000002A   0x7821             LDRB     R1,[R4, #+0]
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD006             BEQ.N    ??check_axes_activity_6
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xE7F4             B.N      ??check_axes_activity_5
    461              }
    462            }
    463            else {
    464              #if FAN_COUNT > 0
    465                for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = fanSpeeds[i];
   \                     ??check_axes_activity_0: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE000             B.N      ??check_axes_activity_7
   \                     ??check_axes_activity_8: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \                     ??check_axes_activity_7: (+1)
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD0FC             BEQ.N    ??check_axes_activity_8
    466              #endif
    467          
    468              #if ENABLED(BARICUDA)
    469                #if HAS_HEATER_1
    470                  tail_valve_pressure = baricuda_valve_pressure;
    471                #endif
    472                #if HAS_HEATER_2
    473                  tail_e_to_p_pressure = baricuda_e_to_p_pressure;
    474                #endif
    475              #endif
    476            }
    477          
    478            #if ENABLED(DISABLE_X)
    479              if (!axis_active[X_AXIS]) disable_X();
    480            #endif
    481            #if ENABLED(DISABLE_Y)
    482              if (!axis_active[Y_AXIS]) disable_Y();
    483            #endif
    484            #if ENABLED(DISABLE_Z)
    485              if (!axis_active[Z_AXIS]) disable_Z();
    486            #endif
    487            #if ENABLED(DISABLE_E)
    488              if (!axis_active[E_AXIS]) disable_e_steppers();
    489            #endif
    490          
    491            #if FAN_COUNT > 0
    492          
    493              #if FAN_KICKSTART_TIME > 0
    494          
    495                static millis_t fan_kick_end[FAN_COUNT] = { 0 };
    496          
    497                #define KICKSTART_FAN(f) \
    498                  if (tail_fan_speed[f]) { \
    499                    millis_t ms = millis(); \
    500                    if (fan_kick_end[f] == 0) { \
    501                      fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
    502                      tail_fan_speed[f] = 255; \
    503                    } else if (PENDING(ms, fan_kick_end[f])) \
    504                      tail_fan_speed[f] = 255; \
    505                  } else fan_kick_end[f] = 0
    506          
    507                #if HAS_FAN0
    508                  KICKSTART_FAN(0);
    509                #endif
    510                #if HAS_FAN1
    511                  KICKSTART_FAN(1);
    512                #endif
    513                #if HAS_FAN2
    514                  KICKSTART_FAN(2);
    515                #endif
    516          
    517              #endif // FAN_KICKSTART_TIME > 0
    518          
    519              #ifdef FAN_MIN_PWM
    520                #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? ( FAN_MIN_PWM + (tail_fan_speed[f] * (255 - FAN_MIN_PWM)) / 255 ) : 0)
    521              #else
    522                #define CALC_FAN_SPEED(f) tail_fan_speed[f]
    523              #endif
    524          
    525              #if ENABLED(FAN_SOFT_PWM)
    526                #if HAS_FAN0
    527                  thermalManager.soft_pwm_amount_fan[0] = CALC_FAN_SPEED(0);
    528                #endif
    529                #if HAS_FAN1
    530                  thermalManager.soft_pwm_amount_fan[1] = CALC_FAN_SPEED(1);
    531                #endif
    532                #if HAS_FAN2
    533                  thermalManager.soft_pwm_amount_fan[2] = CALC_FAN_SPEED(2);
    534                #endif
    535              #else
    536                #if HAS_FAN0
    537                  //analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
    538                #endif
    539                #if HAS_FAN1
    540                  //analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
    541                #endif
    542                #if HAS_FAN2
    543                  //analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
    544                #endif
    545              #endif
    546          
    547            #endif // FAN_COUNT > 0
    548          
    549            #if ENABLED(AUTOTEMP)
    550              getHighESpeed();
   \                     ??check_axes_activity_6: (+1)
   \   0000003E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000042   0x....             B.N      _ZN7Planner13getHighESpeedEv
    551            #endif
    552          
    553            #if ENABLED(BARICUDA)
    554              #if HAS_HEATER_1
    555                analogWrite(HEATER_1_PIN, tail_valve_pressure);
    556              #endif
    557              #if HAS_HEATER_2
    558                analogWrite(HEATER_2_PIN, tail_e_to_p_pressure);
    559              #endif
    560            #endif
    561          }
    562          
    563          #if DISABLED(NO_VOLUMETRICS)
    564          
    565            /**
    566             * Get a volumetric multiplier from a filament diameter.
    567             * This is the reciprocal of the circular cross-section area.
    568             * Return 1.0 with volumetric off or a diameter of 0.0.
    569             */

   \                                 In section .text, align 4
    570            inline float calculate_volumetric_multiplier(const float &diameter) {
   \                     _Z31calculate_volumetric_multiplierRKf: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B04      VPUSH    {D8-D9}
    571              return (parser.volumetric_enabled && diameter) ? 1.0 / CIRCLE_AREA(diameter * 0.5) : 1.0;
   \   00000006   0x4922             LDR.N    R1,??calculate_volumetric_multiplier_0+0x4
   \   00000008   0x7809             LDRB     R1,[R1, #+0]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD039             BEQ.N    ??calculate_volumetric_multiplier_1
   \   0000000E   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000012   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000016   0xEEF1 0xFA10      FMSTAT   
   \   0000001A   0xD032             BEQ.N    ??calculate_volumetric_multiplier_1
   \   0000001C   0xEE10 0x0A10      VMOV     R0,S0
   \   00000020   0x.... 0x....      BL       __aeabi_f2d
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x4B1B             LDR.N    R3,??calculate_volumetric_multiplier_0+0x8  ;; 0x3fe00000
   \   00000028   0x.... 0x....      BL       __aeabi_dmul
   \   0000002C   0xEC41 0x0B18      VMOV     D8,R0,R1
   \   00000030   0x2402             MOVS     R4,#+2
   \   00000032   0xED9F 0x9B19      VLDR.W   D9,??calculate_volumetric_multiplier_0+0xC
   \   00000036   0xE007             B.N      ??calculate_volumetric_multiplier_2
   \                     ??calculate_volumetric_multiplier_3: (+1)
   \   00000038   0xEC51 0x0B18      VMOV     R0,R1,D8
   \   0000003C   0xEC53 0x2B18      VMOV     R2,R3,D8
   \   00000040   0x.... 0x....      BL       __aeabi_dmul
   \   00000044   0xEC41 0x0B18      VMOV     D8,R0,R1
   \                     ??calculate_volumetric_multiplier_2: (+1)
   \   00000048   0x07E0             LSLS     R0,R4,#+31
   \   0000004A   0xD507             BPL.N    ??calculate_volumetric_multiplier_4
   \   0000004C   0xEC51 0x0B19      VMOV     R0,R1,D9
   \   00000050   0xEC53 0x2B18      VMOV     R2,R3,D8
   \   00000054   0x.... 0x....      BL       __aeabi_dmul
   \   00000058   0xEC41 0x0B19      VMOV     D9,R0,R1
   \                     ??calculate_volumetric_multiplier_4: (+1)
   \   0000005C   0x0864             LSRS     R4,R4,#+1
   \   0000005E   0xD1EB             BNE.N    ??calculate_volumetric_multiplier_3
   \   00000060   0xEC53 0x2B19      VMOV     R2,R3,D9
   \   00000064   0x480E             LDR.N    R0,??calculate_volumetric_multiplier_0+0x14  ;; 0x54442d18
   \   00000066   0x490F             LDR.N    R1,??calculate_volumetric_multiplier_0+0x18  ;; 0x400921fb
   \   00000068   0x.... 0x....      BL       __aeabi_dmul
   \   0000006C   0x4602             MOV      R2,R0
   \   0000006E   0x460B             MOV      R3,R1
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x4906             LDR.N    R1,??calculate_volumetric_multiplier_0  ;; 0x3ff00000
   \   00000074   0x.... 0x....      BL       __aeabi_ddiv
   \   00000078   0x.... 0x....      BL       __aeabi_d2f
   \   0000007C   0xEE00 0x0A10      VMOV     S0,R0
   \   00000080   0xE001             B.N      ??calculate_volumetric_multiplier_5
   \                     ??calculate_volumetric_multiplier_1: (+1)
   \   00000082   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \                     ??calculate_volumetric_multiplier_5: (+1)
   \   00000086   0xECBD 0x8B04      VPOP     {D8-D9}
   \   0000008A   0xBD10             POP      {R4,PC}          ;; return
   \                     ??calculate_volumetric_multiplier_0:
   \   0000008C   0x3FF00000         DC32     0x3ff00000
   \   00000090   0x........         DC32     _ZN11GCodeParser18volumetric_enabledE
   \   00000094   0x3FE00000         DC32     0x3fe00000
   \   00000098   0x00000000         DC32     0x0,0x3FF00000
   \              0x3FF00000   
   \   000000A0   0x54442D18         DC32     0x54442d18
   \   000000A4   0x400921FB         DC32     0x400921fb
    572            }
    573          
    574            /**
    575             * Convert the filament sizes into volumetric multipliers.
    576             * The multiplier converts a given E value into a length.
    577             */

   \                                 In section .text, align 2, keep-with-next
    578            void Planner::calculate_volumetric_multipliers() {
   \                     _ZN7Planner32calculate_volumetric_multipliersEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    579              for (uint8_t i = 0; i < COUNT(filament_size); i++) {
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable17_8
   \   00000008   0xE009             B.N      ??calculate_volumetric_multipliers_0
    580                volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
   \                     ??calculate_volumetric_multipliers_1: (+1)
   \   0000000A   0xF104 0x0008      ADD      R0,R4,#+8
   \   0000000E   0x.... 0x....      BL       _Z31calculate_volumetric_multiplierRKf
   \   00000012   0xED84 0x0A01      VSTR     S0,[R4, #+4]
    581                refresh_e_factor(i);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       _ZN7Planner16refresh_e_factorEh
    582              }
   \   0000001C   0x2001             MOVS     R0,#+1
   \                     ??calculate_volumetric_multipliers_0: (+1)
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD0F3             BEQ.N    ??calculate_volumetric_multipliers_1
    583            }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    584          
    585          #endif // !NO_VOLUMETRICS
    586          
    587          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    588            /**
    589             * Convert the ratio value given by the filament width sensor
    590             * into a volumetric multiplier. Conversion differs when using
    591             * linear extrusion vs volumetric extrusion.
    592             */
    593            void Planner::calculate_volumetric_for_width_sensor(const int8_t encoded_ratio) {
    594              // Reconstitute the nominal/measured ratio
    595              const float nom_meas_ratio = 1.0 + 0.01 * encoded_ratio,
    596                          ratio_2 = sq(nom_meas_ratio);
    597          
    598              volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = parser.volumetric_enabled
    599                ? ratio_2 / CIRCLE_AREA(filament_width_nominal * 0.5) // Volumetric uses a true volumetric multiplier
    600                : ratio_2;                                            // Linear squares the ratio, which scales the volume
    601          
    602              refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
    603            }
    604          #endif
    605          
    606          #if PLANNER_LEVELING
    607            /**
    608             * rx, ry, rz - Cartesian positions in mm
    609             *              Leveled XYZ on completion
    610             */
    611            void Planner::apply_leveling(float &rx, float &ry, float &rz) {
    612          
    613              #if ENABLED(SKEW_CORRECTION)
    614                skew(rx, ry, rz);
    615              #endif
    616          
    617              if (!leveling_active) return;
    618          
    619              #if ABL_PLANAR
    620          
    621                float dx = rx - (X_TILT_FULCRUM),
    622                      dy = ry - (Y_TILT_FULCRUM);
    623          
    624                apply_rotation_xyz(bed_level_matrix, dx, dy, rz);
    625          
    626                rx = dx + X_TILT_FULCRUM;
    627                ry = dy + Y_TILT_FULCRUM;
    628          
    629              #else
    630          
    631                #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    632                  const float fade_scaling_factor = fade_scaling_factor_for_z(rz);
    633                  if (!fade_scaling_factor) return;
    634                #elif HAS_MESH
    635                  constexpr float fade_scaling_factor = 1.0;
    636                #endif
    637          
    638                #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
    639                  const float raw[XYZ] = { rx, ry, 0 };
    640                #endif
    641          
    642                rz += (
    643                  #if ENABLED(AUTO_BED_LEVELING_UBL)
    644                    ubl.get_z_correction(rx, ry) * fade_scaling_factor
    645                  #elif ENABLED(MESH_BED_LEVELING)
    646                    mbl.get_z(rx, ry
    647                      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    648                        , fade_scaling_factor
    649                      #endif
    650                    )
    651                  #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
    652                    bilinear_z_offset(raw) * fade_scaling_factor
    653                  #else
    654                    0
    655                  #endif
    656                );
    657          
    658              #endif
    659            }
    660          
    661            void Planner::unapply_leveling(float raw[XYZ]) {
    662          
    663              #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    664                const float fade_scaling_factor = fade_scaling_factor_for_z(raw[Z_AXIS]);
    665              #else
    666                constexpr float fade_scaling_factor = 1.0;
    667              #endif
    668          
    669              if (leveling_active && fade_scaling_factor) {
    670          
    671                #if ABL_PLANAR
    672          
    673                  matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
    674          
    675                  float dx = raw[X_AXIS] - (X_TILT_FULCRUM),
    676                        dy = raw[Y_AXIS] - (Y_TILT_FULCRUM);
    677          
    678                  apply_rotation_xyz(inverse, dx, dy, raw[Z_AXIS]);
    679          
    680                  raw[X_AXIS] = dx + X_TILT_FULCRUM;
    681                  raw[Y_AXIS] = dy + Y_TILT_FULCRUM;
    682          
    683                #else // !ABL_PLANAR
    684          
    685                  raw[Z_AXIS] -= (
    686                    #if ENABLED(AUTO_BED_LEVELING_UBL)
    687                      ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]) * fade_scaling_factor
    688                    #elif ENABLED(MESH_BED_LEVELING)
    689                      mbl.get_z(raw[X_AXIS], raw[Y_AXIS]
    690                        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    691                          , fade_scaling_factor
    692                        #endif
    693                      )
    694                    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
    695                      bilinear_z_offset(raw) * fade_scaling_factor
    696                    #else
    697                      0
    698                    #endif
    699                  );
    700          
    701                #endif // !ABL_PLANAR
    702              }
    703          
    704              #if ENABLED(SKEW_CORRECTION)
    705                unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
    706              #endif
    707            }
    708          
    709          #endif // PLANNER_LEVELING
    710          
    711          /**
    712           * Planner::_buffer_steps
    713           *
    714           * Add a new linear movement to the buffer (in terms of steps).
    715           *
    716           *  target      - target position in steps units
    717           *  fr_mm_s     - (target) speed of the move
    718           *  extruder    - target extruder
    719           */

   \                                 In section .text, align 4, keep-with-next
    720          void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const uint8_t extruder) {
   \                     _ZN7Planner13_buffer_stepsERA4_Kifh: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000008   0xB08A             SUB      SP,SP,#+40
   \   0000000A   0x4682             MOV      R10,R0
   \   0000000C   0xEEF0 0x8A40      VMOV.F32 S17,S0
   \   00000010   0x460C             MOV      R4,R1
    721          
    722            const int32_t da = target[X_AXIS] - position[X_AXIS],
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable10_2
   \   00000016   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000001A   0x6B69             LDR      R1,[R5, #+52]
   \   0000001C   0x1A40             SUBS     R0,R0,R1
   \   0000001E   0x9001             STR      R0,[SP, #+4]
    723                          db = target[Y_AXIS] - position[Y_AXIS],
   \   00000020   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \   00000024   0x6BA9             LDR      R1,[R5, #+56]
   \   00000026   0xEBA0 0x0B01      SUB      R11,R0,R1
    724                          dc = target[Z_AXIS] - position[Z_AXIS];
   \   0000002A   0xF8DA 0x0008      LDR      R0,[R10, #+8]
   \   0000002E   0x6BE9             LDR      R1,[R5, #+60]
   \   00000030   0x1A40             SUBS     R0,R0,R1
   \   00000032   0x9000             STR      R0,[SP, #+0]
    725          
    726            int32_t de = target[E_AXIS] - position[E_AXIS];
   \   00000034   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \   00000038   0x6C29             LDR      R1,[R5, #+64]
   \   0000003A   0x1A46             SUBS     R6,R0,R1
    727          
    728            /* <-- add a slash to enable
    729              SERIAL_ECHOPAIR("  _buffer_steps FR:", fr_mm_s);
    730              SERIAL_ECHOPAIR(" A:", target[A_AXIS]);
    731              SERIAL_ECHOPAIR(" (", da);
    732              SERIAL_ECHOPAIR(" steps) B:", target[B_AXIS]);
    733              SERIAL_ECHOPAIR(" (", db);
    734              SERIAL_ECHOPAIR(" steps) C:", target[C_AXIS]);
    735              SERIAL_ECHOPAIR(" (", dc);
    736              SERIAL_ECHOPAIR(" steps) E:", target[E_AXIS]);
    737              SERIAL_ECHOPAIR(" (", de);
    738              SERIAL_ECHOLNPGM(" steps)");
    739            //*/
                    ^
Warning[Pe009]: nested comment is not allowed
    740          
    741            // If LIN_ADVANCE is disabled then do E move prevention with integers
    742            // Otherwise it's done in _buffer_segment.
    743            #if DISABLED(LIN_ADVANCE) && (ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE))
    744              if (de) {
   \   0000003C   0xD026             BEQ.N    ??_buffer_steps_0
    745                #if ENABLED(PREVENT_COLD_EXTRUSION)
    746                  if (thermalManager.tooColdToExtrude(extruder)) {
    747                    position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
    748                    de = 0; // no difference
    749                    SERIAL_ECHO_START();
    750                    SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
    751                  }
    752                #endif // PREVENT_COLD_EXTRUSION
    753                #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
    754                  if (labs(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000003E   0xEE00 0x6A10      VMOV     S0,R6
   \   00000042   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000046   0xB2E4             UXTB     R4,R4
   \   00000048   0xEB05 0x0084      ADD      R0,R5,R4, LSL #+2
   \   0000004C   0xEDD0 0x0A11      VLDR     S1,[R0, #+68]
   \   00000050   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000054   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000058   0xEE10 0x0A10      VMOV     R0,S0
   \   0000005C   0x.... 0x....      BL       labs
   \   00000060   0xED95 0x0A04      VLDR     S0,[R5, #+16]
   \   00000064   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000068   0xEE10 0x1A10      VMOV     R1,S0
   \   0000006C   0x22C8             MOVS     R2,#+200
   \   0000006E   0x4351             MULS     R1,R2,R1
   \   00000070   0x4281             CMP      R1,R0
   \   00000072   0xDA0B             BGE.N    ??_buffer_steps_0
    755                    position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
   \   00000074   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \   00000078   0x6428             STR      R0,[R5, #+64]
    756                    de = 0; // no difference
   \   0000007A   0x2600             MOVS     R6,#+0
    757                    SERIAL_ECHO_START();
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \   00000080   0x.... 0x....      BL       _Z14serialprintPGMPKc
    758                    SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
   \   00000084   0x.... 0x....      ADR.W    R0,`?<Constant " too long extrusion p...">`
   \   00000088   0x.... 0x....      BL       _Z14serialprintPGMPKc
    759                  }
    760                #endif // PREVENT_LENGTHY_EXTRUDE
    761              }
    762            #endif // !LIN_ADVANCE && (PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE)
    763          
    764            // Compute direction bit-mask for this block
    765            uint8_t dm = 0;
   \                     ??_buffer_steps_0: (+1)
   \   0000008C   0x2700             MOVS     R7,#+0
    766            #if CORE_IS_XY
    767              if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
    768              if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
    769              if (dc < 0) SBI(dm, Z_AXIS);
    770              if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
    771              if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
    772            #elif CORE_IS_XZ
    773              if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
    774              if (db < 0) SBI(dm, Y_AXIS);
    775              if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
    776              if (da + dc < 0) SBI(dm, A_AXIS);           // Motor A direction
    777              if (CORESIGN(da - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
    778            #elif CORE_IS_YZ
    779              if (da < 0) SBI(dm, X_AXIS);
    780              if (db < 0) SBI(dm, Y_HEAD);                // Save the real Extruder (head) direction in Y Axis
    781              if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
    782              if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
    783              if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
    784            #else
    785              if (da < 0) SBI(dm, X_AXIS);
   \   0000008E   0x9801             LDR      R0,[SP, #+4]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD500             BPL.N    ??_buffer_steps_1
   \   00000094   0x2701             MOVS     R7,#+1
    786              if (db < 0) SBI(dm, Y_AXIS);
   \                     ??_buffer_steps_1: (+1)
   \   00000096   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000009A   0xD501             BPL.N    ??_buffer_steps_2
   \   0000009C   0xF047 0x0702      ORR      R7,R7,#0x2
    787              if (dc < 0) SBI(dm, Z_AXIS);
   \                     ??_buffer_steps_2: (+1)
   \   000000A0   0x9800             LDR      R0,[SP, #+0]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD501             BPL.N    ??_buffer_steps_3
   \   000000A6   0xF047 0x0704      ORR      R7,R7,#0x4
    788            #endif
    789            if (de < 0) SBI(dm, E_AXIS);
   \                     ??_buffer_steps_3: (+1)
   \   000000AA   0x2E00             CMP      R6,#+0
   \   000000AC   0xD501             BPL.N    ??_buffer_steps_4
   \   000000AE   0xF047 0x0708      ORR      R7,R7,#0x8
    790          
    791            const float esteps_float = de * e_factor[extruder];
   \                     ??_buffer_steps_4: (+1)
   \   000000B2   0xEE00 0x6A10      VMOV     S0,R6
   \   000000B6   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000BA   0xB2E4             UXTB     R4,R4
   \   000000BC   0xEB05 0x0084      ADD      R0,R5,R4, LSL #+2
   \   000000C0   0xEDD0 0x0A11      VLDR     S1,[R0, #+68]
   \   000000C4   0xEE20 0x8A20      VMUL.F32 S16,S0,S1
    792            const int32_t esteps = abs(esteps_float) + 0.5;
                                          ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000000C8   0xEE18 0x0A10      VMOV     R0,S16
   \   000000CC   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   000000D0   0x.... 0x....      BL       __aeabi_f2d
   \   000000D4   0x2200             MOVS     R2,#+0
   \   000000D6   0x.... 0x....      LDR.W    R3,??DataTable17_10  ;; 0x3fe00000
   \   000000DA   0x.... 0x....      BL       __aeabi_dadd
   \   000000DE   0x.... 0x....      BL       __aeabi_d2iz
   \   000000E2   0x4681             MOV      R9,R0
    793          
    794            // Calculate the buffer head after we push this byte
    795            const uint8_t next_buffer_head = next_block_index(block_buffer_head);
   \   000000E4   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   000000E8   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \   000000EC   0x4680             MOV      R8,R0
   \   000000EE   0xFA5F 0xF888      UXTB     R8,R8
   \   000000F2   0xE001             B.N      ??_buffer_steps_5
    796          
    797            // If the buffer is full: good! That means we are well ahead of the robot.
    798            // Rest here until there is room in the buffer.
    799            while (block_buffer_tail == next_buffer_head) idle();
   \                     ??_buffer_steps_6: (+1)
   \   000000F4   0x.... 0x....      BL       _Z4idlev
   \                     ??_buffer_steps_5: (+1)
   \   000000F8   0x7868             LDRB     R0,[R5, #+1]
   \   000000FA   0x4540             CMP      R0,R8
   \   000000FC   0xD0FA             BEQ.N    ??_buffer_steps_6
    800          
    801            // Prepare to set up new block
    802            block_t* block = &block_buffer[block_buffer_head];
   \   000000FE   0x7828             LDRB     R0,[R5, #+0]
   \   00000100   0x2154             MOVS     R1,#+84
   \   00000102   0x.... 0x....      LDR.W    R2,??DataTable16
   \   00000106   0xFB11 0x2600      SMLABB   R6,R1,R0,R2
    803          
    804            // Clear all flags, including the "busy" bit
    805            block->flag = 0x00;
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x7030             STRB     R0,[R6, #+0]
    806          
    807            // Set direction bits
    808            block->direction_bits = dm;
   \   0000010E   0xF886 0x7024      STRB     R7,[R6, #+36]
    809          
    810            // Number of steps for each axis
    811            // See http://www.corexy.com/theory.html
    812            #if CORE_IS_XY
    813              block->steps[A_AXIS] = labs(da + db);
    814              block->steps[B_AXIS] = labs(da - db);
    815              block->steps[Z_AXIS] = labs(dc);
    816            #elif CORE_IS_XZ
    817              block->steps[A_AXIS] = labs(da + dc);
    818              block->steps[Y_AXIS] = labs(db);
    819              block->steps[C_AXIS] = labs(da - dc);
    820            #elif CORE_IS_YZ
    821              block->steps[X_AXIS] = labs(da);
    822              block->steps[B_AXIS] = labs(db + dc);
    823              block->steps[C_AXIS] = labs(db - dc);
    824            #else
    825              // default non-h-bot planning
    826              block->steps[X_AXIS] = labs(da);
   \   00000112   0x9801             LDR      R0,[SP, #+4]
   \   00000114   0x.... 0x....      BL       labs
   \   00000118   0x6070             STR      R0,[R6, #+4]
    827              block->steps[Y_AXIS] = labs(db);
   \   0000011A   0x4658             MOV      R0,R11
   \   0000011C   0x.... 0x....      BL       labs
   \   00000120   0x60B0             STR      R0,[R6, #+8]
    828              block->steps[Z_AXIS] = labs(dc);
   \   00000122   0x9800             LDR      R0,[SP, #+0]
   \   00000124   0x.... 0x....      BL       labs
   \   00000128   0x60F0             STR      R0,[R6, #+12]
    829            #endif
    830          
    831            block->steps[E_AXIS] = esteps;
   \   0000012A   0xF8C6 0x9010      STR      R9,[R6, #+16]
    832            block->step_event_count = MAX4(block->steps[X_AXIS], block->steps[Y_AXIS], block->steps[Z_AXIS], esteps);
   \   0000012E   0x6870             LDR      R0,[R6, #+4]
   \   00000130   0x68B1             LDR      R1,[R6, #+8]
   \   00000132   0x460A             MOV      R2,R1
   \   00000134   0x4281             CMP      R1,R0
   \   00000136   0xDA00             BGE.N    ??_buffer_steps_7
   \   00000138   0x4602             MOV      R2,R0
   \                     ??_buffer_steps_7: (+1)
   \   0000013A   0x68F3             LDR      R3,[R6, #+12]
   \   0000013C   0x4293             CMP      R3,R2
   \   0000013E   0xDA01             BGE.N    ??_buffer_steps_8
   \   00000140   0x4617             MOV      R7,R2
   \   00000142   0xE000             B.N      ??_buffer_steps_9
   \                     ??_buffer_steps_8: (+1)
   \   00000144   0x461F             MOV      R7,R3
   \                     ??_buffer_steps_9: (+1)
   \   00000146   0x45B9             CMP      R9,R7
   \   00000148   0xDA07             BGE.N    ??_buffer_steps_10
   \   0000014A   0x4293             CMP      R3,R2
   \   0000014C   0xDA03             BGE.N    ??_buffer_steps_11
   \   0000014E   0x4281             CMP      R1,R0
   \   00000150   0xDB04             BLT.N    ??_buffer_steps_12
   \   00000152   0x4608             MOV      R0,R1
   \   00000154   0xE002             B.N      ??_buffer_steps_12
   \                     ??_buffer_steps_11: (+1)
   \   00000156   0x4618             MOV      R0,R3
   \   00000158   0xE000             B.N      ??_buffer_steps_12
   \                     ??_buffer_steps_10: (+1)
   \   0000015A   0x4648             MOV      R0,R9
   \                     ??_buffer_steps_12: (+1)
   \   0000015C   0x6170             STR      R0,[R6, #+20]
    833          
    834            // Bail if this is a zero-length block
    835            if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return;
   \   0000015E   0x2806             CMP      R0,#+6
   \   00000160   0xF0C0 0x8324      BCC.W    ??_buffer_steps_13
    836          
    837            // For a mixing extruder, get a magnified step_event_count for each
    838            #if ENABLED(MIXING_EXTRUDER)
    839              for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
    840                block->mix_event_count[i] = mixing_factor[i] * block->step_event_count;
    841            #endif
    842          
    843            #if FAN_COUNT > 0
    844              for (uint8_t i = 0; i < FAN_COUNT; i++) block->fan_speed[i] = fanSpeeds[i];
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0xE005             B.N      ??_buffer_steps_14
   \                     ??_buffer_steps_15: (+1)
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable17_11
   \   0000016C   0x6800             LDR      R0,[R0, #+0]
   \   0000016E   0xF8A6 0x004C      STRH     R0,[R6, #+76]
   \   00000172   0x2001             MOVS     R0,#+1
   \                     ??_buffer_steps_14: (+1)
   \   00000174   0x2800             CMP      R0,#+0
   \   00000176   0xD0F7             BEQ.N    ??_buffer_steps_15
    845            #endif
    846          
    847            #if ENABLED(BARICUDA)
    848              block->valve_pressure = baricuda_valve_pressure;
    849              block->e_to_p_pressure = baricuda_e_to_p_pressure;
    850            #endif
    851          
    852            block->active_extruder = extruder;
   \   00000178   0x7074             STRB     R4,[R6, #+1]
    853          
    854            //enable active axes
    855            #if CORE_IS_XY
    856              if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
    857                enable_X();
    858                enable_Y();
    859              }
    860              #if DISABLED(Z_LATE_ENABLE)
    861                if (block->steps[Z_AXIS]) enable_Z();
    862              #endif
    863            #elif CORE_IS_XZ
    864              if (block->steps[A_AXIS] || block->steps[C_AXIS]) {
    865                enable_X();
    866                enable_Z();
    867              }
    868              if (block->steps[Y_AXIS]) enable_Y();
    869            #elif CORE_IS_YZ
    870              if (block->steps[B_AXIS] || block->steps[C_AXIS]) {
    871                enable_Y();
    872                enable_Z();
    873              }
    874              if (block->steps[X_AXIS]) enable_X();
    875            #else
    876              if (block->steps[X_AXIS]) enable_X();
    877              if (block->steps[Y_AXIS]) enable_Y();
    878              #if DISABLED(Z_LATE_ENABLE)
    879                if (block->steps[Z_AXIS]) enable_Z();
   \   0000017A   0x68F0             LDR      R0,[R6, #+12]
   \   0000017C   0x2800             CMP      R0,#+0
   \   0000017E   0xD008             BEQ.N    ??_buffer_steps_16
   \   00000180   0x2200             MOVS     R2,#+0
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable17_12
   \   00000186   0x8881             LDRH     R1,[R0, #+4]
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable17_13
   \   0000018C   0x6880             LDR      R0,[R0, #+8]
   \   0000018E   0x.... 0x....      BL       HAL_GPIO_WritePin
    880              #endif
    881            #endif
    882          
    883            // Enable extruder(s)
    884            if (esteps) {
   \                     ??_buffer_steps_16: (+1)
   \   00000192   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000196   0xD010             BEQ.N    ??_buffer_steps_17
    885          
    886              #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
    887          
    888                #define DISABLE_IDLE_E(N) if (!g_uc_extruder_last_move[N]) disable_E##N();
    889          
    890                for (uint8_t i = 0; i < EXTRUDERS; i++)
   \   00000198   0x2000             MOVS     R0,#+0
   \   0000019A   0x.... 0x....      LDR.W    R7,??DataTable17_14
   \   0000019E   0xE005             B.N      ??_buffer_steps_18
    891                  if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
   \                     ??_buffer_steps_19: (+1)
   \   000001A0   0x7838             LDRB     R0,[R7, #+0]
   \   000001A2   0x2800             CMP      R0,#+0
   \   000001A4   0xD001             BEQ.N    ??_buffer_steps_20
   \   000001A6   0x1E40             SUBS     R0,R0,#+1
   \   000001A8   0x7038             STRB     R0,[R7, #+0]
   \                     ??_buffer_steps_20: (+1)
   \   000001AA   0x2001             MOVS     R0,#+1
   \                     ??_buffer_steps_18: (+1)
   \   000001AC   0x2800             CMP      R0,#+0
   \   000001AE   0xD0F7             BEQ.N    ??_buffer_steps_19
    892          
    893                switch(extruder) {
   \   000001B0   0x2C00             CMP      R4,#+0
   \   000001B2   0xD102             BNE.N    ??_buffer_steps_17
    894                  case 0:
    895                    enable_E0();
    896                    g_uc_extruder_last_move[0] = (BLOCK_BUFFER_SIZE) * 2;
   \   000001B4   0x2020             MOVS     R0,#+32
   \   000001B6   0x4639             MOV      R1,R7
   \   000001B8   0x7008             STRB     R0,[R1, #+0]
    897                    #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
    898                      if (extruder_duplication_enabled) {
    899                        enable_E1();
    900                        g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
    901                      }
    902                    #endif
    903                    #if EXTRUDERS > 1
    904                      DISABLE_IDLE_E(1);
    905                      #if EXTRUDERS > 2
    906                        DISABLE_IDLE_E(2);
    907                        #if EXTRUDERS > 3
    908                          DISABLE_IDLE_E(3);
    909                          #if EXTRUDERS > 4
    910                            DISABLE_IDLE_E(4);
    911                          #endif // EXTRUDERS > 4
    912                        #endif // EXTRUDERS > 3
    913                      #endif // EXTRUDERS > 2
    914                    #endif // EXTRUDERS > 1
    915                  break;
    916                  #if EXTRUDERS > 1
    917                    case 1:
    918                      enable_E1();
    919                      g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
    920                      DISABLE_IDLE_E(0);
    921                      #if EXTRUDERS > 2
    922                        DISABLE_IDLE_E(2);
    923                        #if EXTRUDERS > 3
    924                          DISABLE_IDLE_E(3);
    925                          #if EXTRUDERS > 4
    926                            DISABLE_IDLE_E(4);
    927                          #endif // EXTRUDERS > 4
    928                        #endif // EXTRUDERS > 3
    929                      #endif // EXTRUDERS > 2
    930                    break;
    931                    #if EXTRUDERS > 2
    932                      case 2:
    933                        enable_E2();
    934                        g_uc_extruder_last_move[2] = (BLOCK_BUFFER_SIZE) * 2;
    935                        DISABLE_IDLE_E(0);
    936                        DISABLE_IDLE_E(1);
    937                        #if EXTRUDERS > 3
    938                          DISABLE_IDLE_E(3);
    939                          #if EXTRUDERS > 4
    940                            DISABLE_IDLE_E(4);
    941                          #endif
    942                        #endif
    943                      break;
    944                      #if EXTRUDERS > 3
    945                        case 3:
    946                          enable_E3();
    947                          g_uc_extruder_last_move[3] = (BLOCK_BUFFER_SIZE) * 2;
    948                          DISABLE_IDLE_E(0);
    949                          DISABLE_IDLE_E(1);
    950                          DISABLE_IDLE_E(2);
    951                          #if EXTRUDERS > 4
    952                            DISABLE_IDLE_E(4);
    953                          #endif
    954                        break;
    955                        #if EXTRUDERS > 4
    956                          case 4:
    957                            enable_E4();
    958                            g_uc_extruder_last_move[4] = (BLOCK_BUFFER_SIZE) * 2;
    959                            DISABLE_IDLE_E(0);
    960                            DISABLE_IDLE_E(1);
    961                            DISABLE_IDLE_E(2);
    962                            DISABLE_IDLE_E(3);
    963                          break;
    964                        #endif // EXTRUDERS > 4
    965                      #endif // EXTRUDERS > 3
    966                    #endif // EXTRUDERS > 2
    967                  #endif // EXTRUDERS > 1
    968                }
    969              #else
    970                enable_E0();
    971                enable_E1();
    972                enable_E2();
    973                enable_E3();
    974                enable_E4();
    975              #endif
    976            }
    977          
    978            if (esteps)
   \                     ??_buffer_steps_17: (+1)
   \   000001BA   0x.... 0x....      LDR.W    R7,??DataTable17_14
   \   000001BE   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001C2   0xD009             BEQ.N    ??_buffer_steps_21
    979              NOLESS(fr_mm_s, min_feedrate_mm_s);
   \   000001C4   0xED97 0x0A05      VLDR     S0,[R7, #+20]
   \   000001C8   0xEEF4 0x8A40      VCMP.F32 S17,S0
   \   000001CC   0xEEF1 0xFA10      FMSTAT   
   \   000001D0   0xD50B             BPL.N    ??_buffer_steps_22
   \   000001D2   0xEEF0 0x8A40      VMOV.F32 S17,S0
   \   000001D6   0xE008             B.N      ??_buffer_steps_22
    980            else
    981              NOLESS(fr_mm_s, min_travel_feedrate_mm_s);
   \                     ??_buffer_steps_21: (+1)
   \   000001D8   0xED97 0x0A0D      VLDR     S0,[R7, #+52]
   \   000001DC   0xEEF4 0x8A40      VCMP.F32 S17,S0
   \   000001E0   0xEEF1 0xFA10      FMSTAT   
   \   000001E4   0xD501             BPL.N    ??_buffer_steps_22
   \   000001E6   0xEEF0 0x8A40      VMOV.F32 S17,S0
    982          
    983            /**
    984             * This part of the code calculates the total length of the movement.
    985             * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
    986             * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
    987             * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
    988             * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
    989             * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
    990             */
    991            #if IS_CORE
    992              float delta_mm[Z_HEAD + 1];
    993              #if CORE_IS_XY
    994                delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
    995                delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
    996                delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
    997                delta_mm[A_AXIS] = (da + db) * steps_to_mm[A_AXIS];
    998                delta_mm[B_AXIS] = CORESIGN(da - db) * steps_to_mm[B_AXIS];
    999              #elif CORE_IS_XZ
   1000                delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
   1001                delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
   1002                delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
   1003                delta_mm[A_AXIS] = (da + dc) * steps_to_mm[A_AXIS];
   1004                delta_mm[C_AXIS] = CORESIGN(da - dc) * steps_to_mm[C_AXIS];
   1005              #elif CORE_IS_YZ
   1006                delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
   1007                delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
   1008                delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
   1009                delta_mm[B_AXIS] = (db + dc) * steps_to_mm[B_AXIS];
   1010                delta_mm[C_AXIS] = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
   1011              #endif
   1012            #else
   1013              float delta_mm[XYZE];
   1014              delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
   \                     ??_buffer_steps_22: (+1)
   \   000001EA   0xED9D 0x0A01      VLDR     S0,[SP, #+4]
   \   000001EE   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000001F2   0xEDD5 0x0A05      VLDR     S1,[R5, #+20]
   \   000001F6   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000001FA   0xED8D 0x0A06      VSTR     S0,[SP, #+24]
   1015              delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
   \   000001FE   0xEE00 0xBA10      VMOV     S0,R11
   \   00000202   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000206   0xEDD5 0x0A06      VLDR     S1,[R5, #+24]
   \   0000020A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000020E   0xF10D 0x0B18      ADD      R11,SP,#+24
   \   00000212   0xED8B 0x0A01      VSTR     S0,[R11, #+4]
   1016              delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
   \   00000216   0xEDDD 0x0A00      VLDR     S1,[SP, #+0]
   \   0000021A   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000021E   0xED95 0x1A07      VLDR     S2,[R5, #+28]
   \   00000222   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   00000226   0xEDCB 0x0A02      VSTR     S1,[R11, #+8]
   1017            #endif
   1018            delta_mm[E_AXIS] = esteps_float * steps_to_mm[E_AXIS_N];
   \   0000022A   0xED95 0x1A08      VLDR     S2,[R5, #+32]
   \   0000022E   0xEE28 0x1A01      VMUL.F32 S2,S16,S2
   \   00000232   0xED8B 0x1A03      VSTR     S2,[R11, #+12]
   1019          
   1020            if (block->steps[X_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[Y_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[Z_AXIS] < MIN_STEPS_PER_SEGMENT) {
   \   00000236   0x6870             LDR      R0,[R6, #+4]
   \   00000238   0x2806             CMP      R0,#+6
   \   0000023A   0xDA0A             BGE.N    ??_buffer_steps_23
   \   0000023C   0x68B0             LDR      R0,[R6, #+8]
   \   0000023E   0x2806             CMP      R0,#+6
   \   00000240   0xDA07             BGE.N    ??_buffer_steps_23
   \   00000242   0x68F0             LDR      R0,[R6, #+12]
   \   00000244   0x2806             CMP      R0,#+6
   \   00000246   0xDA04             BGE.N    ??_buffer_steps_23
   1021              block->millimeters = FABS(delta_mm[E_AXIS]);
   \   00000248   0xEEB0 0x0AC1      VABS.F32 S0,S2
   \   0000024C   0xED86 0x0A0D      VSTR     S0,[R6, #+52]
   \   00000250   0xE02D             B.N      ??_buffer_steps_24
   1022            }
   1023            else {
   1024              block->millimeters = SQRT(
   1025                #if CORE_IS_XY 
   1026                  sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
   1027                #elif CORE_IS_XZ 
   1028                  sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
   1029                #elif CORE_IS_YZ 
   1030                  sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
   1031                #else
   1032                  sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
   1033                #endif
   1034              );
   \                     ??_buffer_steps_23: (+1)
   \   00000252   0xED9D 0x1A06      VLDR     S2,[SP, #+24]
   \   00000256   0x2002             MOVS     R0,#+2
   \   00000258   0xEEB7 0x8A00      VMOV.F32 S16,#1.0
   \   0000025C   0xEEF0 0x1A48      VMOV.F32 S3,S16
   \   00000260   0xE001             B.N      ??_buffer_steps_25
   \                     ??_buffer_steps_26: (+1)
   \   00000262   0xEE21 0x1A01      VMUL.F32 S2,S2,S2
   \                     ??_buffer_steps_25: (+1)
   \   00000266   0x07C1             LSLS     R1,R0,#+31
   \   00000268   0xD501             BPL.N    ??_buffer_steps_27
   \   0000026A   0xEE61 0x1A81      VMUL.F32 S3,S3,S2
   \                     ??_buffer_steps_27: (+1)
   \   0000026E   0x0840             LSRS     R0,R0,#+1
   \   00000270   0xD1F7             BNE.N    ??_buffer_steps_26
   \   00000272   0x2002             MOVS     R0,#+2
   \   00000274   0xEEB0 0x1A48      VMOV.F32 S2,S16
   \   00000278   0xE001             B.N      ??_buffer_steps_28
   \                     ??_buffer_steps_29: (+1)
   \   0000027A   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \                     ??_buffer_steps_28: (+1)
   \   0000027E   0x07C1             LSLS     R1,R0,#+31
   \   00000280   0xD501             BPL.N    ??_buffer_steps_30
   \   00000282   0xEE21 0x1A00      VMUL.F32 S2,S2,S0
   \                     ??_buffer_steps_30: (+1)
   \   00000286   0x0840             LSRS     R0,R0,#+1
   \   00000288   0xD1F7             BNE.N    ??_buffer_steps_29
   \   0000028A   0x2002             MOVS     R0,#+2
   \   0000028C   0xE001             B.N      ??_buffer_steps_31
   \                     ??_buffer_steps_32: (+1)
   \   0000028E   0xEE60 0x0AA0      VMUL.F32 S1,S1,S1
   \                     ??_buffer_steps_31: (+1)
   \   00000292   0x07C1             LSLS     R1,R0,#+31
   \   00000294   0xD501             BPL.N    ??_buffer_steps_33
   \   00000296   0xEE28 0x8A20      VMUL.F32 S16,S16,S1
   \                     ??_buffer_steps_33: (+1)
   \   0000029A   0x0840             LSRS     R0,R0,#+1
   \   0000029C   0xD1F7             BNE.N    ??_buffer_steps_32
   1035            }
   \   0000029E   0xEE31 0x0A81      VADD.F32 S0,S3,S2
   \   000002A2   0xEE30 0x0A08      VADD.F32 S0,S0,S16
   \   000002A6   0x.... 0x....      BL       sqrtf
   \   000002AA   0xED86 0x0A0D      VSTR     S0,[R6, #+52]
   1036            const float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
   \                     ??_buffer_steps_24: (+1)
   \   000002AE   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   000002B2   0xEDD6 0x0A0D      VLDR     S1,[R6, #+52]
   \   000002B6   0xEE80 0x9A20      VDIV.F32 S18,S0,S1
   1037          
   1038            // Calculate inverse time for this move. No divide by zero due to previous checks.
   1039            // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   1040            float inverse_secs = fr_mm_s * inverse_millimeters;
   \   000002BA   0xEE68 0x8A89      VMUL.F32 S17,S17,S18
   1041          
   1042            const uint8_t moves_queued = movesplanned();
   \   000002BE   0x.... 0x....      BL       _ZN7Planner12movesplannedEv
   \   000002C2   0x4604             MOV      R4,R0
   1043          
   1044            // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   1045            #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
   1046              // Segment time im micro seconds
   1047              uint32_t segment_time_us = LROUND(1000000.0 / inverse_secs);
   1048            #endif
   1049          
   1050            #if ENABLED(SLOWDOWN)
   1051              if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
   1052                if (segment_time_us < min_segment_time_us) {
   1053                  // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
   1054                  const uint32_t nst = segment_time_us + LROUND(2 * (min_segment_time_us - segment_time_us) / moves_queued);
   1055                  inverse_secs = 1000000.0 / nst;
   1056                  #if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
   1057                    segment_time_us = nst;
   1058                  #endif
   1059                }
   1060              }
   1061            #endif
   1062          
   1063            #if ENABLED(ULTRA_LCD)
   1064              CRITICAL_SECTION_START
   1065                block_buffer_runtime_us += segment_time_us;
   1066              CRITICAL_SECTION_END
   1067            #endif
   1068          
   1069            block->nominal_speed = block->millimeters * inverse_secs;           //   (mm/sec) Always > 0
   \   000002C4   0xED96 0x0A0D      VLDR     S0,[R6, #+52]
   \   000002C8   0xEE20 0x0A28      VMUL.F32 S0,S0,S17
   \   000002CC   0xED86 0x0A0A      VSTR     S0,[R6, #+40]
   1070            block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
                                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000002D0   0xED96 0x0A05      VLDR     S0,[R6, #+20]
   \   000002D4   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   000002D8   0xEE20 0x0A28      VMUL.F32 S0,S0,S17
   \   000002DC   0x.... 0x....      BL       ceilf
   \   000002E0   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   000002E4   0xED86 0x0A0F      VSTR     S0,[R6, #+60]
   1071          
   1072            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1073              static float filwidth_e_count = 0, filwidth_delay_dist = 0;
   1074          
   1075              //FMM update ring buffer used for delay with filament measurements
   1076              if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && filwidth_delay_index[1] >= 0) {  //only for extruder with filament sensor and if ring buffer is initialized
   1077          
   1078                constexpr int MMD_CM = MAX_MEASUREMENT_DELAY + 1, MMD_MM = MMD_CM * 10;
   1079          
   1080                // increment counters with next move in e axis
   1081                filwidth_e_count += delta_mm[E_AXIS];
   1082                filwidth_delay_dist += delta_mm[E_AXIS];
   1083          
   1084                // Only get new measurements on forward E movement
   1085                if (!UNEAR_ZERO(filwidth_e_count)) {
   1086          
   1087                  // Loop the delay distance counter (modulus by the mm length)
   1088                  while (filwidth_delay_dist >= MMD_MM) filwidth_delay_dist -= MMD_MM;
   1089          
   1090                  // Convert into an index into the measurement array
   1091                  filwidth_delay_index[0] = int8_t(filwidth_delay_dist * 0.1);
   1092          
   1093                  // If the index has changed (must have gone forward)...
   1094                  if (filwidth_delay_index[0] != filwidth_delay_index[1]) {
   1095                    filwidth_e_count = 0; // Reset the E movement counter
   1096                    const int8_t meas_sample = thermalManager.widthFil_to_size_ratio();
   1097                    do {
   1098                      filwidth_delay_index[1] = (filwidth_delay_index[1] + 1) % MMD_CM; // The next unused slot
   1099                      measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
   1100                    } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
   1101                  }
   1102                }
   1103              }
   1104            #endif
   1105          
   1106            // Calculate and limit speed in mm/sec for each axis
   1107            float current_speed[NUM_AXIS], speed_factor = 1.0; // factor <1 decreases speed
   \   000002E8   0xEEB7 0x8A00      VMOV.F32 S16,#1.0
   \   000002EC   0xEEB0 0x0A48      VMOV.F32 S0,S16
   1108            LOOP_XYZE(i) {
   \   000002F0   0x2000             MOVS     R0,#+0
   \   000002F2   0xE01F             B.N      ??_buffer_steps_34
   1109              const float cs = FABS((current_speed[i] = delta_mm[i] * inverse_secs));
   \                     ??_buffer_steps_35: (+1)
   \   000002F4   0xEB0B 0x0180      ADD      R1,R11,R0, LSL #+2
   \   000002F8   0xEDD1 0x0A00      VLDR     S1,[R1, #0]
   \   000002FC   0xEE60 0x0AA8      VMUL.F32 S1,S1,S17
   \   00000300   0xA902             ADD      R1,SP,#+8
   \   00000302   0xEB01 0x0180      ADD      R1,R1,R0, LSL #+2
   \   00000306   0xEDC1 0x0A00      VSTR     S1,[R1, #0]
   \   0000030A   0xEEF0 0x0AE0      VABS.F32 S1,S1
   \   0000030E   0xEB07 0x0180      ADD      R1,R7,R0, LSL #+2
   \   00000312   0xED91 0x1A01      VLDR     S2,[R1, #+4]
   \   00000316   0xEEB4 0x1A60      VCMP.F32 S2,S1
   \   0000031A   0xEEF1 0xFA10      FMSTAT   
   \   0000031E   0xD508             BPL.N    ??_buffer_steps_36
   1110              #if ENABLED(DISTINCT_E_FACTORS)
   1111                if (i == E_AXIS) i += extruder;
   1112              #endif
   1113              if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   \   00000320   0xEEC1 0x0A20      VDIV.F32 S1,S2,S1
   \   00000324   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000328   0xEEF1 0xFA10      FMSTAT   
   \   0000032C   0xD501             BPL.N    ??_buffer_steps_36
   \   0000032E   0xEEB0 0x0A60      VMOV.F32 S0,S1
   1114            }
   \                     ??_buffer_steps_36: (+1)
   \   00000332   0x1C40             ADDS     R0,R0,#+1
   \                     ??_buffer_steps_34: (+1)
   \   00000334   0x2804             CMP      R0,#+4
   \   00000336   0xDBDD             BLT.N    ??_buffer_steps_35
   1115          
   1116            // Max segment time in µs.
   1117            #ifdef XY_FREQUENCY_LIMIT
   1118          
   1119              // Check and limit the xy direction change frequency
   1120              const unsigned char direction_change = block->direction_bits ^ old_direction_bits;
   1121              old_direction_bits = block->direction_bits;
   1122              segment_time_us = LROUND((float)segment_time_us / speed_factor);
   1123          
   1124              uint32_t xs0 = axis_segment_time_us[X_AXIS][0],
   1125                       xs1 = axis_segment_time_us[X_AXIS][1],
   1126                       xs2 = axis_segment_time_us[X_AXIS][2],
   1127                       ys0 = axis_segment_time_us[Y_AXIS][0],
   1128                       ys1 = axis_segment_time_us[Y_AXIS][1],
   1129                       ys2 = axis_segment_time_us[Y_AXIS][2];
   1130          
   1131              if (TEST(direction_change, X_AXIS)) {
   1132                xs2 = axis_segment_time_us[X_AXIS][2] = xs1;
   1133                xs1 = axis_segment_time_us[X_AXIS][1] = xs0;
   1134                xs0 = 0;
   1135              }
   1136              xs0 = axis_segment_time_us[X_AXIS][0] = xs0 + segment_time_us;
   1137          
   1138              if (TEST(direction_change, Y_AXIS)) {
   1139                ys2 = axis_segment_time_us[Y_AXIS][2] = axis_segment_time_us[Y_AXIS][1];
   1140                ys1 = axis_segment_time_us[Y_AXIS][1] = axis_segment_time_us[Y_AXIS][0];
   1141                ys0 = 0;
   1142              }
   1143              ys0 = axis_segment_time_us[Y_AXIS][0] = ys0 + segment_time_us;
   1144          
   1145              const uint32_t max_x_segment_time = MAX3(xs0, xs1, xs2),
   1146                             max_y_segment_time = MAX3(ys0, ys1, ys2),
   1147                             min_xy_segment_time = min(max_x_segment_time, max_y_segment_time);
   1148              if (min_xy_segment_time < MAX_FREQ_TIME_US) {
   1149                const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME_US);
   1150                NOMORE(speed_factor, low_sf);
   1151              }
   1152            #endif // XY_FREQUENCY_LIMIT
   1153          
   1154            // Correct the speed
   1155            if (speed_factor < 1.0) {
   \   00000338   0xEEF7 0x0A00      VMOV.F32 S1,#1.0
   \   0000033C   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000340   0xEEF1 0xFA10      FMSTAT   
   \   00000344   0xD51F             BPL.N    ??_buffer_steps_37
   1156              LOOP_XYZE(i) current_speed[i] *= speed_factor;
   \   00000346   0x2000             MOVS     R0,#+0
   \   00000348   0xE00B             B.N      ??_buffer_steps_38
   \                     ??_buffer_steps_39: (+1)
   \   0000034A   0xA902             ADD      R1,SP,#+8
   \   0000034C   0xEB01 0x0280      ADD      R2,R1,R0, LSL #+2
   \   00000350   0xEDD2 0x0A00      VLDR     S1,[R2, #0]
   \   00000354   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000358   0xEB01 0x0180      ADD      R1,R1,R0, LSL #+2
   \   0000035C   0xEDC1 0x0A00      VSTR     S1,[R1, #0]
   \   00000360   0x1C40             ADDS     R0,R0,#+1
   \                     ??_buffer_steps_38: (+1)
   \   00000362   0x2804             CMP      R0,#+4
   \   00000364   0xDBF1             BLT.N    ??_buffer_steps_39
   1157              block->nominal_speed *= speed_factor;
   \   00000366   0xEDD6 0x0A0A      VLDR     S1,[R6, #+40]
   \   0000036A   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   0000036E   0xEDC6 0x0A0A      VSTR     S1,[R6, #+40]
   1158              block->nominal_rate *= speed_factor;
   \   00000372   0xEDD6 0x0A0F      VLDR     S1,[R6, #+60]
   \   00000376   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   0000037A   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   0000037E   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   00000382   0xED86 0x0A0F      VSTR     S0,[R6, #+60]
   1159            }
   1160          
   1161            // Compute and limit the acceleration rate for the trapezoid generator.
   1162            const float steps_per_mm = block->step_event_count * inverse_millimeters;
   \                     ??_buffer_steps_37: (+1)
   \   00000386   0xED96 0x0A05      VLDR     S0,[R6, #+20]
   \   0000038A   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   0000038E   0xEE60 0x8A09      VMUL.F32 S17,S0,S18
   1163            uint32_t accel;
   1164            if (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS]) {
   \   00000392   0x6870             LDR      R0,[R6, #+4]
   \   00000394   0x2800             CMP      R0,#+0
   \   00000396   0xD110             BNE.N    ??_buffer_steps_40
   \   00000398   0x68B0             LDR      R0,[R6, #+8]
   \   0000039A   0x2800             CMP      R0,#+0
   \   0000039C   0xD10D             BNE.N    ??_buffer_steps_40
   \   0000039E   0x68F0             LDR      R0,[R6, #+12]
   \   000003A0   0x2800             CMP      R0,#+0
   \   000003A2   0xD10A             BNE.N    ??_buffer_steps_40
   1165              // convert to: acceleration steps/sec^2
   1166              accel = CEIL(retract_acceleration * steps_per_mm);
                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000003A4   0xED97 0x0A07      VLDR     S0,[R7, #+28]
   \   000003A8   0xEE20 0x0A28      VMUL.F32 S0,S0,S17
   \   000003AC   0x.... 0x....      BL       ceilf
   \   000003B0   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   000003B4   0xEE10 0x0A10      VMOV     R0,S0
   \   000003B8   0xE0DE             B.N      ??_buffer_steps_41
   1167            }
   1168            else {
   1169              #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
   1170                if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
   1171                  const uint32_t comp = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count; \
   1172                  if (accel * block->steps[AXIS] > comp) accel = comp / block->steps[AXIS]; \
   1173                } \
   1174              }while(0)
   1175          
   1176              #define LIMIT_ACCEL_FLOAT(AXIS,INDX) do{ \
   1177                if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
   1178                  const float comp = (float)max_acceleration_steps_per_s2[AXIS+INDX] * (float)block->step_event_count; \
   1179                  if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
   1180                } \
   1181              }while(0)
   1182          
   1183              // Start with print or travel acceleration
   1184              accel = CEIL((esteps ? acceleration : travel_acceleration) * steps_per_mm);
                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_40: (+1)
   \   000003BA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000003BE   0xD002             BEQ.N    ??_buffer_steps_42
   \   000003C0   0xED97 0x0A06      VLDR     S0,[R7, #+24]
   \   000003C4   0xE001             B.N      ??_buffer_steps_43
   \                     ??_buffer_steps_42: (+1)
   \   000003C6   0xED97 0x0A08      VLDR     S0,[R7, #+32]
   \                     ??_buffer_steps_43: (+1)
   \   000003CA   0xEE20 0x0A28      VMUL.F32 S0,S0,S17
   \   000003CE   0x.... 0x....      BL       ceilf
   \   000003D2   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   000003D6   0xEE10 0x0A10      VMOV     R0,S0
   1185          
   1186              #if ENABLED(DISTINCT_E_FACTORS)
   1187                #define ACCEL_IDX extruder
   1188              #else
   1189                #define ACCEL_IDX 0
   1190              #endif
   1191          
   1192              // Limit acceleration per axis
   1193              if (block->step_event_count <= cutoff_long) {
   \   000003DA   0x6872             LDR      R2,[R6, #+4]
   \   000003DC   0x6971             LDR      R1,[R6, #+20]
   \   000003DE   0x6E6B             LDR      R3,[R5, #+100]
   \   000003E0   0x428B             CMP      R3,R1
   \   000003E2   0xD336             BCC.N    ??_buffer_steps_44
   1194                LIMIT_ACCEL_LONG(X_AXIS, 0);
   \   000003E4   0x2A00             CMP      R2,#+0
   \   000003E6   0xD009             BEQ.N    ??_buffer_steps_45
   \   000003E8   0x6A6B             LDR      R3,[R5, #+36]
   \   000003EA   0x4283             CMP      R3,R0
   \   000003EC   0xD206             BCS.N    ??_buffer_steps_45
   \   000003EE   0x434B             MULS     R3,R1,R3
   \   000003F0   0xFB02 0xFC00      MUL      R12,R2,R0
   \   000003F4   0x4563             CMP      R3,R12
   \   000003F6   0xD201             BCS.N    ??_buffer_steps_45
   \   000003F8   0xFBB3 0xF0F2      UDIV     R0,R3,R2
   1195                LIMIT_ACCEL_LONG(Y_AXIS, 0);
   \                     ??_buffer_steps_45: (+1)
   \   000003FC   0x68B2             LDR      R2,[R6, #+8]
   \   000003FE   0x2A00             CMP      R2,#+0
   \   00000400   0xD009             BEQ.N    ??_buffer_steps_46
   \   00000402   0x6AAB             LDR      R3,[R5, #+40]
   \   00000404   0x4283             CMP      R3,R0
   \   00000406   0xD206             BCS.N    ??_buffer_steps_46
   \   00000408   0x434B             MULS     R3,R1,R3
   \   0000040A   0xFB02 0xFC00      MUL      R12,R2,R0
   \   0000040E   0x4563             CMP      R3,R12
   \   00000410   0xD201             BCS.N    ??_buffer_steps_46
   \   00000412   0xFBB3 0xF0F2      UDIV     R0,R3,R2
   1196                LIMIT_ACCEL_LONG(Z_AXIS, 0);
   \                     ??_buffer_steps_46: (+1)
   \   00000416   0x68F2             LDR      R2,[R6, #+12]
   \   00000418   0x2A00             CMP      R2,#+0
   \   0000041A   0xD009             BEQ.N    ??_buffer_steps_47
   \   0000041C   0x6AEB             LDR      R3,[R5, #+44]
   \   0000041E   0x4283             CMP      R3,R0
   \   00000420   0xD206             BCS.N    ??_buffer_steps_47
   \   00000422   0x434B             MULS     R3,R1,R3
   \   00000424   0xFB02 0xFC00      MUL      R12,R2,R0
   \   00000428   0x4563             CMP      R3,R12
   \   0000042A   0xD201             BCS.N    ??_buffer_steps_47
   \   0000042C   0xFBB3 0xF0F2      UDIV     R0,R3,R2
   1197                LIMIT_ACCEL_LONG(E_AXIS, ACCEL_IDX);
   \                     ??_buffer_steps_47: (+1)
   \   00000430   0x6932             LDR      R2,[R6, #+16]
   \   00000432   0x2A00             CMP      R2,#+0
   \   00000434   0xF000 0x80A0      BEQ.W    ??_buffer_steps_41
   \   00000438   0x6B2B             LDR      R3,[R5, #+48]
   \   0000043A   0x4283             CMP      R3,R0
   \   0000043C   0xF080 0x809C      BCS.W    ??_buffer_steps_41
   \   00000440   0x4359             MULS     R1,R1,R3
   \   00000442   0xFB02 0xF300      MUL      R3,R2,R0
   \   00000446   0x4299             CMP      R1,R3
   \   00000448   0xF080 0x8096      BCS.W    ??_buffer_steps_41
   \   0000044C   0xFBB1 0xF0F2      UDIV     R0,R1,R2
   \   00000450   0xE092             B.N      ??_buffer_steps_41
   1198              }
   1199              else {
   1200                LIMIT_ACCEL_FLOAT(X_AXIS, 0);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_44: (+1)
   \   00000452   0x2A00             CMP      R2,#+0
   \   00000454   0xD021             BEQ.N    ??_buffer_steps_48
   \   00000456   0x6A6B             LDR      R3,[R5, #+36]
   \   00000458   0x4283             CMP      R3,R0
   \   0000045A   0xD21E             BCS.N    ??_buffer_steps_48
   \   0000045C   0xEE00 0x3A10      VMOV     S0,R3
   \   00000460   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000464   0xEE00 0x1A90      VMOV     S1,R1
   \   00000468   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   0000046C   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000470   0xEE00 0x2A90      VMOV     S1,R2
   \   00000474   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000478   0xEE01 0x0A10      VMOV     S2,R0
   \   0000047C   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \   00000480   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   00000484   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   00000488   0xEEF1 0xFA10      FMSTAT   
   \   0000048C   0xD505             BPL.N    ??_buffer_steps_48
   \   0000048E   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000492   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   00000496   0xEE10 0x0A10      VMOV     R0,S0
   1201                LIMIT_ACCEL_FLOAT(Y_AXIS, 0);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_48: (+1)
   \   0000049A   0x68B2             LDR      R2,[R6, #+8]
   \   0000049C   0x2A00             CMP      R2,#+0
   \   0000049E   0xD021             BEQ.N    ??_buffer_steps_49
   \   000004A0   0x6AAB             LDR      R3,[R5, #+40]
   \   000004A2   0x4283             CMP      R3,R0
   \   000004A4   0xD21E             BCS.N    ??_buffer_steps_49
   \   000004A6   0xEE00 0x3A10      VMOV     S0,R3
   \   000004AA   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   000004AE   0xEE00 0x1A90      VMOV     S1,R1
   \   000004B2   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   000004B6   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000004BA   0xEE00 0x2A90      VMOV     S1,R2
   \   000004BE   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   000004C2   0xEE01 0x0A10      VMOV     S2,R0
   \   000004C6   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \   000004CA   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   000004CE   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   000004D2   0xEEF1 0xFA10      FMSTAT   
   \   000004D6   0xD505             BPL.N    ??_buffer_steps_49
   \   000004D8   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000004DC   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   000004E0   0xEE10 0x0A10      VMOV     R0,S0
   1202                LIMIT_ACCEL_FLOAT(Z_AXIS, 0);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_49: (+1)
   \   000004E4   0x68F2             LDR      R2,[R6, #+12]
   \   000004E6   0x2A00             CMP      R2,#+0
   \   000004E8   0xD021             BEQ.N    ??_buffer_steps_50
   \   000004EA   0x6AEB             LDR      R3,[R5, #+44]
   \   000004EC   0x4283             CMP      R3,R0
   \   000004EE   0xD21E             BCS.N    ??_buffer_steps_50
   \   000004F0   0xEE00 0x3A10      VMOV     S0,R3
   \   000004F4   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   000004F8   0xEE00 0x1A90      VMOV     S1,R1
   \   000004FC   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   00000500   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000504   0xEE00 0x2A90      VMOV     S1,R2
   \   00000508   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000050C   0xEE01 0x0A10      VMOV     S2,R0
   \   00000510   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \   00000514   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   00000518   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   0000051C   0xEEF1 0xFA10      FMSTAT   
   \   00000520   0xD505             BPL.N    ??_buffer_steps_50
   \   00000522   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000526   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   0000052A   0xEE10 0x0A10      VMOV     R0,S0
   1203                LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_steps_50: (+1)
   \   0000052E   0x6932             LDR      R2,[R6, #+16]
   \   00000530   0x2A00             CMP      R2,#+0
   \   00000532   0xD021             BEQ.N    ??_buffer_steps_41
   \   00000534   0x6B2B             LDR      R3,[R5, #+48]
   \   00000536   0x4283             CMP      R3,R0
   \   00000538   0xD21E             BCS.N    ??_buffer_steps_41
   \   0000053A   0xEE00 0x3A10      VMOV     S0,R3
   \   0000053E   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000542   0xEE00 0x1A90      VMOV     S1,R1
   \   00000546   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   0000054A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000054E   0xEE00 0x2A90      VMOV     S1,R2
   \   00000552   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000556   0xEE01 0x0A10      VMOV     S2,R0
   \   0000055A   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \   0000055E   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   00000562   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   00000566   0xEEF1 0xFA10      FMSTAT   
   \   0000056A   0xD505             BPL.N    ??_buffer_steps_41
   \   0000056C   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000570   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   00000574   0xEE10 0x0A10      VMOV     R0,S0
   1204              }
   1205            }
   1206            block->acceleration_steps_per_s2 = accel;
   \                     ??_buffer_steps_41: (+1)
   \   00000578   0x64B0             STR      R0,[R6, #+72]
   1207            block->acceleration = accel / steps_per_mm;
   \   0000057A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000057E   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000582   0xEE80 0x0A28      VDIV.F32 S0,S0,S17
   \   00000586   0xED86 0x0A0E      VSTR     S0,[R6, #+56]
   1208            //block->acceleration_rate = (long)(accel * 16777216.0 / ((F_CPU) * 0.125)); // * 8.388608
   1209            block->acceleration_rate = (long)(accel * 8.388608); // * 8.388608
   \   0000058A   0x.... 0x....      BL       __aeabi_ui2d
   \   0000058E   0x.... 0x....      LDR.W    R2,??DataTable17_15  ;; 0xa0b5ed8d
   \   00000592   0x.... 0x....      LDR.W    R3,??DataTable17_16  ;; 0x4020c6f7
   \   00000596   0x.... 0x....      BL       __aeabi_dmul
   \   0000059A   0x.... 0x....      BL       __aeabi_d2iz
   \   0000059E   0x6230             STR      R0,[R6, #+32]
   1210          
   1211            // Initial limit on the segment entry velocity
   1212            float vmax_junction;
   1213          
   1214            #if 0  // Use old jerk for now
   1215          
   1216              float junction_deviation = 0.1;
   1217          
   1218              // Compute path unit vector
   1219              double unit_vec[XYZ] = {
   1220                delta_mm[X_AXIS] * inverse_millimeters,
   1221                delta_mm[Y_AXIS] * inverse_millimeters,
   1222                delta_mm[Z_AXIS] * inverse_millimeters
   1223              };
   1224          
   1225              /*
   1226                 Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
   1227          
   1228                 Let a circle be tangent to both previous and current path line segments, where the junction
   1229                 deviation is defined as the distance from the junction to the closest edge of the circle,
   1230                 collinear with the circle center.
   1231          
   1232                 The circular segment joining the two paths represents the path of centripetal acceleration.
   1233                 Solve for max velocity based on max acceleration about the radius of the circle, defined
   1234                 indirectly by junction deviation.
   1235          
   1236                 This may be also viewed as path width or max_jerk in the previous grbl version. This approach
   1237                 does not actually deviate from path, but used as a robust way to compute cornering speeds, as
   1238                 it takes into account the nonlinearities of both the junction angle and junction velocity.
   1239               */
   1240          
   1241              vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed
   1242          
   1243              // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
   1244              if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
   1245                // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
   1246                // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
   1247                const float cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
   1248                                        - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
   1249                                        - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS];
   1250                // Skip and use default max junction speed for 0 degree acute junction.
   1251                if (cos_theta < 0.95) {
   1252                  vmax_junction = min(previous_nominal_speed, block->nominal_speed);
   1253                  // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.
   1254                  if (cos_theta > -0.95) {
   1255                    // Compute maximum junction velocity based on maximum acceleration and junction deviation
   1256                    float sin_theta_d2 = SQRT(0.5 * (1.0 - cos_theta)); // Trig half angle identity. Always positive.
   1257                    NOMORE(vmax_junction, SQRT(block->acceleration * junction_deviation * sin_theta_d2 / (1.0 - sin_theta_d2)));
   1258                  }
   1259                }
   1260              }
   1261            #endif
   1262          
   1263            /**
   1264             * Adapted from Průša MKS firmware
   1265             * https://github.com/prusa3d/Prusa-Firmware
   1266             *
   1267             * Start with a safe speed (from which the machine may halt to stop immediately).
   1268             */
   1269          
   1270            // Exit speed limited by a jerk to full halt of a previous last segment
   1271            static float previous_safe_speed;
   1272          
   1273            float safe_speed = block->nominal_speed;
   \   000005A0   0xEDD6 0x8A0A      VLDR     S17,[R6, #+40]
   1274            uint8_t limited = 0;
   \   000005A4   0x2000             MOVS     R0,#+0
   1275            LOOP_XYZE(i) {
   \   000005A6   0x4601             MOV      R1,R0
   \   000005A8   0xE003             B.N      ??_buffer_steps_51
   1276              const float jerk = FABS(current_speed[i]), maxj = max_jerk[i];
   1277              if (jerk > maxj) {
   1278                if (limited) {
   1279                  const float mjerk = maxj * block->nominal_speed;
   1280                  if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
   1281                }
   1282                else {
   1283                  ++limited;
   \                     ??_buffer_steps_52: (+1)
   \   000005AA   0x2001             MOVS     R0,#+1
   1284                  safe_speed = maxj;
   \   000005AC   0xEEF0 0x8A40      VMOV.F32 S17,S0
   1285                }
   \                     ??_buffer_steps_53: (+1)
   \   000005B0   0x1C49             ADDS     R1,R1,#+1
   \                     ??_buffer_steps_51: (+1)
   \   000005B2   0x2904             CMP      R1,#+4
   \   000005B4   0xDA1F             BGE.N    ??_buffer_steps_54
   \   000005B6   0xAA02             ADD      R2,SP,#+8
   \   000005B8   0xF852 0x2021      LDR      R2,[R2, R1, LSL #+2]
   \   000005BC   0xF022 0x4200      BIC      R2,R2,#0x80000000
   \   000005C0   0xEE00 0x2A90      VMOV     S1,R2
   \   000005C4   0xEB07 0x0281      ADD      R2,R7,R1, LSL #+2
   \   000005C8   0xED92 0x0A09      VLDR     S0,[R2, #+36]
   \   000005CC   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000005D0   0xEEF1 0xFA10      FMSTAT   
   \   000005D4   0xD5EC             BPL.N    ??_buffer_steps_53
   \   000005D6   0x2800             CMP      R0,#+0
   \   000005D8   0xD0E7             BEQ.N    ??_buffer_steps_52
   \   000005DA   0xED96 0x1A0A      VLDR     S2,[R6, #+40]
   \   000005DE   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
   \   000005E2   0xEE20 0x1AA8      VMUL.F32 S2,S1,S17
   \   000005E6   0xEEB4 0x0A41      VCMP.F32 S0,S2
   \   000005EA   0xEEF1 0xFA10      FMSTAT   
   \   000005EE   0xD5DF             BPL.N    ??_buffer_steps_53
   \   000005F0   0xEEC0 0x8A20      VDIV.F32 S17,S0,S1
   \   000005F4   0xE7DC             B.N      ??_buffer_steps_53
   1286              }
   1287            }
   1288          
   1289            if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
   \                     ??_buffer_steps_54: (+1)
   \   000005F6   0x2C00             CMP      R4,#+0
   \   000005F8   0xF000 0x8080      BEQ.W    ??_buffer_steps_55
   \   000005FC   0xED95 0x0A1E      VLDR     S0,[R5, #+120]
   \   00000600   0xEDDF 0x....      VLDR.W   S1,??DataTable12  ;; 0x358637be
   \   00000604   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000608   0xEEF1 0xFA10      FMSTAT   
   \   0000060C   0xD476             BMI.N    ??_buffer_steps_55
   1290              // Estimate a maximum velocity allowed at a joint of two successive segments.
   1291              // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
   1292              // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
   1293          
   1294              // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
   1295              // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
   1296              vmax_junction = min(block->nominal_speed, previous_nominal_speed);
   \   0000060E   0xED96 0x9A0A      VLDR     S18,[R6, #+40]
   \   00000612   0xEEB4 0x9A40      VCMP.F32 S18,S0
   \   00000616   0xEEF1 0xFA10      FMSTAT   
   \   0000061A   0xD401             BMI.N    ??_buffer_steps_56
   \   0000061C   0xEEB0 0x9A40      VMOV.F32 S18,S0
   1297          
   1298              // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
   1299              float v_factor = 1;
   1300              limited = 0;
   \                     ??_buffer_steps_56: (+1)
   \   00000620   0x2000             MOVS     R0,#+0
   1301          
   1302              // Now limit the jerk in all axes.
   1303              const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
   \   00000622   0xEE89 0x0A00      VDIV.F32 S0,S18,S0
   1304              LOOP_XYZE(axis) {
   \   00000626   0x4601             MOV      R1,R0
   \   00000628   0xE010             B.N      ??_buffer_steps_57
   1305                // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
   1306                float v_exit = previous_speed[axis] * smaller_speed_factor,
   1307                      v_entry = current_speed[axis];
   1308                if (limited) {
   1309                  v_exit *= v_factor;
   1310                  v_entry *= v_factor;
   1311                }
   1312          
   1313                // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
   1314                const float jerk = (v_exit > v_entry)
   1315                    ? //                                  coasting             axis reversal
   1316                      ( (v_entry > 0 || v_exit < 0) ? (v_exit - v_entry) : max(v_exit, -v_entry) )
   1317                    : // v_exit <= v_entry                coasting             axis reversal
   1318                      ( (v_entry < 0 || v_exit > 0) ? (v_entry - v_exit) : max(-v_exit, v_entry) );
   \                     ??_buffer_steps_58: (+1)
   \   0000062A   0xEEF0 0x0A41      VMOV.F32 S1,S2
   \                     ??_buffer_steps_59: (+1)
   \   0000062E   0xEB07 0x0281      ADD      R2,R7,R1, LSL #+2
   \   00000632   0xED92 0x1A09      VLDR     S2,[R2, #+36]
   \   00000636   0xEEB4 0x1A60      VCMP.F32 S2,S1
   \   0000063A   0xEEF1 0xFA10      FMSTAT   
   \   0000063E   0xD504             BPL.N    ??_buffer_steps_60
   1319          
   1320                if (jerk > max_jerk[axis]) {
   1321                  v_factor *= max_jerk[axis] / jerk;
   \   00000640   0xEEC1 0x0A20      VDIV.F32 S1,S2,S1
   \   00000644   0xEE20 0x8A88      VMUL.F32 S16,S1,S16
   1322                  ++limited;
   \   00000648   0x1C40             ADDS     R0,R0,#+1
   1323                }
   \                     ??_buffer_steps_60: (+1)
   \   0000064A   0x1C49             ADDS     R1,R1,#+1
   \                     ??_buffer_steps_57: (+1)
   \   0000064C   0x2904             CMP      R1,#+4
   \   0000064E   0xDA40             BGE.N    ??_buffer_steps_61
   \   00000650   0xEB05 0x0281      ADD      R2,R5,R1, LSL #+2
   \   00000654   0xEDD2 0x0A1A      VLDR     S1,[R2, #+104]
   \   00000658   0xEE60 0x1A80      VMUL.F32 S3,S1,S0
   \   0000065C   0xAA02             ADD      R2,SP,#+8
   \   0000065E   0xF852 0x2021      LDR      R2,[R2, R1, LSL #+2]
   \   00000662   0xEE01 0x2A10      VMOV     S2,R2
   \   00000666   0xB2C0             UXTB     R0,R0
   \   00000668   0x2800             CMP      R0,#+0
   \   0000066A   0xD003             BEQ.N    ??_buffer_steps_62
   \   0000066C   0xEE61 0x1A88      VMUL.F32 S3,S3,S16
   \   00000670   0xEE21 0x1A08      VMUL.F32 S2,S2,S16
   \                     ??_buffer_steps_62: (+1)
   \   00000674   0xEEB4 0x1A61      VCMP.F32 S2,S3
   \   00000678   0xEEF1 0xFA10      FMSTAT   
   \   0000067C   0xEEB5 0x1A40      VCMP.F32 S2,#0.0
   \   00000680   0xD514             BPL.N    ??_buffer_steps_63
   \   00000682   0xEEF1 0xFA10      FMSTAT   
   \   00000686   0xDC04             BGT.N    ??_buffer_steps_64
   \   00000688   0xEEF5 0x1A40      VCMP.F32 S3,#0.0
   \   0000068C   0xEEF1 0xFA10      FMSTAT   
   \   00000690   0xD502             BPL.N    ??_buffer_steps_65
   \                     ??_buffer_steps_64: (+1)
   \   00000692   0xEE71 0x0AC1      VSUB.F32 S1,S3,S2
   \   00000696   0xE7CA             B.N      ??_buffer_steps_59
   \                     ??_buffer_steps_65: (+1)
   \   00000698   0xEEF1 0x0A41      VNEG.F32 S1,S2
   \   0000069C   0xEEF4 0x0A61      VCMP.F32 S1,S3
   \   000006A0   0xEEF1 0xFA10      FMSTAT   
   \   000006A4   0xD5C3             BPL.N    ??_buffer_steps_59
   \   000006A6   0xEEF0 0x0A61      VMOV.F32 S1,S3
   \   000006AA   0xE7C0             B.N      ??_buffer_steps_59
   \                     ??_buffer_steps_63: (+1)
   \   000006AC   0xEEF1 0xFA10      FMSTAT   
   \   000006B0   0xD404             BMI.N    ??_buffer_steps_66
   \   000006B2   0xEEF5 0x1A40      VCMP.F32 S3,#0.0
   \   000006B6   0xEEF1 0xFA10      FMSTAT   
   \   000006BA   0xDD02             BLE.N    ??_buffer_steps_67
   \                     ??_buffer_steps_66: (+1)
   \   000006BC   0xEE71 0x0A61      VSUB.F32 S1,S2,S3
   \   000006C0   0xE7B5             B.N      ??_buffer_steps_59
   \                     ??_buffer_steps_67: (+1)
   \   000006C2   0xEEF1 0x0A61      VNEG.F32 S1,S3
   \   000006C6   0xEEB4 0x1A60      VCMP.F32 S2,S1
   \   000006CA   0xEEF1 0xFA10      FMSTAT   
   \   000006CE   0xD5AC             BPL.N    ??_buffer_steps_58
   \   000006D0   0xE7AD             B.N      ??_buffer_steps_59
   1324              }
   1325              if (limited) vmax_junction *= v_factor;
   \                     ??_buffer_steps_61: (+1)
   \   000006D2   0xB2C0             UXTB     R0,R0
   \   000006D4   0x2800             CMP      R0,#+0
   \   000006D6   0xD001             BEQ.N    ??_buffer_steps_68
   \   000006D8   0xEE29 0x9A08      VMUL.F32 S18,S18,S16
   1326              // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
   1327              // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
   1328              const float vmax_junction_threshold = vmax_junction * 0.99f;
   \                     ??_buffer_steps_68: (+1)
   \   000006DC   0xED9F 0x....      VLDR.W   S0,??DataTable15  ;; 0x3f7d70a4
   \   000006E0   0xEE29 0x0A00      VMUL.F32 S0,S18,S0
   1329              if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold) {
   \   000006E4   0xEDD7 0x0A0E      VLDR     S1,[R7, #+56]
   \   000006E8   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000006EC   0xEEF1 0xFA10      FMSTAT   
   \   000006F0   0xD50A             BPL.N    ??_buffer_steps_69
   \   000006F2   0xEEB4 0x0A68      VCMP.F32 S0,S17
   \   000006F6   0xEEF1 0xFA10      FMSTAT   
   \   000006FA   0xD505             BPL.N    ??_buffer_steps_69
   1330                // Not coasting. The machine will stop and start the movements anyway,
   1331                // better to start the segment from start.
   1332                SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
   1333                vmax_junction = safe_speed;
   1334              }
   1335            }
   1336            else {
   1337              SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
   \                     ??_buffer_steps_55: (+1)
   \   000006FC   0x7830             LDRB     R0,[R6, #+0]
   \   000006FE   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000702   0x7030             STRB     R0,[R6, #+0]
   1338              vmax_junction = safe_speed;
   \   00000704   0xEEB0 0x9A68      VMOV.F32 S18,S17
   1339            }
   1340          
   1341            // Max entry speed of this block equals the max exit speed of the previous block.
   1342            block->max_entry_speed = vmax_junction;
   \                     ??_buffer_steps_69: (+1)
   \   00000708   0xED86 0x9A0C      VSTR     S18,[R6, #+48]
   1343          
   1344            // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
   1345            const float v_allowable = max_allowable_speed(-block->acceleration, MINIMUM_PLANNER_SPEED, block->millimeters);
   \   0000070C   0xED96 0x0A0E      VLDR     S0,[R6, #+56]
   \   00000710   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000714   0xED8D 0x0A01      VSTR     S0,[SP, #+4]
   \   00000718   0x.... 0x....      LDR.W    R0,??DataTable17_17  ;; 0x3d4ccccd
   \   0000071C   0x9000             STR      R0,[SP, #+0]
   \   0000071E   0xF106 0x0234      ADD      R2,R6,#+52
   \   00000722   0xA900             ADD      R1,SP,#+0
   \   00000724   0xA801             ADD      R0,SP,#+4
   \   00000726   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   1346            block->entry_speed = min(vmax_junction, v_allowable);
   \   0000072A   0xEEB4 0x9A40      VCMP.F32 S18,S0
   \   0000072E   0xEEF1 0xFA10      FMSTAT   
   \   00000732   0xD401             BMI.N    ??_buffer_steps_70
   \   00000734   0xEEB0 0x9A40      VMOV.F32 S18,S0
   \                     ??_buffer_steps_70: (+1)
   \   00000738   0xED86 0x9A0B      VSTR     S18,[R6, #+44]
   1347          
   1348            // Initialize planner efficiency flags
   1349            // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
   1350            // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
   1351            // the current block and next block junction speeds are guaranteed to always be at their maximum
   1352            // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   1353            // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   1354            // the reverse and forward planners, the corresponding block junction speed will always be at the
   1355            // the maximum junction speed and may always be ignored for any speed reduction checks.
   1356            block->flag |= BLOCK_FLAG_RECALCULATE | (block->nominal_speed <= v_allowable ? BLOCK_FLAG_NOMINAL_LENGTH : 0);
   \   0000073C   0xEDD6 0x0A0A      VLDR     S1,[R6, #+40]
   \   00000740   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000744   0xEEF1 0xFA10      FMSTAT   
   \   00000748   0xDB01             BLT.N    ??_buffer_steps_71
   \   0000074A   0x2002             MOVS     R0,#+2
   \   0000074C   0xE000             B.N      ??_buffer_steps_72
   \                     ??_buffer_steps_71: (+1)
   \   0000074E   0x2000             MOVS     R0,#+0
   \                     ??_buffer_steps_72: (+1)
   \   00000750   0x7831             LDRB     R1,[R6, #+0]
   \   00000752   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000756   0x4308             ORRS     R0,R0,R1
   \   00000758   0x7030             STRB     R0,[R6, #+0]
   1357          
   1358            // Update previous path unit_vector and nominal speed
   1359            COPY(previous_speed, current_speed);
   \   0000075A   0x2210             MOVS     R2,#+16
   \   0000075C   0xA902             ADD      R1,SP,#+8
   \   0000075E   0xF105 0x0068      ADD      R0,R5,#+104
   \   00000762   0x.... 0x....      BL       memcpy
   1360            previous_nominal_speed = block->nominal_speed;
   \   00000766   0x6AB0             LDR      R0,[R6, #+40]
   \   00000768   0x67A8             STR      R0,[R5, #+120]
   1361            previous_safe_speed = safe_speed;
   \   0000076A   0xEDC7 0x8A0E      VSTR     S17,[R7, #+56]
   1362          
   1363            #if ENABLED(LIN_ADVANCE)
   1364              /**
   1365               *
   1366               * Use LIN_ADVANCE for blocks if all these are true:
   1367               *
   1368               * esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS]) : This is a print move
   1369               *
   1370               * extruder_advance_k                 : There is an advance factor set.
   1371               *
   1372               * esteps != block->step_event_count  : A problem occurs if the move before a retract is too small.
   1373               *                                      In that case, the retract and move will be executed together.
   1374               *                                      This leads to too many advance steps due to a huge e_acceleration.
   1375               *                                      The math is good, but we must avoid retract moves with advance!
   1376               * lin_dist_e > 0                       : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
   1377               */
   1378              block->use_advance_lead =  esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS])
   1379                                      && extruder_advance_k
   1380                                      && (uint32_t)esteps != block->step_event_count
   1381                                      && lin_dist_e > 0;
   1382              if (block->use_advance_lead)
   1383                block->abs_adv_steps_multiplier8 = LROUND(
   1384                  extruder_advance_k
   1385                  * (UNEAR_ZERO(advance_ed_ratio) ? lin_dist_e / lin_dist_xy : advance_ed_ratio) // Use the fixed ratio, if set
   1386                  * (block->nominal_speed / (float)block->nominal_rate)
   1387                  * axis_steps_per_mm[E_AXIS_N] * 256.0
   1388                );
   1389          
   1390            #endif // LIN_ADVANCE
   1391          
   1392            const float bnsr = 1.0 / block->nominal_speed;
   \   0000076E   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   00000772   0xEDD6 0x0A0A      VLDR     S1,[R6, #+40]
   \   00000776   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   1393            calculate_trapezoid_for_block(block, block->entry_speed * bnsr, safe_speed * bnsr);
   \   0000077A   0xEDD6 0x0A0B      VLDR     S1,[R6, #+44]
   \   0000077E   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000782   0xEDCD 0x0A00      VSTR     S1,[SP, #+0]
   \   00000786   0xEE28 0x0A80      VMUL.F32 S0,S17,S0
   \   0000078A   0xED8D 0x0A01      VSTR     S0,[SP, #+4]
   \   0000078E   0xAA01             ADD      R2,SP,#+4
   \   00000790   0xA900             ADD      R1,SP,#+0
   \   00000792   0x4630             MOV      R0,R6
   \   00000794   0x.... 0x....      BL       _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_
   1394          
   1395            // Move buffer head
   1396            block_buffer_head = next_buffer_head;
   \   00000798   0xF885 0x8000      STRB     R8,[R5, #+0]
   1397          
   1398            // Update the position (only when a move was queued)
   1399            static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
   1400            COPY(position, target);
   \   0000079C   0x2210             MOVS     R2,#+16
   \   0000079E   0x4651             MOV      R1,R10
   \   000007A0   0xF105 0x0034      ADD      R0,R5,#+52
   \   000007A4   0x.... 0x....      BL       memcpy
   1401          
   1402            recalculate();
   \   000007A8   0x.... 0x....      BL       _ZN7Planner11recalculateEv
   1403          
   1404          } // _buffer_steps()
   \                     ??_buffer_steps_13: (+1)
   \   000007AC   0xB00A             ADD      SP,SP,#+40
   \   000007AE   0xECBD 0x8B04      VPOP     {D8-D9}
   \   000007B2   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return

   \                                 In section .bss, align 4
   \                     _ZN7Planner23g_uc_extruder_last_moveE:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \                     _ZN7Planner17max_feedrate_mm_sE:
   \   00000004                      DS8 16
   \                     _ZN7Planner17min_feedrate_mm_sE:
   \   00000014                      DS8 4
   \                     _ZN7Planner12accelerationE:
   \   00000018                      DS8 4
   \                     _ZN7Planner20retract_accelerationE:
   \   0000001C                      DS8 4
   \                     _ZN7Planner19travel_accelerationE:
   \   00000020                      DS8 4
   \                     _ZN7Planner8max_jerkE:
   \   00000024                      DS8 16
   \                     _ZN7Planner24min_travel_feedrate_mm_sE:
   \   00000034                      DS8 4
   \   00000038                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZN7Planner19min_segment_time_usE:
   \   00000000                      DS8 4
   1405          
   1406          /**
   1407           * Planner::buffer_segment
   1408           *
   1409           * Add a new linear movement to the buffer in axis units.
   1410           *
   1411           * Leveling and kinematics should be applied ahead of calling this.
   1412           *
   1413           *  a,b,c,e   - target positions in mm and/or degrees
   1414           *  fr_mm_s   - (target) speed of the move
   1415           *  extruder  - target extruder
   1416           */

   \                                 In section .text, align 2, keep-with-next
   1417          void Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder) {
   \                     _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4617             MOV      R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   1418          
   1419          	if (gCfgItems.breakpoint_reprint_flg == 1) {
   \   0000000C   0x....             LDR.N    R1,??DataTable17_18
   \   0000000E   0xF891 0x2128      LDRB     R2,[R1, #+296]
   \   00000012   0x2A01             CMP      R2,#+1
   \   00000014   0xD108             BNE.N    ??buffer_segment_0
   1420          		if (c < gCfgItems.breakpoint_z_pos) return;
   \   00000016   0xED97 0x0A00      VLDR     S0,[R7, #0]
   \   0000001A   0xEDD1 0x0A6B      VLDR     S1,[R1, #+428]
   \   0000001E   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000022   0xEEF1 0xFA10      FMSTAT   
   \   00000026   0xD46C             BMI.N    ??buffer_segment_1
   1421          	}
   1422              //gCfgItems.breakpoint_reprint_flg = 0;
   1423            // When changing extruders recalculate steps corresponding to the E position
   1424            #if ENABLED(DISTINCT_E_FACTORS)
   1425              if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
   1426                position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
   1427                last_extruder = extruder;
   1428              }
   1429            #endif
   1430          
   1431            // The target position of the tool in absolute steps
   1432            // Calculate target position in absolute steps
   1433            const int32_t target[XYZE] = {
   \                     ??buffer_segment_0: (+1)
   \   00000028   0x....             LDR.N    R5,??DataTable13
   \   0000002A   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000002E   0xEDD5 0x0A01      VLDR     S1,[R5, #+4]
   \   00000032   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000036   0x.... 0x....      BL       lroundf
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0xAE00             ADD      R6,SP,#+0
   \   0000003E   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   00000042   0xEDD5 0x0A02      VLDR     S1,[R5, #+8]
   \   00000046   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000004A   0x.... 0x....      BL       lroundf
   \   0000004E   0x6070             STR      R0,[R6, #+4]
   \   00000050   0xED97 0x0A00      VLDR     S0,[R7, #0]
   \   00000054   0xEDD5 0x0A03      VLDR     S1,[R5, #+12]
   \   00000058   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000005C   0x.... 0x....      BL       lroundf
   \   00000060   0x60B0             STR      R0,[R6, #+8]
   \   00000062   0xED98 0x0A00      VLDR     S0,[R8, #0]
   \   00000066   0xEDD5 0x0A04      VLDR     S1,[R5, #+16]
   \   0000006A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000006E   0x.... 0x....      BL       lroundf
   \   00000072   0x4680             MOV      R8,R0
   \   00000074   0xF8C6 0x800C      STR      R8,[R6, #+12]
   1434              LROUND(a * axis_steps_per_mm[X_AXIS]),
   1435              LROUND(b * axis_steps_per_mm[Y_AXIS]),
   1436              LROUND(c * axis_steps_per_mm[Z_AXIS]),
   1437              LROUND(e * axis_steps_per_mm[E_AXIS_N])
   1438            };
   1439          
   1440            // DRYRUN prevents E moves from taking place
   1441            if (DEBUGGING(DRYRUN)) {
   \   00000078   0x....             LDR.N    R0,??DataTable17_19
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x0700             LSLS     R0,R0,#+28
   \   0000007E   0xD501             BPL.N    ??buffer_segment_2
   1442              position[E_AXIS] = target[E_AXIS];
   \   00000080   0xF8C5 0x8040      STR      R8,[R5, #+64]
   \                     ??buffer_segment_2: (+1)
   \   00000084   0x9F0E             LDR      R7,[SP, #+56]
   \   00000086   0x9C0F             LDR      R4,[SP, #+60]
   1443              #if ENABLED(LIN_ADVANCE)
   1444                position_float[E_AXIS] = e;
   1445              #endif
   1446            }
   1447          
   1448            #if ENABLED(LIN_ADVANCE)
   1449              lin_dist_e = e - position_float[E_AXIS];
   1450            #endif
   1451          
   1452            // If LIN_ADVANCE is enabled then do E move prevention with floats
   1453            // Otherwise it's done in _buffer_steps.
   1454            #if ENABLED(LIN_ADVANCE) && (ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE))
   1455              if (lin_dist_e) {
   1456                #if ENABLED(PREVENT_COLD_EXTRUSION)
   1457                  if (thermalManager.tooColdToExtrude(extruder)) {
   1458                    position_float[E_AXIS] = e; // Behave as if the move really took place, but ignore E part
   1459                    position[E_AXIS] = target[E_AXIS];
   1460                    lin_dist_e = 0;
   1461                    SERIAL_ECHO_START();
   1462                    SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
   1463                  }
   1464                #endif // PREVENT_COLD_EXTRUSION
   1465                #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
   1466                  if (lin_dist_e * e_factor[extruder] > (EXTRUDE_MAXLENGTH)) {
   1467                    position_float[E_AXIS] = e; // Behave as if the move really took place, but ignore E part
   1468                    position[E_AXIS] = target[E_AXIS];
   1469                    lin_dist_e = 0;
   1470                    SERIAL_ECHO_START();
   1471                    SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
   1472                  }
   1473                #endif // PREVENT_LENGTHY_EXTRUDE
   1474              }
   1475            #endif // LIN_ADVANCE && (PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE)
   1476          
   1477            #if ENABLED(LIN_ADVANCE)
   1478              if (lin_dist_e > 0)
   1479                lin_dist_xy = HYPOT(a - position_float[X_AXIS], b - position_float[Y_AXIS]);
   1480            #endif
   1481          
   1482            /* <-- add a slash to enable
   1483              SERIAL_ECHOPAIR("  buffer_segment FR:", fr_mm_s);
   1484              #if IS_KINEMATIC
   1485                SERIAL_ECHOPAIR(" A:", a);
   1486                SERIAL_ECHOPAIR(" (", position[A_AXIS]);
   1487                SERIAL_ECHOPAIR("->", target[A_AXIS]);
   1488                SERIAL_ECHOPAIR(") B:", b);
   1489              #else
   1490                SERIAL_ECHOPAIR(" X:", a);
   1491                SERIAL_ECHOPAIR(" (", position[X_AXIS]);
   1492                SERIAL_ECHOPAIR("->", target[X_AXIS]);
   1493                SERIAL_ECHOPAIR(") Y:", b);
   1494              #endif
   1495              SERIAL_ECHOPAIR(" (", position[Y_AXIS]);
   1496              SERIAL_ECHOPAIR("->", target[Y_AXIS]);
   1497              #if ENABLED(DELTA)
   1498                SERIAL_ECHOPAIR(") C:", c);
   1499              #else
   1500                SERIAL_ECHOPAIR(") Z:", c);
   1501              #endif
   1502              SERIAL_ECHOPAIR(" (", position[Z_AXIS]);
   1503              SERIAL_ECHOPAIR("->", target[Z_AXIS]);
   1504              SERIAL_ECHOPAIR(") E:", e);
   1505              SERIAL_ECHOPAIR(" (", position[E_AXIS]);
   1506              SERIAL_ECHOPAIR("->", target[E_AXIS]);
   1507              SERIAL_ECHOLNPGM(")");
   1508            //*/
                    ^
Warning[Pe009]: nested comment is not allowed
   1509          
   1510            // Always split the first move into two (if not homing or probing)
   1511            if (!blocks_queued()) {
   \   00000088   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD130             BNE.N    ??buffer_segment_3
   1512          
   1513              #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
   1514              const int32_t between[XYZE] = { _BETWEEN(X), _BETWEEN(Y), _BETWEEN(Z), _BETWEEN(E) };
   \   00000090   0x6B68             LDR      R0,[R5, #+52]
   \   00000092   0x9900             LDR      R1,[SP, #+0]
   \   00000094   0x1808             ADDS     R0,R1,R0
   \   00000096   0x1040             ASRS     R0,R0,#+1
   \   00000098   0x9004             STR      R0,[SP, #+16]
   \   0000009A   0xA804             ADD      R0,SP,#+16
   \   0000009C   0x6BA9             LDR      R1,[R5, #+56]
   \   0000009E   0x6872             LDR      R2,[R6, #+4]
   \   000000A0   0x1851             ADDS     R1,R2,R1
   \   000000A2   0x1049             ASRS     R1,R1,#+1
   \   000000A4   0x6041             STR      R1,[R0, #+4]
   \   000000A6   0x6BE9             LDR      R1,[R5, #+60]
   \   000000A8   0x68B2             LDR      R2,[R6, #+8]
   \   000000AA   0x1851             ADDS     R1,R2,R1
   \   000000AC   0x1049             ASRS     R1,R1,#+1
   \   000000AE   0x6081             STR      R1,[R0, #+8]
   \   000000B0   0x6C29             LDR      R1,[R5, #+64]
   \   000000B2   0x4441             ADD      R1,R8,R1
   \   000000B4   0x1049             ASRS     R1,R1,#+1
   \   000000B6   0x60C1             STR      R1,[R0, #+12]
   1515              DISABLE_STEPPER_DRIVER_INTERRUPT();
   \   000000B8   0x....             LDR.N    R6,??DataTable17_20
   \   000000BA   0x4630             MOV      R0,R6
   \   000000BC   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   1516          
   1517              #if ENABLED(LIN_ADVANCE)
   1518                lin_dist_xy *= 0.5;
   1519                lin_dist_e *= 0.5;
   1520              #endif
   1521          
   1522              _buffer_steps(between, fr_mm_s, extruder);
   \   000000C0   0x4621             MOV      R1,R4
   \   000000C2   0xED97 0x0A00      VLDR     S0,[R7, #0]
   \   000000C6   0xA804             ADD      R0,SP,#+16
   \   000000C8   0x.... 0x....      BL       _ZN7Planner13_buffer_stepsERA4_Kifh
   1523          
   1524              #if ENABLED(LIN_ADVANCE)
   1525                position_float[X_AXIS] = (position_float[X_AXIS] + a) * 0.5;
   1526                position_float[Y_AXIS] = (position_float[Y_AXIS] + b) * 0.5;
   1527                //position_float[Z_AXIS] = (position_float[Z_AXIS] + c) * 0.5;
   1528                position_float[E_AXIS] = (position_float[E_AXIS] + e) * 0.5;
   1529              #endif
   1530          
   1531              const uint8_t next = block_buffer_head;
   \   000000CC   0x782D             LDRB     R5,[R5, #+0]
   1532              _buffer_steps(target, fr_mm_s, extruder);
   \   000000CE   0x4621             MOV      R1,R4
   \   000000D0   0xED97 0x0A00      VLDR     S0,[R7, #0]
   \   000000D4   0xA800             ADD      R0,SP,#+0
   \   000000D6   0x.... 0x....      BL       _ZN7Planner13_buffer_stepsERA4_Kifh
   1533              SBI(block_buffer[next].flag, BLOCK_BIT_CONTINUED);
   \   000000DA   0x2054             MOVS     R0,#+84
   \   000000DC   0xFB10 0xF005      SMULBB   R0,R0,R5
   \   000000E0   0x....             LDR.N    R1,??DataTable17
   \   000000E2   0x5C42             LDRB     R2,[R0, R1]
   \   000000E4   0xF042 0x0210      ORR      R2,R2,#0x10
   \   000000E8   0x5442             STRB     R2,[R0, R1]
   1534              ENABLE_STEPPER_DRIVER_INTERRUPT();
   \   000000EA   0x4630             MOV      R0,R6
   \   000000EC   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   \   000000F0   0xE005             B.N      ??buffer_segment_4
   1535            }
   1536            else
   1537              _buffer_steps(target, fr_mm_s, extruder);
   \                     ??buffer_segment_3: (+1)
   \   000000F2   0x4621             MOV      R1,R4
   \   000000F4   0xED97 0x0A00      VLDR     S0,[R7, #0]
   \   000000F8   0xA800             ADD      R0,SP,#+0
   \   000000FA   0x.... 0x....      BL       _ZN7Planner13_buffer_stepsERA4_Kifh
   1538          
   1539            stepper.wake_up();
   \                     ??buffer_segment_4: (+1)
   \   000000FE   0x.... 0x....      BL       _ZN7Stepper7wake_upEv
   1540          
   1541            #if ENABLED(LIN_ADVANCE)
   1542              position_float[X_AXIS] = a;
   1543              position_float[Y_AXIS] = b;
   1544              //position_float[Z_AXIS] = c;
   1545              position_float[E_AXIS] = e;
   1546            #endif
   1547          } // buffer_segment()
   \                     ??buffer_segment_1: (+1)
   \   00000102   0xB008             ADD      SP,SP,#+32
   \   00000104   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1548          
   1549          /**
   1550           * Directly set the planner XYZ position (and stepper positions)
   1551           * converting mm (or angles for SCARA) into steps.
   1552           *
   1553           * On CORE machines stepper ABC will be translated from the given XYZ.
   1554           */
   1555          

   \                                 In section .text, align 2, keep-with-next
   1556          void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   \                     _ZN7Planner16_set_position_mmERKfS1_S1_S1_: (+1)
   \   00000000   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
   \   00000008   0x4698             MOV      R8,R3
   1557            #if ENABLED(DISTINCT_E_FACTORS)
   1558              #define _EINDEX (E_AXIS + active_extruder)
   1559              last_extruder = active_extruder;
   1560            #else
   1561              #define _EINDEX E_AXIS
   1562            #endif
   1563            const int32_t na = position[X_AXIS] = LROUND(a * axis_steps_per_mm[X_AXIS]),
   \   0000000A   0x....             LDR.N    R4,??DataTable17_7
   \   0000000C   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000010   0xEDD4 0x0A01      VLDR     S1,[R4, #+4]
   \   00000014   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000018   0x.... 0x....      BL       lroundf
   \   0000001C   0x4605             MOV      R5,R0
   \   0000001E   0x6365             STR      R5,[R4, #+52]
   1564                          nb = position[Y_AXIS] = LROUND(b * axis_steps_per_mm[Y_AXIS]),
   \   00000020   0xED96 0x0A00      VLDR     S0,[R6, #0]
   \   00000024   0xEDD4 0x0A02      VLDR     S1,[R4, #+8]
   \   00000028   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000002C   0x.... 0x....      BL       lroundf
   \   00000030   0x4606             MOV      R6,R0
   \   00000032   0x63A6             STR      R6,[R4, #+56]
   1565                          nc = position[Z_AXIS] = LROUND(c * axis_steps_per_mm[Z_AXIS]),
   \   00000034   0xED97 0x0A00      VLDR     S0,[R7, #0]
   \   00000038   0xEDD4 0x0A03      VLDR     S1,[R4, #+12]
   \   0000003C   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000040   0x.... 0x....      BL       lroundf
   \   00000044   0x4607             MOV      R7,R0
   \   00000046   0x63E7             STR      R7,[R4, #+60]
   1566                          ne = position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   \   00000048   0xED98 0x0A00      VLDR     S0,[R8, #0]
   \   0000004C   0xEDD4 0x0A04      VLDR     S1,[R4, #+16]
   \   00000050   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000054   0x.... 0x....      BL       lroundf
   \   00000058   0x6420             STR      R0,[R4, #+64]
   1567            #if ENABLED(LIN_ADVANCE)
   1568              position_float[X_AXIS] = a;
   1569              position_float[Y_AXIS] = b;
   1570              //position_float[Z_AXIS] = c;
   1571              position_float[E_AXIS] = e;
   1572            #endif
   1573            stepper.set_position(na, nb, nc, ne);
   \   0000005A   0x9503             STR      R5,[SP, #+12]
   \   0000005C   0x9602             STR      R6,[SP, #+8]
   \   0000005E   0x9701             STR      R7,[SP, #+4]
   \   00000060   0x9000             STR      R0,[SP, #+0]
   \   00000062   0xAB00             ADD      R3,SP,#+0
   \   00000064   0xAA01             ADD      R2,SP,#+4
   \   00000066   0xA902             ADD      R1,SP,#+8
   \   00000068   0xA803             ADD      R0,SP,#+12
   \   0000006A   0x.... 0x....      BL       _ZN7Stepper12set_positionERKlS1_S1_S1_
   1574            previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x67A0             STR      R0,[R4, #+120]
   1575            ZERO(previous_speed);
   \   00000072   0x2210             MOVS     R2,#+16
   \   00000074   0x4601             MOV      R1,R0
   \   00000076   0xF104 0x0068      ADD      R0,R4,#+104
   \   0000007A   0x.... 0x....      BL       memset
   1576          }
   \   0000007E   0xE8BD 0x81FF      POP      {R0-R8,PC}       ;; return
   1577          

   \                                 In section .text, align 2, keep-with-next
   1578          void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
   \                     _ZN7Planner25set_position_mm_kinematicERA4_Kf: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1579          	/*
   1580            #if PLANNER_LEVELING
   1581              float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
   1582              apply_leveling(raw);
   1583            #else
   1584              const float (&raw)[XYZE] = cart;
   1585            #endif
   1586          */
   1587            float raw[NUM_AXIS];
   1588          	  raw[0] = cart[X_AXIS];
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x9100             STR      R1,[SP, #+0]
   1589          	  raw[1] = cart[Y_AXIS];
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x6842             LDR      R2,[R0, #+4]
   \   0000000C   0x604A             STR      R2,[R1, #+4]
   1590          	  raw[2] = cart[Z_AXIS];
   \   0000000E   0x6882             LDR      R2,[R0, #+8]
   \   00000010   0x608A             STR      R2,[R1, #+8]
   1591          	  raw[3] = cart[3];
   \   00000012   0x68C2             LDR      R2,[R0, #+12]
   \   00000014   0x60CA             STR      R2,[R1, #+12]
   1592            #if IS_KINEMATIC
   1593              inverse_kinematics(raw);
   1594              _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS]);
   1595            #else
   1596              _set_position_mm(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS]);
   \   00000016   0xF100 0x030C      ADD      R3,R0,#+12
   \   0000001A   0xAA02             ADD      R2,SP,#+8
   \   0000001C   0xA901             ADD      R1,SP,#+4
   \   0000001E   0xA800             ADD      R0,SP,#+0
   \   00000020   0x.... 0x....      BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
   1597            #endif
   1598          }
   \   00000024   0xB005             ADD      SP,SP,#+20
   \   00000026   0xBD00             POP      {PC}             ;; return
   1599          
   1600          /**
   1601           * Sync from the stepper positions. (e.g., after an interrupted move)
   1602           */

   \                                 In section .text, align 2, keep-with-next
   1603          void Planner::sync_from_steppers() {
   \                     _ZN7Planner18sync_from_steppersEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1604            LOOP_XYZE(i) {
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE008             B.N      ??sync_from_steppers_0
   1605              position[i] = stepper.position((AxisEnum)i);
   \                     ??sync_from_steppers_1: (+1)
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0xB240             SXTB     R0,R0
   \   0000000A   0x.... 0x....      BL       _ZN7Stepper8positionE8AxisEnum
   \   0000000E   0x....             LDR.N    R1,??DataTable17_7
   \   00000010   0xEB01 0x0184      ADD      R1,R1,R4, LSL #+2
   \   00000014   0x6348             STR      R0,[R1, #+52]
   1606              #if ENABLED(LIN_ADVANCE)
   1607                position_float[i] = position[i] * steps_to_mm[i
   1608                  #if ENABLED(DISTINCT_E_FACTORS)
   1609                    + (i == E_AXIS ? active_extruder : 0)
   1610                  #endif
   1611                ];
   1612              #endif
   1613            }
   \   00000016   0x1C64             ADDS     R4,R4,#+1
   \                     ??sync_from_steppers_0: (+1)
   \   00000018   0x2C04             CMP      R4,#+4
   \   0000001A   0xDBF4             BLT.N    ??sync_from_steppers_1
   1614          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   1615          
   1616          /**
   1617           * Setters for planner position (also setting stepper position).
   1618           */

   \                                 In section .text, align 2, keep-with-next
   1619          void Planner::set_position_mm(const AxisEnum axis, const float &v) {
   \                     _ZN7Planner15set_position_mmE8AxisEnumRKf: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x460C             MOV      R4,R1
   1620            #if ENABLED(DISTINCT_E_FACTORS)
   1621              const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
   1622              last_extruder = active_extruder;
   1623            #else
   1624              const uint8_t axis_index = axis;
   1625            #endif
   1626            position[axis] = LROUND(v * axis_steps_per_mm[axis_index]);
   \   00000006   0x....             LDR.N    R5,??DataTable17_7
   \   00000008   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0xEB05 0x0080      ADD      R0,R5,R0, LSL #+2
   \   00000012   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
   \   00000016   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000001A   0x.... 0x....      BL       lroundf
   \   0000001E   0xF99D 0x1008      LDRSB    R1,[SP, #+8]
   \   00000022   0xEB05 0x0181      ADD      R1,R5,R1, LSL #+2
   \   00000026   0x6348             STR      R0,[R1, #+52]
   1627            #if ENABLED(LIN_ADVANCE)
   1628              position_float[axis] = v;
   1629            #endif
   1630            stepper.set_position(axis, v);
                                              ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000028   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   0000002C   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000030   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   00000034   0xA900             ADD      R1,SP,#+0
   \   00000036   0xA802             ADD      R0,SP,#+8
   \   00000038   0x.... 0x....      BL       _ZN7Stepper12set_positionERK8AxisEnumRKl
   1631            previous_speed[axis] = 0.0;
   \   0000003C   0xF99D 0x0008      LDRSB    R0,[SP, #+8]
   \   00000040   0xEB05 0x0080      ADD      R0,R5,R0, LSL #+2
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x6681             STR      R1,[R0, #+104]
   1632          }
   \   00000048   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   1633          
   1634          // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2

   \                                 In section .text, align 2, keep-with-next
   1635          void Planner::reset_acceleration_rates() {
   1636            #if ENABLED(DISTINCT_E_FACTORS)
   1637              #define HIGHEST_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
   1638            #else
   1639              #define HIGHEST_CONDITION true
   1640            #endif
   1641            uint32_t highest_rate = 1;
   \                     _ZN7Planner24reset_acceleration_ratesEv: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   1642            LOOP_XYZE_N(i) {
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0xE012             B.N      ??reset_acceleration_rates_0
   1643              max_acceleration_steps_per_s2[i] = max_acceleration_mm_per_s2[i] * axis_steps_per_mm[i];
                                                      ^
Warning[Pa093]: implicit conversion from floating point to integer

      FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
                                                   ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.h",294  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

      static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
                                    ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.h",504  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
   \                     ??reset_acceleration_rates_1: (+1)
   \   00000006   0xEB02 0x0281      ADD      R2,R2,R1, LSL #+2
   \   0000000A   0xED92 0x0A12      VLDR     S0,[R2, #+72]
   \   0000000E   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000012   0xEDD2 0x0A01      VLDR     S1,[R2, #+4]
   \   00000016   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000001A   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   0000001E   0xEE10 0x3A10      VMOV     R3,S0
   \   00000022   0x6253             STR      R3,[R2, #+36]
   1644              if (HIGHEST_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   \   00000024   0x4298             CMP      R0,R3
   \   00000026   0xD200             BCS.N    ??reset_acceleration_rates_2
   \   00000028   0x4618             MOV      R0,R3
   1645            }
   \                     ??reset_acceleration_rates_2: (+1)
   \   0000002A   0x1C49             ADDS     R1,R1,#+1
   \                     ??reset_acceleration_rates_0: (+1)
   \   0000002C   0x....             LDR.N    R2,??DataTable17_7
   \   0000002E   0x2904             CMP      R1,#+4
   \   00000030   0xDBE9             BLT.N    ??reset_acceleration_rates_1
   1646            cutoff_long = 4294967295UL / highest_rate;
   \   00000032   0xF04F 0x31FF      MOV      R1,#-1
   \   00000036   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   0000003A   0x6650             STR      R0,[R2, #+100]
   1647          }
   \   0000003C   0x4770             BX       LR               ;; return
   1648          
   1649          // Recalculate position, steps_to_mm if axis_steps_per_mm changes!

   \                                 In section .text, align 2, keep-with-next
   1650          void Planner::refresh_positioning() {
   \                     _ZN7Planner19refresh_positioningEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1651            LOOP_XYZE_N(i) steps_to_mm[i] = 1.0 / axis_steps_per_mm[i];
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xE00B             B.N      ??refresh_positioning_0
   \                     ??refresh_positioning_1: (+1)
   \   00000006   0x....             LDR.N    R1,??DataTable17_7
   \   00000008   0xEB01 0x0180      ADD      R1,R1,R0, LSL #+2
   \   0000000C   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
   \   00000010   0xEDD1 0x0A01      VLDR     S1,[R1, #+4]
   \   00000014   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000018   0xED81 0x0A05      VSTR     S0,[R1, #+20]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \                     ??refresh_positioning_0: (+1)
   \   0000001E   0x2804             CMP      R0,#+4
   \   00000020   0xDBF1             BLT.N    ??refresh_positioning_1
   1652            set_position_mm_kinematic(current_position);
   \   00000022   0x....             LDR.N    R0,??DataTable17_21
   \   00000024   0x.... 0x....      BL       _ZN7Planner25set_position_mm_kinematicERA4_Kf
   1653            reset_acceleration_rates();
   \   00000028   0xE8BD 0x4001      POP      {R0,LR}
   \   0000002C   0x....             B.N      _ZN7Planner24reset_acceleration_ratesEv
   1654          }
   1655          
   1656          #if ENABLED(AUTOTEMP)
   1657          

   \                                 In section .text, align 2, keep-with-next
   1658            void Planner::autotemp_M104_M109() {
   \                     _ZN7Planner18autotemp_M104_M109Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1659              autotemp_enabled = parser.seen('F');
   \   00000002   0x2046             MOVS     R0,#+70
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x....             LDR.N    R4,??DataTable17_7
   \   0000000A   0x70A0             STRB     R0,[R4, #+2]
   1660              if (autotemp_enabled) autotemp_factor = parser.value_celsius_diff();
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??autotemp_M104_M109_0
   \   00000010   0x.... 0x....      BL       _ZN11GCodeParser18value_celsius_diffEv
   \   00000014   0xED84 0x0A18      VSTR     S0,[R4, #+96]
   1661              if (parser.seen('S')) autotemp_min = parser.value_celsius();
   \                     ??autotemp_M104_M109_0: (+1)
   \   00000018   0x2053             MOVS     R0,#+83
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD003             BEQ.N    ??autotemp_M104_M109_1
   \   00000022   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000026   0xED84 0x0A17      VSTR     S0,[R4, #+92]
   1662              if (parser.seen('B')) autotemp_max = parser.value_celsius();
   \                     ??autotemp_M104_M109_1: (+1)
   \   0000002A   0x2042             MOVS     R0,#+66
   \   0000002C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD003             BEQ.N    ??autotemp_M104_M109_2
   \   00000034   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000038   0xED84 0x0A16      VSTR     S0,[R4, #+88]
   1663            }
   \                     ??autotemp_M104_M109_2: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp Planner::subobject Planner()
   \                     _ZN7PlannerC2Ev: (+1)
   \   00000000   0x....             B.N      _ZN7PlannerC1Ev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x00000000         DC32     0x0,0x3FF80000
   \              0x3FF80000   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x00000000         DC32     0x0,0x3FF00000
   \              0x3FF00000   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     _ZN7Planner23volumetric_area_nominalE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x54442D18         DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x400921FB         DC32     0x400921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x358637BE         DC32     0x358637be

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x3F7D70A4         DC32     0x3f7d70a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     _ZN7Planner12block_bufferE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     _ZN7Planner12block_bufferE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x9999999A         DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x3FA99999         DC32     0x3fa99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x47AE1480         DC32     0x47ae1480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x3F947AE1         DC32     0x3f947ae1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0xF5C28F5C         DC32     0xf5c28f5c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x3FEF5C28         DC32     0x3fef5c28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x........         DC32     _ZN7Planner15flow_percentageE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x........         DC32     fanSpeeds

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   0x........         DC32     _ZN7Planner23g_uc_extruder_last_moveE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \   00000000   0xA0B5ED8D         DC32     0xa0b5ed8d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_16:
   \   00000000   0x4020C6F7         DC32     0x4020c6f7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_17:
   \   00000000   0x3D4CCCCD         DC32     0x3d4ccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_18:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_19:
   \   00000000   0x........         DC32     marlin_debug_flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_20:
   \   00000000   0x........         DC32     htim2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_21:
   \   00000000   0x........         DC32     current_position

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " too long extrusion p...">`:
   \   00000000   0x20 0x74          DC8 " too long extrusion prevented\012"
   \              0x6F 0x6F    
   \              0x20 0x6C    
   \              0x6F 0x6E    
   \              0x67 0x20    
   \              0x65 0x78    
   \              0x74 0x72    
   \              0x75 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0
   1664          
   1665          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GCodeParser::seen(char)
       0   GCodeParser::value_celsius()
         0   -> GCodeParser::value_float()
       0   GCodeParser::value_celsius_diff()
         0   -> GCodeParser::value_float()
      16   GCodeParser::value_float()
        16   -> __aeabi_d2f
        16   -> strtod
       8   Planner::Planner()
         8   -> Planner::init()
      96   Planner::_buffer_steps(signed int const (&)[4], float, uint8_t)
        96   -> HAL_GPIO_WritePin
        96   -> Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
        96   -> Planner::max_allowable_speed(float const &, float const &, float const &)
        96   -> Planner::movesplanned()
        96   -> Planner::next_block_index(int8_t)
        96   -> Planner::recalculate()
        96   -> __aeabi_d2iz
        96   -> __aeabi_dadd
        96   -> __aeabi_dmul
        96   -> __aeabi_f2d
        96   -> __aeabi_ui2d
        96   -> ceilf
        96   -> idle()
        96   -> labs
        96   -> memcpy
        96   -> serialprintPGM(char const *)
        96   -> sqrtf
      40   Planner::_set_position_mm(float const &, float const &, float const &, float const &)
        40   -> Stepper::set_position(long const &, long const &, long const &, long const &)
        40   -> lroundf
        40   -> memset
       8   Planner::autotemp_M104_M109()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_celsius()
         8   -> GCodeParser::value_celsius_diff()
       0   Planner::blocks_queued()
      56   Planner::buffer_segment(float const &, float const &, float const &, float const &, float const &, uint8_t)
        56   -> HAL_TIM_Base_Start_IT
        56   -> HAL_TIM_Base_Stop_IT
        56   -> Planner::_buffer_steps(signed int const (&)[4], float, uint8_t)
        56   -> Planner::blocks_queued()
        56   -> Stepper::wake_up()
        56   -> lroundf
      64   Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
        64   -> Planner::estimate_acceleration_distance(float const &, float const &, float const &)
        64   -> Planner::intersection_distance(float const &, float const &, float const &, float const &)
        64   -> ceilf
        64   -> floorf
       8   Planner::calculate_volumetric_multipliers()
         8   -> Planner::refresh_e_factor(uint8_t)
         8   -> calculate_volumetric_multiplier(float const &)
       8   Planner::check_axes_activity()
         8   -> Planner::blocks_queued()
         0   -> Planner::getHighESpeed()
         8   -> Planner::next_block_index(int8_t)
       0   Planner::estimate_acceleration_distance(float const &, float const &, float const &)
      24   Planner::forward_pass()
         0   -> Planner::forward_pass_kernel(block_t const *, block_t *)
        24   -> Planner::forward_pass_kernel(block_t const *, block_t *)
        24   -> Planner::next_block_index(int8_t)
      24   Planner::forward_pass_kernel(block_t const *, block_t *)
        24   -> Planner::max_allowable_speed(float const &, float const &, float const &)
      24   Planner::getHighESpeed()
        24   -> Planner::next_block_index(int8_t)
        24   -> Temperature::degTargetHotend(uint8_t)
         0   -> Temperature::setTargetHotend(float, uint8_t)
        24   -> __aeabi_d2f
        24   -> __aeabi_dadd
        24   -> __aeabi_dmul
        24   -> __aeabi_f2d
       8   Planner::init()
         8   -> memset
       4   Planner::intersection_distance(float const &, float const &, float const &, float const &)
       0   Planner::max_allowable_speed(float const &, float const &, float const &)
         0   -> sqrtf
       0   Planner::movesplanned()
       0   Planner::next_block_index(int8_t)
       0   Planner::prev_block_index(int8_t)
       8   Planner::recalculate()
         8   -> Planner::forward_pass()
         0   -> Planner::recalculate_trapezoids()
         8   -> Planner::reverse_pass()
      32   Planner::recalculate_trapezoids()
        32   -> Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
        32   -> Planner::next_block_index(int8_t)
        32   -> __aeabi_d2f
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
      24   Planner::refresh_e_factor(uint8_t)
        24   -> __aeabi_d2f
        24   -> __aeabi_dmul
        24   -> __aeabi_f2d
        24   -> __aeabi_i2d
       8   Planner::refresh_positioning()
         0   -> Planner::reset_acceleration_rates()
         8   -> Planner::set_position_mm_kinematic(float const (&)[4])
       0   Planner::reset_acceleration_rates()
      32   Planner::reverse_pass()
        32   -> Planner::movesplanned()
        32   -> Planner::prev_block_index(int8_t)
        32   -> Planner::reverse_pass_kernel(block_t *, block_t const *)
      32   Planner::reverse_pass_kernel(block_t *, block_t const *)
        32   -> Planner::max_allowable_speed(float const &, float const &, float const &)
      24   Planner::set_position_mm(AxisEnum, float const &)
        24   -> Stepper::set_position(AxisEnum const &, long const &)
        24   -> lroundf
      24   Planner::set_position_mm_kinematic(float const (&)[4])
        24   -> Planner::_set_position_mm(float const &, float const &, float const &, float const &)
       0   Planner::subobject Planner()
         0   -> Planner::Planner()
       8   Planner::sync_from_steppers()
         8   -> Stepper::position(AxisEnum)
       0   Temperature::degTargetHotend(uint8_t)
       0   Temperature::setTargetHotend(float, uint8_t)
         0   -> Temperature::start_watching_heater(uint8_t)
      32   __sti__routine()
        32   -> Planner::Planner()
        32   -> __aeabi_d2f
        32   -> __aeabi_dmul
      24   calculate_volumetric_multiplier(float const &)
        24   -> __aeabi_d2f
        24   -> __aeabi_ddiv
        24   -> __aeabi_dmul
        24   -> __aeabi_f2d
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant " too long extrusion p...">
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_16
       4  ??DataTable17_17
       4  ??DataTable17_18
       4  ??DataTable17_19
       4  ??DataTable17_2
       4  ??DataTable17_20
       4  ??DataTable17_21
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
       8  ??DataTable4
       8  ??DataTable5
       4  ??DataTable9
       4  ??DataTable9_1
      76  GCodeParser::seen(char)
       4  GCodeParser::value_celsius()
       4  GCodeParser::value_celsius_diff()
     100  GCodeParser::value_float()
      12  Planner::Planner()
    1974  Planner::_buffer_steps(signed int const (&)[4], float, uint8_t)
     130  Planner::_set_position_mm(float const &, float const &, float const &, float const &)
      62  Planner::autotemp_M104_M109()
    1344  Planner::block_buffer
     128  Planner::block_buffer_head
          Planner::block_buffer_tail
          Planner::autotemp_enabled
          Planner::axis_steps_per_mm
          Planner::steps_to_mm
          Planner::max_acceleration_steps_per_s2
          Planner::position
          Planner::e_factor
          Planner::max_acceleration_mm_per_s2
          Planner::autotemp_max
          Planner::autotemp_min
          Planner::autotemp_factor
          Planner::cutoff_long
          Planner::previous_speed
          Planner::previous_nominal_speed
          oldt
      24  Planner::blocks_queued()
     264  Planner::buffer_segment(float const &, float const &, float const &, float const &, float const &, uint8_t)
     308  Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
      36  Planner::calculate_volumetric_multipliers()
      68  Planner::check_axes_activity()
     104  Planner::estimate_acceleration_distance(float const &, float const &, float const &)
      12  Planner::flow_percentage
          Planner::volumetric_multiplier
          Planner::filament_size
      62  Planner::forward_pass()
     134  Planner::forward_pass_kernel(block_t const *, block_t *)
      60  Planner::g_uc_extruder_last_move
          Planner::max_feedrate_mm_s
          Planner::min_feedrate_mm_s
          Planner::acceleration
          Planner::retract_acceleration
          Planner::travel_acceleration
          Planner::max_jerk
          Planner::min_travel_feedrate_mm_s
          previous_safe_speed
     282  Planner::getHighESpeed()
      42  Planner::init()
     128  Planner::intersection_distance(float const &, float const &, float const &, float const &)
       1  Planner::leveling_active
      52  Planner::max_allowable_speed(float const &, float const &, float const &)
       4  Planner::min_segment_time_us
      20  Planner::movesplanned()
       8  Planner::next_block_index(int8_t)
       8  Planner::prev_block_index(int8_t)
      16  Planner::recalculate()
     188  Planner::recalculate_trapezoids()
      76  Planner::refresh_e_factor(uint8_t)
      46  Planner::refresh_positioning()
      62  Planner::reset_acceleration_rates()
      90  Planner::reverse_pass()
     144  Planner::reverse_pass_kernel(block_t *, block_t const *)
      74  Planner::set_position_mm(AxisEnum, float const &)
      40  Planner::set_position_mm_kinematic(float const (&)[4])
       2  Planner::subobject Planner()
      30  Planner::sync_from_steppers()
       8  Planner::volumetric_area_nominal
          planner
      16  Temperature::degTargetHotend(uint8_t)
      20  Temperature::setTargetHotend(float, uint8_t)
      96  __sti__routine()
     168  calculate_volumetric_multiplier(float const &)
      28  serialprintPGM(char const *)
       5  -- Other

 
 1 416 bytes in section .bss
   140 bytes in section .data
     4 bytes in section .init_array
     2 bytes in section .rodata
 5 170 bytes in section .text
 
 4 338 bytes of CODE  memory (+ 836 bytes shared)
     1 byte  of CONST memory (+   1 byte  shared)
 1 556 bytes of DATA  memory

Errors: none
Warnings: 66
