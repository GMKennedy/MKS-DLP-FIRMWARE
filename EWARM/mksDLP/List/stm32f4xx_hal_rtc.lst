###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:17
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_rtc.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_rtc.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\stm32f4xx_hal_rtc.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\stm32f4xx_hal_rtc.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_rtc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_rtc.c
      4            * @author  MCD Application Team
      5            * @version V1.5.2
      6            * @date    22-September-2016
      7            * @brief   RTC HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Real Time Clock (RTC) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + RTC Time and Date functions
     12            *           + RTC Alarm functions
     13            *           + Peripheral Control functions   
     14            *           + Peripheral State functions
     15            *         
     16            @verbatim
     17            ==============================================================================
     18                        ##### Backup Domain Operating Condition #####
     19            ==============================================================================
     20            [..] The real-time clock (RTC), the RTC backup registers, and the backup 
     21                 SRAM (BKP SRAM) can be powered from the VBAT voltage when the main 
     22                 VDD supply is powered off.
     23                 To retain the content of the RTC backup registers, backup SRAM, and supply 
     24                 the RTC when VDD is turned off, VBAT pin can be connected to an optional 
     25                 standby voltage supplied by a battery or by another source.
     26          
     27            [..] To allow the RTC operating even when the main digital supply (VDD) is turned
     28                 off, the VBAT pin powers the following blocks:
     29              (#) The RTC
     30              (#) The LSE oscillator
     31              (#) The backup SRAM when the low power backup regulator is enabled
     32              (#) PC13 to PC15 I/Os, plus PI8 I/O (when available)
     33            
     34            [..] When the backup domain is supplied by VDD (analog switch connected to VDD),
     35                 the following pins are available:
     36              (#) PC14 and PC15 can be used as either GPIO or LSE pins
     37              (#) PC13 can be used as a GPIO or as the RTC_AF1 pin
     38              (#) PI8 can be used as a GPIO or as the RTC_AF2 pin
     39            
     40            [..] When the backup domain is supplied by VBAT (analog switch connected to VBAT 
     41                 because VDD is not present), the following pins are available:
     42              (#) PC14 and PC15 can be used as LSE pins only
     43              (#) PC13 can be used as the RTC_AF1 pin 
     44              (#) PI8 can be used as the RTC_AF2 pin
     45                       
     46                             ##### Backup Domain Reset #####
     47            ==================================================================
     48            [..] The backup domain reset sets all RTC registers and the RCC_BDCR register 
     49                 to their reset values. The BKPSRAM is not affected by this reset. The only
     50                 way to reset the BKPSRAM is through the Flash interface by requesting 
     51                 a protection level change from 1 to 0.
     52            [..] A backup domain reset is generated when one of the following events occurs:
     53              (#) Software reset, triggered by setting the BDRST bit in the 
     54                  RCC Backup domain control register (RCC_BDCR). 
     55              (#) VDD or VBAT power on, if both supplies have previously been powered off.  
     56          
     57                             ##### Backup Domain Access #####
     58            ==================================================================
     59            [..] After reset, the backup domain (RTC registers, RTC backup data 
     60                 registers and backup SRAM) is protected against possible unwanted write 
     61                 accesses. 
     62            [..] To enable access to the RTC Domain and RTC registers, proceed as follows:
     63              (+) Enable the Power Controller (PWR) APB1 interface clock using the
     64                  __HAL_RCC_PWR_CLK_ENABLE() function.
     65              (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.
     66              (+) Select the RTC clock source using the __HAL_RCC_RTC_CONFIG() function.
     67              (+) Enable RTC Clock using the __HAL_RCC_RTC_ENABLE() function.
     68            
     69            
     70                            ##### How to use this driver #####
     71            ==================================================================
     72            [..] 
     73              (+) Enable the RTC domain access (see description in the section above).
     74              (+) Configure the RTC Prescaler (Asynchronous and Synchronous) and RTC hour 
     75                  format using the HAL_RTC_Init() function.
     76            
     77            *** Time and Date configuration ***
     78            ===================================
     79            [..] 
     80              (+) To configure the RTC Calendar (Time and Date) use the HAL_RTC_SetTime() 
     81                  and HAL_RTC_SetDate() functions.
     82              (+) To read the RTC Calendar, use the HAL_RTC_GetTime() and HAL_RTC_GetDate() functions. 
     83            
     84            *** Alarm configuration ***
     85            ===========================
     86            [..]
     87              (+) To configure the RTC Alarm use the HAL_RTC_SetAlarm() function. 
     88                  You can also configure the RTC Alarm with interrupt mode using the HAL_RTC_SetAlarm_IT() function.
     89              (+) To read the RTC Alarm, use the HAL_RTC_GetAlarm() function.
     90            
     91                            ##### RTC and low power modes #####
     92            ==================================================================
     93            [..] The MCU can be woken up from a low power mode by an RTC alternate 
     94                 function.
     95            [..] The RTC alternate functions are the RTC alarms (Alarm A and Alarm B), 
     96                 RTC wake-up, RTC tamper event detection and RTC time stamp event detection.
     97                 These RTC alternate functions can wake up the system from the Stop and 
     98                 Standby low power modes.
     99            [..] The system can also wake up from low power modes without depending 
    100                 on an external interrupt (Auto-wake-up mode), by using the RTC alarm 
    101                 or the RTC wake-up events.
    102            [..] The RTC provides a programmable time base for waking up from the 
    103                 Stop or Standby mode at regular intervals.
    104                 Wake-up from STOP and STANDBY modes is possible only when the RTC clock source
    105                 is LSE or LSI.
    106               
    107             @endverbatim
    108            ******************************************************************************
    109            * @attention
    110            *
    111            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    112            *
    113            * Redistribution and use in source and binary forms, with or without modification,
    114            * are permitted provided that the following conditions are met:
    115            *   1. Redistributions of source code must retain the above copyright notice,
    116            *      this list of conditions and the following disclaimer.
    117            *   2. Redistributions in binary form must reproduce the above copyright notice,
    118            *      this list of conditions and the following disclaimer in the documentation
    119            *      and/or other materials provided with the distribution.
    120            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    121            *      may be used to endorse or promote products derived from this software
    122            *      without specific prior written permission.
    123            *
    124            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    125            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    126            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    127            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    128            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    129            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    130            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    131            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    132            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    133            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    134            *
    135            ******************************************************************************
    136            */ 
    137          
    138          /* Includes ------------------------------------------------------------------*/
    139          #include "stm32f4xx_hal.h"
    140          
    141          /** @addtogroup STM32F4xx_HAL_Driver
    142            * @{
    143            */
    144          
    145          /** @defgroup RTC RTC
    146            * @brief RTC HAL module driver
    147            * @{
    148            */
    149          
    150          #ifdef HAL_RTC_MODULE_ENABLED
    151          
    152          /* Private typedef -----------------------------------------------------------*/
    153          /* Private define ------------------------------------------------------------*/
    154          /* Private macro -------------------------------------------------------------*/
    155          /* Private variables ---------------------------------------------------------*/
    156          /* Private function prototypes -----------------------------------------------*/
    157          /* Private functions ---------------------------------------------------------*/
    158          
    159          /** @defgroup RTC_Exported_Functions RTC Exported Functions
    160            * @{
    161            */
    162            
    163          /** @defgroup RTC_Exported_Functions_Group1 Initialization and de-initialization functions 
    164           *  @brief    Initialization and Configuration functions 
    165           *
    166          @verbatim    
    167           ===============================================================================
    168                        ##### Initialization and de-initialization functions #####
    169           ===============================================================================
    170             [..] This section provides functions allowing to initialize and configure the 
    171                   RTC Prescaler (Synchronous and Asynchronous), RTC Hour format, disable 
    172                   RTC registers Write protection, enter and exit the RTC initialization mode, 
    173                   RTC registers synchronization check and reference clock detection enable.
    174                   (#) The RTC Prescaler is programmed to generate the RTC 1Hz time base. 
    175                       It is split into 2 programmable prescalers to minimize power consumption.
    176                       (++) A 7-bit asynchronous prescaler and a 13-bit synchronous prescaler.
    177                       (++) When both prescalers are used, it is recommended to configure the 
    178                           asynchronous prescaler to a high value to minimize power consumption.
    179                   (#) All RTC registers are Write protected. Writing to the RTC registers
    180                       is enabled by writing a key into the Write Protection register, RTC_WPR.
    181                   (#) To configure the RTC Calendar, user application should enter 
    182                       initialization mode. In this mode, the calendar counter is stopped 
    183                       and its value can be updated. When the initialization sequence is 
    184                       complete, the calendar restarts counting after 4 RTCCLK cycles.
    185                   (#) To read the calendar through the shadow registers after Calendar 
    186                       initialization, calendar update or after wake-up from low power modes 
    187                       the software must first clear the RSF flag. The software must then 
    188                       wait until it is set again before reading the calendar, which means 
    189                       that the calendar registers have been correctly copied into the 
    190                       RTC_TR and RTC_DR shadow registers.The HAL_RTC_WaitForSynchro() function 
    191                       implements the above software sequence (RSF clear and RSF check).
    192           
    193          @endverbatim
    194            * @{
    195            */
    196          
    197          /**
    198            * @brief  Initializes the RTC peripheral 
    199            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    200            *                the configuration information for RTC.
    201            * @retval HAL status
    202            */

   \                                 In section .text, align 2, keep-with-next
    203          HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
    204          {
   \                     HAL_RTC_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    205            /* Check the RTC peripheral state */
    206            if(hrtc == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_RTC_Init_0
    207            {
    208               return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD70             POP      {R4-R6,PC}
    209            }
    210            
    211            /* Check the parameters */
    212            assert_param(IS_RTC_HOUR_FORMAT(hrtc->Init.HourFormat));
    213            assert_param(IS_RTC_ASYNCH_PREDIV(hrtc->Init.AsynchPrediv));
    214            assert_param(IS_RTC_SYNCH_PREDIV(hrtc->Init.SynchPrediv));
    215            assert_param (IS_RTC_OUTPUT(hrtc->Init.OutPut));
    216            assert_param (IS_RTC_OUTPUT_POL(hrtc->Init.OutPutPolarity));
    217            assert_param(IS_RTC_OUTPUT_TYPE(hrtc->Init.OutPutType));
    218              
    219            if(hrtc->State == HAL_RTC_STATE_RESET)
   \                     ??HAL_RTC_Init_0: (+1)
   \   0000000A   0xF994 0x001D      LDRSB    R0,[R4, #+29]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD104             BNE.N    ??HAL_RTC_Init_1
    220            {
    221              /* Allocate lock resource and initialize it */
    222              hrtc->Lock = HAL_UNLOCKED;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7720             STRB     R0,[R4, #+28]
    223              /* Initialize RTC MSP */
    224              HAL_RTC_MspInit(hrtc);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_RTC_MspInit
    225            }
    226            
    227            /* Set RTC state */  
    228            hrtc->State = HAL_RTC_STATE_BUSY;  
   \                     ??HAL_RTC_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x7760             STRB     R0,[R4, #+29]
    229                 
    230            /* Disable the write protection for RTC registers */
    231            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \   00000020   0x20CA             MOVS     R0,#+202
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x6248             STR      R0,[R1, #+36]
   \   00000026   0x2053             MOVS     R0,#+83
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x6248             STR      R0,[R1, #+36]
    232          
    233            /* Set Initialization mode */
    234            if(RTC_EnterInitMode(hrtc) != HAL_OK)
   \   0000002C   0x6826             LDR      R6,[R4, #+0]
   \   0000002E   0x25FF             MOVS     R5,#+255
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD004             BEQ.N    ??HAL_RTC_Init_2
    235            {
    236              /* Enable the write protection for RTC registers */
    237              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
   \   0000003A   0x6275             STR      R5,[R6, #+36]
    238              
    239              /* Set RTC state */
    240              hrtc->State = HAL_RTC_STATE_ERROR;
   \   0000003C   0x2004             MOVS     R0,#+4
   \   0000003E   0x7760             STRB     R0,[R4, #+29]
    241              
    242              return HAL_ERROR;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xBD70             POP      {R4-R6,PC}
    243            } 
    244            else
    245            { 
    246              /* Clear RTC_CR FMT, OSEL and POL Bits */
    247              hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
   \                     ??HAL_RTC_Init_2: (+1)
   \   00000044   0x68B0             LDR      R0,[R6, #+8]
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable7  ;; 0xff8fffbf
   \   0000004A   0x4008             ANDS     R0,R1,R0
   \   0000004C   0x60B0             STR      R0,[R6, #+8]
    248              /* Set RTC_CR register */
    249              hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6881             LDR      R1,[R0, #+8]
   \   00000052   0x6862             LDR      R2,[R4, #+4]
   \   00000054   0x6923             LDR      R3,[R4, #+16]
   \   00000056   0x431A             ORRS     R2,R3,R2
   \   00000058   0x6963             LDR      R3,[R4, #+20]
   \   0000005A   0x431A             ORRS     R2,R3,R2
   \   0000005C   0x4311             ORRS     R1,R2,R1
   \   0000005E   0x6081             STR      R1,[R0, #+8]
    250              
    251              /* Configure the RTC PRER */
    252              hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
   \   00000060   0x68E0             LDR      R0,[R4, #+12]
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x6108             STR      R0,[R1, #+16]
    253              hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6901             LDR      R1,[R0, #+16]
   \   0000006A   0x68A2             LDR      R2,[R4, #+8]
   \   0000006C   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000070   0x6101             STR      R1,[R0, #+16]
    254              
    255              /* Exit Initialization mode */
    256              hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT; 
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x68C1             LDR      R1,[R0, #+12]
   \   00000076   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000007A   0x60C1             STR      R1,[R0, #+12]
    257              
    258              hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_ALARMOUTTYPE;
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6C01             LDR      R1,[R0, #+64]
   \   00000080   0xF421 0x2180      BIC      R1,R1,#0x40000
   \   00000084   0x6401             STR      R1,[R0, #+64]
    259              hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType); 
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6C01             LDR      R1,[R0, #+64]
   \   0000008A   0x69A2             LDR      R2,[R4, #+24]
   \   0000008C   0x4311             ORRS     R1,R2,R1
   \   0000008E   0x6401             STR      R1,[R0, #+64]
    260              
    261              /* Enable the write protection for RTC registers */
    262              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6245             STR      R5,[R0, #+36]
    263              
    264              /* Set RTC state */
    265              hrtc->State = HAL_RTC_STATE_READY;
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x7760             STRB     R0,[R4, #+29]
    266              
    267              return HAL_OK;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xBD70             POP      {R4-R6,PC}       ;; return
    268            }
    269          }
    270          
    271          /**
    272            * @brief  DeInitializes the RTC peripheral 
    273            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    274            *                the configuration information for RTC.
    275            * @note   This function doesn't reset the RTC Backup Data registers.   
    276            * @retval HAL status
    277            */

   \                                 In section .text, align 2, keep-with-next
    278          HAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc)
    279          {
   \                     HAL_RTC_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    280            uint32_t tickstart = 0U;
    281          
    282            /* Set RTC state */
    283            hrtc->State = HAL_RTC_STATE_BUSY; 
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x7760             STRB     R0,[R4, #+29]
    284            
    285            /* Disable the write protection for RTC registers */
    286            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \   00000008   0x20CA             MOVS     R0,#+202
   \   0000000A   0x6821             LDR      R1,[R4, #+0]
   \   0000000C   0x6248             STR      R0,[R1, #+36]
   \   0000000E   0x2053             MOVS     R0,#+83
   \   00000010   0x6821             LDR      R1,[R4, #+0]
   \   00000012   0x6248             STR      R0,[R1, #+36]
    287            
    288            /* Set Initialization mode */
    289            if(RTC_EnterInitMode(hrtc) != HAL_OK)
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       RTC_EnterInitMode
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD145             BNE.N    ??HAL_RTC_DeInit_0
    290            {
    291              /* Enable the write protection for RTC registers */
    292              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
    293              
    294              /* Set RTC state */
    295              hrtc->State = HAL_RTC_STATE_ERROR;
    296              
    297              return HAL_ERROR;
    298            }  
    299            else
    300            {
    301              /* Reset TR, DR and CR registers */
    302              hrtc->Instance->TR = (uint32_t)0x00000000U;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x6008             STR      R0,[R1, #+0]
    303              hrtc->Instance->DR = (uint32_t)0x00002101U;
   \   00000024   0xF242 0x1001      MOVW     R0,#+8449
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x6048             STR      R0,[R1, #+4]
    304              /* Reset All CR bits except CR[2:0] */
    305              hrtc->Instance->CR &= (uint32_t)0x00000007U;
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6881             LDR      R1,[R0, #+8]
   \   00000030   0xF001 0x0107      AND      R1,R1,#0x7
   \   00000034   0x6081             STR      R1,[R0, #+8]
    306          
    307              /* Get tick */
    308              tickstart = HAL_GetTick();
   \   00000036   0x.... 0x....      BL       HAL_GetTick
   \   0000003A   0x4605             MOV      R5,R0
    309          
    310              /* Wait till WUTWF flag is set and if Time out is reached exit */
    311              while(((hrtc->Instance->ISR) & RTC_ISR_WUTWF) == (uint32_t)RESET)
   \                     ??HAL_RTC_DeInit_1: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x68C1             LDR      R1,[R0, #+12]
   \   00000040   0x0749             LSLS     R1,R1,#+29
   \   00000042   0xD40B             BMI.N    ??HAL_RTC_DeInit_2
    312              {
    313                if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
   \   00000044   0x.... 0x....      BL       HAL_GetTick
   \   00000048   0x1B40             SUBS     R0,R0,R5
   \   0000004A   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   0000004E   0xD9F5             BLS.N    ??HAL_RTC_DeInit_1
    314                { 
    315                  /* Enable the write protection for RTC registers */
    316                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
   \   00000050   0x20FF             MOVS     R0,#+255
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x6248             STR      R0,[R1, #+36]
    317                  
    318                  /* Set RTC state */
    319                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \   00000056   0x2003             MOVS     R0,#+3
   \   00000058   0x7760             STRB     R0,[R4, #+29]
    320                  
    321                  return HAL_TIMEOUT;
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}
    322                }      
    323              }
    324              
    325              /* Reset all RTC CR register bits */
    326              hrtc->Instance->CR &= (uint32_t)0x00000000U;
   \                     ??HAL_RTC_DeInit_2: (+1)
   \   0000005C   0x6881             LDR      R1,[R0, #+8]
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x6081             STR      R1,[R0, #+8]
    327              hrtc->Instance->WUTR = (uint32_t)0x0000FFFFU;
   \   00000062   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6148             STR      R0,[R1, #+20]
    328              hrtc->Instance->PRER = (uint32_t)0x007F00FFU;
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable7_1  ;; 0x7f00ff
   \   0000006E   0x6821             LDR      R1,[R4, #+0]
   \   00000070   0x6108             STR      R0,[R1, #+16]
    329              hrtc->Instance->CALIBR = (uint32_t)0x00000000U;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x6188             STR      R0,[R1, #+24]
    330              hrtc->Instance->ALRMAR = (uint32_t)0x00000000U;
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x61C8             STR      R0,[R1, #+28]
    331              hrtc->Instance->ALRMBR = (uint32_t)0x00000000U;
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x6208             STR      R0,[R1, #+32]
    332              hrtc->Instance->SHIFTR = (uint32_t)0x00000000U;
   \   00000080   0x6821             LDR      R1,[R4, #+0]
   \   00000082   0x62C8             STR      R0,[R1, #+44]
    333              hrtc->Instance->CALR = (uint32_t)0x00000000U;
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x63C8             STR      R0,[R1, #+60]
    334              hrtc->Instance->ALRMASSR = (uint32_t)0x00000000U;
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x6448             STR      R0,[R1, #+68]
    335              hrtc->Instance->ALRMBSSR = (uint32_t)0x00000000U;
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x6488             STR      R0,[R1, #+72]
    336              
    337              /* Reset ISR register and exit initialization mode */
    338              hrtc->Instance->ISR = (uint32_t)0x00000000U;
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x60C8             STR      R0,[R1, #+12]
    339              
    340              /* Reset Tamper and alternate functions configuration register */
    341              hrtc->Instance->TAFCR = 0x00000000U;
   \   00000094   0x6821             LDR      R1,[R4, #+0]
   \   00000096   0x6408             STR      R0,[R1, #+64]
    342              
    343              /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    344              if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x6880             LDR      R0,[R0, #+8]
   \   0000009C   0x0680             LSLS     R0,R0,#+26
   \   0000009E   0xD40B             BMI.N    ??HAL_RTC_DeInit_3
    345              {
    346                if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       HAL_RTC_WaitForSynchro
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD006             BEQ.N    ??HAL_RTC_DeInit_3
    347                {
    348                  /* Enable the write protection for RTC registers */
    349                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
   \                     ??HAL_RTC_DeInit_0: (+1)
   \   000000AA   0x20FF             MOVS     R0,#+255
   \   000000AC   0x6821             LDR      R1,[R4, #+0]
   \   000000AE   0x6248             STR      R0,[R1, #+36]
    350                  
    351                  hrtc->State = HAL_RTC_STATE_ERROR;
   \   000000B0   0x2004             MOVS     R0,#+4
   \   000000B2   0x7760             STRB     R0,[R4, #+29]
    352                  
    353                  return HAL_ERROR;
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0xBD32             POP      {R1,R4,R5,PC}
    354                }
    355              }    
    356            }
    357            
    358            /* Enable the write protection for RTC registers */
    359            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_DeInit_3: (+1)
   \   000000B8   0x20FF             MOVS     R0,#+255
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x6248             STR      R0,[R1, #+36]
    360            
    361            /* De-Initialize RTC MSP */
    362            HAL_RTC_MspDeInit(hrtc);
   \   000000BE   0x4620             MOV      R0,R4
   \   000000C0   0x.... 0x....      BL       HAL_RTC_MspDeInit
    363            
    364            hrtc->State = HAL_RTC_STATE_RESET; 
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x7760             STRB     R0,[R4, #+29]
    365          
    366            /* Release Lock */
    367            __HAL_UNLOCK(hrtc);
   \   000000C8   0x7720             STRB     R0,[R4, #+28]
    368          
    369            return HAL_OK;
   \   000000CA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    370          }
    371          
    372          /**
    373            * @brief  Initializes the RTC MSP.
    374            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    375            *                the configuration information for RTC.  
    376            * @retval None
    377            */

   \                                 In section .text, align 2, keep-with-next
    378          __weak void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
    379          {
    380            /* Prevent unused argument(s) compilation warning */
    381            UNUSED(hrtc);
    382            /* NOTE : This function Should not be modified, when the callback is needed,
    383                      the HAL_RTC_MspInit could be implemented in the user file
    384             */ 
    385          }
   \                     HAL_RTC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    386          
    387          /**
    388            * @brief  DeInitializes the RTC MSP.
    389            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    390            *                the configuration information for RTC. 
    391            * @retval None
    392            */

   \                                 In section .text, align 2, keep-with-next
    393          __weak void HAL_RTC_MspDeInit(RTC_HandleTypeDef* hrtc)
    394          {
    395            /* Prevent unused argument(s) compilation warning */
    396            UNUSED(hrtc);
    397            /* NOTE : This function Should not be modified, when the callback is needed,
    398                      the HAL_RTC_MspDeInit could be implemented in the user file
    399             */ 
    400          }
   \                     HAL_RTC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    401          
    402          /**
    403            * @}
    404            */
    405          
    406          /** @defgroup RTC_Exported_Functions_Group2 RTC Time and Date functions
    407           *  @brief   RTC Time and Date functions
    408           *
    409          @verbatim   
    410           ===============================================================================
    411                           ##### RTC Time and Date functions #####
    412           ===============================================================================  
    413           
    414           [..] This section provides functions allowing to configure Time and Date features
    415          
    416          @endverbatim
    417            * @{
    418            */
    419          
    420          /**
    421            * @brief  Sets RTC current time.
    422            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    423            *                the configuration information for RTC.
    424            * @param  sTime: Pointer to Time structure
    425            * @param  Format: Specifies the format of the entered parameters.
    426            *          This parameter can be one of the following values:
    427            *            @arg RTC_FORMAT_BIN: Binary data format 
    428            *            @arg RTC_FORMAT_BCD: BCD data format
    429            * @retval HAL status
    430            */

   \                                 In section .text, align 2, keep-with-next
    431          HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
    432          {
   \                     HAL_RTC_SetTime: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    433            uint32_t tmpreg = 0U;
    434            
    435           /* Check the parameters */
    436            assert_param(IS_RTC_FORMAT(Format));
    437            assert_param(IS_RTC_DAYLIGHT_SAVING(sTime->DayLightSaving));
    438            assert_param(IS_RTC_STORE_OPERATION(sTime->StoreOperation));
    439            
    440            /* Process Locked */ 
    441            __HAL_LOCK(hrtc);
   \   00000006   0xF994 0x001C      LDRSB    R0,[R4, #+28]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_RTC_SetTime_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_RTC_SetTime_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7720             STRB     R0,[R4, #+28]
    442            
    443            hrtc->State = HAL_RTC_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x7760             STRB     R0,[R4, #+29]
    444            
    445            if(Format == RTC_FORMAT_BIN)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0x6880             LDR      R0,[R0, #+8]
   \   00000020   0xD115             BNE.N    ??HAL_RTC_SetTime_1
    446            {
    447              if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \   00000022   0x0640             LSLS     R0,R0,#+25
   \   00000024   0xD401             BMI.N    ??HAL_RTC_SetTime_2
    448              {
    449                assert_param(IS_RTC_HOUR12(sTime->Hours));
    450                assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
    451              } 
    452              else
    453              {
    454                sTime->TimeFormat = 0x00U;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x70E8             STRB     R0,[R5, #+3]
    455                assert_param(IS_RTC_HOUR24(sTime->Hours));
    456              }
    457              assert_param(IS_RTC_MINUTES(sTime->Minutes));
    458              assert_param(IS_RTC_SECONDS(sTime->Seconds));
    459              
    460              tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
    461                                  ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
    462                                  ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
    463                                  (((uint32_t)sTime->TimeFormat) << 16U));  
   \                     ??HAL_RTC_SetTime_2: (+1)
   \   0000002A   0x7828             LDRB     R0,[R5, #+0]
   \   0000002C   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000030   0x4606             MOV      R6,R0
   \   00000032   0x7868             LDRB     R0,[R5, #+1]
   \   00000034   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000038   0x0200             LSLS     R0,R0,#+8
   \   0000003A   0xEA40 0x4606      ORR      R6,R0,R6, LSL #+16
   \   0000003E   0x78A8             LDRB     R0,[R5, #+2]
   \   00000040   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000044   0x4330             ORRS     R0,R0,R6
   \   00000046   0x78E9             LDRB     R1,[R5, #+3]
   \   00000048   0xEA40 0x4601      ORR      R6,R0,R1, LSL #+16
   \   0000004C   0xE011             B.N      ??HAL_RTC_SetTime_3
    464            }
    465            else
    466            {
    467              if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \                     ??HAL_RTC_SetTime_1: (+1)
   \   0000004E   0x0640             LSLS     R0,R0,#+25
   \   00000050   0xD503             BPL.N    ??HAL_RTC_SetTime_4
    468              {
    469                tmpreg = RTC_Bcd2ToByte(sTime->Hours);
   \   00000052   0x7828             LDRB     R0,[R5, #+0]
   \   00000054   0x.... 0x....      BL       RTC_Bcd2ToByte
    470                assert_param(IS_RTC_HOUR12(tmpreg));
    471                assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat)); 
   \   00000058   0xE001             B.N      ??HAL_RTC_SetTime_5
    472              } 
    473              else
    474              {
    475                sTime->TimeFormat = 0x00U;
   \                     ??HAL_RTC_SetTime_4: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x70E8             STRB     R0,[R5, #+3]
    476                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
    477              }
    478              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
    479              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
    480              tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
    481                        ((uint32_t)(sTime->Minutes) << 8U) | \
    482                        ((uint32_t)sTime->Seconds) | \
    483                        ((uint32_t)(sTime->TimeFormat) << 16U));   
   \                     ??HAL_RTC_SetTime_5: (+1)
   \   0000005E   0x7828             LDRB     R0,[R5, #+0]
   \   00000060   0x7869             LDRB     R1,[R5, #+1]
   \   00000062   0x0209             LSLS     R1,R1,#+8
   \   00000064   0xEA41 0x4000      ORR      R0,R1,R0, LSL #+16
   \   00000068   0x78A9             LDRB     R1,[R5, #+2]
   \   0000006A   0x4308             ORRS     R0,R1,R0
   \   0000006C   0x78E9             LDRB     R1,[R5, #+3]
   \   0000006E   0xEA40 0x4601      ORR      R6,R0,R1, LSL #+16
    484            }
    485            
    486            /* Disable the write protection for RTC registers */
    487            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \                     ??HAL_RTC_SetTime_3: (+1)
   \   00000072   0x20CA             MOVS     R0,#+202
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x6248             STR      R0,[R1, #+36]
   \   00000078   0x2053             MOVS     R0,#+83
   \   0000007A   0x6821             LDR      R1,[R4, #+0]
   \   0000007C   0x6248             STR      R0,[R1, #+36]
    488            
    489            /* Set Initialization mode */
    490            if(RTC_EnterInitMode(hrtc) != HAL_OK)
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD11E             BNE.N    ??HAL_RTC_SetTime_6
    491            {
    492              /* Enable the write protection for RTC registers */
    493              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
    494              
    495              /* Set RTC state */
    496              hrtc->State = HAL_RTC_STATE_ERROR;
    497              
    498              /* Process Unlocked */ 
    499              __HAL_UNLOCK(hrtc);
    500              
    501              return HAL_ERROR;
    502            } 
    503            else
    504            {
    505              /* Set the RTC_TR register */
    506              hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable7_2  ;; 0x7f7f7f
   \   0000008C   0x4030             ANDS     R0,R0,R6
   \   0000008E   0x6821             LDR      R1,[R4, #+0]
   \   00000090   0x6008             STR      R0,[R1, #+0]
    507               
    508              /* Clear the bits to be configured */
    509              hrtc->Instance->CR &= (uint32_t)~RTC_CR_BCK;
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6881             LDR      R1,[R0, #+8]
   \   00000096   0xF421 0x2180      BIC      R1,R1,#0x40000
   \   0000009A   0x6081             STR      R1,[R0, #+8]
    510              
    511              /* Configure the RTC_CR register */
    512              hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x6881             LDR      R1,[R0, #+8]
   \   000000A0   0x68EA             LDR      R2,[R5, #+12]
   \   000000A2   0x692B             LDR      R3,[R5, #+16]
   \   000000A4   0x431A             ORRS     R2,R3,R2
   \   000000A6   0x4311             ORRS     R1,R2,R1
   \   000000A8   0x6081             STR      R1,[R0, #+8]
    513              
    514              /* Exit Initialization mode */
    515              hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;  
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x68C1             LDR      R1,[R0, #+12]
   \   000000AE   0xF021 0x0180      BIC      R1,R1,#0x80
   \   000000B2   0x60C1             STR      R1,[R0, #+12]
    516              
    517              /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    518              if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x6880             LDR      R0,[R0, #+8]
   \   000000B8   0x0680             LSLS     R0,R0,#+26
   \   000000BA   0xD40D             BMI.N    ??HAL_RTC_SetTime_7
    519              {
    520                if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
   \   000000BC   0x4620             MOV      R0,R4
   \   000000BE   0x.... 0x....      BL       HAL_RTC_WaitForSynchro
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD008             BEQ.N    ??HAL_RTC_SetTime_7
    521                {        
    522                  /* Enable the write protection for RTC registers */
    523                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
   \                     ??HAL_RTC_SetTime_6: (+1)
   \   000000C6   0x20FF             MOVS     R0,#+255
   \   000000C8   0x6821             LDR      R1,[R4, #+0]
   \   000000CA   0x6248             STR      R0,[R1, #+36]
    524                  
    525                  hrtc->State = HAL_RTC_STATE_ERROR;
   \   000000CC   0x2004             MOVS     R0,#+4
   \   000000CE   0x7760             STRB     R0,[R4, #+29]
    526                  
    527                  /* Process Unlocked */ 
    528                  __HAL_UNLOCK(hrtc);
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x7720             STRB     R0,[R4, #+28]
    529                  
    530                  return HAL_ERROR;
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0xBD70             POP      {R4-R6,PC}
    531                }
    532              }
    533              
    534              /* Enable the write protection for RTC registers */
    535              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_SetTime_7: (+1)
   \   000000D8   0x20FF             MOVS     R0,#+255
   \   000000DA   0x6821             LDR      R1,[R4, #+0]
   \   000000DC   0x6248             STR      R0,[R1, #+36]
    536              
    537             hrtc->State = HAL_RTC_STATE_READY;
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0x7760             STRB     R0,[R4, #+29]
    538            
    539             __HAL_UNLOCK(hrtc); 
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x7720             STRB     R0,[R4, #+28]
    540               
    541             return HAL_OK;
   \   000000E6   0xBD70             POP      {R4-R6,PC}       ;; return
    542            }
    543          }
    544          
    545          /**
    546            * @brief  Gets RTC current time.
    547            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    548            *                the configuration information for RTC.
    549            * @param  sTime: Pointer to Time structure
    550            * @param  Format: Specifies the format of the entered parameters.
    551            *          This parameter can be one of the following values:
    552            *            @arg RTC_FORMAT_BIN: Binary data format 
    553            *            @arg RTC_FORMAT_BCD: BCD data format
    554            * @note  You can use SubSeconds and SecondFraction (sTime structure fields returned) to convert SubSeconds
    555            *        value in second fraction ratio with time unit following generic formula:
    556            *        Second fraction ratio * time_unit= [(SecondFraction-SubSeconds)/(SecondFraction+1)] * time_unit
    557            *        This conversion can be performed only if no shift operation is pending (ie. SHFP=0) when PREDIV_S >= SS
    558            * @note You must call HAL_RTC_GetDate() after HAL_RTC_GetTime() to unlock the values 
    559            *        in the higher-order calendar shadow registers to ensure consistency between the time and date values.
    560            *        Reading RTC current time locks the values in calendar shadow registers until current date is read.
    561            * @retval HAL status
    562            */

   \                                 In section .text, align 2, keep-with-next
    563          HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
    564          {
   \                     HAL_RTC_GetTime: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    565            uint32_t tmpreg = 0U;
    566          
    567            /* Check the parameters */
    568            assert_param(IS_RTC_FORMAT(Format));
    569            
    570            /* Get subseconds structure field from the corresponding register */
    571            sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x6A89             LDR      R1,[R1, #+40]
   \   00000008   0x6061             STR      R1,[R4, #+4]
    572            
    573            /* Get SecondFraction structure field from the corresponding register field*/
    574            sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x6909             LDR      R1,[R1, #+16]
   \   0000000E   0x0449             LSLS     R1,R1,#+17
   \   00000010   0x0C49             LSRS     R1,R1,#+17
   \   00000012   0x60A1             STR      R1,[R4, #+8]
    575          
    576            /* Get the TR register */
    577            tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK); 
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable7_2  ;; 0x7f7f7f
   \   0000001C   0x4008             ANDS     R0,R1,R0
   \   0000001E   0x0C01             LSRS     R1,R0,#+16
   \   00000020   0xF001 0x033F      AND      R3,R1,#0x3F
   \   00000024   0x7023             STRB     R3,[R4, #+0]
    578            
    579            /* Fill the structure fields with the read parameters */
    580            sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16U);
    581            sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8U);
   \   00000026   0x0A03             LSRS     R3,R0,#+8
   \   00000028   0xF003 0x037F      AND      R3,R3,#0x7F
   \   0000002C   0x7063             STRB     R3,[R4, #+1]
    582            sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
   \   0000002E   0xF000 0x007F      AND      R0,R0,#0x7F
   \   00000032   0x70A0             STRB     R0,[R4, #+2]
    583            sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16U); 
   \   00000034   0xF001 0x0040      AND      R0,R1,#0x40
   \   00000038   0x70E0             STRB     R0,[R4, #+3]
    584            
    585            /* Check the input parameters format */
    586            if(Format == RTC_FORMAT_BIN)
   \   0000003A   0x2A00             CMP      R2,#+0
   \   0000003C   0xD10B             BNE.N    ??HAL_RTC_GetTime_0
    587            {
    588              /* Convert the time structure parameters to Binary format */
    589              sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
   \   0000003E   0x7820             LDRB     R0,[R4, #+0]
   \   00000040   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000044   0x7020             STRB     R0,[R4, #+0]
    590              sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
   \   00000046   0x7860             LDRB     R0,[R4, #+1]
   \   00000048   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000004C   0x7060             STRB     R0,[R4, #+1]
    591              sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);  
   \   0000004E   0x78A0             LDRB     R0,[R4, #+2]
   \   00000050   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000054   0x70A0             STRB     R0,[R4, #+2]
    592            }
    593            
    594            return HAL_OK;
   \                     ??HAL_RTC_GetTime_0: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    595          }
    596          
    597          /**
    598            * @brief  Sets RTC current date.
    599            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    600            *                the configuration information for RTC.
    601            * @param  sDate: Pointer to date structure
    602            * @param  Format: specifies the format of the entered parameters.
    603            *          This parameter can be one of the following values:
    604            *            @arg RTC_FORMAT_BIN: Binary data format 
    605            *            @arg RTC_FORMAT_BCD: BCD data format
    606            * @retval HAL status
    607            */

   \                                 In section .text, align 2, keep-with-next
    608          HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
    609          {
   \                     HAL_RTC_SetDate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    610            uint32_t datetmpreg = 0U;
    611            
    612           /* Check the parameters */
    613            assert_param(IS_RTC_FORMAT(Format));
    614            
    615           /* Process Locked */ 
    616           __HAL_LOCK(hrtc);
   \   00000006   0xF994 0x001C      LDRSB    R0,[R4, #+28]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_RTC_SetDate_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_RTC_SetDate_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7720             STRB     R0,[R4, #+28]
    617            
    618            hrtc->State = HAL_RTC_STATE_BUSY; 
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x7760             STRB     R0,[R4, #+29]
    619            
    620            if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD106             BNE.N    ??HAL_RTC_SetDate_1
   \   0000001E   0x7868             LDRB     R0,[R5, #+1]
   \   00000020   0x06C1             LSLS     R1,R0,#+27
   \   00000022   0xD503             BPL.N    ??HAL_RTC_SetDate_1
    621            {
    622              sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
   \   00000024   0xF000 0x00EF      AND      R0,R0,#0xEF
   \   00000028   0x300A             ADDS     R0,R0,#+10
   \   0000002A   0x7068             STRB     R0,[R5, #+1]
    623            }
    624            
    625            assert_param(IS_RTC_WEEKDAY(sDate->WeekDay));
    626            
    627            if(Format == RTC_FORMAT_BIN)
   \                     ??HAL_RTC_SetDate_1: (+1)
   \   0000002C   0x2A00             CMP      R2,#+0
   \   0000002E   0xD111             BNE.N    ??HAL_RTC_SetDate_2
    628            {   
    629              assert_param(IS_RTC_YEAR(sDate->Year));
    630              assert_param(IS_RTC_MONTH(sDate->Month));
    631              assert_param(IS_RTC_DATE(sDate->Date)); 
    632              
    633             datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
    634                           ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
    635                           ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
    636                           ((uint32_t)sDate->WeekDay << 13U));   
   \   00000030   0x78E8             LDRB     R0,[R5, #+3]
   \   00000032   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000036   0x4606             MOV      R6,R0
   \   00000038   0x7868             LDRB     R0,[R5, #+1]
   \   0000003A   0x.... 0x....      BL       RTC_ByteToBcd2
   \   0000003E   0x0200             LSLS     R0,R0,#+8
   \   00000040   0xEA40 0x4606      ORR      R6,R0,R6, LSL #+16
   \   00000044   0x78A8             LDRB     R0,[R5, #+2]
   \   00000046   0x.... 0x....      BL       RTC_ByteToBcd2
   \   0000004A   0x4330             ORRS     R0,R0,R6
   \   0000004C   0x7829             LDRB     R1,[R5, #+0]
   \   0000004E   0xEA40 0x3541      ORR      R5,R0,R1, LSL #+13
   \   00000052   0xE00F             B.N      ??HAL_RTC_SetDate_3
    637            }
    638            else
    639            {   
    640              assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
    641              datetmpreg = RTC_Bcd2ToByte(sDate->Month);
   \                     ??HAL_RTC_SetDate_2: (+1)
   \   00000054   0x7868             LDRB     R0,[R5, #+1]
   \   00000056   0x.... 0x....      BL       RTC_Bcd2ToByte
    642              assert_param(IS_RTC_MONTH(datetmpreg));
    643              datetmpreg = RTC_Bcd2ToByte(sDate->Date);
   \   0000005A   0x78A8             LDRB     R0,[R5, #+2]
   \   0000005C   0x.... 0x....      BL       RTC_Bcd2ToByte
    644              assert_param(IS_RTC_DATE(datetmpreg));
    645              
    646              datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
    647                            (((uint32_t)sDate->Month) << 8U) | \
    648                            ((uint32_t)sDate->Date) | \
    649                            (((uint32_t)sDate->WeekDay) << 13U));  
   \   00000060   0x78E8             LDRB     R0,[R5, #+3]
   \   00000062   0x7869             LDRB     R1,[R5, #+1]
   \   00000064   0x0209             LSLS     R1,R1,#+8
   \   00000066   0xEA41 0x4000      ORR      R0,R1,R0, LSL #+16
   \   0000006A   0x78A9             LDRB     R1,[R5, #+2]
   \   0000006C   0x4308             ORRS     R0,R1,R0
   \   0000006E   0x7829             LDRB     R1,[R5, #+0]
   \   00000070   0xEA40 0x3541      ORR      R5,R0,R1, LSL #+13
    650            }
    651          
    652            /* Disable the write protection for RTC registers */
    653            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \                     ??HAL_RTC_SetDate_3: (+1)
   \   00000074   0x20CA             MOVS     R0,#+202
   \   00000076   0x6821             LDR      R1,[R4, #+0]
   \   00000078   0x6248             STR      R0,[R1, #+36]
   \   0000007A   0x2053             MOVS     R0,#+83
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x6248             STR      R0,[R1, #+36]
    654            
    655            /* Set Initialization mode */
    656            if(RTC_EnterInitMode(hrtc) != HAL_OK)
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD112             BNE.N    ??HAL_RTC_SetDate_4
    657            {
    658              /* Enable the write protection for RTC registers */
    659              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
    660              
    661              /* Set RTC state*/
    662              hrtc->State = HAL_RTC_STATE_ERROR;
    663              
    664              /* Process Unlocked */ 
    665              __HAL_UNLOCK(hrtc);
    666              
    667              return HAL_ERROR;
    668            } 
    669            else
    670            {
    671              /* Set the RTC_DR register */
    672              hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable7_3  ;; 0xffff3f
   \   0000008E   0x4028             ANDS     R0,R0,R5
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x6048             STR      R0,[R1, #+4]
    673              
    674              /* Exit Initialization mode */
    675              hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;  
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x68C1             LDR      R1,[R0, #+12]
   \   00000098   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000009C   0x60C1             STR      R1,[R0, #+12]
    676              
    677              /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    678              if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6880             LDR      R0,[R0, #+8]
   \   000000A2   0x0680             LSLS     R0,R0,#+26
   \   000000A4   0xD40D             BMI.N    ??HAL_RTC_SetDate_5
    679              {
    680                if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0x.... 0x....      BL       HAL_RTC_WaitForSynchro
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD008             BEQ.N    ??HAL_RTC_SetDate_5
    681                { 
    682                  /* Enable the write protection for RTC registers */
    683                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
   \                     ??HAL_RTC_SetDate_4: (+1)
   \   000000B0   0x20FF             MOVS     R0,#+255
   \   000000B2   0x6821             LDR      R1,[R4, #+0]
   \   000000B4   0x6248             STR      R0,[R1, #+36]
    684                  
    685                  hrtc->State = HAL_RTC_STATE_ERROR;
   \   000000B6   0x2004             MOVS     R0,#+4
   \   000000B8   0x7760             STRB     R0,[R4, #+29]
    686                  
    687                  /* Process Unlocked */ 
    688                  __HAL_UNLOCK(hrtc);
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x7720             STRB     R0,[R4, #+28]
    689                  
    690                  return HAL_ERROR;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xBD70             POP      {R4-R6,PC}
    691                }
    692              }
    693              
    694              /* Enable the write protection for RTC registers */
    695              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
   \                     ??HAL_RTC_SetDate_5: (+1)
   \   000000C2   0x20FF             MOVS     R0,#+255
   \   000000C4   0x6821             LDR      R1,[R4, #+0]
   \   000000C6   0x6248             STR      R0,[R1, #+36]
    696              
    697              hrtc->State = HAL_RTC_STATE_READY ;
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0x7760             STRB     R0,[R4, #+29]
    698              
    699              /* Process Unlocked */ 
    700              __HAL_UNLOCK(hrtc);
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x7720             STRB     R0,[R4, #+28]
    701              
    702              return HAL_OK;    
   \   000000D0   0xBD70             POP      {R4-R6,PC}       ;; return
    703            }
    704          }
    705          
    706          /**
    707            * @brief  Gets RTC current date.
    708            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    709            *                the configuration information for RTC.
    710            * @param  sDate: Pointer to Date structure
    711            * @param  Format: Specifies the format of the entered parameters.
    712            *          This parameter can be one of the following values:
    713            *            @arg RTC_FORMAT_BIN:  Binary data format 
    714            *            @arg RTC_FORMAT_BCD:  BCD data format
    715            * @note You must call HAL_RTC_GetDate() after HAL_RTC_GetTime() to unlock the values 
    716            * in the higher-order calendar shadow registers to ensure consistency between the time and date values.
    717            * Reading RTC current time locks the values in calendar shadow registers until Current date is read.
    718            * @retval HAL status
    719            */

   \                                 In section .text, align 2, keep-with-next
    720          HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
    721          {
   \                     HAL_RTC_GetDate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    722            uint32_t datetmpreg = 0U;
    723          
    724            /* Check the parameters */
    725            assert_param(IS_RTC_FORMAT(Format));
    726                    
    727            /* Get the DR register */
    728            datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK); 
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6840             LDR      R0,[R0, #+4]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable7_3  ;; 0xffff3f
   \   0000000C   0x4008             ANDS     R0,R1,R0
    729          
    730            /* Fill the structure fields with the read parameters */
    731            sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16U);
   \   0000000E   0x0C01             LSRS     R1,R0,#+16
   \   00000010   0x70E1             STRB     R1,[R4, #+3]
    732            sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8U);
   \   00000012   0x0A01             LSRS     R1,R0,#+8
   \   00000014   0xF001 0x011F      AND      R1,R1,#0x1F
   \   00000018   0x7061             STRB     R1,[R4, #+1]
    733            sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
   \   0000001A   0xF000 0x013F      AND      R1,R0,#0x3F
   \   0000001E   0x70A1             STRB     R1,[R4, #+2]
    734            sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13U); 
   \   00000020   0x0B40             LSRS     R0,R0,#+13
   \   00000022   0xF000 0x0007      AND      R0,R0,#0x7
   \   00000026   0x7020             STRB     R0,[R4, #+0]
    735          
    736            /* Check the input parameters format */
    737            if(Format == RTC_FORMAT_BIN)
   \   00000028   0x2A00             CMP      R2,#+0
   \   0000002A   0xD10B             BNE.N    ??HAL_RTC_GetDate_0
    738            {    
    739              /* Convert the date structure parameters to Binary format */
    740              sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
   \   0000002C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000002E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000032   0x70E0             STRB     R0,[R4, #+3]
    741              sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
   \   00000034   0x7860             LDRB     R0,[R4, #+1]
   \   00000036   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000003A   0x7060             STRB     R0,[R4, #+1]
    742              sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);  
   \   0000003C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000003E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000042   0x70A0             STRB     R0,[R4, #+2]
    743            }
    744            return HAL_OK;
   \                     ??HAL_RTC_GetDate_0: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    745          }
    746          
    747          /**
    748            * @}
    749            */
    750          
    751          /** @defgroup RTC_Exported_Functions_Group3 RTC Alarm functions
    752           *  @brief   RTC Alarm functions
    753           *
    754          @verbatim   
    755           ===============================================================================
    756                           ##### RTC Alarm functions #####
    757           ===============================================================================  
    758           
    759           [..] This section provides functions allowing to configure Alarm feature
    760          
    761          @endverbatim
    762            * @{
    763            */
    764          /**
    765            * @brief  Sets the specified RTC Alarm.
    766            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    767            *                the configuration information for RTC.
    768            * @param  sAlarm: Pointer to Alarm structure
    769            * @param  Format: Specifies the format of the entered parameters.
    770            *          This parameter can be one of the following values:
    771            *             @arg RTC_FORMAT_BIN: Binary data format 
    772            *             @arg RTC_FORMAT_BCD: BCD data format
    773            * @retval HAL status
    774            */

   \                                 In section .text, align 2, keep-with-next
    775          HAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
    776          {
   \                     HAL_RTC_SetAlarm: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    777            uint32_t tickstart = 0U;
    778            uint32_t tmpreg = 0U, subsecondtmpreg = 0U;
    779            
    780            /* Check the parameters */
    781            assert_param(IS_RTC_FORMAT(Format));
    782            assert_param(IS_RTC_ALARM(sAlarm->Alarm));
    783            assert_param(IS_RTC_ALARM_MASK(sAlarm->AlarmMask));
    784            assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
    785            assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
    786            assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));
    787            
    788            /* Process Locked */ 
    789            __HAL_LOCK(hrtc);
   \   00000006   0xF994 0x001C      LDRSB    R0,[R4, #+28]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_RTC_SetAlarm_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??HAL_RTC_SetAlarm_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7720             STRB     R0,[R4, #+28]
    790            
    791            hrtc->State = HAL_RTC_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x7760             STRB     R0,[R4, #+29]
    792            
    793            if(Format == RTC_FORMAT_BIN)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0x6880             LDR      R0,[R0, #+8]
   \   00000020   0xD121             BNE.N    ??HAL_RTC_SetAlarm_1
    794            {
    795              if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \   00000022   0x0640             LSLS     R0,R0,#+25
   \   00000024   0xD401             BMI.N    ??HAL_RTC_SetAlarm_2
    796              {
    797                assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
    798                assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
    799              } 
    800              else
    801              {
    802                sAlarm->AlarmTime.TimeFormat = 0x00U;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x70E8             STRB     R0,[R5, #+3]
    803                assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
    804              }
    805              assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
    806              assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
    807              
    808              if(sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
    809              {
    810                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(sAlarm->AlarmDateWeekDay));
    811              }
    812              else
    813              {
    814                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    815              }
    816              
    817              tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
    818                        ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
    819                        ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
    820                        ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
    821                        ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24U) | \
    822                        ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
    823                        ((uint32_t)sAlarm->AlarmMask)); 
   \                     ??HAL_RTC_SetAlarm_2: (+1)
   \   0000002A   0x7828             LDRB     R0,[R5, #+0]
   \   0000002C   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000030   0x4606             MOV      R6,R0
   \   00000032   0x7868             LDRB     R0,[R5, #+1]
   \   00000034   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000038   0x4607             MOV      R7,R0
   \   0000003A   0x78A8             LDRB     R0,[R5, #+2]
   \   0000003C   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000040   0x0239             LSLS     R1,R7,#+8
   \   00000042   0xEA41 0x4106      ORR      R1,R1,R6, LSL #+16
   \   00000046   0x4308             ORRS     R0,R0,R1
   \   00000048   0x78E9             LDRB     R1,[R5, #+3]
   \   0000004A   0xEA40 0x4601      ORR      R6,R0,R1, LSL #+16
   \   0000004E   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \   00000052   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000056   0xEA46 0x6000      ORR      R0,R6,R0, LSL #+24
   \   0000005A   0x69E9             LDR      R1,[R5, #+28]
   \   0000005C   0x4308             ORRS     R0,R1,R0
   \   0000005E   0x6969             LDR      R1,[R5, #+20]
   \   00000060   0xEA41 0x0600      ORR      R6,R1,R0
   \   00000064   0xE024             B.N      ??HAL_RTC_SetAlarm_3
    824            }
    825            else
    826            {
    827              if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \                     ??HAL_RTC_SetAlarm_1: (+1)
   \   00000066   0x0640             LSLS     R0,R0,#+25
   \   00000068   0xD503             BPL.N    ??HAL_RTC_SetAlarm_4
    828              {
    829                tmpreg = RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours);
   \   0000006A   0x7828             LDRB     R0,[R5, #+0]
   \   0000006C   0x.... 0x....      BL       RTC_Bcd2ToByte
    830                assert_param(IS_RTC_HOUR12(tmpreg));
    831                assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
   \   00000070   0xE001             B.N      ??HAL_RTC_SetAlarm_5
    832              } 
    833              else
    834              {
    835                sAlarm->AlarmTime.TimeFormat = 0x00U;
   \                     ??HAL_RTC_SetAlarm_4: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x70E8             STRB     R0,[R5, #+3]
    836                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
    837              }
    838              
    839              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
    840              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
    841              
    842              if(sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
   \                     ??HAL_RTC_SetAlarm_5: (+1)
   \   00000076   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \   0000007A   0x69E9             LDR      R1,[R5, #+28]
   \   0000007C   0x2900             CMP      R1,#+0
   \   0000007E   0xD102             BNE.N    ??HAL_RTC_SetAlarm_6
    843              {
    844                tmpreg = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
   \   00000080   0x.... 0x....      BL       RTC_Bcd2ToByte
    845                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
   \   00000084   0xE001             B.N      ??HAL_RTC_SetAlarm_7
    846              }
    847              else
    848              {
    849                tmpreg = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
   \                     ??HAL_RTC_SetAlarm_6: (+1)
   \   00000086   0x.... 0x....      BL       RTC_Bcd2ToByte
    850                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
    851              }  
    852              
    853              tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
    854                        ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8U) | \
    855                        ((uint32_t) sAlarm->AlarmTime.Seconds) | \
    856                        ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
    857                        ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24U) | \
    858                        ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
    859                        ((uint32_t)sAlarm->AlarmMask));   
   \                     ??HAL_RTC_SetAlarm_7: (+1)
   \   0000008A   0x7828             LDRB     R0,[R5, #+0]
   \   0000008C   0x7869             LDRB     R1,[R5, #+1]
   \   0000008E   0x0209             LSLS     R1,R1,#+8
   \   00000090   0xEA41 0x4000      ORR      R0,R1,R0, LSL #+16
   \   00000094   0x78A9             LDRB     R1,[R5, #+2]
   \   00000096   0x4308             ORRS     R0,R1,R0
   \   00000098   0x78E9             LDRB     R1,[R5, #+3]
   \   0000009A   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   0000009E   0xF895 0x1020      LDRB     R1,[R5, #+32]
   \   000000A2   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
   \   000000A6   0x69E9             LDR      R1,[R5, #+28]
   \   000000A8   0x4308             ORRS     R0,R1,R0
   \   000000AA   0x6969             LDR      R1,[R5, #+20]
   \   000000AC   0xEA41 0x0600      ORR      R6,R1,R0
    860            }
    861            
    862            /* Configure the Alarm A or Alarm B Sub Second registers */
    863            subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
   \                     ??HAL_RTC_SetAlarm_3: (+1)
   \   000000B0   0x6868             LDR      R0,[R5, #+4]
   \   000000B2   0x69A9             LDR      R1,[R5, #+24]
   \   000000B4   0xEA41 0x0700      ORR      R7,R1,R0
    864            
    865            /* Disable the write protection for RTC registers */
    866            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \   000000B8   0x20CA             MOVS     R0,#+202
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x6248             STR      R0,[R1, #+36]
   \   000000BE   0x2053             MOVS     R0,#+83
   \   000000C0   0x6821             LDR      R1,[R4, #+0]
   \   000000C2   0x6248             STR      R0,[R1, #+36]
    867          
    868            /* Configure the Alarm register */
    869            if(sAlarm->Alarm == RTC_ALARM_A)
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6A69             LDR      R1,[R5, #+36]
   \   000000C8   0xF5B1 0x7F80      CMP      R1,#+256
   \   000000CC   0x6881             LDR      R1,[R0, #+8]
   \   000000CE   0xD11E             BNE.N    ??HAL_RTC_SetAlarm_8
    870            {
    871              /* Disable the Alarm A interrupt */
    872              __HAL_RTC_ALARMA_DISABLE(hrtc);
   \   000000D0   0xF421 0x7180      BIC      R1,R1,#0x100
   \   000000D4   0x6081             STR      R1,[R0, #+8]
    873              
    874              /* In case of interrupt mode is used, the interrupt source must disabled */ 
    875              __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x6881             LDR      R1,[R0, #+8]
   \   000000DA   0xF421 0x5180      BIC      R1,R1,#0x1000
   \   000000DE   0x6081             STR      R1,[R0, #+8]
    876          
    877              /* Get tick */
    878              tickstart = HAL_GetTick();
   \   000000E0   0x.... 0x....      BL       HAL_GetTick
   \   000000E4   0x4605             MOV      R5,R0
    879          
    880              /* Wait till RTC ALRAWF flag is set and if Time out is reached exit */
    881              while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
   \                     ??HAL_RTC_SetAlarm_9: (+1)
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x68C1             LDR      R1,[R0, #+12]
   \   000000EA   0x07C9             LSLS     R1,R1,#+31
   \   000000EC   0xD406             BMI.N    ??HAL_RTC_SetAlarm_10
    882              {
    883                if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
   \   000000EE   0x.... 0x....      BL       HAL_GetTick
   \   000000F2   0x1B40             SUBS     R0,R0,R5
   \   000000F4   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   000000F8   0xD9F5             BLS.N    ??HAL_RTC_SetAlarm_9
   \   000000FA   0xE01D             B.N      ??HAL_RTC_SetAlarm_11
    884                {
    885                  /* Enable the write protection for RTC registers */
    886                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
    887                  
    888                  hrtc->State = HAL_RTC_STATE_TIMEOUT; 
    889                  
    890                  /* Process Unlocked */ 
    891                  __HAL_UNLOCK(hrtc);
    892                  
    893                  return HAL_TIMEOUT;
    894                }   
    895              }
    896              
    897              hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
   \                     ??HAL_RTC_SetAlarm_10: (+1)
   \   000000FC   0x61C6             STR      R6,[R0, #+28]
    898              /* Configure the Alarm A Sub Second register */
    899              hrtc->Instance->ALRMASSR = subsecondtmpreg;
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x6447             STR      R7,[R0, #+68]
    900              /* Configure the Alarm state: Enable Alarm */
    901              __HAL_RTC_ALARMA_ENABLE(hrtc);
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x6881             LDR      R1,[R0, #+8]
   \   00000106   0xF441 0x7180      ORR      R1,R1,#0x100
   \   0000010A   0x6081             STR      R1,[R0, #+8]
   \   0000010C   0xE025             B.N      ??HAL_RTC_SetAlarm_12
    902            }
    903            else
    904            {
    905              /* Disable the Alarm B interrupt */
    906              __HAL_RTC_ALARMB_DISABLE(hrtc);
   \                     ??HAL_RTC_SetAlarm_8: (+1)
   \   0000010E   0xF421 0x7100      BIC      R1,R1,#0x200
   \   00000112   0x6081             STR      R1,[R0, #+8]
    907              
    908              /* In case of interrupt mode is used, the interrupt source must disabled */ 
    909              __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x6881             LDR      R1,[R0, #+8]
   \   00000118   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   0000011C   0x6081             STR      R1,[R0, #+8]
    910          
    911              /* Get tick */
    912              tickstart = HAL_GetTick();
   \   0000011E   0x.... 0x....      BL       HAL_GetTick
   \   00000122   0x4605             MOV      R5,R0
    913          
    914              /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
    915              while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
   \                     ??HAL_RTC_SetAlarm_13: (+1)
   \   00000124   0x6820             LDR      R0,[R4, #+0]
   \   00000126   0x68C1             LDR      R1,[R0, #+12]
   \   00000128   0x0789             LSLS     R1,R1,#+30
   \   0000012A   0xD40E             BMI.N    ??HAL_RTC_SetAlarm_14
    916              {
    917                if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
   \   0000012C   0x.... 0x....      BL       HAL_GetTick
   \   00000130   0x1B40             SUBS     R0,R0,R5
   \   00000132   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000136   0xD9F5             BLS.N    ??HAL_RTC_SetAlarm_13
    918                {
    919                  /* Enable the write protection for RTC registers */
    920                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_SetAlarm_11: (+1)
   \   00000138   0x20FF             MOVS     R0,#+255
   \   0000013A   0x6821             LDR      R1,[R4, #+0]
   \   0000013C   0x6248             STR      R0,[R1, #+36]
    921                  
    922                  hrtc->State = HAL_RTC_STATE_TIMEOUT; 
   \   0000013E   0x2003             MOVS     R0,#+3
   \   00000140   0x7760             STRB     R0,[R4, #+29]
    923                  
    924                  /* Process Unlocked */ 
    925                  __HAL_UNLOCK(hrtc);
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0x7720             STRB     R0,[R4, #+28]
    926                  
    927                  return HAL_TIMEOUT;
   \   00000146   0x2003             MOVS     R0,#+3
   \   00000148   0xBDF2             POP      {R1,R4-R7,PC}
    928                }  
    929              }    
    930              
    931              hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
   \                     ??HAL_RTC_SetAlarm_14: (+1)
   \   0000014A   0x6206             STR      R6,[R0, #+32]
    932              /* Configure the Alarm B Sub Second register */
    933              hrtc->Instance->ALRMBSSR = subsecondtmpreg;
   \   0000014C   0x6820             LDR      R0,[R4, #+0]
   \   0000014E   0x6487             STR      R7,[R0, #+72]
    934              /* Configure the Alarm state: Enable Alarm */
    935              __HAL_RTC_ALARMB_ENABLE(hrtc); 
   \   00000150   0x6820             LDR      R0,[R4, #+0]
   \   00000152   0x6881             LDR      R1,[R0, #+8]
   \   00000154   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000158   0x6081             STR      R1,[R0, #+8]
    936            }
    937            
    938            /* Enable the write protection for RTC registers */
    939            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);   
   \                     ??HAL_RTC_SetAlarm_12: (+1)
   \   0000015A   0x20FF             MOVS     R0,#+255
   \   0000015C   0x6821             LDR      R1,[R4, #+0]
   \   0000015E   0x6248             STR      R0,[R1, #+36]
    940            
    941            /* Change RTC state */
    942            hrtc->State = HAL_RTC_STATE_READY; 
   \   00000160   0x2001             MOVS     R0,#+1
   \   00000162   0x7760             STRB     R0,[R4, #+29]
    943            
    944            /* Process Unlocked */ 
    945            __HAL_UNLOCK(hrtc);
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0x7720             STRB     R0,[R4, #+28]
    946            
    947            return HAL_OK;
   \   00000168   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    948          }
    949          
    950          /**
    951            * @brief  Sets the specified RTC Alarm with Interrupt 
    952            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
    953            *                the configuration information for RTC.
    954            * @param  sAlarm: Pointer to Alarm structure
    955            * @param  Format: Specifies the format of the entered parameters.
    956            *          This parameter can be one of the following values:
    957            *             @arg RTC_FORMAT_BIN: Binary data format 
    958            *             @arg RTC_FORMAT_BCD: BCD data format
    959            * @retval HAL status
    960            */

   \                                 In section .text, align 2, keep-with-next
    961          HAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
    962          {
   \                     HAL_RTC_SetAlarm_IT: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
    963            uint32_t tmpreg = 0U, subsecondtmpreg = 0U;
    964            __IO uint32_t count = RTC_TIMEOUT_VALUE  * (SystemCoreClock / 32U / 1000U) ;
   \   0000000A   0x....             LDR.N    R0,??DataTable7_4
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0940             LSRS     R0,R0,#+5
   \   00000010   0xF44F 0x717A      MOV      R1,#+1000
   \   00000014   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000018   0x4348             MULS     R0,R1,R0
   \   0000001A   0x9000             STR      R0,[SP, #+0]
    965            
    966            /* Check the parameters */
    967            assert_param(IS_RTC_FORMAT(Format));
    968            assert_param(IS_RTC_ALARM(sAlarm->Alarm));
    969            assert_param(IS_RTC_ALARM_MASK(sAlarm->AlarmMask));
    970            assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
    971            assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
    972            assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));
    973                
    974            /* Process Locked */ 
    975            __HAL_LOCK(hrtc);
   \   0000001C   0xF994 0x001C      LDRSB    R0,[R4, #+28]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD101             BNE.N    ??HAL_RTC_SetAlarm_IT_0
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xE0B7             B.N      ??HAL_RTC_SetAlarm_IT_1
   \                     ??HAL_RTC_SetAlarm_IT_0: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x7720             STRB     R0,[R4, #+28]
    976            
    977            hrtc->State = HAL_RTC_STATE_BUSY;
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0x7760             STRB     R0,[R4, #+29]
    978            
    979            if(Format == RTC_FORMAT_BIN)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x2A00             CMP      R2,#+0
   \   00000034   0x6880             LDR      R0,[R0, #+8]
   \   00000036   0xD122             BNE.N    ??HAL_RTC_SetAlarm_IT_2
    980            {
    981              if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \   00000038   0x0640             LSLS     R0,R0,#+25
   \   0000003A   0xD401             BMI.N    ??HAL_RTC_SetAlarm_IT_3
    982              {
    983                assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
    984                assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
    985              } 
    986              else
    987              {
    988                sAlarm->AlarmTime.TimeFormat = 0x00U;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x70E8             STRB     R0,[R5, #+3]
    989                assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
    990              }
    991              assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
    992              assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
    993              
    994              if(sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
    995              {
    996                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(sAlarm->AlarmDateWeekDay));
    997              }
    998              else
    999              {
   1000                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
   1001              }
   1002              tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
   1003                        ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
   1004                        ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
   1005                        ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
   1006                        ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24U) | \
   1007                        ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
   1008                        ((uint32_t)sAlarm->AlarmMask)); 
   \                     ??HAL_RTC_SetAlarm_IT_3: (+1)
   \   00000040   0x7828             LDRB     R0,[R5, #+0]
   \   00000042   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000046   0x4606             MOV      R6,R0
   \   00000048   0x7868             LDRB     R0,[R5, #+1]
   \   0000004A   0x.... 0x....      BL       RTC_ByteToBcd2
   \   0000004E   0x4607             MOV      R7,R0
   \   00000050   0x78A8             LDRB     R0,[R5, #+2]
   \   00000052   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000056   0x4680             MOV      R8,R0
   \   00000058   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \   0000005C   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000060   0x0239             LSLS     R1,R7,#+8
   \   00000062   0xEA41 0x4106      ORR      R1,R1,R6, LSL #+16
   \   00000066   0xEA48 0x0101      ORR      R1,R8,R1
   \   0000006A   0x78EA             LDRB     R2,[R5, #+3]
   \   0000006C   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000070   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000074   0x69E9             LDR      R1,[R5, #+28]
   \   00000076   0x4308             ORRS     R0,R1,R0
   \   00000078   0x6969             LDR      R1,[R5, #+20]
   \   0000007A   0x4308             ORRS     R0,R1,R0
   \   0000007C   0xE023             B.N      ??HAL_RTC_SetAlarm_IT_4
   1009            }
   1010            else
   1011            {
   1012              if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \                     ??HAL_RTC_SetAlarm_IT_2: (+1)
   \   0000007E   0x0640             LSLS     R0,R0,#+25
   \   00000080   0xD503             BPL.N    ??HAL_RTC_SetAlarm_IT_5
   1013              {
   1014                tmpreg = RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours);
   \   00000082   0x7828             LDRB     R0,[R5, #+0]
   \   00000084   0x.... 0x....      BL       RTC_Bcd2ToByte
   1015                assert_param(IS_RTC_HOUR12(tmpreg));
   1016                assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
   \   00000088   0xE001             B.N      ??HAL_RTC_SetAlarm_IT_6
   1017              } 
   1018              else
   1019              {
   1020                sAlarm->AlarmTime.TimeFormat = 0x00U;
   \                     ??HAL_RTC_SetAlarm_IT_5: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x70E8             STRB     R0,[R5, #+3]
   1021                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
   1022              }
   1023              
   1024              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
   1025              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
   1026              
   1027              if(sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
   \                     ??HAL_RTC_SetAlarm_IT_6: (+1)
   \   0000008E   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \   00000092   0x69E9             LDR      R1,[R5, #+28]
   \   00000094   0x2900             CMP      R1,#+0
   \   00000096   0xD102             BNE.N    ??HAL_RTC_SetAlarm_IT_7
   1028              {
   1029                tmpreg = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
   \   00000098   0x.... 0x....      BL       RTC_Bcd2ToByte
   1030                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
   \   0000009C   0xE001             B.N      ??HAL_RTC_SetAlarm_IT_8
   1031              }
   1032              else
   1033              {
   1034                tmpreg = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
   \                     ??HAL_RTC_SetAlarm_IT_7: (+1)
   \   0000009E   0x.... 0x....      BL       RTC_Bcd2ToByte
   1035                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
   1036              }
   1037              tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
   1038                        ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8U) | \
   1039                        ((uint32_t) sAlarm->AlarmTime.Seconds) | \
   1040                        ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
   1041                        ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24U) | \
   1042                        ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
   1043                        ((uint32_t)sAlarm->AlarmMask));     
   \                     ??HAL_RTC_SetAlarm_IT_8: (+1)
   \   000000A2   0x7828             LDRB     R0,[R5, #+0]
   \   000000A4   0x7869             LDRB     R1,[R5, #+1]
   \   000000A6   0x0209             LSLS     R1,R1,#+8
   \   000000A8   0xEA41 0x4000      ORR      R0,R1,R0, LSL #+16
   \   000000AC   0x78A9             LDRB     R1,[R5, #+2]
   \   000000AE   0x4308             ORRS     R0,R1,R0
   \   000000B0   0x78E9             LDRB     R1,[R5, #+3]
   \   000000B2   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   000000B6   0xF895 0x1020      LDRB     R1,[R5, #+32]
   \   000000BA   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
   \   000000BE   0x69E9             LDR      R1,[R5, #+28]
   \   000000C0   0x4308             ORRS     R0,R1,R0
   \   000000C2   0x6969             LDR      R1,[R5, #+20]
   \   000000C4   0x4308             ORRS     R0,R1,R0
   1044            }
   1045            /* Configure the Alarm A or Alarm B Sub Second registers */
   1046            subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
   \                     ??HAL_RTC_SetAlarm_IT_4: (+1)
   \   000000C6   0x6869             LDR      R1,[R5, #+4]
   \   000000C8   0x69AA             LDR      R2,[R5, #+24]
   \   000000CA   0x4311             ORRS     R1,R2,R1
   1047            
   1048            /* Disable the write protection for RTC registers */
   1049            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \   000000CC   0x22CA             MOVS     R2,#+202
   \   000000CE   0x6823             LDR      R3,[R4, #+0]
   \   000000D0   0x625A             STR      R2,[R3, #+36]
   \   000000D2   0x2253             MOVS     R2,#+83
   \   000000D4   0x6823             LDR      R3,[R4, #+0]
   \   000000D6   0x625A             STR      R2,[R3, #+36]
   1050            
   1051            /* Configure the Alarm register */
   1052            if(sAlarm->Alarm == RTC_ALARM_A)
   \   000000D8   0x6822             LDR      R2,[R4, #+0]
   \   000000DA   0x6A6B             LDR      R3,[R5, #+36]
   \   000000DC   0xF5B3 0x7F80      CMP      R3,#+256
   \   000000E0   0x6893             LDR      R3,[R2, #+8]
   \   000000E2   0xD120             BNE.N    ??HAL_RTC_SetAlarm_IT_9
   1053            {
   1054              /* Disable the Alarm A interrupt */
   1055              __HAL_RTC_ALARMA_DISABLE(hrtc);
   \   000000E4   0xF423 0x7380      BIC      R3,R3,#0x100
   \   000000E8   0x6093             STR      R3,[R2, #+8]
   1056          
   1057              /* Clear flag alarm A */
   1058              __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
   \   000000EA   0x6822             LDR      R2,[R4, #+0]
   \   000000EC   0x68D3             LDR      R3,[R2, #+12]
   \   000000EE   0xF003 0x0380      AND      R3,R3,#0x80
   \   000000F2   0xF463 0x73C0      ORN      R3,R3,#+384
   \   000000F6   0x60D3             STR      R3,[R2, #+12]
   1059          
   1060              /* Wait till RTC ALRAWF flag is set and if Time out is reached exit */
   1061              do
   1062              {
   1063                if (count-- == 0)
   \                     ??HAL_RTC_SetAlarm_IT_10: (+1)
   \   000000F8   0x9A00             LDR      R2,[SP, #+0]
   \   000000FA   0x1E53             SUBS     R3,R2,#+1
   \   000000FC   0x9300             STR      R3,[SP, #+0]
   \   000000FE   0x2A00             CMP      R2,#+0
   \   00000100   0xD020             BEQ.N    ??HAL_RTC_SetAlarm_IT_11
   1064                {
   1065                  /* Enable the write protection for RTC registers */
   1066                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1067          
   1068                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1069          
   1070                  /* Process Unlocked */
   1071                  __HAL_UNLOCK(hrtc);
   1072          
   1073                  return HAL_TIMEOUT;
   1074                }
   1075              } 
   1076              while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET);
   \   00000102   0x6822             LDR      R2,[R4, #+0]
   \   00000104   0x68D3             LDR      R3,[R2, #+12]
   \   00000106   0x07DB             LSLS     R3,R3,#+31
   \   00000108   0xD5F6             BPL.N    ??HAL_RTC_SetAlarm_IT_10
   1077          
   1078              hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
   \   0000010A   0x61D0             STR      R0,[R2, #+28]
   1079              /* Configure the Alarm A Sub Second register */
   1080              hrtc->Instance->ALRMASSR = subsecondtmpreg;
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x6441             STR      R1,[R0, #+68]
   1081              /* Configure the Alarm state: Enable Alarm */
   1082              __HAL_RTC_ALARMA_ENABLE(hrtc);
   \   00000110   0x6820             LDR      R0,[R4, #+0]
   \   00000112   0x6881             LDR      R1,[R0, #+8]
   \   00000114   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000118   0x6081             STR      R1,[R0, #+8]
   1083              /* Configure the Alarm interrupt */
   1084              __HAL_RTC_ALARM_ENABLE_IT(hrtc,RTC_IT_ALRA);
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0x6881             LDR      R1,[R0, #+8]
   \   0000011E   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000122   0x6081             STR      R1,[R0, #+8]
   \   00000124   0xE028             B.N      ??HAL_RTC_SetAlarm_IT_12
   1085            }
   1086            else
   1087            {
   1088              /* Disable the Alarm B interrupt */
   1089              __HAL_RTC_ALARMB_DISABLE(hrtc);
   \                     ??HAL_RTC_SetAlarm_IT_9: (+1)
   \   00000126   0xF423 0x7300      BIC      R3,R3,#0x200
   \   0000012A   0x6093             STR      R3,[R2, #+8]
   1090          
   1091              /* Clear flag alarm B */
   1092              __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
   \   0000012C   0x6822             LDR      R2,[R4, #+0]
   \   0000012E   0x68D3             LDR      R3,[R2, #+12]
   \   00000130   0xF003 0x0380      AND      R3,R3,#0x80
   \   00000134   0xF463 0x7320      ORN      R3,R3,#+640
   \   00000138   0x60D3             STR      R3,[R2, #+12]
   1093          
   1094              /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
   1095              do
   1096              {
   1097                if (count-- == 0)
   \                     ??HAL_RTC_SetAlarm_IT_13: (+1)
   \   0000013A   0x9A00             LDR      R2,[SP, #+0]
   \   0000013C   0x1E53             SUBS     R3,R2,#+1
   \   0000013E   0x9300             STR      R3,[SP, #+0]
   \   00000140   0x2A00             CMP      R2,#+0
   \   00000142   0xD108             BNE.N    ??HAL_RTC_SetAlarm_IT_14
   1098                {
   1099                  /* Enable the write protection for RTC registers */
   1100                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_SetAlarm_IT_11: (+1)
   \   00000144   0x20FF             MOVS     R0,#+255
   \   00000146   0x6821             LDR      R1,[R4, #+0]
   \   00000148   0x6248             STR      R0,[R1, #+36]
   1101          
   1102                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \   0000014A   0x2003             MOVS     R0,#+3
   \   0000014C   0x7760             STRB     R0,[R4, #+29]
   1103          
   1104                  /* Process Unlocked */
   1105                  __HAL_UNLOCK(hrtc);
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0x7720             STRB     R0,[R4, #+28]
   1106          
   1107                  return HAL_TIMEOUT;
   \   00000152   0x2003             MOVS     R0,#+3
   \   00000154   0xE020             B.N      ??HAL_RTC_SetAlarm_IT_1
   1108                }
   1109              } 
   1110              while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET);
   \                     ??HAL_RTC_SetAlarm_IT_14: (+1)
   \   00000156   0x6822             LDR      R2,[R4, #+0]
   \   00000158   0x68D3             LDR      R3,[R2, #+12]
   \   0000015A   0x079B             LSLS     R3,R3,#+30
   \   0000015C   0xD5ED             BPL.N    ??HAL_RTC_SetAlarm_IT_13
   1111              
   1112              hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
   \   0000015E   0x6210             STR      R0,[R2, #+32]
   1113              /* Configure the Alarm B Sub Second register */
   1114              hrtc->Instance->ALRMBSSR = subsecondtmpreg;
   \   00000160   0x6820             LDR      R0,[R4, #+0]
   \   00000162   0x6481             STR      R1,[R0, #+72]
   1115              /* Configure the Alarm state: Enable Alarm */
   1116              __HAL_RTC_ALARMB_ENABLE(hrtc);
   \   00000164   0x6820             LDR      R0,[R4, #+0]
   \   00000166   0x6881             LDR      R1,[R0, #+8]
   \   00000168   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000016C   0x6081             STR      R1,[R0, #+8]
   1117              /* Configure the Alarm interrupt */
   1118              __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRB);
   \   0000016E   0x6820             LDR      R0,[R4, #+0]
   \   00000170   0x6881             LDR      R1,[R0, #+8]
   \   00000172   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000176   0x6081             STR      R1,[R0, #+8]
   1119            }
   1120          
   1121            /* RTC Alarm Interrupt Configuration: EXTI configuration */
   1122            __HAL_RTC_ALARM_EXTI_ENABLE_IT();
   \                     ??HAL_RTC_SetAlarm_IT_12: (+1)
   \   00000178   0x....             LDR.N    R0,??DataTable7_5  ;; 0x40013c00
   \   0000017A   0x6801             LDR      R1,[R0, #+0]
   \   0000017C   0xF441 0x3100      ORR      R1,R1,#0x20000
   \   00000180   0x6001             STR      R1,[R0, #+0]
   1123            
   1124            EXTI->RTSR |= RTC_EXTI_LINE_ALARM_EVENT;
   \   00000182   0x6881             LDR      R1,[R0, #+8]
   \   00000184   0xF441 0x3100      ORR      R1,R1,#0x20000
   \   00000188   0x6081             STR      R1,[R0, #+8]
   1125            
   1126            /* Enable the write protection for RTC registers */
   1127            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
   \   0000018A   0x20FF             MOVS     R0,#+255
   \   0000018C   0x6821             LDR      R1,[R4, #+0]
   \   0000018E   0x6248             STR      R0,[R1, #+36]
   1128            
   1129            hrtc->State = HAL_RTC_STATE_READY; 
   \   00000190   0x2001             MOVS     R0,#+1
   \   00000192   0x7760             STRB     R0,[R4, #+29]
   1130            
   1131            /* Process Unlocked */ 
   1132            __HAL_UNLOCK(hrtc);  
   \   00000194   0x2000             MOVS     R0,#+0
   \   00000196   0x7720             STRB     R0,[R4, #+28]
   1133            
   1134            return HAL_OK;
   \                     ??HAL_RTC_SetAlarm_IT_1: (+1)
   \   00000198   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1135          }
   1136          
   1137          /**
   1138            * @brief  Deactivate the specified RTC Alarm 
   1139            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
   1140            *                the configuration information for RTC.
   1141            * @param  Alarm: Specifies the Alarm.
   1142            *          This parameter can be one of the following values:
   1143            *            @arg RTC_ALARM_A:  AlarmA
   1144            *            @arg RTC_ALARM_B:  AlarmB
   1145            * @retval HAL status
   1146            */

   \                                 In section .text, align 2, keep-with-next
   1147          HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
   1148          {
   \                     HAL_RTC_DeactivateAlarm: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1149            uint32_t tickstart = 0U;
   1150            
   1151            /* Check the parameters */
   1152            assert_param(IS_RTC_ALARM(Alarm));
   1153            
   1154            /* Process Locked */ 
   1155            __HAL_LOCK(hrtc);
   \   00000004   0xF994 0x001C      LDRSB    R0,[R4, #+28]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_RTC_DeactivateAlarm_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_RTC_DeactivateAlarm_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x7720             STRB     R0,[R4, #+28]
   1156            
   1157            hrtc->State = HAL_RTC_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x7760             STRB     R0,[R4, #+29]
   1158            
   1159            /* Disable the write protection for RTC registers */
   1160            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   \   00000018   0x20CA             MOVS     R0,#+202
   \   0000001A   0x6822             LDR      R2,[R4, #+0]
   \   0000001C   0x6250             STR      R0,[R2, #+36]
   \   0000001E   0x2053             MOVS     R0,#+83
   \   00000020   0x6822             LDR      R2,[R4, #+0]
   \   00000022   0x6250             STR      R0,[R2, #+36]
   1161            
   1162            if(Alarm == RTC_ALARM_A)
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0xF5B1 0x7F80      CMP      R1,#+256
   \   0000002A   0x6881             LDR      R1,[R0, #+8]
   \   0000002C   0xD115             BNE.N    ??HAL_RTC_DeactivateAlarm_1
   1163            {
   1164              /* AlarmA */
   1165              __HAL_RTC_ALARMA_DISABLE(hrtc);
   \   0000002E   0xF421 0x7180      BIC      R1,R1,#0x100
   \   00000032   0x6081             STR      R1,[R0, #+8]
   1166              
   1167              /* In case of interrupt mode is used, the interrupt source must disabled */ 
   1168              __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6881             LDR      R1,[R0, #+8]
   \   00000038   0xF421 0x5180      BIC      R1,R1,#0x1000
   \   0000003C   0x6081             STR      R1,[R0, #+8]
   1169          
   1170              /* Get tick */
   1171              tickstart = HAL_GetTick();
   \   0000003E   0x.... 0x....      BL       HAL_GetTick
   \   00000042   0x4605             MOV      R5,R0
   1172          
   1173              /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
   1174              while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
   \                     ??HAL_RTC_DeactivateAlarm_2: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C0             LDR      R0,[R0, #+12]
   \   00000048   0x07C0             LSLS     R0,R0,#+31
   \   0000004A   0xD424             BMI.N    ??HAL_RTC_DeactivateAlarm_3
   1175              {
   1176                if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
   \   0000004C   0x.... 0x....      BL       HAL_GetTick
   \   00000050   0x1B40             SUBS     R0,R0,R5
   \   00000052   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000056   0xD9F5             BLS.N    ??HAL_RTC_DeactivateAlarm_2
   \   00000058   0xE014             B.N      ??HAL_RTC_DeactivateAlarm_4
   1177                { 
   1178                  /* Enable the write protection for RTC registers */
   1179                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1180                  
   1181                  hrtc->State = HAL_RTC_STATE_TIMEOUT; 
   1182                  
   1183                  /* Process Unlocked */ 
   1184                  __HAL_UNLOCK(hrtc);
   1185                  
   1186                  return HAL_TIMEOUT;
   1187                }      
   1188              }
   1189            }
   1190            else
   1191            {
   1192              /* AlarmB */
   1193              __HAL_RTC_ALARMB_DISABLE(hrtc);
   \                     ??HAL_RTC_DeactivateAlarm_1: (+1)
   \   0000005A   0xF421 0x7100      BIC      R1,R1,#0x200
   \   0000005E   0x6081             STR      R1,[R0, #+8]
   1194              
   1195              /* In case of interrupt mode is used, the interrupt source must disabled */ 
   1196              __HAL_RTC_ALARM_DISABLE_IT(hrtc,RTC_IT_ALRB);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6881             LDR      R1,[R0, #+8]
   \   00000064   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   00000068   0x6081             STR      R1,[R0, #+8]
   1197          
   1198              /* Get tick */
   1199              tickstart = HAL_GetTick();
   \   0000006A   0x.... 0x....      BL       HAL_GetTick
   \   0000006E   0x4605             MOV      R5,R0
   1200          
   1201              /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
   1202              while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
   \                     ??HAL_RTC_DeactivateAlarm_5: (+1)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x68C0             LDR      R0,[R0, #+12]
   \   00000074   0x0780             LSLS     R0,R0,#+30
   \   00000076   0xD40E             BMI.N    ??HAL_RTC_DeactivateAlarm_3
   1203              {
   1204                if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
   \   00000078   0x.... 0x....      BL       HAL_GetTick
   \   0000007C   0x1B40             SUBS     R0,R0,R5
   \   0000007E   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000082   0xD9F5             BLS.N    ??HAL_RTC_DeactivateAlarm_5
   1205                {
   1206                  /* Enable the write protection for RTC registers */
   1207                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_DeactivateAlarm_4: (+1)
   \   00000084   0x20FF             MOVS     R0,#+255
   \   00000086   0x6821             LDR      R1,[R4, #+0]
   \   00000088   0x6248             STR      R0,[R1, #+36]
   1208                  
   1209                  hrtc->State = HAL_RTC_STATE_TIMEOUT; 
   \   0000008A   0x2003             MOVS     R0,#+3
   \   0000008C   0x7760             STRB     R0,[R4, #+29]
   1210                  
   1211                  /* Process Unlocked */ 
   1212                  __HAL_UNLOCK(hrtc);
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x7720             STRB     R0,[R4, #+28]
   1213                  
   1214                  return HAL_TIMEOUT;
   \   00000092   0x2003             MOVS     R0,#+3
   \   00000094   0xBD32             POP      {R1,R4,R5,PC}
   1215                }    
   1216              }
   1217            }
   1218            /* Enable the write protection for RTC registers */
   1219            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   \                     ??HAL_RTC_DeactivateAlarm_3: (+1)
   \   00000096   0x20FF             MOVS     R0,#+255
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x6248             STR      R0,[R1, #+36]
   1220            
   1221            hrtc->State = HAL_RTC_STATE_READY; 
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0x7760             STRB     R0,[R4, #+29]
   1222            
   1223            /* Process Unlocked */ 
   1224            __HAL_UNLOCK(hrtc);  
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x7720             STRB     R0,[R4, #+28]
   1225            
   1226            return HAL_OK; 
   \   000000A4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1227          }
   1228                     
   1229          /**
   1230            * @brief  Gets the RTC Alarm value and masks.
   1231            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
   1232            *                the configuration information for RTC.
   1233            * @param  sAlarm: Pointer to Date structure
   1234            * @param  Alarm: Specifies the Alarm.
   1235            *          This parameter can be one of the following values:
   1236            *             @arg RTC_ALARM_A: AlarmA
   1237            *             @arg RTC_ALARM_B: AlarmB  
   1238            * @param  Format: Specifies the format of the entered parameters.
   1239            *          This parameter can be one of the following values:
   1240            *             @arg RTC_FORMAT_BIN: Binary data format 
   1241            *             @arg RTC_FORMAT_BCD: BCD data format
   1242            * @retval HAL status
   1243            */

   \                                 In section .text, align 2, keep-with-next
   1244          HAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format)
   1245          {
   \                     HAL_RTC_GetAlarm: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   1246            uint32_t tmpreg = 0U, subsecondtmpreg = 0U;
   1247            
   1248            /* Check the parameters */
   1249            assert_param(IS_RTC_FORMAT(Format));
   1250            assert_param(IS_RTC_ALARM(Alarm));
   1251            
   1252            if(Alarm == RTC_ALARM_A)
   \   00000004   0xF5B2 0x7F80      CMP      R2,#+256
   \   00000008   0xD108             BNE.N    ??HAL_RTC_GetAlarm_0
   1253            {
   1254              /* AlarmA */
   1255              sAlarm->Alarm = RTC_ALARM_A;
   \   0000000A   0xF44F 0x7180      MOV      R1,#+256
   \   0000000E   0x6261             STR      R1,[R4, #+36]
   1256              
   1257              tmpreg = (uint32_t)(hrtc->Instance->ALRMAR);
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x69C8             LDR      R0,[R1, #+28]
   1258              subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMASSR ) & RTC_ALRMASSR_SS);
   \   00000014   0x6C49             LDR      R1,[R1, #+68]
   \   00000016   0x0449             LSLS     R1,R1,#+17
   \   00000018   0x0C49             LSRS     R1,R1,#+17
   \   0000001A   0xE007             B.N      ??HAL_RTC_GetAlarm_1
   1259            }
   1260            else
   1261            {
   1262              sAlarm->Alarm = RTC_ALARM_B;
   \                     ??HAL_RTC_GetAlarm_0: (+1)
   \   0000001C   0xF44F 0x7100      MOV      R1,#+512
   \   00000020   0x6261             STR      R1,[R4, #+36]
   1263              
   1264              tmpreg = (uint32_t)(hrtc->Instance->ALRMBR);
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x6A08             LDR      R0,[R1, #+32]
   1265              subsecondtmpreg = (uint32_t)((hrtc->Instance->ALRMBSSR) & RTC_ALRMBSSR_SS);
   \   00000026   0x6C89             LDR      R1,[R1, #+72]
   \   00000028   0x0449             LSLS     R1,R1,#+17
   \   0000002A   0x0C49             LSRS     R1,R1,#+17
   \                     ??HAL_RTC_GetAlarm_1: (+1)
   \   0000002C   0x0C02             LSRS     R2,R0,#+16
   \   0000002E   0xF002 0x053F      AND      R5,R2,#0x3F
   \   00000032   0x7025             STRB     R5,[R4, #+0]
   1266            }
   1267              
   1268            /* Fill the structure with the read parameters */
   1269            sAlarm->AlarmTime.Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | RTC_ALRMAR_HU)) >> 16U);
   1270            sAlarm->AlarmTime.Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | RTC_ALRMAR_MNU)) >> 8U);
   \   00000034   0x0A05             LSRS     R5,R0,#+8
   \   00000036   0xF005 0x057F      AND      R5,R5,#0x7F
   \   0000003A   0x7065             STRB     R5,[R4, #+1]
   1271            sAlarm->AlarmTime.Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | RTC_ALRMAR_SU));
   \   0000003C   0xF000 0x057F      AND      R5,R0,#0x7F
   \   00000040   0x70A5             STRB     R5,[R4, #+2]
   1272            sAlarm->AlarmTime.TimeFormat = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16U);
   \   00000042   0xF002 0x0240      AND      R2,R2,#0x40
   \   00000046   0x70E2             STRB     R2,[R4, #+3]
   1273            sAlarm->AlarmTime.SubSeconds = (uint32_t) subsecondtmpreg;
   \   00000048   0x6061             STR      R1,[R4, #+4]
   1274            sAlarm->AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24U);
   \   0000004A   0x0E01             LSRS     R1,R0,#+24
   \   0000004C   0xF001 0x013F      AND      R1,R1,#0x3F
   \   00000050   0xF884 0x1020      STRB     R1,[R4, #+32]
   1275            sAlarm->AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
   \   00000054   0xF000 0x4180      AND      R1,R0,#0x40000000
   \   00000058   0x61E1             STR      R1,[R4, #+28]
   1276            sAlarm->AlarmMask = (uint32_t)(tmpreg & RTC_ALARMMASK_ALL);
   \   0000005A   0xF020 0x307F      BIC      R0,R0,#0x7F7F7F7F
   \   0000005E   0x6160             STR      R0,[R4, #+20]
   1277              
   1278            if(Format == RTC_FORMAT_BIN)
   \   00000060   0x2B00             CMP      R3,#+0
   \   00000062   0xD111             BNE.N    ??HAL_RTC_GetAlarm_2
   1279            {
   1280              sAlarm->AlarmTime.Hours = RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours);
   \   00000064   0x7820             LDRB     R0,[R4, #+0]
   \   00000066   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000006A   0x7020             STRB     R0,[R4, #+0]
   1281              sAlarm->AlarmTime.Minutes = RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes);
   \   0000006C   0x7860             LDRB     R0,[R4, #+1]
   \   0000006E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000072   0x7060             STRB     R0,[R4, #+1]
   1282              sAlarm->AlarmTime.Seconds = RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds);
   \   00000074   0x78A0             LDRB     R0,[R4, #+2]
   \   00000076   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000007A   0x70A0             STRB     R0,[R4, #+2]
   1283              sAlarm->AlarmDateWeekDay = RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay);
   \   0000007C   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   00000080   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000084   0xF884 0x0020      STRB     R0,[R4, #+32]
   1284            }  
   1285              
   1286            return HAL_OK;
   \                     ??HAL_RTC_GetAlarm_2: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1287          }
   1288          
   1289          /**
   1290            * @brief  This function handles Alarm interrupt request.
   1291            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
   1292            *                the configuration information for RTC.
   1293            * @retval None
   1294            */

   \                                 In section .text, align 2, keep-with-next
   1295          void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef* hrtc)
   1296          {  
   \                     HAL_RTC_AlarmIRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1297            if(__HAL_RTC_ALARM_GET_IT(hrtc, RTC_IT_ALRA))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0x05C9             LSLS     R1,R1,#+23
   \   0000000A   0xD50C             BPL.N    ??HAL_RTC_AlarmIRQHandler_0
   1298            {
   1299              /* Get the status of the Interrupt */
   1300              if((uint32_t)(hrtc->Instance->CR & RTC_IT_ALRA) != (uint32_t)RESET)
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0x04C0             LSLS     R0,R0,#+19
   \   00000010   0xD509             BPL.N    ??HAL_RTC_AlarmIRQHandler_0
   1301              {
   1302                /* AlarmA callback */ 
   1303                HAL_RTC_AlarmAEventCallback(hrtc);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       HAL_RTC_AlarmAEventCallback
   1304                
   1305                /* Clear the Alarm interrupt pending bit */
   1306                __HAL_RTC_ALARM_CLEAR_FLAG(hrtc,RTC_FLAG_ALRAF);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C1             LDR      R1,[R0, #+12]
   \   0000001C   0xF001 0x0180      AND      R1,R1,#0x80
   \   00000020   0xF461 0x71C0      ORN      R1,R1,#+384
   \   00000024   0x60C1             STR      R1,[R0, #+12]
   1307              }
   1308            }
   1309            
   1310            if(__HAL_RTC_ALARM_GET_IT(hrtc, RTC_IT_ALRB))
   \                     ??HAL_RTC_AlarmIRQHandler_0: (+1)
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C1             LDR      R1,[R0, #+12]
   \   0000002A   0x0589             LSLS     R1,R1,#+22
   \   0000002C   0xD50C             BPL.N    ??HAL_RTC_AlarmIRQHandler_1
   1311            {
   1312              /* Get the status of the Interrupt */
   1313              if((uint32_t)(hrtc->Instance->CR & RTC_IT_ALRB) != (uint32_t)RESET)
   \   0000002E   0x6880             LDR      R0,[R0, #+8]
   \   00000030   0x0480             LSLS     R0,R0,#+18
   \   00000032   0xD509             BPL.N    ??HAL_RTC_AlarmIRQHandler_1
   1314              {
   1315                /* AlarmB callback */ 
   1316                HAL_RTCEx_AlarmBEventCallback(hrtc);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       HAL_RTCEx_AlarmBEventCallback
   1317                
   1318                /* Clear the Alarm interrupt pending bit */
   1319                __HAL_RTC_ALARM_CLEAR_FLAG(hrtc,RTC_FLAG_ALRBF);
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C1             LDR      R1,[R0, #+12]
   \   0000003E   0xF001 0x0180      AND      R1,R1,#0x80
   \   00000042   0xF461 0x7120      ORN      R1,R1,#+640
   \   00000046   0x60C1             STR      R1,[R0, #+12]
   1320              }
   1321            }
   1322            
   1323            /* Clear the EXTI's line Flag for RTC Alarm */
   1324            __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
   \                     ??HAL_RTC_AlarmIRQHandler_1: (+1)
   \   00000048   0xF44F 0x3000      MOV      R0,#+131072
   \   0000004C   0x....             LDR.N    R1,??DataTable7_6  ;; 0x40013c14
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1325            
   1326            /* Change RTC state */
   1327            hrtc->State = HAL_RTC_STATE_READY; 
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x7760             STRB     R0,[R4, #+29]
   1328          }
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
   1329          
   1330          /**
   1331            * @brief  Alarm A callback.
   1332            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
   1333            *                the configuration information for RTC.
   1334            * @retval None
   1335            */

   \                                 In section .text, align 2, keep-with-next
   1336          __weak void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
   1337          {
   1338            /* Prevent unused argument(s) compilation warning */
   1339            UNUSED(hrtc);
   1340            /* NOTE : This function Should not be modified, when the callback is needed,
   1341                      the HAL_RTC_AlarmAEventCallback could be implemented in the user file
   1342             */
   1343          }
   \                     HAL_RTC_AlarmAEventCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1344          
   1345          /**
   1346            * @brief  This function handles AlarmA Polling request.
   1347            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
   1348            *                the configuration information for RTC.
   1349            * @param  Timeout: Timeout duration
   1350            * @retval HAL status
   1351            */

   \                                 In section .text, align 2, keep-with-next
   1352          HAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
   1353          {
   \                     HAL_RTC_PollForAlarmAEvent: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1354            uint32_t tickstart = 0U; 
   1355          
   1356              /* Get tick */
   1357              tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
   1358          
   1359            while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) == RESET)
   \                     ??HAL_RTC_PollForAlarmAEvent_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x68C1             LDR      R1,[R0, #+12]
   \   00000010   0x05C9             LSLS     R1,R1,#+23
   \   00000012   0xD40C             BMI.N    ??HAL_RTC_PollForAlarmAEvent_1
   1360            {
   1361              if(Timeout != HAL_MAX_DELAY)
   \   00000014   0xF115 0x0F01      CMN      R5,#+1
   \   00000018   0xD0F8             BEQ.N    ??HAL_RTC_PollForAlarmAEvent_0
   1362              {
   1363                if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD004             BEQ.N    ??HAL_RTC_PollForAlarmAEvent_2
   \   0000001E   0x.... 0x....      BL       HAL_GetTick
   \   00000022   0x1B80             SUBS     R0,R0,R6
   \   00000024   0x4285             CMP      R5,R0
   \   00000026   0xD2F1             BCS.N    ??HAL_RTC_PollForAlarmAEvent_0
   1364                {
   1365                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   \                     ??HAL_RTC_PollForAlarmAEvent_2: (+1)
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x7760             STRB     R0,[R4, #+29]
   1366                  return HAL_TIMEOUT;
   \   0000002C   0xBD70             POP      {R4-R6,PC}
   1367                }
   1368              }
   1369            }
   1370            
   1371            /* Clear the Alarm interrupt pending bit */
   1372            __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
   \                     ??HAL_RTC_PollForAlarmAEvent_1: (+1)
   \   0000002E   0x68C1             LDR      R1,[R0, #+12]
   \   00000030   0xF001 0x0180      AND      R1,R1,#0x80
   \   00000034   0xF461 0x71C0      ORN      R1,R1,#+384
   \   00000038   0x60C1             STR      R1,[R0, #+12]
   1373            
   1374            /* Change RTC state */
   1375            hrtc->State = HAL_RTC_STATE_READY; 
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x7760             STRB     R0,[R4, #+29]
   1376            
   1377            return HAL_OK;  
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
   1378          }
   1379          
   1380          /**
   1381            * @}
   1382            */
   1383          
   1384          /** @defgroup RTC_Exported_Functions_Group4 Peripheral Control functions 
   1385           *  @brief   Peripheral Control functions 
   1386           *
   1387          @verbatim   
   1388           ===============================================================================
   1389                               ##### Peripheral Control functions #####
   1390           ===============================================================================  
   1391              [..]
   1392              This subsection provides functions allowing to
   1393                (+) Wait for RTC Time and Date Synchronization
   1394          
   1395          @endverbatim
   1396            * @{
   1397            */
   1398          
   1399          /**
   1400            * @brief  Waits until the RTC Time and Date registers (RTC_TR and RTC_DR) are 
   1401            *         synchronized with RTC APB clock.
   1402            * @note   The RTC Resynchronization mode is write protected, use the 
   1403            *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function. 
   1404            * @note   To read the calendar through the shadow registers after Calendar 
   1405            *         initialization, calendar update or after wake-up from low power modes 
   1406            *         the software must first clear the RSF flag. 
   1407            *         The software must then wait until it is set again before reading 
   1408            *         the calendar, which means that the calendar registers have been 
   1409            *         correctly copied into the RTC_TR and RTC_DR shadow registers.   
   1410            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
   1411            *                the configuration information for RTC.
   1412            * @retval HAL status
   1413            */

   \                                 In section .text, align 2, keep-with-next
   1414          HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
   1415          {
   \                     HAL_RTC_WaitForSynchro: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1416            uint32_t tickstart = 0U;
   1417          
   1418            /* Clear RSF flag */
   1419            hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0xF021 0x01A0      BIC      R1,R1,#0xA0
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   1420          
   1421              /* Get tick */
   1422              tickstart = HAL_GetTick();
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x4605             MOV      R5,R0
   1423          
   1424            /* Wait the registers to be synchronised */
   1425            while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
   \                     ??HAL_RTC_WaitForSynchro_0: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0x0680             LSLS     R0,R0,#+26
   \   0000001A   0xD407             BMI.N    ??HAL_RTC_WaitForSynchro_1
   1426            {
   1427              if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
   \   0000001C   0x.... 0x....      BL       HAL_GetTick
   \   00000020   0x1B40             SUBS     R0,R0,R5
   \   00000022   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000026   0xD9F5             BLS.N    ??HAL_RTC_WaitForSynchro_0
   1428              {       
   1429                return HAL_TIMEOUT;
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}
   1430              } 
   1431            }
   1432          
   1433            return HAL_OK;
   \                     ??HAL_RTC_WaitForSynchro_1: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1434          }
   1435          
   1436          /**
   1437            * @}
   1438            */
   1439          
   1440          /** @defgroup RTC_Exported_Functions_Group5 Peripheral State functions 
   1441           *  @brief   Peripheral State functions 
   1442           *
   1443          @verbatim   
   1444           ===============================================================================
   1445                               ##### Peripheral State functions #####
   1446           ===============================================================================  
   1447              [..]
   1448              This subsection provides functions allowing to
   1449                (+) Get RTC state
   1450          
   1451          @endverbatim
   1452            * @{
   1453            */
   1454          /**
   1455            * @brief  Returns the RTC state.
   1456            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
   1457            *                the configuration information for RTC.
   1458            * @retval HAL state
   1459            */

   \                                 In section .text, align 2, keep-with-next
   1460          HAL_RTCStateTypeDef HAL_RTC_GetState(RTC_HandleTypeDef* hrtc)
   1461          {
   1462            return hrtc->State;
   \                     HAL_RTC_GetState: (+1)
   \   00000000   0xF990 0x001D      LDRSB    R0,[R0, #+29]
   \   00000004   0x4770             BX       LR               ;; return
   1463          }
   1464          
   1465          /**
   1466            * @}
   1467            */
   1468          
   1469          /**
   1470            * @brief  Enters the RTC Initialization mode.
   1471            * @note   The RTC Initialization mode is write protected, use the
   1472            *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
   1473            * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
   1474            *                the configuration information for RTC.
   1475            * @retval HAL status
   1476            */

   \                                 In section .text, align 2, keep-with-next
   1477          HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
   1478          {
   \                     RTC_EnterInitMode: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1479            uint32_t tickstart = 0U; 
   1480            
   1481            /* Check if the Initialization mode is set */
   1482            if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0x0649             LSLS     R1,R1,#+25
   \   0000000A   0xD411             BMI.N    ??RTC_EnterInitMode_0
   1483            {
   1484              /* Set the Initialization mode */
   1485              hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
   \   0000000C   0xF04F 0x31FF      MOV      R1,#-1
   \   00000010   0x60C1             STR      R1,[R0, #+12]
   1486          
   1487              /* Get tick */
   1488              tickstart = HAL_GetTick();
   \   00000012   0x.... 0x....      BL       HAL_GetTick
   \   00000016   0x4605             MOV      R5,R0
   1489          
   1490              /* Wait till RTC is in INIT state and if Time out is reached exit */
   1491              while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
   \                     ??RTC_EnterInitMode_1: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0x0640             LSLS     R0,R0,#+25
   \   0000001E   0xD407             BMI.N    ??RTC_EnterInitMode_0
   1492              {
   1493                if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
   \   00000020   0x.... 0x....      BL       HAL_GetTick
   \   00000024   0x1B40             SUBS     R0,R0,R5
   \   00000026   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   0000002A   0xD9F5             BLS.N    ??RTC_EnterInitMode_1
   1494                {       
   1495                  return HAL_TIMEOUT;
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}
   1496                } 
   1497              }
   1498            }
   1499            
   1500            return HAL_OK;  
   \                     ??RTC_EnterInitMode_0: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1501          }
   1502          
   1503          
   1504          /**
   1505            * @brief  Converts a 2 digit decimal to BCD format.
   1506            * @param  Value: Byte to be converted
   1507            * @retval Converted byte
   1508            */

   \                                 In section .text, align 2, keep-with-next
   1509          uint8_t RTC_ByteToBcd2(uint8_t Value)
   1510          {
   1511            uint32_t bcdhigh = 0U;
   \                     RTC_ByteToBcd2: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE001             B.N      ??RTC_ByteToBcd2_0
   1512            
   1513            while(Value >= 10U)
   1514            {
   1515              bcdhigh++;
   \                     ??RTC_ByteToBcd2_1: (+1)
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   1516              Value -= 10U;
   \   00000006   0x380A             SUBS     R0,R0,#+10
   1517            }
   \                     ??RTC_ByteToBcd2_0: (+1)
   \   00000008   0xB2C0             UXTB     R0,R0
   \   0000000A   0x280A             CMP      R0,#+10
   \   0000000C   0xD2FA             BCS.N    ??RTC_ByteToBcd2_1
   1518            
   1519            return  ((uint8_t)(bcdhigh << 4U) | Value);
   \   0000000E   0xEA40 0x1001      ORR      R0,R0,R1, LSL #+4
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x4770             BX       LR               ;; return
   1520          }
   1521          
   1522          /**
   1523            * @brief  Converts from 2 digit BCD to Binary.
   1524            * @param  Value: BCD value to be converted
   1525            * @retval Converted word
   1526            */

   \                                 In section .text, align 2, keep-with-next
   1527          uint8_t RTC_Bcd2ToByte(uint8_t Value)
   1528          {
   1529            uint32_t tmp = 0U;
   1530            tmp = ((uint8_t)(Value & (uint8_t)0xF0U) >> (uint8_t)0x4U) * 10U;
   1531            return (tmp + (Value & (uint8_t)0x0FU));
   \                     RTC_Bcd2ToByte: (+1)
   \   00000000   0x0901             LSRS     R1,R0,#+4
   \   00000002   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000006   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000000A   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x4770             BX       LR               ;; return
   1532          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0xFF8FFFBF         DC32     0xff8fffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x007F00FF         DC32     0x7f00ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x007F7F7F         DC32     0x7f7f7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x00FFFF3F         DC32     0xffff3f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x40013C00         DC32     0x40013c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x40013C14         DC32     0x40013c14
   1533          
   1534          /**
   1535            * @}
   1536            */
   1537          
   1538          #endif /* HAL_RTC_MODULE_ENABLED */
   1539          /**
   1540            * @}
   1541            */
   1542          
   1543          /**
   1544            * @}
   1545            */
   1546          
   1547          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RTC_AlarmAEventCallback
       8   HAL_RTC_AlarmIRQHandler
         8   -> HAL_RTCEx_AlarmBEventCallback
         8   -> HAL_RTC_AlarmAEventCallback
      16   HAL_RTC_DeInit
        16   -> HAL_GetTick
        16   -> HAL_RTC_MspDeInit
        16   -> HAL_RTC_WaitForSynchro
        16   -> RTC_EnterInitMode
      16   HAL_RTC_DeactivateAlarm
        16   -> HAL_GetTick
      16   HAL_RTC_GetAlarm
        16   -> RTC_Bcd2ToByte
       8   HAL_RTC_GetDate
         8   -> RTC_Bcd2ToByte
       0   HAL_RTC_GetState
       8   HAL_RTC_GetTime
         8   -> RTC_Bcd2ToByte
      16   HAL_RTC_Init
        16   -> HAL_RTC_MspInit
        16   -> RTC_EnterInitMode
       0   HAL_RTC_MspDeInit
       0   HAL_RTC_MspInit
      16   HAL_RTC_PollForAlarmAEvent
        16   -> HAL_GetTick
      24   HAL_RTC_SetAlarm
        24   -> HAL_GetTick
        24   -> RTC_Bcd2ToByte
        24   -> RTC_ByteToBcd2
      32   HAL_RTC_SetAlarm_IT
        32   -> RTC_Bcd2ToByte
        32   -> RTC_ByteToBcd2
      16   HAL_RTC_SetDate
        16   -> HAL_RTC_WaitForSynchro
        16   -> RTC_Bcd2ToByte
        16   -> RTC_ByteToBcd2
        16   -> RTC_EnterInitMode
      16   HAL_RTC_SetTime
        16   -> HAL_RTC_WaitForSynchro
        16   -> RTC_Bcd2ToByte
        16   -> RTC_ByteToBcd2
        16   -> RTC_EnterInitMode
      16   HAL_RTC_WaitForSynchro
        16   -> HAL_GetTick
       0   RTC_Bcd2ToByte
       0   RTC_ByteToBcd2
      16   RTC_EnterInitMode
        16   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       2  HAL_RTC_AlarmAEventCallback
      86  HAL_RTC_AlarmIRQHandler
     204  HAL_RTC_DeInit
     166  HAL_RTC_DeactivateAlarm
     140  HAL_RTC_GetAlarm
      72  HAL_RTC_GetDate
       6  HAL_RTC_GetState
      90  HAL_RTC_GetTime
     156  HAL_RTC_Init
       2  HAL_RTC_MspDeInit
       2  HAL_RTC_MspInit
      66  HAL_RTC_PollForAlarmAEvent
     362  HAL_RTC_SetAlarm
     412  HAL_RTC_SetAlarm_IT
     210  HAL_RTC_SetDate
     232  HAL_RTC_SetTime
      48  HAL_RTC_WaitForSynchro
      18  RTC_Bcd2ToByte
      22  RTC_ByteToBcd2
      52  RTC_EnterInitMode

 
 2 376 bytes in section .text
 
 2 376 bytes of CODE memory

Errors: none
Warnings: none
