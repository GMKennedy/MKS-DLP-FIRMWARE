###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:58:21
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUIArc.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUIArc.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\GUIArc.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\GUIArc.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\Core\GUIArc.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUIARCFloat.C
     16          Purpose     : Draw Arc routines based on floating point
     17          ----------------------------------------------------------------------
     18          Version-Date---Author-Explanation
     19          ----------------------------------------------------------------------
     20          2.00.00 000325 RS     First release of the new algorithm
     21          ----------------------------------------------------------------------
     22          Known problems or limitations with current version
     23          ----------------------------------------------------------------------
     24          None.
     25          ----------------------------------------------------------------------
     26          Open issues
     27          ----------------------------------------------------------------------
     28          None
     29          ---------------------------END-OF-HEADER------------------------------
     30          */
     31          
     32          #include <stddef.h>           /* needed for definition of NULL */
     33          #include <math.h>
     34          #include "GUI_Protected.h"
     35          
     36          /*********************************************************************
     37          *
     38          *       Static code
     39          *
     40          **********************************************************************
     41          */
     42          /*********************************************************************
     43          *
     44          *       _CalcX
     45          */

   \                                 In section .text, align 2, keep-with-next
     46          static void _CalcX(int*px, int y, U32 r2) {
   \                     _CalcX: (+1)
   \   00000000   0xB410             PUSH     {R4}
     47            int x =*px;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
     48            U32 y2 = (U32)y*(U32)y;
   \   00000004   0x4349             MULS     R1,R1,R1
     49            U32 r2y2 = r2-y2;
   \   00000006   0x1A54             SUBS     R4,R2,R1
     50            U32 x2;
     51            if (y2>=r2) {
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0xD302             BCC.N    ??_CalcX_0
     52              *px=0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6001             STR      R1,[R0, #+0]
     53          		return;
   \   00000010   0xE006             B.N      ??_CalcX_1
     54          	}
     55            /* x2 = r2-y2 */
     56            do {
     57              x++;
   \                     ??_CalcX_0: (+1)
   \   00000012   0x1C5B             ADDS     R3,R3,#+1
     58              x2 =(U32)x*(U32)x;
     59          	} while (x2 < r2y2);
   \   00000014   0xFB03 0xF103      MUL      R1,R3,R3
   \   00000018   0x42A1             CMP      R1,R4
   \   0000001A   0xD3FA             BCC.N    ??_CalcX_0
     60          	*px = x-1;
   \   0000001C   0x1E59             SUBS     R1,R3,#+1
   \   0000001E   0x6001             STR      R1,[R0, #+0]
     61          }
   \                     ??_CalcX_1: (+1)
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
     62          
     63          /*********************************************************************
     64          *
     65          *       _CalcInterSectLin
     66          */

   \                                 In section .text, align 2, keep-with-next
     67          static float _CalcInterSectLin(float y, float y0, float y1, float x0, float x1) {
     68            if (y1==y0) {
   \                     _CalcInterSectLin: (+1)
   \   00000000   0xEEB4 0x1A60      VCMP.F32 S2,S1
   \   00000004   0xEEF1 0xFA10      FMSTAT   
   \   00000008   0xD102             BNE.N    ??_CalcInterSectLin_0
     69          	  return y0;
   \   0000000A   0xEEB0 0x0A60      VMOV.F32 S0,S1
   \   0000000E   0x4770             BX       LR
     70          	} else {
     71              float Slope = (x1-x0)/(y1-y0);
     72             return (y-y0)*Slope+x0;
   \                     ??_CalcInterSectLin_0: (+1)
   \   00000010   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   00000014   0xEE32 0x2A61      VSUB.F32 S4,S4,S3
   \   00000018   0xEE71 0x0A60      VSUB.F32 S1,S2,S1
   \   0000001C   0xEEC2 0x0A20      VDIV.F32 S1,S4,S1
   \   00000020   0xEE40 0x1A20      VMLA.F32 S3,S0,S1
   \   00000024   0xEEB0 0x0A61      VMOV.F32 S0,S3
   \   00000028   0x4770             BX       LR               ;; return
     73          	}
     74          }
     75          
     76          /*********************************************************************
     77          *
     78          *       _DrawArc
     79          */

   \                                 In section .text, align 4, keep-with-next
     80          static void _DrawArc(int x0, int y0, int rx, int ry, int Angle0, int Angle1, int xMul, int yMul) {
   \                     _DrawArc: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xED2D 0x8B0C      VPUSH    {D8-D13}
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x4605             MOV      R5,R0
   \   0000000C   0x460E             MOV      R6,R1
   \   0000000E   0x4617             MOV      R7,R2
     81            float afx[4];
     82            float afy[4];
     83          	float ri = rx-(GUI_Context.PenSize+1.5)/2;
   \   00000010   0x.... 0x....      LDR.W    R4,??DataTable1
   \   00000014   0x7D20             LDRB     R0,[R4, #+20]
   \   00000016   0x.... 0x....      BL       __aeabi_ui2d
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x.... 0x....      LDR.W    R3,??DataTable1_1  ;; 0x3ff80000
   \   00000020   0x.... 0x....      BL       __aeabi_dadd
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x.... 0x....      LDR.W    R3,??DataTable1_2  ;; 0x3fe00000
   \   0000002A   0x.... 0x....      BL       __aeabi_dmul
   \   0000002E   0xEC41 0x0B18      VMOV     D8,R0,R1
   \   00000032   0x4638             MOV      R0,R7
   \   00000034   0x.... 0x....      BL       __aeabi_i2d
   \   00000038   0xEC41 0x0B19      VMOV     D9,R0,R1
   \   0000003C   0xEC53 0x2B18      VMOV     R2,R3,D8
   \   00000040   0x.... 0x....      BL       __aeabi_dsub
   \   00000044   0x.... 0x....      BL       __aeabi_d2f
   \   00000048   0xEE0B 0x0A90      VMOV     S23,R0
     84          	float ro = rx+(GUI_Context.PenSize+1.5)/2;
   \   0000004C   0xEC53 0x2B19      VMOV     R2,R3,D9
   \   00000050   0xEC51 0x0B18      VMOV     R0,R1,D8
   \   00000054   0x.... 0x....      BL       __aeabi_dadd
   \   00000058   0x.... 0x....      BL       __aeabi_d2f
   \   0000005C   0xEE0C 0x0A10      VMOV     S24,R0
     85            float fAngle0 = Angle0*3.1415926/180;
   \   00000060   0xED9F 0x....      VLDR.W   D8,??DataTable0
   \   00000064   0x9816             LDR      R0,[SP, #+88]
   \   00000066   0x.... 0x....      BL       __aeabi_i2d
   \   0000006A   0xEC53 0x2B18      VMOV     R2,R3,D8
   \   0000006E   0x.... 0x....      BL       __aeabi_dmul
   \   00000072   0x2200             MOVS     R2,#+0
   \   00000074   0x.... 0x....      LDR.W    R3,??DataTable1_3  ;; 0x40668000
   \   00000078   0x.... 0x....      BL       __aeabi_ddiv
   \   0000007C   0x.... 0x....      BL       __aeabi_d2f
   \   00000080   0xEE09 0x0A10      VMOV     S18,R0
     86            float fAngle1 = Angle1*3.1415926/180;
   \   00000084   0x9817             LDR      R0,[SP, #+92]
   \   00000086   0x.... 0x....      BL       __aeabi_i2d
   \   0000008A   0xEC53 0x2B18      VMOV     R2,R3,D8
   \   0000008E   0x.... 0x....      BL       __aeabi_dmul
   \   00000092   0x2200             MOVS     R2,#+0
   \   00000094   0x....             LDR.N    R3,??DataTable1_3  ;; 0x40668000
   \   00000096   0x.... 0x....      BL       __aeabi_ddiv
   \   0000009A   0x.... 0x....      BL       __aeabi_d2f
   \   0000009E   0xEE09 0x0A90      VMOV     S19,R0
     87            float sin0 = sin(fAngle0); 
   \   000000A2   0xEE19 0x0A10      VMOV     R0,S18
   \   000000A6   0x.... 0x....      BL       __aeabi_f2d
   \   000000AA   0xEC41 0x0B18      VMOV     D8,R0,R1
   \   000000AE   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000B2   0xEEF0 0x0A68      VMOV.F32 S1,S17
   \   000000B6   0x.... 0x....      BL       sin
   \   000000BA   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   000000BE   0x.... 0x....      BL       __aeabi_d2f
   \   000000C2   0xEE09 0x0A10      VMOV     S18,R0
     88            float sin1 = sin(fAngle1); 
   \   000000C6   0xEE19 0x0A90      VMOV     R0,S19
   \   000000CA   0x.... 0x....      BL       __aeabi_f2d
   \   000000CE   0xEC41 0x0B1D      VMOV     D13,R0,R1
   \   000000D2   0xEEB0 0x0A4D      VMOV.F32 S0,S26
   \   000000D6   0xEEF0 0x0A6D      VMOV.F32 S1,S27
   \   000000DA   0x.... 0x....      BL       sin
   \   000000DE   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   000000E2   0x.... 0x....      BL       __aeabi_d2f
   \   000000E6   0xEE0A 0x0A10      VMOV     S20,R0
     89            float cos0 = cos(fAngle0); 
   \   000000EA   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000EE   0xEEF0 0x0A68      VMOV.F32 S1,S17
   \   000000F2   0x.... 0x....      BL       cos
   \   000000F6   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   000000FA   0x.... 0x....      BL       __aeabi_d2f
   \   000000FE   0xEE0B 0x0A10      VMOV     S22,R0
     90            float cos1 = cos(fAngle1); 
   \   00000102   0xEEB0 0x0A4D      VMOV.F32 S0,S26
   \   00000106   0xEEF0 0x0A6D      VMOV.F32 S1,S27
   \   0000010A   0x.... 0x....      BL       cos
   \   0000010E   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   00000112   0x.... 0x....      BL       __aeabi_d2f
   \   00000116   0xEE00 0x0A10      VMOV     S0,R0
     91            U32   ri2 = ri*ri;
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000011A   0xEE6B 0x0AAB      VMUL.F32 S1,S23,S23
   \   0000011E   0xEEFC 0xCAE0      VCVT.U32.F32 S25,S1
     92            U32   ro2 = ro*ro;
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000122   0xEE6C 0x0A0C      VMUL.F32 S1,S24,S24
   \   00000126   0xEEBC 0x8AE0      VCVT.U32.F32 S16,S1
     93          	int y, yMax, yMin;
     94          	afy[0] = ri*sin0;
   \   0000012A   0xEE6B 0x8A89      VMUL.F32 S17,S23,S18
     95          	afy[1] = ro*sin0;
   \   0000012E   0xEE2C 0x9A09      VMUL.F32 S18,S24,S18
     96          	afy[2] = ri*sin1;
   \   00000132   0xEE6B 0x9A8A      VMUL.F32 S19,S23,S20
     97          	afy[3] = ro*sin1;
   \   00000136   0xEE2C 0xAA0A      VMUL.F32 S20,S24,S20
     98          	afx[0] = ri*cos0;
   \   0000013A   0xEE6B 0xAA8B      VMUL.F32 S21,S23,S22
     99          	afx[1] = ro*cos0;
   \   0000013E   0xEE2C 0xBA0B      VMUL.F32 S22,S24,S22
    100          	afx[2] = ri*cos1;
   \   00000142   0xEE6B 0xBA80      VMUL.F32 S23,S23,S0
    101          	afx[3] = ro*cos1;
   \   00000146   0xEE2C 0xCA00      VMUL.F32 S24,S24,S0
    102          	yMin = ceil(afy[0]);
                 	     ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000014A   0xEE18 0x0A90      VMOV     R0,S17
   \   0000014E   0x.... 0x....      BL       __aeabi_f2d
   \   00000152   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   00000156   0x.... 0x....      BL       ceil
   \   0000015A   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   0000015E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000162   0x4607             MOV      R7,R0
    103            yMax = floor(afy[3]);
                        ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000164   0xEE1A 0x0A10      VMOV     R0,S20
   \   00000168   0x.... 0x....      BL       __aeabi_f2d
   \   0000016C   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   00000170   0x.... 0x....      BL       floor
   \   00000174   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   00000178   0x.... 0x....      BL       __aeabi_d2iz
    104            /* Use Clipping rect to reduce calculation (if possible) */
    105            if (GUI_Context.pClipRect_HL) {
   \   0000017C   0x6921             LDR      R1,[R4, #+16]
   \   0000017E   0xF8DD 0x8064      LDR      R8,[SP, #+100]
   \   00000182   0x2900             CMP      R1,#+0
   \   00000184   0xD01D             BEQ.N    ??_DrawArc_0
    106              if (yMul ==1) {
   \   00000186   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000018A   0xD10B             BNE.N    ??_DrawArc_1
    107                if (yMax > (GUI_Context.pClipRect_HL->y1 -y0))
   \   0000018C   0xF9B1 0x2006      LDRSH    R2,[R1, #+6]
   \   00000190   0x1B92             SUBS     R2,R2,R6
   \   00000192   0x4282             CMP      R2,R0
   \   00000194   0xDA00             BGE.N    ??_DrawArc_2
    108                  yMax = (GUI_Context.pClipRect_HL->y1 -y0);
   \   00000196   0x4610             MOV      R0,R2
    109                if (yMin < (GUI_Context.pClipRect_HL->y0 -y0))
   \                     ??_DrawArc_2: (+1)
   \   00000198   0xF9B1 0x2002      LDRSH    R2,[R1, #+2]
   \   0000019C   0x1B92             SUBS     R2,R2,R6
   \   0000019E   0x4297             CMP      R7,R2
   \   000001A0   0xDA00             BGE.N    ??_DrawArc_1
    110                  yMin = (GUI_Context.pClipRect_HL->y0 -y0);
   \   000001A2   0x4617             MOV      R7,R2
    111              }
    112              if (yMul == -1) {
   \                     ??_DrawArc_1: (+1)
   \   000001A4   0xF118 0x0F01      CMN      R8,#+1
   \   000001A8   0xD10B             BNE.N    ??_DrawArc_0
    113                if (yMin > (GUI_Context.pClipRect_HL->y1 -y0))
   \   000001AA   0xF9B1 0x2006      LDRSH    R2,[R1, #+6]
   \   000001AE   0x1B92             SUBS     R2,R2,R6
   \   000001B0   0x42BA             CMP      R2,R7
   \   000001B2   0xDA00             BGE.N    ??_DrawArc_3
    114                  yMin = (GUI_Context.pClipRect_HL->y1 -y0);
   \   000001B4   0x4617             MOV      R7,R2
    115                if (yMax < (GUI_Context.pClipRect_HL->y0 -y0))
   \                     ??_DrawArc_3: (+1)
   \   000001B6   0xF9B1 0x1002      LDRSH    R1,[R1, #+2]
   \   000001BA   0x1B8A             SUBS     R2,R1,R6
   \   000001BC   0x4290             CMP      R0,R2
   \   000001BE   0xDA00             BGE.N    ??_DrawArc_0
    116                  yMax = (GUI_Context.pClipRect_HL->y0 -y0);
   \   000001C0   0x4610             MOV      R0,R2
    117              }
    118            }
    119            /* Start drawing lines ... */
    120            {
    121            int xMinDisp, xMaxDisp, xMin=0,xMax=0;
   \                     ??_DrawArc_0: (+1)
   \   000001C2   0x2100             MOVS     R1,#+0
   \   000001C4   0x9101             STR      R1,[SP, #+4]
   \   000001C6   0x9100             STR      R1,[SP, #+0]
    122              for (y=yMax; y>=yMin; y--) {
   \   000001C8   0x4604             MOV      R4,R0
   \   000001CA   0xF8DD 0x9060      LDR      R9,[SP, #+96]
   \   000001CE   0xE005             B.N      ??_DrawArc_4
    123                _CalcX(&xMin, y, ri2);
    124                _CalcX(&xMax, y, ro2);
    125                if ((float)y< afy[1]) {
    126                  xMaxDisp = _CalcInterSectLin(y,afy[0], afy[1], afx[0], afx[1]);
                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
    127          			} else {
    128                  xMaxDisp = xMax;			
    129          			}
    130                if ((float)y > afy[2]) {
    131                  xMinDisp = _CalcInterSectLin(y,afy[2], afy[3], afx[2], afx[3]);
                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
    132          			} else {
    133                  xMinDisp = xMin;			
    134          			}
    135                if (xMul>0)
    136                  LCD_HL_DrawHLine(xMinDisp+x0, yMul*y+y0, xMaxDisp+x0);
    137                else
    138                  LCD_HL_DrawHLine(-xMaxDisp+x0, yMul*y+y0, -xMinDisp+x0);
   \                     ??_DrawArc_5: (+1)
   \   000001D0   0x1A2A             SUBS     R2,R5,R0
   \   000001D2   0xEBA5 0x000A      SUB      R0,R5,R10
   \   000001D6   0x.... 0x....      BL       LCD_DrawHLine
   \                     ??_DrawArc_6: (+1)
   \   000001DA   0x1E64             SUBS     R4,R4,#+1
   \                     ??_DrawArc_4: (+1)
   \   000001DC   0x42BC             CMP      R4,R7
   \   000001DE   0xDB49             BLT.N    ??_DrawArc_7
   \   000001E0   0xEE1C 0x2A90      VMOV     R2,S25
   \   000001E4   0x4621             MOV      R1,R4
   \   000001E6   0xA801             ADD      R0,SP,#+4
   \   000001E8   0x.... 0x....      BL       _CalcX
   \   000001EC   0xEE18 0x2A10      VMOV     R2,S16
   \   000001F0   0x4621             MOV      R1,R4
   \   000001F2   0xA800             ADD      R0,SP,#+0
   \   000001F4   0x.... 0x....      BL       _CalcX
   \   000001F8   0xEE00 0x4A10      VMOV     S0,R4
   \   000001FC   0xEEB8 0xDAC0      VCVT.F32.S32 S26,S0
   \   00000200   0xEEB4 0xDA49      VCMP.F32 S26,S18
   \   00000204   0xEEF1 0xFA10      FMSTAT   
   \   00000208   0xD510             BPL.N    ??_DrawArc_8
   \   0000020A   0xEEB0 0x2A4B      VMOV.F32 S4,S22
   \   0000020E   0xEEF0 0x1A6A      VMOV.F32 S3,S21
   \   00000212   0xEEB0 0x1A49      VMOV.F32 S2,S18
   \   00000216   0xEEF0 0x0A68      VMOV.F32 S1,S17
   \   0000021A   0xEEB0 0x0A4D      VMOV.F32 S0,S26
   \   0000021E   0x.... 0x....      BL       _CalcInterSectLin
   \   00000222   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000226   0xEE10 0xAA10      VMOV     R10,S0
   \   0000022A   0xE001             B.N      ??_DrawArc_9
   \                     ??_DrawArc_8: (+1)
   \   0000022C   0xF8DD 0xA000      LDR      R10,[SP, #+0]
   \                     ??_DrawArc_9: (+1)
   \   00000230   0xEEF4 0x9A4D      VCMP.F32 S19,S26
   \   00000234   0xEEF1 0xFA10      FMSTAT   
   \   00000238   0xD510             BPL.N    ??_DrawArc_10
   \   0000023A   0xEEB0 0x2A4C      VMOV.F32 S4,S24
   \   0000023E   0xEEF0 0x1A6B      VMOV.F32 S3,S23
   \   00000242   0xEEB0 0x1A4A      VMOV.F32 S2,S20
   \   00000246   0xEEF0 0x0A69      VMOV.F32 S1,S19
   \   0000024A   0xEEB0 0x0A4D      VMOV.F32 S0,S26
   \   0000024E   0x.... 0x....      BL       _CalcInterSectLin
   \   00000252   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000256   0xEE10 0x0A10      VMOV     R0,S0
   \   0000025A   0xE000             B.N      ??_DrawArc_11
   \                     ??_DrawArc_10: (+1)
   \   0000025C   0x9801             LDR      R0,[SP, #+4]
   \                     ??_DrawArc_11: (+1)
   \   0000025E   0xFB04 0x6108      MLA      R1,R4,R8,R6
   \   00000262   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000266   0xDBB3             BLT.N    ??_DrawArc_5
   \   00000268   0xEB05 0x020A      ADD      R2,R5,R10
   \   0000026C   0x1828             ADDS     R0,R5,R0
   \   0000026E   0x.... 0x....      BL       LCD_DrawHLine
   \   00000272   0xE7B2             B.N      ??_DrawArc_6
    139              }
    140          	}
    141          #if 0  /* Test code */
    142          {
    143            int i;
    144            GUI_SetColor( GUI_WHITE ); 
    145          	for (i=0; i<4; i++)
    146              LCD_HL_DrawPixel(afx[i]+x0, afy[i]+y0);
    147          }
    148          #endif
    149            GUI_USE_PARA(ry);
    150          }
   \                     ??_DrawArc_7: (+1)
   \   00000274   0xB002             ADD      SP,SP,#+8
   \   00000276   0xECBD 0x8B0C      VPOP     {D8-D13}
   \   0000027A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    151          
    152          /*********************************************************************
    153          *
    154          *       Public code
    155          *
    156          **********************************************************************
    157          */
    158          /*********************************************************************
    159          *
    160          *       GL_DrawArc
    161          */

   \                                 In section .text, align 2, keep-with-next
    162          void GL_DrawArc(int x0, int y0, int rx, int ry, int a0, int a1) {
   \                     GL_DrawArc: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
    163            int aEnd;
    164            a0+=360;
   \   0000000E   0x980C             LDR      R0,[SP, #+48]
   \   00000010   0xF500 0x78B4      ADD      R8,R0,#+360
    165          	a1+=360;
   \   00000014   0x980D             LDR      R0,[SP, #+52]
   \   00000016   0xF500 0x79B4      ADD      R9,R0,#+360
   \   0000001A   0xE003             B.N      ??GL_DrawArc_0
    166          	while (a0>=360) {
    167              a0 -= 360;
   \                     ??GL_DrawArc_1: (+1)
   \   0000001C   0xF5A8 0x78B4      SUB      R8,R8,#+360
    168              a1 -= 360;
   \   00000020   0xF5A9 0x79B4      SUB      R9,R9,#+360
    169          	}
   \                     ??GL_DrawArc_0: (+1)
   \   00000024   0xF5B8 0x7FB4      CMP      R8,#+360
   \   00000028   0xDAF8             BGE.N    ??GL_DrawArc_1
    170          /* Do first quadrant 0-90 degree */
    171          DoFirst:
    172            if (a1<=0)
   \                     ??GL_DrawArc_2: (+1)
   \   0000002A   0xF1B9 0x0F01      CMP      R9,#+1
   \   0000002E   0xDA02             BGE.N    ??GL_DrawArc_3
    173          	  return;
   \                     ??GL_DrawArc_4: (+1)
   \   00000030   0xB005             ADD      SP,SP,#+20
   \   00000032   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    174          	if (a0<90) {
   \                     ??GL_DrawArc_3: (+1)
   \   00000036   0xF1B8 0x0F5A      CMP      R8,#+90
   \   0000003A   0xDA17             BGE.N    ??GL_DrawArc_5
    175              if (a0<0)
   \   0000003C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000040   0xD501             BPL.N    ??GL_DrawArc_6
    176          		  a0=0;
   \   00000042   0xF04F 0x0800      MOV      R8,#+0
    177              aEnd = (a1<90) ? a1 : 90;
   \                     ??GL_DrawArc_6: (+1)
   \   00000046   0x205A             MOVS     R0,#+90
   \   00000048   0xF1B9 0x0F5A      CMP      R9,#+90
   \   0000004C   0xDC00             BGT.N    ??GL_DrawArc_7
   \   0000004E   0x4648             MOV      R0,R9
    178              _DrawArc(x0,y0,rx,ry,a0,aEnd, 1, -1);
   \                     ??GL_DrawArc_7: (+1)
   \   00000050   0xF04F 0x31FF      MOV      R1,#-1
   \   00000054   0x9103             STR      R1,[SP, #+12]
   \   00000056   0x2101             MOVS     R1,#+1
   \   00000058   0x9102             STR      R1,[SP, #+8]
   \   0000005A   0x9001             STR      R0,[SP, #+4]
   \   0000005C   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000060   0x463B             MOV      R3,R7
   \   00000062   0x4632             MOV      R2,R6
   \   00000064   0x4629             MOV      R1,R5
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       _DrawArc
    179          	}
    180            a1-=90;
   \                     ??GL_DrawArc_5: (+1)
   \   0000006C   0xF1A9 0x095A      SUB      R9,R9,#+90
    181          	a0-=90;
   \   00000070   0xF1A8 0x085A      SUB      R8,R8,#+90
    182          /* Do second quadrant 90-180 degree */
    183            if (a1<=0)
   \   00000074   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000078   0xDBDA             BLT.N    ??GL_DrawArc_4
    184          	  return;
    185          	if (a0<90) {
   \   0000007A   0xF1B8 0x0F5A      CMP      R8,#+90
   \   0000007E   0xDA19             BGE.N    ??GL_DrawArc_8
    186              if (a0<0)
   \   00000080   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000084   0xD501             BPL.N    ??GL_DrawArc_9
    187          		  a0=0;
   \   00000086   0xF04F 0x0800      MOV      R8,#+0
    188              aEnd = (a1<90) ? a1 : 90;
   \                     ??GL_DrawArc_9: (+1)
   \   0000008A   0x205A             MOVS     R0,#+90
   \   0000008C   0xF1B9 0x0F5A      CMP      R9,#+90
   \   00000090   0xDC00             BGT.N    ??GL_DrawArc_10
   \   00000092   0x4648             MOV      R0,R9
    189              _DrawArc(x0,y0,rx,ry,90-aEnd, 90-a0,-1,-1);
   \                     ??GL_DrawArc_10: (+1)
   \   00000094   0xF04F 0x31FF      MOV      R1,#-1
   \   00000098   0x9103             STR      R1,[SP, #+12]
   \   0000009A   0x9102             STR      R1,[SP, #+8]
   \   0000009C   0xF1C8 0x015A      RSB      R1,R8,#+90
   \   000000A0   0x9101             STR      R1,[SP, #+4]
   \   000000A2   0xF1C0 0x005A      RSB      R0,R0,#+90
   \   000000A6   0x9000             STR      R0,[SP, #+0]
   \   000000A8   0x463B             MOV      R3,R7
   \   000000AA   0x4632             MOV      R2,R6
   \   000000AC   0x4629             MOV      R1,R5
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       _DrawArc
    190          	}
    191            a1-=90;
   \                     ??GL_DrawArc_8: (+1)
   \   000000B4   0xF1A9 0x095A      SUB      R9,R9,#+90
    192          	a0-=90;
   \   000000B8   0xF1A8 0x085A      SUB      R8,R8,#+90
    193          /* Do third quadrant 180-270 degree */
    194            if (a1<=0)
   \   000000BC   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000C0   0xDBB6             BLT.N    ??GL_DrawArc_4
    195          	  return;
    196          	if (a0<90) {
   \   000000C2   0xF1B8 0x0F5A      CMP      R8,#+90
   \   000000C6   0xDA17             BGE.N    ??GL_DrawArc_11
    197              if (a0<0)
   \   000000C8   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000CC   0xD501             BPL.N    ??GL_DrawArc_12
    198          		  a0=0;
   \   000000CE   0xF04F 0x0800      MOV      R8,#+0
    199              aEnd = (a1<90) ? a1 : 90;
   \                     ??GL_DrawArc_12: (+1)
   \   000000D2   0x205A             MOVS     R0,#+90
   \   000000D4   0xF1B9 0x0F5A      CMP      R9,#+90
   \   000000D8   0xDC00             BGT.N    ??GL_DrawArc_13
   \   000000DA   0x4648             MOV      R0,R9
    200              _DrawArc(x0,y0,rx,ry,a0,aEnd, -1, 1);
   \                     ??GL_DrawArc_13: (+1)
   \   000000DC   0x2101             MOVS     R1,#+1
   \   000000DE   0x9103             STR      R1,[SP, #+12]
   \   000000E0   0xF04F 0x31FF      MOV      R1,#-1
   \   000000E4   0x9102             STR      R1,[SP, #+8]
   \   000000E6   0x9001             STR      R0,[SP, #+4]
   \   000000E8   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000EC   0x463B             MOV      R3,R7
   \   000000EE   0x4632             MOV      R2,R6
   \   000000F0   0x4629             MOV      R1,R5
   \   000000F2   0x4620             MOV      R0,R4
   \   000000F4   0x.... 0x....      BL       _DrawArc
    201          	}
    202            a1-=90;
   \                     ??GL_DrawArc_11: (+1)
   \   000000F8   0xF1A9 0x095A      SUB      R9,R9,#+90
    203          	a0-=90;
   \   000000FC   0xF1A8 0x085A      SUB      R8,R8,#+90
    204          /* Do last quadrant 270-360 degree */
    205            if (a1<=0)
   \   00000100   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000104   0xDB94             BLT.N    ??GL_DrawArc_4
    206          	  return;
    207          	if (a0<90) {
   \   00000106   0xF1B8 0x0F5A      CMP      R8,#+90
   \   0000010A   0xDA18             BGE.N    ??GL_DrawArc_14
    208              if (a0<0)
   \   0000010C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000110   0xD501             BPL.N    ??GL_DrawArc_15
    209          		  a0=0;
   \   00000112   0xF04F 0x0800      MOV      R8,#+0
    210              aEnd = (a1<90) ? a1 : 90;
   \                     ??GL_DrawArc_15: (+1)
   \   00000116   0x205A             MOVS     R0,#+90
   \   00000118   0xF1B9 0x0F5A      CMP      R9,#+90
   \   0000011C   0xDC00             BGT.N    ??GL_DrawArc_16
   \   0000011E   0x4648             MOV      R0,R9
    211              _DrawArc(x0,y0,rx,ry,90-aEnd, 90-a0,1,1);
   \                     ??GL_DrawArc_16: (+1)
   \   00000120   0x2101             MOVS     R1,#+1
   \   00000122   0x9103             STR      R1,[SP, #+12]
   \   00000124   0x9102             STR      R1,[SP, #+8]
   \   00000126   0xF1C8 0x015A      RSB      R1,R8,#+90
   \   0000012A   0x9101             STR      R1,[SP, #+4]
   \   0000012C   0xF1C0 0x005A      RSB      R0,R0,#+90
   \   00000130   0x9000             STR      R0,[SP, #+0]
   \   00000132   0x463B             MOV      R3,R7
   \   00000134   0x4632             MOV      R2,R6
   \   00000136   0x4629             MOV      R1,R5
   \   00000138   0x4620             MOV      R0,R4
   \   0000013A   0x.... 0x....      BL       _DrawArc
    212          	}
    213            a1-=90;
   \                     ??GL_DrawArc_14: (+1)
   \   0000013E   0xF1A9 0x095A      SUB      R9,R9,#+90
    214          	a0-=90;
   \   00000142   0xF1A8 0x085A      SUB      R8,R8,#+90
    215          goto DoFirst;
   \   00000146   0xE770             B.N      ??GL_DrawArc_2
    216          }
    217          
    218          /*********************************************************************
    219          *
    220          *       GUI_DrawArc
    221          */

   \                                 In section .text, align 2, keep-with-next
    222          void GUI_DrawArc(int x0, int y0, int rx, int ry, int a0, int a1) {
   \                     GUI_DrawArc: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461D             MOV      R5,R3
    223            GUI_LOCK();
    224            #if (GUI_WINSUPPORT)
    225              WM_ADDORG(x0,y0);
   \   0000000A   0x....             LDR.N    R2,??DataTable1
   \   0000000C   0x6C13             LDR      R3,[R2, #+64]
   \   0000000E   0xEB03 0x0800      ADD      R8,R3,R0
   \   00000012   0x6C50             LDR      R0,[R2, #+68]
   \   00000014   0xEB00 0x0901      ADD      R9,R0,R1
    226              WM_ITERATE_START(NULL) {
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       WM__InitIVRSearch
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD00D             BEQ.N    ??GUI_DrawArc_0
   \   00000022   0x9E0A             LDR      R6,[SP, #+40]
   \   00000024   0x9F0B             LDR      R7,[SP, #+44]
    227            #endif
    228            GL_DrawArc( x0, y0, rx, ry, a0, a1);
   \                     ??GUI_DrawArc_1: (+1)
   \   00000026   0x9701             STR      R7,[SP, #+4]
   \   00000028   0x9600             STR      R6,[SP, #+0]
   \   0000002A   0x462B             MOV      R3,R5
   \   0000002C   0x4622             MOV      R2,R4
   \   0000002E   0x4649             MOV      R1,R9
   \   00000030   0x4640             MOV      R0,R8
   \   00000032   0x.... 0x....      BL       GL_DrawArc
    229            #if (GUI_WINSUPPORT)
    230              } WM_ITERATE_END();
   \   00000036   0x.... 0x....      BL       WM__GetNextIVR
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD1F3             BNE.N    ??GUI_DrawArc_1
    231            #endif
    232            GUI_UNLOCK();
    233          }
   \                     ??GUI_DrawArc_0: (+1)
   \   0000003E   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x4D12D84A         DC32     0x4D12D84A,0x400921FB
   \              0x400921FB   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     GUI_Context

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x3FF80000         DC32     0x3ff80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x40668000         DC32     0x40668000
    234          
    235          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   GL_DrawArc
        48   -> _DrawArc
      40   GUI_DrawArc
        40   -> GL_DrawArc
        40   -> WM__GetNextIVR
        40   -> WM__InitIVRSearch
       0   _CalcInterSectLin
       4   _CalcX
      88   _DrawArc
        88   -> LCD_DrawHLine
        88   -> _CalcInterSectLin
        88   -> _CalcX
        88   -> __aeabi_d2f
        88   -> __aeabi_d2iz
        88   -> __aeabi_dadd
        88   -> __aeabi_ddiv
        88   -> __aeabi_dmul
        88   -> __aeabi_dsub
        88   -> __aeabi_f2d
        88   -> __aeabi_i2d
        88   -> __aeabi_ui2d
        88   -> ceil
        88   -> cos
        88   -> floor
        88   -> sin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??DataTable0
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
     328  GL_DrawArc
      66  GUI_DrawArc
      42  _CalcInterSectLin
      36  _CalcX
     638  _DrawArc

 
 1 134 bytes in section .text
 
 1 134 bytes of CODE memory

Errors: none
Warnings: 6
