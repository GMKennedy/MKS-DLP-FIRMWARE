###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:13
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_gpio.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_gpio.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\stm32f4xx_hal_gpio.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\stm32f4xx_hal_gpio.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_gpio.c
      4            * @author  MCD Application Team
      5            * @version V1.5.2
      6            * @date    22-September-2016
      7            * @brief   GPIO HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the General Purpose Input/Output (GPIO) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *
     13            @verbatim
     14            ==============================================================================
     15                              ##### GPIO Peripheral features #####
     16            ==============================================================================
     17            [..] 
     18            Subject to the specific hardware characteristics of each I/O port listed in the datasheet, each
     19            port bit of the General Purpose IO (GPIO) Ports, can be individually configured by software
     20            in several modes:
     21            (+) Input mode 
     22            (+) Analog mode
     23            (+) Output mode
     24            (+) Alternate function mode
     25            (+) External interrupt/event lines
     26          
     27            [..]  
     28            During and just after reset, the alternate functions and external interrupt  
     29            lines are not active and the I/O ports are configured in input floating mode.
     30            
     31            [..]   
     32            All GPIO pins have weak internal pull-up and pull-down resistors, which can be 
     33            activated or not.
     34          
     35            [..]
     36            In Output or Alternate mode, each IO can be configured on open-drain or push-pull
     37            type and the IO speed can be selected depending on the VDD value.
     38          
     39            [..]  
     40            All ports have external interrupt/event capability. To use external interrupt 
     41            lines, the port must be configured in input mode. All available GPIO pins are 
     42            connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.
     43            
     44            [..]
     45            The external interrupt/event controller consists of up to 23 edge detectors 
     46            (16 lines are connected to GPIO) for generating event/interrupt requests (each 
     47            input line can be independently configured to select the type (interrupt or event) 
     48            and the corresponding trigger event (rising or falling or both). Each line can 
     49            also be masked independently. 
     50          
     51                               ##### How to use this driver #####
     52            ==============================================================================  
     53            [..]
     54              (#) Enable the GPIO AHB clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE(). 
     55          
     56              (#) Configure the GPIO pin(s) using HAL_GPIO_Init().
     57                  (++) Configure the IO mode using "Mode" member from GPIO_InitTypeDef structure
     58                  (++) Activate Pull-up, Pull-down resistor using "Pull" member from GPIO_InitTypeDef 
     59                       structure.
     60                  (++) In case of Output or alternate function mode selection: the speed is 
     61                       configured through "Speed" member from GPIO_InitTypeDef structure.
     62                  (++) In alternate mode is selection, the alternate function connected to the IO
     63                       is configured through "Alternate" member from GPIO_InitTypeDef structure.
     64                  (++) Analog mode is required when a pin is to be used as ADC channel 
     65                       or DAC output.
     66                  (++) In case of external interrupt/event selection the "Mode" member from 
     67                       GPIO_InitTypeDef structure select the type (interrupt or event) and 
     68                       the corresponding trigger event (rising or falling or both).
     69          
     70              (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority 
     71                  mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using
     72                  HAL_NVIC_EnableIRQ().
     73                   
     74              (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().
     75                      
     76              (#) To set/reset the level of a pin configured in output mode use 
     77                  HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().
     78              
     79              (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().
     80          
     81                           
     82              (#) During and just after reset, the alternate functions are not 
     83                  active and the GPIO pins are configured in input floating mode (except JTAG
     84                  pins).
     85            
     86              (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose 
     87                  (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has 
     88                  priority over the GPIO function.
     89            
     90              (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as 
     91                  general purpose PH0 and PH1, respectively, when the HSE oscillator is off. 
     92                  The HSE has priority over the GPIO function.
     93            
     94            @endverbatim
     95            ******************************************************************************
     96            * @attention
     97            *
     98            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     99            *
    100            * Redistribution and use in source and binary forms, with or without modification,
    101            * are permitted provided that the following conditions are met:
    102            *   1. Redistributions of source code must retain the above copyright notice,
    103            *      this list of conditions and the following disclaimer.
    104            *   2. Redistributions in binary form must reproduce the above copyright notice,
    105            *      this list of conditions and the following disclaimer in the documentation
    106            *      and/or other materials provided with the distribution.
    107            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    108            *      may be used to endorse or promote products derived from this software
    109            *      without specific prior written permission.
    110            *
    111            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    112            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    113            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    114            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    115            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    116            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    117            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    118            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    119            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    120            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    121            *
    122            ******************************************************************************
    123            */ 
    124          
    125          /* Includes ------------------------------------------------------------------*/
    126          #include "stm32f4xx_hal.h"
    127          
    128          /** @addtogroup STM32F4xx_HAL_Driver
    129            * @{
    130            */
    131          
    132          /** @defgroup GPIO GPIO
    133            * @brief GPIO HAL module driver
    134            * @{
    135            */
    136          
    137          #ifdef HAL_GPIO_MODULE_ENABLED
    138          
    139          /* Private typedef -----------------------------------------------------------*/
    140          /* Private define ------------------------------------------------------------*/
    141          /** @addtogroup GPIO_Private_Constants GPIO Private Constants
    142            * @{
    143            */
    144          #define GPIO_MODE             ((uint32_t)0x00000003U)
    145          #define EXTI_MODE             ((uint32_t)0x10000000U)
    146          #define GPIO_MODE_IT          ((uint32_t)0x00010000U)
    147          #define GPIO_MODE_EVT         ((uint32_t)0x00020000U)
    148          #define RISING_EDGE           ((uint32_t)0x00100000U)
    149          #define FALLING_EDGE          ((uint32_t)0x00200000U)
    150          #define GPIO_OUTPUT_TYPE      ((uint32_t)0x00000010U)
    151          
    152          #define GPIO_NUMBER           ((uint32_t)16U)
    153          /**
    154            * @}
    155            */
    156          /* Private macro -------------------------------------------------------------*/
    157          /* Private variables ---------------------------------------------------------*/
    158          /* Private function prototypes -----------------------------------------------*/
    159          /* Private functions ---------------------------------------------------------*/
    160          /* Exported functions --------------------------------------------------------*/
    161          /** @defgroup GPIO_Exported_Functions GPIO Exported Functions
    162            * @{
    163            */
    164          
    165          /** @defgroup GPIO_Exported_Functions_Group1 Initialization and de-initialization functions
    166            *  @brief    Initialization and Configuration functions
    167            *
    168          @verbatim    
    169           ===============================================================================
    170                        ##### Initialization and de-initialization functions #####
    171           ===============================================================================
    172            [..]
    173              This section provides functions allowing to initialize and de-initialize the GPIOs
    174              to be ready for use.
    175           
    176          @endverbatim
    177            * @{
    178            */
    179          
    180          
    181          /**
    182            * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.
    183            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    184            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    185            * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
    186            *         the configuration information for the specified GPIO peripheral.
    187            * @retval None
    188            */

   \                                 In section .text, align 2, keep-with-next
    189          void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
    190          {
   \                     HAL_GPIO_Init: (+1)
   \   00000000   0xB4F8             PUSH     {R3-R7}
    191            uint32_t position;
    192            uint32_t ioposition = 0x00U;
    193            uint32_t iocurrent = 0x00U;
    194            uint32_t temp = 0x00U;
    195          
    196            /* Check the parameters */
    197            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    198            assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    199            assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    200            assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    201          
    202            /* Configure the port pins */
    203            for(position = 0U; position < GPIO_NUMBER; position++)
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xE025             B.N      ??HAL_GPIO_Init_0
    204            {
    205              /* Get the IO position */
    206              ioposition = ((uint32_t)0x01U) << position;
    207              /* Get the current IO position */
    208              iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
    209          
    210              if(iocurrent == ioposition)
    211              {
    212                /*--------------------- GPIO Mode Configuration ------------------------*/
    213                /* In case of Alternate function mode selection */
    214                if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
    215                {
    216                  /* Check the Alternate function parameter */
    217                  assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    218                  /* Configure Alternate function mapped with the current IO */
    219                  temp = GPIOx->AFR[position >> 3U];
    220                  temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
    221                  temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
    222                  GPIOx->AFR[position >> 3U] = temp;
    223                }
    224          
    225                /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
    226                temp = GPIOx->MODER;
    227                temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
    228                temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    229                GPIOx->MODER = temp;
    230          
    231                /* In case of Output or Alternate function mode selection */
    232                if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
    233                   (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
    234                {
    235                  /* Check the Speed parameter */
    236                  assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    237                  /* Configure the IO Speed */
    238                  temp = GPIOx->OSPEEDR; 
    239                  temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
    240                  temp |= (GPIO_Init->Speed << (position * 2U));
    241                  GPIOx->OSPEEDR = temp;
    242          
    243                  /* Configure the IO Output Type */
    244                  temp = GPIOx->OTYPER;
    245                  temp &= ~(GPIO_OTYPER_OT_0 << position) ;
    246                  temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
    247                  GPIOx->OTYPER = temp;
    248                }
    249          
    250                /* Activate the Pull-up or Pull down resistor for the current IO */
    251                temp = GPIOx->PUPDR;
    252                temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
    253                temp |= ((GPIO_Init->Pull) << (position * 2U));
    254                GPIOx->PUPDR = temp;
    255          
    256                /*--------------------- EXTI Mode Configuration ------------------------*/
    257                /* Configure the External Interrupt or event for the current IO */
    258                if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
    259                {
    260                  /* Enable SYSCFG Clock */
    261                  __HAL_RCC_SYSCFG_CLK_ENABLE();
    262          
    263                  temp = SYSCFG->EXTICR[position >> 2U];
    264                  temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
    265                  temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
   \                     ??HAL_GPIO_Init_1: (+1)
   \   00000006   0xF04F 0x0C08      MOV      R12,#+8
   \                     ??HAL_GPIO_Init_2: (+1)
   \   0000000A   0xFA0C 0xF606      LSL      R6,R12,R6
   \   0000000E   0x433E             ORRS     R6,R6,R7
    266                  SYSCFG->EXTICR[position >> 2U] = temp;
   \   00000010   0xF845 0x6024      STR      R6,[R5, R4, LSL #+2]
    267          
    268                  /* Clear EXTI line configuration */
    269                  temp = EXTI->IMR;
   \   00000014   0x....             LDR.N    R4,??DataTable2  ;; 0x40013c00
   \   00000016   0x6826             LDR      R6,[R4, #+0]
    270                  temp &= ~((uint32_t)iocurrent);
   \   00000018   0x43DD             MVNS     R5,R3
   \   0000001A   0x402E             ANDS     R6,R5,R6
    271                  if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
   \   0000001C   0x684F             LDR      R7,[R1, #+4]
   \   0000001E   0x03FF             LSLS     R7,R7,#+15
   \   00000020   0xD500             BPL.N    ??HAL_GPIO_Init_3
    272                  {
    273                    temp |= iocurrent;
   \   00000022   0x431E             ORRS     R6,R3,R6
    274                  }
    275                  EXTI->IMR = temp;
   \                     ??HAL_GPIO_Init_3: (+1)
   \   00000024   0x6026             STR      R6,[R4, #+0]
    276          
    277                  temp = EXTI->EMR;
   \   00000026   0x6866             LDR      R6,[R4, #+4]
    278                  temp &= ~((uint32_t)iocurrent);
   \   00000028   0x402E             ANDS     R6,R5,R6
    279                  if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
   \   0000002A   0x684F             LDR      R7,[R1, #+4]
   \   0000002C   0x03BF             LSLS     R7,R7,#+14
   \   0000002E   0xD500             BPL.N    ??HAL_GPIO_Init_4
    280                  {
    281                    temp |= iocurrent;
   \   00000030   0x431E             ORRS     R6,R3,R6
    282                  }
    283                  EXTI->EMR = temp;
   \                     ??HAL_GPIO_Init_4: (+1)
   \   00000032   0x6066             STR      R6,[R4, #+4]
    284          
    285                  /* Clear Rising Falling edge configuration */
    286                  temp = EXTI->RTSR;
   \   00000034   0x68A6             LDR      R6,[R4, #+8]
    287                  temp &= ~((uint32_t)iocurrent);
   \   00000036   0x402E             ANDS     R6,R5,R6
    288                  if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
   \   00000038   0x684F             LDR      R7,[R1, #+4]
   \   0000003A   0x02FF             LSLS     R7,R7,#+11
   \   0000003C   0xD500             BPL.N    ??HAL_GPIO_Init_5
    289                  {
    290                    temp |= iocurrent;
   \   0000003E   0x431E             ORRS     R6,R3,R6
    291                  }
    292                  EXTI->RTSR = temp;
   \                     ??HAL_GPIO_Init_5: (+1)
   \   00000040   0x60A6             STR      R6,[R4, #+8]
    293          
    294                  temp = EXTI->FTSR;
   \   00000042   0x68E6             LDR      R6,[R4, #+12]
    295                  temp &= ~((uint32_t)iocurrent);
   \   00000044   0x4035             ANDS     R5,R5,R6
    296                  if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
   \   00000046   0x684E             LDR      R6,[R1, #+4]
   \   00000048   0x02B6             LSLS     R6,R6,#+10
   \   0000004A   0xD500             BPL.N    ??HAL_GPIO_Init_6
    297                  {
    298                    temp |= iocurrent;
   \   0000004C   0x431D             ORRS     R5,R3,R5
    299                  }
    300                  EXTI->FTSR = temp;
   \                     ??HAL_GPIO_Init_6: (+1)
   \   0000004E   0x60E5             STR      R5,[R4, #+12]
   \                     ??HAL_GPIO_Init_7: (+1)
   \   00000050   0x1C52             ADDS     R2,R2,#+1
   \                     ??HAL_GPIO_Init_0: (+1)
   \   00000052   0x2A10             CMP      R2,#+16
   \   00000054   0xF080 0x80A5      BCS.W    ??HAL_GPIO_Init_8
   \   00000058   0x2301             MOVS     R3,#+1
   \   0000005A   0xFA03 0xF402      LSL      R4,R3,R2
   \   0000005E   0x680B             LDR      R3,[R1, #+0]
   \   00000060   0x4023             ANDS     R3,R4,R3
   \   00000062   0x42A3             CMP      R3,R4
   \   00000064   0xD1F4             BNE.N    ??HAL_GPIO_Init_7
   \   00000066   0x684D             LDR      R5,[R1, #+4]
   \   00000068   0x2D02             CMP      R5,#+2
   \   0000006A   0xD001             BEQ.N    ??HAL_GPIO_Init_9
   \   0000006C   0x2D12             CMP      R5,#+18
   \   0000006E   0xD112             BNE.N    ??HAL_GPIO_Init_10
   \                     ??HAL_GPIO_Init_9: (+1)
   \   00000070   0x08D5             LSRS     R5,R2,#+3
   \   00000072   0xEB00 0x0685      ADD      R6,R0,R5, LSL #+2
   \   00000076   0x6A35             LDR      R5,[R6, #+32]
   \   00000078   0xF002 0x0707      AND      R7,R2,#0x7
   \   0000007C   0x00BF             LSLS     R7,R7,#+2
   \   0000007E   0xF04F 0x0C0F      MOV      R12,#+15
   \   00000082   0xFA0C 0xFC07      LSL      R12,R12,R7
   \   00000086   0xEA25 0x050C      BIC      R5,R5,R12
   \   0000008A   0xF8D1 0xC010      LDR      R12,[R1, #+16]
   \   0000008E   0xFA0C 0xF707      LSL      R7,R12,R7
   \   00000092   0x433D             ORRS     R5,R7,R5
   \   00000094   0x6235             STR      R5,[R6, #+32]
   \                     ??HAL_GPIO_Init_10: (+1)
   \   00000096   0x6805             LDR      R5,[R0, #+0]
   \   00000098   0x0056             LSLS     R6,R2,#+1
   \   0000009A   0x2703             MOVS     R7,#+3
   \   0000009C   0x40B7             LSLS     R7,R7,R6
   \   0000009E   0x43FF             MVNS     R7,R7
   \   000000A0   0x403D             ANDS     R5,R7,R5
   \   000000A2   0xF891 0xC004      LDRB     R12,[R1, #+4]
   \   000000A6   0xF00C 0x0C03      AND      R12,R12,#0x3
   \   000000AA   0xFA0C 0xFC06      LSL      R12,R12,R6
   \   000000AE   0xEA4C 0x0505      ORR      R5,R12,R5
   \   000000B2   0x6005             STR      R5,[R0, #+0]
   \   000000B4   0x684D             LDR      R5,[R1, #+4]
   \   000000B6   0x2D01             CMP      R5,#+1
   \   000000B8   0xD005             BEQ.N    ??HAL_GPIO_Init_11
   \   000000BA   0x2D02             CMP      R5,#+2
   \   000000BC   0xD003             BEQ.N    ??HAL_GPIO_Init_11
   \   000000BE   0x2D11             CMP      R5,#+17
   \   000000C0   0xD001             BEQ.N    ??HAL_GPIO_Init_11
   \   000000C2   0x2D12             CMP      R5,#+18
   \   000000C4   0xD111             BNE.N    ??HAL_GPIO_Init_12
   \                     ??HAL_GPIO_Init_11: (+1)
   \   000000C6   0x6885             LDR      R5,[R0, #+8]
   \   000000C8   0x403D             ANDS     R5,R7,R5
   \   000000CA   0xF8D1 0xC00C      LDR      R12,[R1, #+12]
   \   000000CE   0xFA0C 0xFC06      LSL      R12,R12,R6
   \   000000D2   0xEA4C 0x0505      ORR      R5,R12,R5
   \   000000D6   0x6085             STR      R5,[R0, #+8]
   \   000000D8   0x6845             LDR      R5,[R0, #+4]
   \   000000DA   0xEA25 0x0404      BIC      R4,R5,R4
   \   000000DE   0x684D             LDR      R5,[R1, #+4]
   \   000000E0   0xF3C5 0x1500      UBFX     R5,R5,#+4,#+1
   \   000000E4   0x4095             LSLS     R5,R5,R2
   \   000000E6   0x432C             ORRS     R4,R5,R4
   \   000000E8   0x6044             STR      R4,[R0, #+4]
   \                     ??HAL_GPIO_Init_12: (+1)
   \   000000EA   0x68C5             LDR      R5,[R0, #+12]
   \   000000EC   0xEA07 0x0405      AND      R4,R7,R5
   \   000000F0   0x688D             LDR      R5,[R1, #+8]
   \   000000F2   0x40B5             LSLS     R5,R5,R6
   \   000000F4   0x432C             ORRS     R4,R5,R4
   \   000000F6   0x60C4             STR      R4,[R0, #+12]
   \   000000F8   0x684C             LDR      R4,[R1, #+4]
   \   000000FA   0x00E4             LSLS     R4,R4,#+3
   \   000000FC   0xD5A8             BPL.N    ??HAL_GPIO_Init_7
   \   000000FE   0x2400             MOVS     R4,#+0
   \   00000100   0x9400             STR      R4,[SP, #+0]
   \   00000102   0x....             LDR.N    R4,??DataTable2_1  ;; 0x40023844
   \   00000104   0x6825             LDR      R5,[R4, #+0]
   \   00000106   0xF445 0x4580      ORR      R5,R5,#0x4000
   \   0000010A   0x6025             STR      R5,[R4, #+0]
   \   0000010C   0x6824             LDR      R4,[R4, #+0]
   \   0000010E   0xF404 0x4480      AND      R4,R4,#0x4000
   \   00000112   0x9400             STR      R4,[SP, #+0]
   \   00000114   0x9C00             LDR      R4,[SP, #+0]
   \   00000116   0x0894             LSRS     R4,R2,#+2
   \   00000118   0x....             LDR.N    R5,??DataTable2_2  ;; 0x40013808
   \   0000011A   0xF855 0x7024      LDR      R7,[R5, R4, LSL #+2]
   \   0000011E   0xF002 0x0603      AND      R6,R2,#0x3
   \   00000122   0x00B6             LSLS     R6,R6,#+2
   \   00000124   0xF04F 0x0C0F      MOV      R12,#+15
   \   00000128   0xFA0C 0xFC06      LSL      R12,R12,R6
   \   0000012C   0xEA27 0x070C      BIC      R7,R7,R12
   \   00000130   0x.... 0x....      LDR.W    R12,??DataTable2_3  ;; 0x40020000
   \   00000134   0x4560             CMP      R0,R12
   \   00000136   0xD102             BNE.N    ??HAL_GPIO_Init_13
   \   00000138   0xF04F 0x0C00      MOV      R12,#+0
   \   0000013C   0xE765             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_13: (+1)
   \   0000013E   0x.... 0x....      LDR.W    R12,??DataTable2_4  ;; 0x40020400
   \   00000142   0x4560             CMP      R0,R12
   \   00000144   0xD102             BNE.N    ??HAL_GPIO_Init_14
   \   00000146   0xF04F 0x0C01      MOV      R12,#+1
   \   0000014A   0xE75E             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_14: (+1)
   \   0000014C   0x.... 0x....      LDR.W    R12,??DataTable2_5  ;; 0x40020800
   \   00000150   0x4560             CMP      R0,R12
   \   00000152   0xD102             BNE.N    ??HAL_GPIO_Init_15
   \   00000154   0xF04F 0x0C02      MOV      R12,#+2
   \   00000158   0xE757             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_15: (+1)
   \   0000015A   0x.... 0x....      LDR.W    R12,??DataTable2_6  ;; 0x40020c00
   \   0000015E   0x4560             CMP      R0,R12
   \   00000160   0xD102             BNE.N    ??HAL_GPIO_Init_16
   \   00000162   0xF04F 0x0C03      MOV      R12,#+3
   \   00000166   0xE750             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_16: (+1)
   \   00000168   0x.... 0x....      LDR.W    R12,??DataTable2_7  ;; 0x40021000
   \   0000016C   0x4560             CMP      R0,R12
   \   0000016E   0xD102             BNE.N    ??HAL_GPIO_Init_17
   \   00000170   0xF04F 0x0C04      MOV      R12,#+4
   \   00000174   0xE749             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_17: (+1)
   \   00000176   0x.... 0x....      LDR.W    R12,??DataTable2_8  ;; 0x40021400
   \   0000017A   0x4560             CMP      R0,R12
   \   0000017C   0xD102             BNE.N    ??HAL_GPIO_Init_18
   \   0000017E   0xF04F 0x0C05      MOV      R12,#+5
   \   00000182   0xE742             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_18: (+1)
   \   00000184   0x.... 0x....      LDR.W    R12,??DataTable2_9  ;; 0x40021800
   \   00000188   0x4560             CMP      R0,R12
   \   0000018A   0xD102             BNE.N    ??HAL_GPIO_Init_19
   \   0000018C   0xF04F 0x0C06      MOV      R12,#+6
   \   00000190   0xE73B             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_19: (+1)
   \   00000192   0x.... 0x....      LDR.W    R12,??DataTable2_10  ;; 0x40021c00
   \   00000196   0x4560             CMP      R0,R12
   \   00000198   0xF47F 0xAF35      BNE.W    ??HAL_GPIO_Init_1
   \   0000019C   0xF04F 0x0C07      MOV      R12,#+7
   \   000001A0   0xE733             B.N      ??HAL_GPIO_Init_2
    301                }
    302              }
    303            }
    304          }
   \                     ??HAL_GPIO_Init_8: (+1)
   \   000001A2   0xBCF1             POP      {R0,R4-R7}
   \   000001A4   0x4770             BX       LR               ;; return
    305          
    306          /**
    307            * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
    308            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    309            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    310            * @param  GPIO_Pin: specifies the port bit to be written.
    311            *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
    312            * @retval None
    313            */

   \                                 In section .text, align 2, keep-with-next
    314          void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
    315          {
   \                     HAL_GPIO_DeInit: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    316            uint32_t position;
    317            uint32_t ioposition = 0x00U;
    318            uint32_t iocurrent = 0x00U;
    319            uint32_t tmp = 0x00U;
    320          
    321            /* Check the parameters */
    322            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    323            
    324            /* Configure the port pins */
    325            for(position = 0U; position < GPIO_NUMBER; position++)
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xE01A             B.N      ??HAL_GPIO_DeInit_0
    326            {
    327              /* Get the IO position */
    328              ioposition = ((uint32_t)0x01U) << position;
    329              /* Get the current IO position */
    330              iocurrent = (GPIO_Pin) & ioposition;
    331          
    332              if(iocurrent == ioposition)
    333              {
    334                /*------------------------- GPIO Mode Configuration --------------------*/
    335                /* Configure IO Direction in Input Floating Mode */
    336                GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));
    337          
    338                /* Configure the default Alternate Function in current IO */
    339                GPIOx->AFR[position >> 3U] &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
    340          
    341                /* Configure the default value for IO Speed */
    342                GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
    343          
    344                /* Configure the default value IO Output Type */
    345                GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
    346          
    347                /* Deactivate the Pull-up and Pull-down resistor for the current IO */
    348                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
    349          
    350                /*------------------------- EXTI Mode Configuration --------------------*/
    351                tmp = SYSCFG->EXTICR[position >> 2U];
    352                tmp &= (((uint32_t)0x0FU) << (4U * (position & 0x03U)));
    353                if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
   \                     ??HAL_GPIO_DeInit_1: (+1)
   \   00000006   0xF04F 0x0E08      MOV      LR,#+8
   \                     ??HAL_GPIO_DeInit_2: (+1)
   \   0000000A   0xFA0E 0xF707      LSL      R7,LR,R7
   \   0000000E   0x45BC             CMP      R12,R7
   \   00000010   0xD113             BNE.N    ??HAL_GPIO_DeInit_3
    354                {
    355                  /* Configure the External Interrupt or event for the current IO */
    356                  tmp = ((uint32_t)0x0FU) << (4U * (position & 0x03U));
    357                  SYSCFG->EXTICR[position >> 2U] &= ~tmp;
   \   00000012   0xF854 0x7025      LDR      R7,[R4, R5, LSL #+2]
   \   00000016   0xEA27 0x0606      BIC      R6,R7,R6
   \   0000001A   0xF844 0x6025      STR      R6,[R4, R5, LSL #+2]
    358          
    359                  /* Clear EXTI line configuration */
    360                  EXTI->IMR &= ~((uint32_t)iocurrent);
   \   0000001E   0x43DB             MVNS     R3,R3
   \   00000020   0x....             LDR.N    R4,??DataTable2  ;; 0x40013c00
   \   00000022   0x6825             LDR      R5,[R4, #+0]
   \   00000024   0x401D             ANDS     R5,R3,R5
   \   00000026   0x6025             STR      R5,[R4, #+0]
    361                  EXTI->EMR &= ~((uint32_t)iocurrent);
   \   00000028   0x6865             LDR      R5,[R4, #+4]
   \   0000002A   0x401D             ANDS     R5,R3,R5
   \   0000002C   0x6065             STR      R5,[R4, #+4]
    362                  
    363                  /* Clear Rising Falling edge configuration */
    364                  EXTI->RTSR &= ~((uint32_t)iocurrent);
   \   0000002E   0x68A5             LDR      R5,[R4, #+8]
   \   00000030   0x401D             ANDS     R5,R3,R5
   \   00000032   0x60A5             STR      R5,[R4, #+8]
    365                  EXTI->FTSR &= ~((uint32_t)iocurrent);
   \   00000034   0x68E5             LDR      R5,[R4, #+12]
   \   00000036   0x402B             ANDS     R3,R3,R5
   \   00000038   0x60E3             STR      R3,[R4, #+12]
    366                }
   \                     ??HAL_GPIO_DeInit_3: (+1)
   \   0000003A   0x1C52             ADDS     R2,R2,#+1
   \                     ??HAL_GPIO_DeInit_0: (+1)
   \   0000003C   0x2A10             CMP      R2,#+16
   \   0000003E   0xD26A             BCS.N    ??HAL_GPIO_DeInit_4
   \   00000040   0x2301             MOVS     R3,#+1
   \   00000042   0xFA03 0xF402      LSL      R4,R3,R2
   \   00000046   0xEA04 0x0301      AND      R3,R4,R1
   \   0000004A   0x42A3             CMP      R3,R4
   \   0000004C   0xD1F5             BNE.N    ??HAL_GPIO_DeInit_3
   \   0000004E   0x2503             MOVS     R5,#+3
   \   00000050   0x0056             LSLS     R6,R2,#+1
   \   00000052   0x40B5             LSLS     R5,R5,R6
   \   00000054   0x43ED             MVNS     R5,R5
   \   00000056   0x6806             LDR      R6,[R0, #+0]
   \   00000058   0x402E             ANDS     R6,R5,R6
   \   0000005A   0x6006             STR      R6,[R0, #+0]
   \   0000005C   0x08D6             LSRS     R6,R2,#+3
   \   0000005E   0xEB00 0x0786      ADD      R7,R0,R6, LSL #+2
   \   00000062   0x260F             MOVS     R6,#+15
   \   00000064   0xF8D7 0xC020      LDR      R12,[R7, #+32]
   \   00000068   0xF002 0x0E07      AND      LR,R2,#0x7
   \   0000006C   0xEA4F 0x0E8E      LSL      LR,LR,#+2
   \   00000070   0xFA06 0xFE0E      LSL      LR,R6,LR
   \   00000074   0xEA2C 0x0C0E      BIC      R12,R12,LR
   \   00000078   0xF8C7 0xC020      STR      R12,[R7, #+32]
   \   0000007C   0x6887             LDR      R7,[R0, #+8]
   \   0000007E   0x402F             ANDS     R7,R5,R7
   \   00000080   0x6087             STR      R7,[R0, #+8]
   \   00000082   0x6847             LDR      R7,[R0, #+4]
   \   00000084   0xEA27 0x0404      BIC      R4,R7,R4
   \   00000088   0x6044             STR      R4,[R0, #+4]
   \   0000008A   0x68C4             LDR      R4,[R0, #+12]
   \   0000008C   0x402C             ANDS     R4,R5,R4
   \   0000008E   0x60C4             STR      R4,[R0, #+12]
   \   00000090   0x0895             LSRS     R5,R2,#+2
   \   00000092   0x....             LDR.N    R4,??DataTable2_2  ;; 0x40013808
   \   00000094   0xF854 0xC025      LDR      R12,[R4, R5, LSL #+2]
   \   00000098   0xF002 0x0703      AND      R7,R2,#0x3
   \   0000009C   0x00BF             LSLS     R7,R7,#+2
   \   0000009E   0x40BE             LSLS     R6,R6,R7
   \   000000A0   0xEA06 0x0C0C      AND      R12,R6,R12
   \   000000A4   0x.... 0x....      LDR.W    LR,??DataTable2_3  ;; 0x40020000
   \   000000A8   0x4570             CMP      R0,LR
   \   000000AA   0xD102             BNE.N    ??HAL_GPIO_DeInit_5
   \   000000AC   0xF04F 0x0E00      MOV      LR,#+0
   \   000000B0   0xE7AB             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_5: (+1)
   \   000000B2   0x.... 0x....      LDR.W    LR,??DataTable2_4  ;; 0x40020400
   \   000000B6   0x4570             CMP      R0,LR
   \   000000B8   0xD102             BNE.N    ??HAL_GPIO_DeInit_6
   \   000000BA   0xF04F 0x0E01      MOV      LR,#+1
   \   000000BE   0xE7A4             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_6: (+1)
   \   000000C0   0x.... 0x....      LDR.W    LR,??DataTable2_5  ;; 0x40020800
   \   000000C4   0x4570             CMP      R0,LR
   \   000000C6   0xD102             BNE.N    ??HAL_GPIO_DeInit_7
   \   000000C8   0xF04F 0x0E02      MOV      LR,#+2
   \   000000CC   0xE79D             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_7: (+1)
   \   000000CE   0x.... 0x....      LDR.W    LR,??DataTable2_6  ;; 0x40020c00
   \   000000D2   0x4570             CMP      R0,LR
   \   000000D4   0xD102             BNE.N    ??HAL_GPIO_DeInit_8
   \   000000D6   0xF04F 0x0E03      MOV      LR,#+3
   \   000000DA   0xE796             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_8: (+1)
   \   000000DC   0x.... 0x....      LDR.W    LR,??DataTable2_7  ;; 0x40021000
   \   000000E0   0x4570             CMP      R0,LR
   \   000000E2   0xD102             BNE.N    ??HAL_GPIO_DeInit_9
   \   000000E4   0xF04F 0x0E04      MOV      LR,#+4
   \   000000E8   0xE78F             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_9: (+1)
   \   000000EA   0x.... 0x....      LDR.W    LR,??DataTable2_8  ;; 0x40021400
   \   000000EE   0x4570             CMP      R0,LR
   \   000000F0   0xD102             BNE.N    ??HAL_GPIO_DeInit_10
   \   000000F2   0xF04F 0x0E05      MOV      LR,#+5
   \   000000F6   0xE788             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_10: (+1)
   \   000000F8   0x.... 0x....      LDR.W    LR,??DataTable2_9  ;; 0x40021800
   \   000000FC   0x4570             CMP      R0,LR
   \   000000FE   0xD102             BNE.N    ??HAL_GPIO_DeInit_11
   \   00000100   0xF04F 0x0E06      MOV      LR,#+6
   \   00000104   0xE781             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_11: (+1)
   \   00000106   0x.... 0x....      LDR.W    LR,??DataTable2_10  ;; 0x40021c00
   \   0000010A   0x4570             CMP      R0,LR
   \   0000010C   0xF47F 0xAF7B      BNE.W    ??HAL_GPIO_DeInit_1
   \   00000110   0xF04F 0x0E07      MOV      LR,#+7
   \   00000114   0xE779             B.N      ??HAL_GPIO_DeInit_2
    367              }
    368            }
    369          }
   \                     ??HAL_GPIO_DeInit_4: (+1)
   \   00000116   0xBDF0             POP      {R4-R7,PC}       ;; return
    370          
    371          /**
    372            * @}
    373            */
    374          
    375          /** @defgroup GPIO_Exported_Functions_Group2 IO operation functions 
    376            *  @brief   GPIO Read and Write
    377            *
    378          @verbatim
    379           ===============================================================================
    380                                 ##### IO operation functions #####
    381           ===============================================================================
    382          
    383          @endverbatim
    384            * @{
    385            */
    386          
    387          /**
    388            * @brief  Reads the specified input port pin.
    389            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    390            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    391            * @param  GPIO_Pin: specifies the port bit to read.
    392            *         This parameter can be GPIO_PIN_x where x can be (0..15).
    393            * @retval The input port pin value.
    394            */

   \                                 In section .text, align 2, keep-with-next
    395          GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    396          {
    397            GPIO_PinState bitstatus;
    398          
    399            /* Check the parameters */
    400            assert_param(IS_GPIO_PIN(GPIO_Pin));
    401          
    402            if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
   \                     HAL_GPIO_ReadPin: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x4008             ANDS     R0,R1,R0
   \   00000004   0x1E40             SUBS     R0,R0,#+1
   \   00000006   0x4180             SBCS     R0,R0,R0
   \   00000008   0x43C0             MVNS     R0,R0
   \   0000000A   0x0FC0             LSRS     R0,R0,#+31
    403            {
    404              bitstatus = GPIO_PIN_SET;
    405            }
    406            else
    407            {
    408              bitstatus = GPIO_PIN_RESET;
    409            }
    410            return bitstatus;
   \   0000000C   0xB240             SXTB     R0,R0
   \   0000000E   0x4770             BX       LR               ;; return
    411          }
    412          
    413          /**
    414            * @brief  Sets or clears the selected data port bit.
    415            *
    416            * @note   This function uses GPIOx_BSRR register to allow atomic read/modify
    417            *         accesses. In this way, there is no risk of an IRQ occurring between
    418            *         the read and the modify access.
    419            *
    420            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    421            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    422            * @param  GPIO_Pin: specifies the port bit to be written.
    423            *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
    424            * @param  PinState: specifies the value to be written to the selected bit.
    425            *          This parameter can be one of the GPIO_PinState enum values:
    426            *            @arg GPIO_PIN_RESET: to clear the port pin
    427            *            @arg GPIO_PIN_SET: to set the port pin
    428            * @retval None
    429            */

   \                                 In section .text, align 2, keep-with-next
    430          void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
    431          {
    432            /* Check the parameters */
    433            assert_param(IS_GPIO_PIN(GPIO_Pin));
    434            assert_param(IS_GPIO_PIN_ACTION(PinState));
    435          
    436            if(PinState != GPIO_PIN_RESET)
   \                     HAL_GPIO_WritePin: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0xD001             BEQ.N    ??HAL_GPIO_WritePin_0
    437            {
    438              GPIOx->BSRR = GPIO_Pin;
   \   00000004   0x6181             STR      R1,[R0, #+24]
   \   00000006   0x4770             BX       LR
    439            }
    440            else
    441            {
    442              GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
   \                     ??HAL_GPIO_WritePin_0: (+1)
   \   00000008   0x0409             LSLS     R1,R1,#+16
   \   0000000A   0x6181             STR      R1,[R0, #+24]
    443            }
    444          }
   \   0000000C   0x4770             BX       LR               ;; return
    445          
    446          /**
    447            * @brief  Toggles the specified GPIO pins.
    448            * @param  GPIOx: Where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    449            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    450            * @param  GPIO_Pin: Specifies the pins to be toggled.
    451            * @retval None
    452            */

   \                                 In section .text, align 2, keep-with-next
    453          void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    454          {
    455            /* Check the parameters */
    456            assert_param(IS_GPIO_PIN(GPIO_Pin));
    457          
    458            GPIOx->ODR ^= GPIO_Pin;
   \                     HAL_GPIO_TogglePin: (+1)
   \   00000000   0x6942             LDR      R2,[R0, #+20]
   \   00000002   0x4051             EORS     R1,R1,R2
   \   00000004   0x6141             STR      R1,[R0, #+20]
    459          }
   \   00000006   0x4770             BX       LR               ;; return
    460          
    461          /**
    462            * @brief  Locks GPIO Pins configuration registers.
    463            * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    464            *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    465            * @note   The configuration of the locked GPIO pins can no longer be modified
    466            *         until the next reset.
    467            * @param  GPIOx: where x can be (A..F) to select the GPIO peripheral for STM32F4 family
    468            * @param  GPIO_Pin: specifies the port bit to be locked.
    469            *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
    470            * @retval None
    471            */

   \                                 In section .text, align 2, keep-with-next
    472          HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    473          {
   \                     HAL_GPIO_LockPin: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    474            __IO uint32_t tmp = GPIO_LCKR_LCKK;
   \   00000002   0xF44F 0x3280      MOV      R2,#+65536
   \   00000006   0x9200             STR      R2,[SP, #+0]
    475          
    476            /* Check the parameters */
    477            assert_param(IS_GPIO_PIN(GPIO_Pin));
    478          
    479            /* Apply lock key write sequence */
    480            tmp |= GPIO_Pin;
   \   00000008   0x9A00             LDR      R2,[SP, #+0]
   \   0000000A   0x430A             ORRS     R2,R1,R2
   \   0000000C   0x9200             STR      R2,[SP, #+0]
    481            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    482            GPIOx->LCKR = tmp;
   \   0000000E   0x9A00             LDR      R2,[SP, #+0]
   \   00000010   0x61C2             STR      R2,[R0, #+28]
    483            /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
    484            GPIOx->LCKR = GPIO_Pin;
   \   00000012   0x61C1             STR      R1,[R0, #+28]
    485            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    486            GPIOx->LCKR = tmp;
   \   00000014   0x9900             LDR      R1,[SP, #+0]
   \   00000016   0x61C1             STR      R1,[R0, #+28]
    487            /* Read LCKK bit*/
    488            tmp = GPIOx->LCKR;
   \   00000018   0x69C1             LDR      R1,[R0, #+28]
   \   0000001A   0x9100             STR      R1,[SP, #+0]
    489          
    490           if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
   \   0000001C   0x69C0             LDR      R0,[R0, #+28]
   \   0000001E   0x03C0             LSLS     R0,R0,#+15
   \   00000020   0xD501             BPL.N    ??HAL_GPIO_LockPin_0
    491            {
    492              return HAL_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE000             B.N      ??HAL_GPIO_LockPin_1
    493            }
    494            else
    495            {
    496              return HAL_ERROR;
   \                     ??HAL_GPIO_LockPin_0: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \                     ??HAL_GPIO_LockPin_1: (+1)
   \   00000028   0xB001             ADD      SP,SP,#+4
   \   0000002A   0x4770             BX       LR               ;; return
    497            }
    498          }
    499          
    500          /**
    501            * @brief  This function handles EXTI interrupt request.
    502            * @param  GPIO_Pin: Specifies the pins connected EXTI line
    503            * @retval None
    504            */

   \                                 In section .text, align 2, keep-with-next
    505          void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
    506          {
    507            /* EXTI line interrupt detected */
    508            if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
   \                     HAL_GPIO_EXTI_IRQHandler: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0x....             LDR.N    R2,??DataTable2_11  ;; 0x40013c14
   \   00000004   0x6813             LDR      R3,[R2, #+0]
   \   00000006   0x420B             TST      R3,R1
   \   00000008   0xD100             BNE.N    ??HAL_GPIO_EXTI_IRQHandler_0
   \   0000000A   0x4770             BX       LR
    509            {
    510              __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
   \                     ??HAL_GPIO_EXTI_IRQHandler_0: (+1)
   \   0000000C   0xB580             PUSH     {R7,LR}
   \   0000000E   0x6011             STR      R1,[R2, #+0]
    511              HAL_GPIO_EXTI_Callback(GPIO_Pin);
   \   00000010   0x.... 0x....      BL       HAL_GPIO_EXTI_Callback
    512            }
    513          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    514          
    515          /**
    516            * @brief  EXTI line detection callbacks.
    517            * @param  GPIO_Pin: Specifies the pins connected EXTI line
    518            * @retval None
    519            */

   \                                 In section .text, align 2, keep-with-next
    520          __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
    521          {
    522            /* Prevent unused argument(s) compilation warning */
    523            UNUSED(GPIO_Pin);
    524            /* NOTE: This function Should not be modified, when the callback is needed,
    525                     the HAL_GPIO_EXTI_Callback could be implemented in the user file
    526             */
    527          }
   \                     HAL_GPIO_EXTI_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40013C00         DC32     0x40013c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x40013808         DC32     0x40013808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \   00000000   0x40013C14         DC32     0x40013c14
    528          
    529          /**
    530            * @}
    531            */
    532          
    533          
    534          /**
    535            * @}
    536            */
    537          
    538          #endif /* HAL_GPIO_MODULE_ENABLED */
    539          /**
    540            * @}
    541            */
    542          
    543          /**
    544            * @}
    545            */
    546          
    547          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      20   HAL_GPIO_DeInit
       0   HAL_GPIO_EXTI_Callback
       8   HAL_GPIO_EXTI_IRQHandler
         8   -> HAL_GPIO_EXTI_Callback
      20   HAL_GPIO_Init
       4   HAL_GPIO_LockPin
       0   HAL_GPIO_ReadPin
       0   HAL_GPIO_TogglePin
       0   HAL_GPIO_WritePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     280  HAL_GPIO_DeInit
       2  HAL_GPIO_EXTI_Callback
      22  HAL_GPIO_EXTI_IRQHandler
     422  HAL_GPIO_Init
      44  HAL_GPIO_LockPin
      16  HAL_GPIO_ReadPin
       8  HAL_GPIO_TogglePin
      14  HAL_GPIO_WritePin

 
 856 bytes in section .text
 
 856 bytes of CODE memory

Errors: none
Warnings: none
