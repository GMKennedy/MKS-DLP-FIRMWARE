###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:14:32
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\FatFs\src\diskio.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\FatFs\src\diskio.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\diskio.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\diskio.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\FatFs\src\diskio.c
      1          /*-----------------------------------------------------------------------*/
      2          /* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2014        */
      3          /*                                                                       */
      4          /*   Portions COPYRIGHT 2015 STMicroelectronics                          */
      5          /*   Portions Copyright (C) 2014, ChaN, all right reserved               */
      6          /*-----------------------------------------------------------------------*/
      7          /* If a working storage control module is available, it should be        */
      8          /* attached to the FatFs via a glue function rather than modifying it.   */
      9          /* This is an example of glue functions to attach various exsisting      */
     10          /* storage control modules to the FatFs module with a defined API.       */
     11          /*-----------------------------------------------------------------------*/
     12          
     13          /**
     14            ******************************************************************************
     15            * @file    diskio.c 
     16            * @author  MCD Application Team
     17            * @version V1.3.0
     18            * @date    08-May-2015
     19            * @brief   FatFs low level disk I/O module.
     20            ******************************************************************************
     21            * @attention
     22            *
     23            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     24            * You may not use this file except in compliance with the License.
     25            * You may obtain a copy of the License at:
     26            *
     27            *        http://www.st.com/software_license_agreement_liberty_v2
     28            *
     29            * Unless required by applicable law or agreed to in writing, software 
     30            * distributed under the License is distributed on an "AS IS" BASIS, 
     31            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     32            * See the License for the specific language governing permissions and
     33            * limitations under the License.
     34            *
     35            ******************************************************************************
     36            */
     37          
     38          /* Includes ------------------------------------------------------------------*/
     39          #include "diskio.h"
     40          #include "ff_gen_drv.h"
     41          
     42          /* Private typedef -----------------------------------------------------------*/
     43          /* Private define ------------------------------------------------------------*/
     44          /* Private variables ---------------------------------------------------------*/
     45          extern Disk_drvTypeDef  disk;
     46          
     47          /* Private function prototypes -----------------------------------------------*/
     48          /* Private functions ---------------------------------------------------------*/
     49          
     50          /**
     51            * @brief  Gets Disk Status 
     52            * @param  pdrv: Physical drive number (0..)
     53            * @retval DSTATUS: Operation status
     54            */

   \                                 In section .text, align 2, keep-with-next
     55          DSTATUS disk_status (
     56          	BYTE pdrv		/* Physical drive nmuber to identify the drive */
     57          )
     58          {
   \                     disk_status: (+1)
   \   00000000   0x4601             MOV      R1,R0
     59            DSTATUS stat;
     60            
     61            stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
     62            return stat;
   \   00000002   0x....             LDR.N    R2,??DataTable4
   \   00000004   0x1888             ADDS     R0,R1,R2
   \   00000006   0x7B00             LDRB     R0,[R0, #+12]
   \   00000008   0xEB02 0x0181      ADD      R1,R2,R1, LSL #+2
   \   0000000C   0x6849             LDR      R1,[R1, #+4]
   \   0000000E   0x6849             LDR      R1,[R1, #+4]
   \   00000010   0x4708             BX       R1
     63          }
     64          
     65          /**
     66            * @brief  Initializes a Drive
     67            * @param  pdrv: Physical drive number (0..)
     68            * @retval DSTATUS: Operation status
     69            */

   \                                 In section .text, align 2, keep-with-next
     70          DSTATUS disk_initialize (
     71          	BYTE pdrv				/* Physical drive nmuber to identify the drive */
     72          )
     73          {
   \                     disk_initialize: (+1)
   \   00000000   0x4601             MOV      R1,R0
     74            DSTATUS stat = RES_OK;
   \   00000002   0x2000             MOVS     R0,#+0
     75            
     76            if(disk.is_initialized[pdrv] == 0)
   \   00000004   0x....             LDR.N    R2,??DataTable4
   \   00000006   0x5C8B             LDRB     R3,[R1, R2]
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD108             BNE.N    ??disk_initialize_0
     77            { 
     78              disk.is_initialized[pdrv] = 1;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x5488             STRB     R0,[R1, R2]
     79              stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
   \   00000010   0x1888             ADDS     R0,R1,R2
   \   00000012   0x7B00             LDRB     R0,[R0, #+12]
   \   00000014   0xEB02 0x0181      ADD      R1,R2,R1, LSL #+2
   \   00000018   0x6849             LDR      R1,[R1, #+4]
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x4708             BX       R1
     80            }
     81            return stat;
   \                     ??disk_initialize_0: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
     82          }
     83          
     84          /**
     85            * @brief  Reads Sector(s) 
     86            * @param  pdrv: Physical drive number (0..)
     87            * @param  *buff: Data buffer to store read data
     88            * @param  sector: Sector address (LBA)
     89            * @param  count: Number of sectors to read (1..128)
     90            * @retval DRESULT: Operation result
     91            */

   \                                 In section .text, align 2, keep-with-next
     92          DRESULT disk_read (
     93          	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
     94          	BYTE *buff,		/* Data buffer to store read data */
     95          	DWORD sector,	        /* Sector address in LBA */
     96          	UINT count		/* Number of sectors to read */
     97          )
     98          {
   \                     disk_read: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
     99            DRESULT res;
    100           
    101            res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
    102            return res;
   \   00000004   0x....             LDR.N    R5,??DataTable4
   \   00000006   0x1960             ADDS     R0,R4,R5
   \   00000008   0x7B00             LDRB     R0,[R0, #+12]
   \   0000000A   0xEB05 0x0484      ADD      R4,R5,R4, LSL #+2
   \   0000000E   0x6864             LDR      R4,[R4, #+4]
   \   00000010   0x68A4             LDR      R4,[R4, #+8]
   \   00000012   0x47A0             BLX      R4
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    103          }
    104          
    105          /**
    106            * @brief  Writes Sector(s)  
    107            * @param  pdrv: Physical drive number (0..)
    108            * @param  *buff: Data to be written
    109            * @param  sector: Sector address (LBA)
    110            * @param  count: Number of sectors to write (1..128)
    111            * @retval DRESULT: Operation result
    112            */
    113          #if _USE_WRITE == 1

   \                                 In section .text, align 2, keep-with-next
    114          DRESULT disk_write (
    115          	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
    116          	const BYTE *buff,	/* Data to be written */
    117          	DWORD sector,		/* Sector address in LBA */
    118          	UINT count        	/* Number of sectors to write */
    119          )
    120          {
   \                     disk_write: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    121            DRESULT res;
    122            
    123            res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
    124            return res;
   \   00000004   0x....             LDR.N    R5,??DataTable4
   \   00000006   0x1960             ADDS     R0,R4,R5
   \   00000008   0x7B00             LDRB     R0,[R0, #+12]
   \   0000000A   0xEB05 0x0484      ADD      R4,R5,R4, LSL #+2
   \   0000000E   0x6864             LDR      R4,[R4, #+4]
   \   00000010   0x68E4             LDR      R4,[R4, #+12]
   \   00000012   0x47A0             BLX      R4
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    125          }
    126          #endif /* _USE_WRITE == 1 */
    127          
    128          /**
    129            * @brief  I/O control operation  
    130            * @param  pdrv: Physical drive number (0..)
    131            * @param  cmd: Control code
    132            * @param  *buff: Buffer to send/receive control data
    133            * @retval DRESULT: Operation result
    134            */
    135          #if _USE_IOCTL == 1

   \                                 In section .text, align 2, keep-with-next
    136          DRESULT disk_ioctl (
    137          	BYTE pdrv,		/* Physical drive nmuber (0..) */
    138          	BYTE cmd,		/* Control code */
    139          	void *buff		/* Buffer to send/receive control data */
    140          )
    141          {
   \                     disk_ioctl: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   \   00000002   0x4603             MOV      R3,R0
    142            DRESULT res;
    143          
    144            res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
    145            return res;
   \   00000004   0x....             LDR.N    R4,??DataTable4
   \   00000006   0x1918             ADDS     R0,R3,R4
   \   00000008   0x7B00             LDRB     R0,[R0, #+12]
   \   0000000A   0xEB04 0x0383      ADD      R3,R4,R3, LSL #+2
   \   0000000E   0x685B             LDR      R3,[R3, #+4]
   \   00000010   0x691B             LDR      R3,[R3, #+16]
   \   00000012   0xB001             ADD      SP,SP,#+4
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4718             BX       R3
    146          }
    147          #endif /* _USE_IOCTL == 1 */
    148          
    149          /**
    150            * @brief  Gets Time from RTC 
    151            * @param  None
    152            * @retval Time in DWORD
    153            */

   \                                 In section .text, align 2, keep-with-next
    154          __weak DWORD get_fattime (void)
    155          {
    156            return 0;
   \                     get_fattime: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    157          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     disk
    158          
    159          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    160          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   disk_initialize
         0   -- Indirect call
       8   disk_ioctl
         0   -- Indirect call
      16   disk_read
        16   -- Indirect call
       0   disk_status
         0   -- Indirect call
      16   disk_write
        16   -- Indirect call
       0   get_fattime


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
      32  disk_initialize
      24  disk_ioctl
      22  disk_read
      18  disk_status
      22  disk_write
       4  get_fattime

 
 126 bytes in section .text
 
 126 bytes of CODE memory

Errors: none
Warnings: none
