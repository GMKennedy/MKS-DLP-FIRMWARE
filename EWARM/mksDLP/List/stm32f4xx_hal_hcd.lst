###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:13
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_hcd.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_hcd.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\stm32f4xx_hal_hcd.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\stm32f4xx_hal_hcd.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_hcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_hcd.c
      4            * @author  MCD Application Team
      5            * @version V1.5.2
      6            * @date    22-September-2016
      7            * @brief   HCD HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the USB Peripheral Controller:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            *         
     15            @verbatim
     16            ==============================================================================
     17                              ##### How to use this driver #####
     18            ==============================================================================
     19            [..]
     20              (#)Declare a HCD_HandleTypeDef handle structure, for example:
     21                 HCD_HandleTypeDef  hhcd;
     22                  
     23              (#)Fill parameters of Init structure in HCD handle
     24            
     25              (#)Call HAL_HCD_Init() API to initialize the HCD peripheral (Core, Host core, ...) 
     26          
     27              (#)Initialize the HCD low level resources through the HAL_HCD_MspInit() API:
     28                  (##) Enable the HCD/USB Low Level interface clock using the following macros
     29                       (+++) __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
     30                       (+++) __HAL_RCC_USB_OTG_HS_CLK_ENABLE(); (For High Speed Mode)
     31                       (+++) __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE(); (For High Speed Mode)
     32                     
     33                  (##) Initialize the related GPIO clocks
     34                  (##) Configure HCD pin-out
     35                  (##) Configure HCD NVIC interrupt
     36              
     37              (#)Associate the Upper USB Host stack to the HAL HCD Driver:
     38                  (##) hhcd.pData = phost;
     39          
     40              (#)Enable HCD transmission and reception:
     41                  (##) HAL_HCD_Start();
     42          
     43            @endverbatim
     44            ******************************************************************************
     45            * @attention
     46            *
     47            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     48            *
     49            * Redistribution and use in source and binary forms, with or without modification,
     50            * are permitted provided that the following conditions are met:
     51            *   1. Redistributions of source code must retain the above copyright notice,
     52            *      this list of conditions and the following disclaimer.
     53            *   2. Redistributions in binary form must reproduce the above copyright notice,
     54            *      this list of conditions and the following disclaimer in the documentation
     55            *      and/or other materials provided with the distribution.
     56            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     57            *      may be used to endorse or promote products derived from this software
     58            *      without specific prior written permission.
     59            *
     60            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     61            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     62            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     63            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     64            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     65            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     66            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     67            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     68            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     69            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     70            *
     71            ******************************************************************************
     72            */ 
     73          
     74          /* Includes ------------------------------------------------------------------*/
     75          #include "stm32f4xx_hal.h"
     76          
     77          /** @addtogroup STM32F4xx_HAL_Driver
     78            * @{
     79            */
     80          
     81          /** @defgroup HCD HCD 
     82            * @brief HCD HAL module driver
     83            * @{
     84            */
     85          
     86          #ifdef HAL_HCD_MODULE_ENABLED
     87          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
     88              defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
     89              defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || \
     90              defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
     91              defined(STM32F412Rx) || defined(STM32F412Cx)
     92          /* Private typedef -----------------------------------------------------------*/
     93          /* Private define ------------------------------------------------------------*/
     94          /* Private macro -------------------------------------------------------------*/
     95          /* Private variables ---------------------------------------------------------*/
     96          /* Private function prototypes -----------------------------------------------*/
     97          /** @defgroup HCD_Private_Functions HCD Private Functions
     98            * @{
     99            */
    100          static void HCD_HC_IN_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum);
    101          static void HCD_HC_OUT_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum); 
    102          static void HCD_RXQLVL_IRQHandler(HCD_HandleTypeDef *hhcd);
    103          static void HCD_Port_IRQHandler(HCD_HandleTypeDef *hhcd);
    104          /**
    105            * @}
    106            */
    107          
    108          /* Exported functions --------------------------------------------------------*/
    109          /** @defgroup HCD_Exported_Functions HCD Exported Functions
    110            * @{
    111            */
    112          
    113          /** @defgroup HCD_Exported_Functions_Group1 Initialization and de-initialization functions 
    114           *  @brief    Initialization and Configuration functions 
    115           *
    116          @verbatim     
    117           ===============================================================================
    118                    ##### Initialization and de-initialization functions #####
    119           ===============================================================================
    120              [..]  This section provides functions allowing to:
    121           
    122          @endverbatim
    123            * @{
    124            */
    125          
    126          /**
    127            * @brief  Initialize the host driver.
    128            * @param  hhcd: HCD handle
    129            * @retval HAL status
    130            */

   \                                 In section .text, align 2, keep-with-next
    131          HAL_StatusTypeDef HAL_HCD_Init(HCD_HandleTypeDef *hhcd)
    132          { 
   \                     HAL_HCD_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
    133            /* Check the HCD handle allocation */
    134            if(hhcd == NULL)
   \   00000006   0xD101             BNE.N    ??HAL_HCD_Init_0
    135            {
    136              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE024             B.N      ??HAL_HCD_Init_1
    137            }
    138            
    139            /* Check the parameters */
    140            assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
    141            
    142            hhcd->State = HAL_HCD_STATE_BUSY;
   \                     ??HAL_HCD_Init_0: (+1)
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0xF884 0x0291      STRB     R0,[R4, #+657]
    143            
    144            /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    145            HAL_HCD_MspInit(hhcd);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       HAL_HCD_MspInit
    146            
    147            /* Disable the Interrupts */
    148            __HAL_HCD_DISABLE(hhcd);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       USB_DisableGlobalInt
    149            
    150            /* Init the Core (common init.) */
    151            USB_CoreInit(hhcd->Instance, hhcd->Init);
   \   0000001E   0x1D21             ADDS     R1,R4,#+4
   \   00000020   0xB083             SUB      SP,SP,#+12
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x2234             MOVS     R2,#+52
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002A   0xBC0E             POP      {R1-R3}
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      BL       USB_CoreInit
    152            
    153            /* Force Host Mode*/
    154            USB_SetCurrentMode(hhcd->Instance , USB_OTG_HOST_MODE);
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       USB_SetCurrentMode
    155            
    156            /* Init Host */
    157            USB_HostInit(hhcd->Instance, hhcd->Init);
   \   0000003A   0x1D21             ADDS     R1,R4,#+4
   \   0000003C   0xB083             SUB      SP,SP,#+12
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x2234             MOVS     R2,#+52
   \   00000042   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000046   0xBC0E             POP      {R1-R3}
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x.... 0x....      BL       USB_HostInit
    158            
    159            hhcd->State= HAL_HCD_STATE_READY;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xF884 0x0291      STRB     R0,[R4, #+657]
    160            
    161            return HAL_OK;
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??HAL_HCD_Init_1: (+1)
   \   00000056   0xB00A             ADD      SP,SP,#+40
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    162          }
    163          
    164          /**
    165            * @brief  Initialize a host channel.
    166            * @param  hhcd: HCD handle
    167            * @param  ch_num: Channel number.
    168            *         This parameter can be a value from 1 to 15
    169            * @param  epnum: Endpoint number.
    170            *          This parameter can be a value from 1 to 15
    171            * @param  dev_address : Current device address
    172            *          This parameter can be a value from 0 to 255
    173            * @param  speed: Current device speed.
    174            *          This parameter can be one of these values:
    175            *            HCD_SPEED_HIGH: High speed mode,
    176            *            HCD_SPEED_FULL: Full speed mode,
    177            *            HCD_SPEED_LOW: Low speed mode
    178            * @param  ep_type: Endpoint Type.
    179            *          This parameter can be one of these values:
    180            *            EP_TYPE_CTRL: Control type,
    181            *            EP_TYPE_ISOC: Isochronous type,
    182            *            EP_TYPE_BULK: Bulk type,
    183            *            EP_TYPE_INTR: Interrupt type
    184            * @param  mps: Max Packet Size.
    185            *          This parameter can be a value from 0 to32K
    186            * @retval HAL status
    187            */

   \                                 In section .text, align 2, keep-with-next
    188          HAL_StatusTypeDef HAL_HCD_HC_Init(HCD_HandleTypeDef *hhcd,  
    189                                            uint8_t ch_num,
    190                                            uint8_t epnum,
    191                                            uint8_t dev_address,
    192                                            uint8_t speed,
    193                                            uint8_t ep_type,
    194                                            uint16_t mps)
    195          {
   \                     HAL_HCD_HC_Init: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
    196            HAL_StatusTypeDef status = HAL_OK;
    197            
    198            __HAL_LOCK(hhcd); 
   \   00000004   0xF996 0x0290      LDRSB    R0,[R6, #+656]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_HCD_HC_Init_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBDFE             POP      {R1-R7,PC}
   \                     ??HAL_HCD_HC_Init_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF886 0x0290      STRB     R0,[R6, #+656]
    199            
    200            hhcd->hc[ch_num].dev_addr = dev_address;
   \   00000016   0xEB01 0x0081      ADD      R0,R1,R1, LSL #+2
   \   0000001A   0xEB06 0x00C0      ADD      R0,R6,R0, LSL #+3
   \   0000001E   0xF880 0x3038      STRB     R3,[R0, #+56]
    201            hhcd->hc[ch_num].max_packet = mps;
   \   00000022   0xF100 0x0738      ADD      R7,R0,#+56
   \   00000026   0x980A             LDR      R0,[SP, #+40]
   \   00000028   0x8138             STRH     R0,[R7, #+8]
    202            hhcd->hc[ch_num].ch_num = ch_num;
   \   0000002A   0x7079             STRB     R1,[R7, #+1]
   \   0000002C   0x9C09             LDR      R4,[SP, #+36]
    203            hhcd->hc[ch_num].ep_type = ep_type;
   \   0000002E   0x71FC             STRB     R4,[R7, #+7]
    204            hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
   \   00000030   0xF002 0x057F      AND      R5,R2,#0x7F
   \   00000034   0x70BD             STRB     R5,[R7, #+2]
    205            hhcd->hc[ch_num].ep_is_in = ((epnum & 0x80U) == 0x80U);
   \   00000036   0x09D5             LSRS     R5,R2,#+7
   \   00000038   0x70FD             STRB     R5,[R7, #+3]
   \   0000003A   0x9D08             LDR      R5,[SP, #+32]
    206            hhcd->hc[ch_num].speed = speed;
   \   0000003C   0x713D             STRB     R5,[R7, #+4]
    207            
    208            status =  USB_HC_Init(hhcd->Instance, 
    209                                  ch_num,
    210                                  epnum,
    211                                  dev_address,
    212                                  speed,
    213                                  ep_type,
    214                                  mps);
   \   0000003E   0x9002             STR      R0,[SP, #+8]
   \   00000040   0x9401             STR      R4,[SP, #+4]
   \   00000042   0x9500             STR      R5,[SP, #+0]
   \   00000044   0x6830             LDR      R0,[R6, #+0]
   \   00000046   0x.... 0x....      BL       USB_HC_Init
    215            __HAL_UNLOCK(hhcd); 
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0xF886 0x1290      STRB     R1,[R6, #+656]
    216            
    217            return status;
   \   00000050   0xBDFE             POP      {R1-R7,PC}       ;; return
    218          }
    219          
    220          /**
    221            * @brief  Halt a host channel.
    222            * @param  hhcd: HCD handle
    223            * @param  ch_num: Channel number.
    224            *         This parameter can be a value from 1 to 15
    225            * @retval HAL status
    226            */

   \                                 In section .text, align 2, keep-with-next
    227          HAL_StatusTypeDef HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
    228          {
   \                     HAL_HCD_HC_Halt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    229            HAL_StatusTypeDef status = HAL_OK;
    230            
    231            __HAL_LOCK(hhcd);   
   \   00000004   0xF994 0x0290      LDRSB    R0,[R4, #+656]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_HCD_HC_Halt_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_HCD_HC_Halt_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0290      STRB     R0,[R4, #+656]
    232            USB_HC_Halt(hhcd->Instance, ch_num);   
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_HC_Halt
    233            __HAL_UNLOCK(hhcd);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x0290      STRB     R0,[R4, #+656]
    234            
    235            return status;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    236          }
    237          
    238          /**
    239            * @brief  DeInitialize the host driver.
    240            * @param  hhcd: HCD handle
    241            * @retval HAL status
    242            */

   \                                 In section .text, align 2, keep-with-next
    243          HAL_StatusTypeDef HAL_HCD_DeInit(HCD_HandleTypeDef *hhcd)
    244          {
   \                     HAL_HCD_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    245            /* Check the HCD handle allocation */
    246            if(hhcd == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_HCD_DeInit_0
    247            {
    248              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    249            }
    250            
    251            hhcd->State = HAL_HCD_STATE_BUSY;
   \                     ??HAL_HCD_DeInit_0: (+1)
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0xF884 0x0291      STRB     R0,[R4, #+657]
    252            
    253            /* DeInit the low level hardware */
    254            HAL_HCD_MspDeInit(hhcd);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       HAL_HCD_MspDeInit
    255            
    256            __HAL_HCD_DISABLE(hhcd);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DisableGlobalInt
    257            
    258            hhcd->State = HAL_HCD_STATE_RESET; 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x0291      STRB     R0,[R4, #+657]
    259            
    260            return HAL_OK;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    261          }
    262          
    263          /**
    264            * @brief  Initialize the HCD MSP.
    265            * @param  hhcd: HCD handle
    266            * @retval None
    267            */

   \                                 In section .text, align 2, keep-with-next
    268          __weak void  HAL_HCD_MspInit(HCD_HandleTypeDef *hhcd)
    269          {
    270            /* Prevent unused argument(s) compilation warning */
    271            UNUSED(hhcd);
    272            /* NOTE : This function Should not be modified, when the callback is needed,
    273                      the HAL_PCD_MspInit could be implemented in the user file
    274             */
    275          }
   \                     HAL_HCD_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    276          
    277          /**
    278            * @brief  DeInitialize the HCD MSP.
    279            * @param  hhcd: HCD handle
    280            * @retval None
    281            */

   \                                 In section .text, align 2, keep-with-next
    282          __weak void  HAL_HCD_MspDeInit(HCD_HandleTypeDef *hhcd)
    283          {
    284            /* Prevent unused argument(s) compilation warning */
    285            UNUSED(hhcd);
    286            /* NOTE : This function Should not be modified, when the callback is needed,
    287                      the HAL_PCD_MspDeInit could be implemented in the user file
    288             */
    289          }
   \                     HAL_HCD_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    290          
    291          /**
    292            * @}
    293            */
    294          
    295          /** @defgroup HCD_Exported_Functions_Group2 Input and Output operation functions
    296            *  @brief   HCD IO operation functions
    297            *
    298          @verbatim
    299           ===============================================================================
    300                                ##### IO operation functions #####
    301           ===============================================================================
    302           [..] This subsection provides a set of functions allowing to manage the USB Host Data 
    303              Transfer
    304                 
    305          @endverbatim
    306            * @{
    307            */
    308            
    309          /**                                
    310            * @brief  Submit a new URB for processing. 
    311            * @param  hhcd: HCD handle
    312            * @param  ch_num: Channel number.
    313            *         This parameter can be a value from 1 to 15
    314            * @param  direction: Channel number.
    315            *          This parameter can be one of these values:
    316            *           0 : Output / 1 : Input
    317            * @param  ep_type: Endpoint Type.
    318            *          This parameter can be one of these values:
    319            *            EP_TYPE_CTRL: Control type/
    320            *            EP_TYPE_ISOC: Isochronous type/
    321            *            EP_TYPE_BULK: Bulk type/
    322            *            EP_TYPE_INTR: Interrupt type/
    323            * @param  token: Endpoint Type.
    324            *          This parameter can be one of these values:
    325            *            0: HC_PID_SETUP / 1: HC_PID_DATA1
    326            * @param  pbuff: pointer to URB data
    327            * @param  length: Length of URB data
    328            * @param  do_ping: activate do ping protocol (for high speed only).
    329            *          This parameter can be one of these values:
    330            *           0 : do ping inactive / 1 : do ping active 
    331            * @retval HAL status
    332            */

   \                                 In section .text, align 2, keep-with-next
    333          HAL_StatusTypeDef HAL_HCD_HC_SubmitRequest(HCD_HandleTypeDef *hhcd,
    334                                                     uint8_t ch_num, 
    335                                                     uint8_t direction,
    336                                                     uint8_t ep_type,  
    337                                                     uint8_t token, 
    338                                                     uint8_t* pbuff, 
    339                                                     uint16_t length,
    340                                                     uint8_t do_ping) 
    341          {
   \                     HAL_HCD_HC_SubmitRequest: (+1)
   \   00000000   0xB4FC             PUSH     {R2-R7}
    342            hhcd->hc[ch_num].ep_is_in = direction;
   \   00000002   0xEB01 0x0481      ADD      R4,R1,R1, LSL #+2
   \   00000006   0xEB00 0x06C4      ADD      R6,R0,R4, LSL #+3
   \   0000000A   0xF206 0x0739      ADDW     R7,R6,#+57
   \   0000000E   0x70BA             STRB     R2,[R7, #+2]
    343            hhcd->hc[ch_num].ep_type  = ep_type; 
   \   00000010   0x71BB             STRB     R3,[R7, #+6]
   \   00000012   0x9D06             LDR      R5,[SP, #+24]
    344            
    345            if(token == 0U)
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD102             BNE.N    ??HAL_HCD_HC_SubmitRequest_0
    346            {
    347              hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
   \   00000018   0x2403             MOVS     R4,#+3
   \   0000001A   0x727C             STRB     R4,[R7, #+9]
   \   0000001C   0xE001             B.N      ??HAL_HCD_HC_SubmitRequest_1
    348            }
    349            else
    350            {
    351              hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
   \                     ??HAL_HCD_HC_SubmitRequest_0: (+1)
   \   0000001E   0x2402             MOVS     R4,#+2
   \   00000020   0x727C             STRB     R4,[R7, #+9]
   \                     ??HAL_HCD_HC_SubmitRequest_1: (+1)
   \   00000022   0x9C08             LDR      R4,[SP, #+32]
    352            }
    353            
    354            /* Manage Data Toggle */
    355            switch(ep_type)
   \   00000024   0x2B00             CMP      R3,#+0
   \   00000026   0xD005             BEQ.N    ??HAL_HCD_HC_SubmitRequest_2
   \   00000028   0x2B02             CMP      R3,#+2
   \   0000002A   0xD00E             BEQ.N    ??HAL_HCD_HC_SubmitRequest_3
   \   0000002C   0xD327             BCC.N    ??HAL_HCD_HC_SubmitRequest_4
   \   0000002E   0x2B03             CMP      R3,#+3
   \   00000030   0xD01E             BEQ.N    ??HAL_HCD_HC_SubmitRequest_5
   \   00000032   0xE026             B.N      ??HAL_HCD_HC_SubmitRequest_6
    356            {
    357            case EP_TYPE_CTRL:
    358              if((token == 1U) && (direction == 0U)) /*send data */
   \                     ??HAL_HCD_HC_SubmitRequest_2: (+1)
   \   00000034   0x2D01             CMP      R5,#+1
   \   00000036   0xD124             BNE.N    ??HAL_HCD_HC_SubmitRequest_6
   \   00000038   0x2A00             CMP      R2,#+0
   \   0000003A   0xD122             BNE.N    ??HAL_HCD_HC_SubmitRequest_6
    359              {
    360                if (length == 0U)
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD106             BNE.N    ??HAL_HCD_HC_SubmitRequest_7
    361                { /* For Status OUT stage, Length==0, Status Out PID = 1 */
    362                  hhcd->hc[ch_num].toggle_out = 1U;
   \   00000040   0x2201             MOVS     R2,#+1
   \   00000042   0xF106 0x0344      ADD      R3,R6,#+68
   \   00000046   0x735A             STRB     R2,[R3, #+13]
   \   00000048   0xE001             B.N      ??HAL_HCD_HC_SubmitRequest_7
    363                }
    364                
    365                /* Set the Data Toggle bit as per the Flag */
    366                if (hhcd->hc[ch_num].toggle_out == 0U)
    367                { /* Put the PID 0 */
    368                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;    
    369                }
    370                else
    371                { /* Put the PID 1 */
    372                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    373                }
    374                if(hhcd->hc[ch_num].urb_state  != URB_NOTREADY)
    375                {
    376                  hhcd->hc[ch_num].do_ping = do_ping;
    377                }
    378              }
    379              break;
    380            
    381            case EP_TYPE_BULK:
    382              if(direction == 0U)
   \                     ??HAL_HCD_HC_SubmitRequest_3: (+1)
   \   0000004A   0x2A00             CMP      R2,#+0
   \   0000004C   0xD12E             BNE.N    ??HAL_HCD_HC_SubmitRequest_8
    383              {
    384                /* Set the Data Toggle bit as per the Flag */
    385                if ( hhcd->hc[ch_num].toggle_out == 0U)
   \                     ??HAL_HCD_HC_SubmitRequest_7: (+1)
   \   0000004E   0xF106 0x0244      ADD      R2,R6,#+68
   \   00000052   0x7B53             LDRB     R3,[R2, #+13]
   \   00000054   0x2B00             CMP      R3,#+0
   \   00000056   0xD102             BNE.N    ??HAL_HCD_HC_SubmitRequest_9
    386                { /* Put the PID 0 */
    387                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;    
   \   00000058   0x2300             MOVS     R3,#+0
   \   0000005A   0x727B             STRB     R3,[R7, #+9]
   \   0000005C   0xE001             B.N      ??HAL_HCD_HC_SubmitRequest_10
    388                }
    389                else
    390                { /* Put the PID 1 */
    391                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
   \                     ??HAL_HCD_HC_SubmitRequest_9: (+1)
   \   0000005E   0x2302             MOVS     R3,#+2
   \   00000060   0x727B             STRB     R3,[R7, #+9]
    392                }
    393                if(hhcd->hc[ch_num].urb_state  != URB_NOTREADY)
   \                     ??HAL_HCD_HC_SubmitRequest_10: (+1)
   \   00000062   0xF992 0x2018      LDRSB    R2,[R2, #+24]
   \   00000066   0x2A02             CMP      R2,#+2
   \   00000068   0xD00B             BEQ.N    ??HAL_HCD_HC_SubmitRequest_6
    394                {
    395                  hhcd->hc[ch_num].do_ping = do_ping;
   \   0000006A   0x9A09             LDR      R2,[SP, #+36]
   \   0000006C   0x713A             STRB     R2,[R7, #+4]
   \   0000006E   0xE008             B.N      ??HAL_HCD_HC_SubmitRequest_6
    396                }
    397              }
    398              else
    399              {
    400                if( hhcd->hc[ch_num].toggle_in == 0U)
    401                {
    402                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
    403                }
    404                else
    405                {
    406                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    407                }
    408              }
    409              
    410              break;
    411            case EP_TYPE_INTR:
    412              if(direction == 0U)
   \                     ??HAL_HCD_HC_SubmitRequest_5: (+1)
   \   00000070   0x2A00             CMP      R2,#+0
   \   00000072   0xD11B             BNE.N    ??HAL_HCD_HC_SubmitRequest_8
    413              {
    414                /* Set the Data Toggle bit as per the Flag */
    415                if ( hhcd->hc[ch_num].toggle_out == 0U)
   \   00000074   0xF106 0x0244      ADD      R2,R6,#+68
   \   00000078   0x7B52             LDRB     R2,[R2, #+13]
   \   0000007A   0x2A00             CMP      R2,#+0
   \   0000007C   0xD11B             BNE.N    ??HAL_HCD_HC_SubmitRequest_11
    416                { /* Put the PID 0 */
    417                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;    
    418                }
    419                else
    420                { /* Put the PID 1 */
    421                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    422                }
    423              }
    424              else
    425              {
    426                if( hhcd->hc[ch_num].toggle_in == 0U)
    427                {
    428                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
    429                }
    430                else
    431                {
    432                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    433                }
    434              }
    435              break;
    436              
    437            case EP_TYPE_ISOC: 
    438              hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
   \                     ??HAL_HCD_HC_SubmitRequest_4: (+1)
   \   0000007E   0x2200             MOVS     R2,#+0
   \   00000080   0x727A             STRB     R2,[R7, #+9]
    439              break;  
    440            }
    441            
    442            hhcd->hc[ch_num].xfer_buff = pbuff;
   \                     ??HAL_HCD_HC_SubmitRequest_6: (+1)
   \   00000082   0x9A07             LDR      R2,[SP, #+28]
   \   00000084   0x6472             STR      R2,[R6, #+68]
    443            hhcd->hc[ch_num].xfer_len  = length;
   \   00000086   0xF106 0x0244      ADD      R2,R6,#+68
   \   0000008A   0x6054             STR      R4,[R2, #+4]
    444            hhcd->hc[ch_num].urb_state = URB_IDLE;  
   \   0000008C   0x2300             MOVS     R3,#+0
   \   0000008E   0x7613             STRB     R3,[R2, #+24]
    445            hhcd->hc[ch_num].xfer_count = 0U;
   \   00000090   0x6093             STR      R3,[R2, #+8]
    446            hhcd->hc[ch_num].ch_num = ch_num;
   \   00000092   0xF886 0x1039      STRB     R1,[R6, #+57]
    447            hhcd->hc[ch_num].state = HC_IDLE;
   \   00000096   0x4619             MOV      R1,R3
   \   00000098   0x7651             STRB     R1,[R2, #+25]
    448            
    449            return USB_HC_StartXfer(hhcd->Instance, &(hhcd->hc[ch_num]), hhcd->Init.dma_enable);
   \   0000009A   0x6902             LDR      R2,[R0, #+16]
   \   0000009C   0xB2D2             UXTB     R2,R2
   \   0000009E   0xF106 0x0138      ADD      R1,R6,#+56
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xB002             ADD      SP,SP,#+8
   \   000000A6   0xBCF0             POP      {R4-R7}
   \   000000A8   0x.... 0x....      B.W      USB_HC_StartXfer
   \                     ??HAL_HCD_HC_SubmitRequest_8: (+1)
   \   000000AC   0xF106 0x0244      ADD      R2,R6,#+68
   \   000000B0   0x7B12             LDRB     R2,[R2, #+12]
   \   000000B2   0x2A00             CMP      R2,#+0
   \   000000B4   0xD0E3             BEQ.N    ??HAL_HCD_HC_SubmitRequest_4
   \                     ??HAL_HCD_HC_SubmitRequest_11: (+1)
   \   000000B6   0x2202             MOVS     R2,#+2
   \   000000B8   0x727A             STRB     R2,[R7, #+9]
   \   000000BA   0xE7E2             B.N      ??HAL_HCD_HC_SubmitRequest_6
    450          }
    451          
    452          /**
    453            * @brief  Handle HCD interrupt request.
    454            * @param  hhcd: HCD handle
    455            * @retval None
    456            */

   \                                 In section .text, align 2, keep-with-next
    457          void HAL_HCD_IRQHandler(HCD_HandleTypeDef *hhcd)
    458          {
   \                     HAL_HCD_IRQHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    459            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
   \   00000004   0x6826             LDR      R6,[R4, #+0]
    460            uint32_t i = 0U , interrupt = 0U;
   \   00000006   0x2500             MOVS     R5,#+0
    461            
    462            /* Ensure that we are in device mode */
    463            if (USB_GetMode(hhcd->Instance) == USB_OTG_MODE_HOST)
   \   00000008   0x4630             MOV      R0,R6
   \   0000000A   0x.... 0x....      BL       USB_GetMode
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xF040 0x8089      BNE.W    ??HAL_HCD_IRQHandler_0
    464            {
    465              /* Avoid spurious interrupt */
    466              if(__HAL_HCD_IS_INVALID_INTERRUPT(hhcd)) 
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xF000 0x8083      BEQ.W    ??HAL_HCD_IRQHandler_0
    467              {
    468                return;
    469              }
    470              
    471              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000026   0x0280             LSLS     R0,R0,#+10
   \   00000028   0xD503             BPL.N    ??HAL_HCD_IRQHandler_1
    472              {
    473                /* Incorrect mode, acknowledge the interrupt */
    474                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
   \   0000002A   0xF44F 0x1000      MOV      R0,#+2097152
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x6148             STR      R0,[R1, #+20]
    475              }
    476              
    477              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
   \                     ??HAL_HCD_IRQHandler_1: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000038   0x02C0             LSLS     R0,R0,#+11
   \   0000003A   0xD503             BPL.N    ??HAL_HCD_IRQHandler_2
    478              {
    479                /* Incorrect mode, acknowledge the interrupt */
    480                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
   \   0000003C   0xF44F 0x1080      MOV      R0,#+1048576
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6148             STR      R0,[R1, #+20]
    481              }
    482              
    483              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
   \                     ??HAL_HCD_IRQHandler_2: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000004A   0x0140             LSLS     R0,R0,#+5
   \   0000004C   0xD503             BPL.N    ??HAL_HCD_IRQHandler_3
    484              {
    485                /* Incorrect mode, acknowledge the interrupt */
    486                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
   \   0000004E   0xF04F 0x6080      MOV      R0,#+67108864
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x6148             STR      R0,[R1, #+20]
    487              }   
    488              
    489              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
   \                     ??HAL_HCD_IRQHandler_3: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000005C   0x0780             LSLS     R0,R0,#+30
   \   0000005E   0xD502             BPL.N    ??HAL_HCD_IRQHandler_4
    490              {
    491                /* Incorrect mode, acknowledge the interrupt */
    492                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x6148             STR      R0,[R1, #+20]
    493              }     
    494              
    495              /* Handle Host Disconnect Interrupts */
    496              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
   \                     ??HAL_HCD_IRQHandler_4: (+1)
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000006C   0x0080             LSLS     R0,R0,#+2
   \   0000006E   0xD510             BPL.N    ??HAL_HCD_IRQHandler_5
   \   00000070   0xF506 0x6088      ADD      R0,R6,#+1088
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0xF021 0x012E      BIC      R1,R1,#0x2E
   \   0000007A   0x6001             STR      R1,[R0, #+0]
    497              {
    498                
    499                /* Cleanup HPRT */
    500                USBx_HPRT0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |\
    501                  USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
    502                
    503                /* Handle Host Port Interrupts */
    504                HAL_HCD_Disconnect_Callback(hhcd);
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       HAL_HCD_Disconnect_Callback
    505                USB_InitFSLSPClkSel(hhcd->Instance ,HCFG_48_MHZ );
   \   00000082   0x2101             MOVS     R1,#+1
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x.... 0x....      BL       USB_InitFSLSPClkSel
    506                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
   \   0000008A   0xF04F 0x5000      MOV      R0,#+536870912
   \   0000008E   0x6821             LDR      R1,[R4, #+0]
   \   00000090   0x6148             STR      R0,[R1, #+20]
    507              }
    508              
    509              /* Handle Host Port Interrupts */
    510              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
   \                     ??HAL_HCD_IRQHandler_5: (+1)
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000098   0x01C0             LSLS     R0,R0,#+7
   \   0000009A   0xD502             BPL.N    ??HAL_HCD_IRQHandler_6
    511              {
    512                HCD_Port_IRQHandler (hhcd);
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       HCD_Port_IRQHandler
    513              }
    514              
    515              /* Handle Host SOF Interrupts */
    516              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_SOF))
   \                     ??HAL_HCD_IRQHandler_6: (+1)
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x.... 0x....      BL       USB_ReadInterrupts
   \   000000A8   0x0700             LSLS     R0,R0,#+28
   \   000000AA   0xD505             BPL.N    ??HAL_HCD_IRQHandler_7
    517              {
    518                HAL_HCD_SOF_Callback(hhcd);
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0x.... 0x....      BL       HAL_HCD_SOF_Callback
    519                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_SOF);
   \   000000B2   0x2008             MOVS     R0,#+8
   \   000000B4   0x6821             LDR      R1,[R4, #+0]
   \   000000B6   0x6148             STR      R0,[R1, #+20]
    520              }
    521              
    522              /* Handle Host channel Interrupts */
    523              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HCINT))
   \                     ??HAL_HCD_IRQHandler_7: (+1)
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x.... 0x....      BL       USB_ReadInterrupts
   \   000000BE   0x0180             LSLS     R0,R0,#+6
   \   000000C0   0xD51F             BPL.N    ??HAL_HCD_IRQHandler_8
    524              {
    525                interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x.... 0x....      BL       USB_HC_ReadInterrupt
   \   000000C8   0x4607             MOV      R7,R0
    526                for (i = 0U; i < hhcd->Init.Host_channels; i++)
   \   000000CA   0xE002             B.N      ??HAL_HCD_IRQHandler_9
    527                {
    528                  if (interrupt & (1U << i))
    529                  {
    530                    if ((USBx_HC(i)->HCCHAR) &  USB_OTG_HCCHAR_EPDIR)
    531                    {
    532                      HCD_HC_IN_IRQHandler(hhcd, i);
    533                    }
    534                    else
    535                    {
    536                      HCD_HC_OUT_IRQHandler (hhcd, i);
   \                     ??HAL_HCD_IRQHandler_10: (+1)
   \   000000CC   0x.... 0x....      BL       HCD_HC_OUT_IRQHandler
    537                    }
   \                     ??HAL_HCD_IRQHandler_11: (+1)
   \   000000D0   0x1C6D             ADDS     R5,R5,#+1
   \                     ??HAL_HCD_IRQHandler_9: (+1)
   \   000000D2   0x68A0             LDR      R0,[R4, #+8]
   \   000000D4   0x4285             CMP      R5,R0
   \   000000D6   0xD210             BCS.N    ??HAL_HCD_IRQHandler_12
   \   000000D8   0xFA27 0xF005      LSR      R0,R7,R5
   \   000000DC   0x07C0             LSLS     R0,R0,#+31
   \   000000DE   0xD5F7             BPL.N    ??HAL_HCD_IRQHandler_11
   \   000000E0   0xEB06 0x1045      ADD      R0,R6,R5, LSL #+5
   \   000000E4   0xF500 0x60A0      ADD      R0,R0,#+1280
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0x0400             LSLS     R0,R0,#+16
   \   000000EC   0x4629             MOV      R1,R5
   \   000000EE   0xB2C9             UXTB     R1,R1
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0xD5EB             BPL.N    ??HAL_HCD_IRQHandler_10
   \   000000F4   0x.... 0x....      BL       HCD_HC_IN_IRQHandler
   \   000000F8   0xE7EA             B.N      ??HAL_HCD_IRQHandler_11
    538                  }
    539                }
    540                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_HCINT);
   \                     ??HAL_HCD_IRQHandler_12: (+1)
   \   000000FA   0xF04F 0x7000      MOV      R0,#+33554432
   \   000000FE   0x6821             LDR      R1,[R4, #+0]
   \   00000100   0x6148             STR      R0,[R1, #+20]
    541              } 
    542              
    543              /* Handle Rx Queue Level Interrupts */
    544              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_RXFLVL))
   \                     ??HAL_HCD_IRQHandler_8: (+1)
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000108   0x06C0             LSLS     R0,R0,#+27
   \   0000010A   0xD50C             BPL.N    ??HAL_HCD_IRQHandler_0
    545              {
    546                USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x6981             LDR      R1,[R0, #+24]
   \   00000110   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000114   0x6181             STR      R1,[R0, #+24]
    547                
    548                HCD_RXQLVL_IRQHandler (hhcd);
   \   00000116   0x4620             MOV      R0,R4
   \   00000118   0x.... 0x....      BL       HCD_RXQLVL_IRQHandler
    549                
    550                USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \   0000011C   0x6820             LDR      R0,[R4, #+0]
   \   0000011E   0x6981             LDR      R1,[R0, #+24]
   \   00000120   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000124   0x6181             STR      R1,[R0, #+24]
    551              }
    552            }
    553          }
   \                     ??HAL_HCD_IRQHandler_0: (+1)
   \   00000126   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    554          
    555          /**
    556            * @brief  SOF callback.
    557            * @param  hhcd: HCD handle
    558            * @retval None
    559            */

   \                                 In section .text, align 2, keep-with-next
    560          __weak void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
    561          {
    562            /* Prevent unused argument(s) compilation warning */
    563            UNUSED(hhcd);
    564            /* NOTE : This function Should not be modified, when the callback is needed,
    565                      the HAL_HCD_SOF_Callback could be implemented in the user file
    566             */
    567          }
   \                     HAL_HCD_SOF_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    568          
    569          /**
    570            * @brief Connection Event callback.
    571            * @param  hhcd: HCD handle
    572            * @retval None
    573            */

   \                                 In section .text, align 2, keep-with-next
    574          __weak void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
    575          {
    576            /* Prevent unused argument(s) compilation warning */
    577            UNUSED(hhcd);
    578            /* NOTE : This function Should not be modified, when the callback is needed,
    579                      the HAL_HCD_Connect_Callback could be implemented in the user file
    580             */
    581          }
   \                     HAL_HCD_Connect_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    582          
    583          /**
    584            * @brief  Disconnection Event callback.
    585            * @param  hhcd: HCD handle
    586            * @retval None
    587            */

   \                                 In section .text, align 2, keep-with-next
    588          __weak void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
    589          {
    590            /* Prevent unused argument(s) compilation warning */
    591            UNUSED(hhcd);
    592            /* NOTE : This function Should not be modified, when the callback is needed,
    593                      the HAL_HCD_Disconnect_Callback could be implemented in the user file
    594             */
    595          } 
   \                     HAL_HCD_Disconnect_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    596          
    597          /**
    598            * @brief  Notify URB state change callback.
    599            * @param  hhcd: HCD handle
    600            * @param  chnum: Channel number.
    601            *         This parameter can be a value from 1 to 15
    602            * @param  urb_state:
    603            *          This parameter can be one of these values:
    604            *            URB_IDLE/
    605            *            URB_DONE/
    606            *            URB_NOTREADY/
    607            *            URB_NYET/
    608            *            URB_ERROR/
    609            *            URB_STALL/
    610            * @retval None
    611            */

   \                                 In section .text, align 2, keep-with-next
    612          __weak void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
    613          {
    614            /* Prevent unused argument(s) compilation warning */
    615            UNUSED(hhcd);
    616            UNUSED(chnum);
    617            UNUSED(urb_state);
    618            /* NOTE : This function Should not be modified, when the callback is needed,
    619                      the HAL_HCD_HC_NotifyURBChange_Callback could be implemented in the user file
    620             */
    621          }
   \                     HAL_HCD_HC_NotifyURBChange_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    622          
    623          /**
    624            * @}
    625            */
    626          
    627          /** @defgroup HCD_Exported_Functions_Group3 Peripheral Control functions 
    628           *  @brief   Management functions 
    629           *
    630          @verbatim 
    631           ===============================================================================
    632                                ##### Peripheral Control functions #####
    633           ===============================================================================  
    634              [..]
    635              This subsection provides a set of functions allowing to control the HCD data 
    636              transfers.
    637          
    638          @endverbatim
    639            * @{
    640            */
    641          
    642          /**
    643            * @brief  Start the host driver.
    644            * @param  hhcd: HCD handle
    645            * @retval HAL status
    646            */

   \                                 In section .text, align 2, keep-with-next
    647          HAL_StatusTypeDef HAL_HCD_Start(HCD_HandleTypeDef *hhcd)
    648          { 
   \                     HAL_HCD_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    649            __HAL_LOCK(hhcd); 
   \   00000004   0xF994 0x0290      LDRSB    R0,[R4, #+656]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_HCD_Start_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_HCD_Start_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0290      STRB     R0,[R4, #+656]
    650            __HAL_HCD_ENABLE(hhcd);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_EnableGlobalInt
    651            USB_DriveVbus(hhcd->Instance, 1U);  
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       USB_DriveVbus
    652            __HAL_UNLOCK(hhcd); 
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF884 0x0290      STRB     R0,[R4, #+656]
    653            return HAL_OK;
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    654          }
    655          
    656          /**
    657            * @brief  Stop the host driver.
    658            * @param  hhcd: HCD handle
    659            * @retval HAL status
    660            */
    661          

   \                                 In section .text, align 2, keep-with-next
    662          HAL_StatusTypeDef HAL_HCD_Stop(HCD_HandleTypeDef *hhcd)
    663          { 
   \                     HAL_HCD_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    664            __HAL_LOCK(hhcd); 
   \   00000004   0xF994 0x0290      LDRSB    R0,[R4, #+656]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_HCD_Stop_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_HCD_Stop_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0290      STRB     R0,[R4, #+656]
    665            USB_StopHost(hhcd->Instance);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_StopHost
    666            __HAL_UNLOCK(hhcd); 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x0290      STRB     R0,[R4, #+656]
    667            return HAL_OK;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    668          }
    669          
    670          /**
    671            * @brief  Reset the host port.
    672            * @param  hhcd: HCD handle
    673            * @retval HAL status
    674            */

   \                                 In section .text, align 2, keep-with-next
    675          HAL_StatusTypeDef HAL_HCD_ResetPort(HCD_HandleTypeDef *hhcd)
    676          {
    677            return (USB_ResetPort(hhcd->Instance));
   \                     HAL_HCD_ResetPort: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x.... 0x....      B.W      USB_ResetPort
    678          }
    679          
    680          /**
    681            * @}
    682            */
    683          
    684          /** @defgroup HCD_Exported_Functions_Group4 Peripheral State functions 
    685           *  @brief   Peripheral State functions 
    686           *
    687          @verbatim 
    688           ===============================================================================
    689                                ##### Peripheral State functions #####
    690           ===============================================================================  
    691              [..]
    692              This subsection permits to get in run-time the status of the peripheral 
    693              and the data flow.
    694          
    695          @endverbatim
    696            * @{
    697            */
    698          
    699          /**
    700            * @brief  Return the HCD handle state.
    701            * @param  hhcd: HCD handle
    702            * @retval HAL state
    703            */

   \                                 In section .text, align 2, keep-with-next
    704          HCD_StateTypeDef HAL_HCD_GetState(HCD_HandleTypeDef *hhcd)
    705          {
    706            return hhcd->State;
   \                     HAL_HCD_GetState: (+1)
   \   00000000   0xF990 0x0291      LDRSB    R0,[R0, #+657]
   \   00000004   0x4770             BX       LR               ;; return
    707          }
    708          
    709          /**
    710            * @brief  Return  URB state for a channel.
    711            * @param  hhcd: HCD handle
    712            * @param  chnum: Channel number.
    713            *         This parameter can be a value from 1 to 15
    714            * @retval URB state.
    715            *          This parameter can be one of these values:
    716            *            URB_IDLE/
    717            *            URB_DONE/
    718            *            URB_NOTREADY/
    719            *            URB_NYET/ 
    720            *            URB_ERROR/  
    721            *            URB_STALL      
    722            */

   \                                 In section .text, align 2, keep-with-next
    723          HCD_URBStateTypeDef HAL_HCD_HC_GetURBState(HCD_HandleTypeDef *hhcd, uint8_t chnum)
    724          {
    725            return hhcd->hc[chnum].urb_state;
   \                     HAL_HCD_HC_GetURBState: (+1)
   \   00000000   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000004   0xEB00 0x00C2      ADD      R0,R0,R2, LSL #+3
   \   00000008   0xF990 0x005C      LDRSB    R0,[R0, #+92]
   \   0000000C   0x4770             BX       LR               ;; return
    726          }
    727          
    728          
    729          /**
    730            * @brief  Return the last host transfer size.
    731            * @param  hhcd: HCD handle
    732            * @param  chnum: Channel number.
    733            *         This parameter can be a value from 1 to 15
    734            * @retval last transfer size in byte
    735            */

   \                                 In section .text, align 2, keep-with-next
    736          uint32_t HAL_HCD_HC_GetXferCount(HCD_HandleTypeDef *hhcd, uint8_t chnum)
    737          {
    738            return hhcd->hc[chnum].xfer_count; 
   \                     HAL_HCD_HC_GetXferCount: (+1)
   \   00000000   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000004   0xEB00 0x00C2      ADD      R0,R0,R2, LSL #+3
   \   00000008   0x6CC0             LDR      R0,[R0, #+76]
   \   0000000A   0x4770             BX       LR               ;; return
    739          }
    740            
    741          /**
    742            * @brief  Return the Host Channel state.
    743            * @param  hhcd: HCD handle
    744            * @param  chnum: Channel number.
    745            *         This parameter can be a value from 1 to 15
    746            * @retval Host channel state
    747            *          This parameter can be one of these values:
    748            *            HC_IDLE/
    749            *            HC_XFRC/
    750            *            HC_HALTED/
    751            *            HC_NYET/ 
    752            *            HC_NAK/  
    753            *            HC_STALL/ 
    754            *            HC_XACTERR/  
    755            *            HC_BBLERR/  
    756            *            HC_DATATGLERR    
    757            */

   \                                 In section .text, align 2, keep-with-next
    758          HCD_HCStateTypeDef  HAL_HCD_HC_GetState(HCD_HandleTypeDef *hhcd, uint8_t chnum)
    759          {
    760            return hhcd->hc[chnum].state;
   \                     HAL_HCD_HC_GetState: (+1)
   \   00000000   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000004   0xEB00 0x00C2      ADD      R0,R0,R2, LSL #+3
   \   00000008   0xF990 0x005D      LDRSB    R0,[R0, #+93]
   \   0000000C   0x4770             BX       LR               ;; return
    761          }
    762          
    763          /**
    764            * @brief  Return the current Host frame number.
    765            * @param  hhcd: HCD handle
    766            * @retval Current Host frame number
    767            */

   \                                 In section .text, align 2, keep-with-next
    768          uint32_t HAL_HCD_GetCurrentFrame(HCD_HandleTypeDef *hhcd)
    769          {
    770            return (USB_GetCurrentFrame(hhcd->Instance));
   \                     HAL_HCD_GetCurrentFrame: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x.... 0x....      B.W      USB_GetCurrentFrame
    771          }
    772          
    773          /**
    774            * @brief  Return the Host enumeration speed.
    775            * @param  hhcd: HCD handle
    776            * @retval Enumeration speed
    777            */

   \                                 In section .text, align 2, keep-with-next
    778          uint32_t HAL_HCD_GetCurrentSpeed(HCD_HandleTypeDef *hhcd)
    779          {
    780            return (USB_GetHostSpeed(hhcd->Instance));
   \                     HAL_HCD_GetCurrentSpeed: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x.... 0x....      B.W      USB_GetHostSpeed
    781          }
    782          
    783          /**
    784            * @}
    785            */
    786          
    787          /**
    788            * @}
    789            */
    790          
    791          /** @addtogroup HCD_Private_Functions
    792            * @{
    793            */
    794          /**
    795            * @brief  Handle Host Channel IN interrupt requests.
    796            * @param  hhcd: HCD handle
    797            * @param  chnum: Channel number.
    798            *         This parameter can be a value from 1 to 15
    799            * @retval None
    800            */

   \                                 In section .text, align 2, keep-with-next
    801          static void HCD_HC_IN_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum)
    802          {
   \                     HCD_HC_IN_IRQHandler: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    803            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
   \   00000008   0x6820             LDR      R0,[R4, #+0]
    804            uint32_t tmpreg = 0U;
    805            
    806            if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_AHBERR)
   \   0000000A   0xEB00 0x1045      ADD      R0,R0,R5, LSL #+5
   \   0000000E   0xF500 0x66A0      ADD      R6,R0,#+1280
   \   00000012   0x68B0             LDR      R0,[R6, #+8]
   \   00000014   0x0740             LSLS     R0,R0,#+29
   \   00000016   0xD506             BPL.N    ??HCD_HC_IN_IRQHandler_0
    807            {
    808              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x60B0             STR      R0,[R6, #+8]
    809              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   0000001C   0x68F0             LDR      R0,[R6, #+12]
   \   0000001E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000022   0x60F0             STR      R0,[R6, #+12]
   \   00000024   0xE030             B.N      ??HCD_HC_IN_IRQHandler_1
    810            }  
    811            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_ACK)
   \                     ??HCD_HC_IN_IRQHandler_0: (+1)
   \   00000026   0x68B0             LDR      R0,[R6, #+8]
   \   00000028   0x0680             LSLS     R0,R0,#+26
   \   0000002A   0xD502             BPL.N    ??HCD_HC_IN_IRQHandler_2
    812            {
    813              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
   \   0000002C   0x2020             MOVS     R0,#+32
   \   0000002E   0x60B0             STR      R0,[R6, #+8]
   \   00000030   0xE02A             B.N      ??HCD_HC_IN_IRQHandler_1
    814            }
    815            
    816            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_STALL)  
   \                     ??HCD_HC_IN_IRQHandler_2: (+1)
   \   00000032   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000036   0xEB04 0x08C0      ADD      R8,R4,R0, LSL #+3
   \   0000003A   0x68B0             LDR      R0,[R6, #+8]
   \   0000003C   0x0700             LSLS     R0,R0,#+28
   \   0000003E   0xD510             BPL.N    ??HCD_HC_IN_IRQHandler_3
    817            {
    818              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   00000040   0x68F0             LDR      R0,[R6, #+12]
   \   00000042   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000046   0x60F0             STR      R0,[R6, #+12]
    819              hhcd->hc[chnum].state = HC_STALL;
   \   00000048   0x2005             MOVS     R0,#+5
   \   0000004A   0xF108 0x0148      ADD      R1,R8,#+72
   \   0000004E   0x7548             STRB     R0,[R1, #+21]
    820              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   00000050   0x2010             MOVS     R0,#+16
   \   00000052   0x60B0             STR      R0,[R6, #+8]
    821              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);    
   \   00000054   0x2008             MOVS     R0,#+8
   \   00000056   0x60B0             STR      R0,[R6, #+8]
    822              USB_HC_Halt(hhcd->Instance, chnum);    
   \   00000058   0x4629             MOV      R1,R5
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x.... 0x....      BL       USB_HC_Halt
   \   00000060   0xE012             B.N      ??HCD_HC_IN_IRQHandler_1
    823            }
    824            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_DTERR)
   \                     ??HCD_HC_IN_IRQHandler_3: (+1)
   \   00000062   0x68B0             LDR      R0,[R6, #+8]
   \   00000064   0x0540             LSLS     R0,R0,#+21
   \   00000066   0xD50F             BPL.N    ??HCD_HC_IN_IRQHandler_1
    825            {
    826              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   00000068   0x68F0             LDR      R0,[R6, #+12]
   \   0000006A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000006E   0x60F0             STR      R0,[R6, #+12]
    827              USB_HC_Halt(hhcd->Instance, chnum);  
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x.... 0x....      BL       USB_HC_Halt
    828              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);    
   \   00000076   0x2010             MOVS     R0,#+16
   \   00000078   0x60B0             STR      R0,[R6, #+8]
    829              hhcd->hc[chnum].state = HC_DATATGLERR;
   \   0000007A   0x2008             MOVS     R0,#+8
   \   0000007C   0xF108 0x0148      ADD      R1,R8,#+72
   \   00000080   0x7548             STRB     R0,[R1, #+21]
    830              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);
   \   00000082   0xF44F 0x6080      MOV      R0,#+1024
   \   00000086   0x60B0             STR      R0,[R6, #+8]
    831            }    
    832            
    833            if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_FRMOR)
   \                     ??HCD_HC_IN_IRQHandler_1: (+1)
   \   00000088   0x68B0             LDR      R0,[R6, #+8]
   \   0000008A   0x0580             LSLS     R0,R0,#+22
   \   0000008C   0xD50B             BPL.N    ??HCD_HC_IN_IRQHandler_4
    834            {
    835              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   0000008E   0x68F0             LDR      R0,[R6, #+12]
   \   00000090   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000094   0x60F0             STR      R0,[R6, #+12]
    836              USB_HC_Halt(hhcd->Instance, chnum);  
   \   00000096   0x4629             MOV      R1,R5
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x.... 0x....      BL       USB_HC_Halt
    837              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
   \   0000009E   0xF44F 0x7000      MOV      R0,#+512
   \   000000A2   0x60B0             STR      R0,[R6, #+8]
   \   000000A4   0xE0B1             B.N      ??HCD_HC_IN_IRQHandler_5
    838            }
    839            
    840            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_XFRC)
   \                     ??HCD_HC_IN_IRQHandler_4: (+1)
   \   000000A6   0x68B0             LDR      R0,[R6, #+8]
   \   000000A8   0x07C0             LSLS     R0,R0,#+31
   \   000000AA   0xD538             BPL.N    ??HCD_HC_IN_IRQHandler_6
    841            {
    842              
    843              if (hhcd->Init.dma_enable)
   \   000000AC   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   000000B0   0xEB04 0x08C0      ADD      R8,R4,R0, LSL #+3
   \   000000B4   0xF108 0x0748      ADD      R7,R8,#+72
   \   000000B8   0x6920             LDR      R0,[R4, #+16]
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD006             BEQ.N    ??HCD_HC_IN_IRQHandler_7
    844              {
    845                hhcd->hc[chnum].xfer_count = hhcd->hc[chnum].xfer_len - \
    846                  (USBx_HC(chnum)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
   \   000000BE   0xF8D8 0x0048      LDR      R0,[R8, #+72]
   \   000000C2   0x6931             LDR      R1,[R6, #+16]
   \   000000C4   0x0349             LSLS     R1,R1,#+13
   \   000000C6   0xEBB0 0x3051      SUBS     R0,R0,R1, LSR #+13
   \   000000CA   0x6078             STR      R0,[R7, #+4]
    847              }
    848              
    849              hhcd->hc[chnum].state = HC_XFRC;
   \                     ??HCD_HC_IN_IRQHandler_7: (+1)
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x7578             STRB     R0,[R7, #+21]
    850              hhcd->hc[chnum].ErrCnt = 0U;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x6138             STR      R0,[R7, #+16]
    851              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x60B0             STR      R0,[R6, #+8]
    852              
    853              
    854              if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL)||
    855                  (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
   \   000000D8   0xF898 0x003F      LDRB     R0,[R8, #+63]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD001             BEQ.N    ??HCD_HC_IN_IRQHandler_8
   \   000000E0   0x2802             CMP      R0,#+2
   \   000000E2   0xD10A             BNE.N    ??HCD_HC_IN_IRQHandler_9
    856              {
    857                __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \                     ??HCD_HC_IN_IRQHandler_8: (+1)
   \   000000E4   0x68F0             LDR      R0,[R6, #+12]
   \   000000E6   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000EA   0x60F0             STR      R0,[R6, #+12]
    858                USB_HC_Halt(hhcd->Instance, chnum); 
   \   000000EC   0x4629             MOV      R1,R5
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x.... 0x....      BL       USB_HC_Halt
    859                __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   000000F4   0x2010             MOVS     R0,#+16
   \   000000F6   0x60B0             STR      R0,[R6, #+8]
   \   000000F8   0xE00C             B.N      ??HCD_HC_IN_IRQHandler_10
    860                
    861              }
    862              else if(hhcd->hc[chnum].ep_type == EP_TYPE_INTR)
   \                     ??HCD_HC_IN_IRQHandler_9: (+1)
   \   000000FA   0x2803             CMP      R0,#+3
   \   000000FC   0xD10A             BNE.N    ??HCD_HC_IN_IRQHandler_10
    863              {
    864                USBx_HC(chnum)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
   \   000000FE   0x6830             LDR      R0,[R6, #+0]
   \   00000100   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \   00000104   0x6030             STR      R0,[R6, #+0]
    865                hhcd->hc[chnum].urb_state = URB_DONE; 
   \   00000106   0x2001             MOVS     R0,#+1
   \   00000108   0x7538             STRB     R0,[R7, #+20]
    866                HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
   \   0000010A   0x4602             MOV      R2,R0
   \   0000010C   0x4629             MOV      R1,R5
   \   0000010E   0x4620             MOV      R0,R4
   \   00000110   0x.... 0x....      BL       HAL_HCD_HC_NotifyURBChange_Callback
    867              }
    868              hhcd->hc[chnum].toggle_in ^= 1U;
   \                     ??HCD_HC_IN_IRQHandler_10: (+1)
   \   00000114   0x7A38             LDRB     R0,[R7, #+8]
   \   00000116   0xF080 0x0001      EOR      R0,R0,#0x1
   \   0000011A   0x7238             STRB     R0,[R7, #+8]
   \   0000011C   0xE075             B.N      ??HCD_HC_IN_IRQHandler_5
    869              
    870            }
    871            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_CHH)
   \                     ??HCD_HC_IN_IRQHandler_6: (+1)
   \   0000011E   0x68B0             LDR      R0,[R6, #+8]
   \   00000120   0x0780             LSLS     R0,R0,#+30
   \   00000122   0xD534             BPL.N    ??HCD_HC_IN_IRQHandler_11
    872            {
    873              __HAL_HCD_MASK_HALT_HC_INT(chnum); 
   \   00000124   0x68F0             LDR      R0,[R6, #+12]
   \   00000126   0xF020 0x0002      BIC      R0,R0,#0x2
   \   0000012A   0x60F0             STR      R0,[R6, #+12]
    874              
    875              if(hhcd->hc[chnum].state == HC_XFRC)
   \   0000012C   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000130   0xEB04 0x08C0      ADD      R8,R4,R0, LSL #+3
   \   00000134   0xF108 0x0748      ADD      R7,R8,#+72
   \   00000138   0xF997 0x0015      LDRSB    R0,[R7, #+21]
   \   0000013C   0x2801             CMP      R0,#+1
   \   0000013E   0xD102             BNE.N    ??HCD_HC_IN_IRQHandler_12
    876              {
    877                hhcd->hc[chnum].urb_state  = URB_DONE;      
   \   00000140   0x2001             MOVS     R0,#+1
   \   00000142   0x7538             STRB     R0,[R7, #+20]
   \   00000144   0xE01A             B.N      ??HCD_HC_IN_IRQHandler_13
    878              }
    879              
    880              else if (hhcd->hc[chnum].state == HC_STALL) 
   \                     ??HCD_HC_IN_IRQHandler_12: (+1)
   \   00000146   0x2805             CMP      R0,#+5
   \   00000148   0xD102             BNE.N    ??HCD_HC_IN_IRQHandler_14
    881              {
    882                hhcd->hc[chnum].urb_state  = URB_STALL;
   \   0000014A   0x2005             MOVS     R0,#+5
   \   0000014C   0x7538             STRB     R0,[R7, #+20]
   \   0000014E   0xE015             B.N      ??HCD_HC_IN_IRQHandler_13
    883              }   
    884              
    885              else if((hhcd->hc[chnum].state == HC_XACTERR) ||
    886                      (hhcd->hc[chnum].state == HC_DATATGLERR))
   \                     ??HCD_HC_IN_IRQHandler_14: (+1)
   \   00000150   0x2806             CMP      R0,#+6
   \   00000152   0xD001             BEQ.N    ??HCD_HC_IN_IRQHandler_15
   \   00000154   0x2808             CMP      R0,#+8
   \   00000156   0xD111             BNE.N    ??HCD_HC_IN_IRQHandler_13
    887              {
    888                if(hhcd->hc[chnum].ErrCnt++ > 3U)
   \                     ??HCD_HC_IN_IRQHandler_15: (+1)
   \   00000158   0x6938             LDR      R0,[R7, #+16]
   \   0000015A   0x1C41             ADDS     R1,R0,#+1
   \   0000015C   0x6139             STR      R1,[R7, #+16]
   \   0000015E   0x2804             CMP      R0,#+4
   \   00000160   0xD304             BCC.N    ??HCD_HC_IN_IRQHandler_16
    889                {      
    890                  hhcd->hc[chnum].ErrCnt = 0U;
   \   00000162   0x2000             MOVS     R0,#+0
   \   00000164   0x6138             STR      R0,[R7, #+16]
    891                  hhcd->hc[chnum].urb_state = URB_ERROR;
   \   00000166   0x2004             MOVS     R0,#+4
   \   00000168   0x7538             STRB     R0,[R7, #+20]
   \   0000016A   0xE001             B.N      ??HCD_HC_IN_IRQHandler_17
    892                }
    893                else
    894                {
    895                  hhcd->hc[chnum].urb_state = URB_NOTREADY;
   \                     ??HCD_HC_IN_IRQHandler_16: (+1)
   \   0000016C   0x2002             MOVS     R0,#+2
   \   0000016E   0x7538             STRB     R0,[R7, #+20]
    896                }
    897                
    898                /* re-activate the channel  */
    899                tmpreg = USBx_HC(chnum)->HCCHAR;
   \                     ??HCD_HC_IN_IRQHandler_17: (+1)
   \   00000170   0x6830             LDR      R0,[R6, #+0]
    900                tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
    901                tmpreg |= USB_OTG_HCCHAR_CHENA;
    902                USBx_HC(chnum)->HCCHAR = tmpreg;
   \   00000172   0xF020 0x4080      BIC      R0,R0,#0x40000000
   \   00000176   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   0000017A   0x6030             STR      R0,[R6, #+0]
    903              }
    904              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_CHH);
   \                     ??HCD_HC_IN_IRQHandler_13: (+1)
   \   0000017C   0x2002             MOVS     R0,#+2
   \   0000017E   0x60B0             STR      R0,[R6, #+8]
    905              HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
   \   00000180   0xF997 0x2014      LDRSB    R2,[R7, #+20]
   \   00000184   0x4629             MOV      R1,R5
   \   00000186   0x4620             MOV      R0,R4
   \   00000188   0x.... 0x....      BL       HAL_HCD_HC_NotifyURBChange_Callback
   \   0000018C   0xE03D             B.N      ??HCD_HC_IN_IRQHandler_5
    906            }  
    907            
    908            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_TXERR)
   \                     ??HCD_HC_IN_IRQHandler_11: (+1)
   \   0000018E   0x68B0             LDR      R0,[R6, #+8]
   \   00000190   0x0600             LSLS     R0,R0,#+24
   \   00000192   0xD515             BPL.N    ??HCD_HC_IN_IRQHandler_18
    909            {
    910              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000194   0x68F0             LDR      R0,[R6, #+12]
   \   00000196   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000019A   0x60F0             STR      R0,[R6, #+12]
    911              hhcd->hc[chnum].ErrCnt++;
   \   0000019C   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   000001A0   0xEB04 0x08C0      ADD      R8,R4,R0, LSL #+3
   \   000001A4   0xF108 0x0748      ADD      R7,R8,#+72
   \   000001A8   0x6938             LDR      R0,[R7, #+16]
   \   000001AA   0x1C40             ADDS     R0,R0,#+1
   \   000001AC   0x6138             STR      R0,[R7, #+16]
    912              hhcd->hc[chnum].state = HC_XACTERR;
   \   000001AE   0x2006             MOVS     R0,#+6
   \   000001B0   0x7578             STRB     R0,[R7, #+21]
    913              USB_HC_Halt(hhcd->Instance, chnum);     
   \   000001B2   0x4629             MOV      R1,R5
   \   000001B4   0x6820             LDR      R0,[R4, #+0]
   \   000001B6   0x.... 0x....      BL       USB_HC_Halt
    914              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
   \   000001BA   0x2080             MOVS     R0,#+128
   \   000001BC   0x60B0             STR      R0,[R6, #+8]
   \   000001BE   0xE024             B.N      ??HCD_HC_IN_IRQHandler_5
    915            }
    916            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_NAK)
   \                     ??HCD_HC_IN_IRQHandler_18: (+1)
   \   000001C0   0x68B0             LDR      R0,[R6, #+8]
   \   000001C2   0x06C0             LSLS     R0,R0,#+27
   \   000001C4   0xD521             BPL.N    ??HCD_HC_IN_IRQHandler_5
    917            {  
    918              if(hhcd->hc[chnum].ep_type == EP_TYPE_INTR)
   \   000001C6   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   000001CA   0xEB04 0x08C0      ADD      R8,R4,R0, LSL #+3
   \   000001CE   0xF898 0x003F      LDRB     R0,[R8, #+63]
   \   000001D2   0x4601             MOV      R1,R0
   \   000001D4   0x2903             CMP      R1,#+3
   \   000001D6   0xD108             BNE.N    ??HCD_HC_IN_IRQHandler_19
    919              {
    920                __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   000001D8   0x68F0             LDR      R0,[R6, #+12]
   \   000001DA   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000001DE   0x60F0             STR      R0,[R6, #+12]
    921                USB_HC_Halt(hhcd->Instance, chnum);  
   \   000001E0   0x4629             MOV      R1,R5
   \   000001E2   0x6820             LDR      R0,[R4, #+0]
   \   000001E4   0x.... 0x....      BL       USB_HC_Halt
   \   000001E8   0xE009             B.N      ??HCD_HC_IN_IRQHandler_20
    922              }
    923              else if  ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL)||
    924                        (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
   \                     ??HCD_HC_IN_IRQHandler_19: (+1)
   \   000001EA   0x2800             CMP      R0,#+0
   \   000001EC   0xD001             BEQ.N    ??HCD_HC_IN_IRQHandler_21
   \   000001EE   0x2902             CMP      R1,#+2
   \   000001F0   0xD105             BNE.N    ??HCD_HC_IN_IRQHandler_20
    925              {
    926                /* re-activate the channel */
    927                tmpreg = USBx_HC(chnum)->HCCHAR;
   \                     ??HCD_HC_IN_IRQHandler_21: (+1)
   \   000001F2   0x6830             LDR      R0,[R6, #+0]
    928                tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
    929                tmpreg |= USB_OTG_HCCHAR_CHENA;
    930                USBx_HC(chnum)->HCCHAR = tmpreg;
   \   000001F4   0xF020 0x4080      BIC      R0,R0,#0x40000000
   \   000001F8   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   000001FC   0x6030             STR      R0,[R6, #+0]
    931              }
    932              hhcd->hc[chnum].state = HC_NAK;
   \                     ??HCD_HC_IN_IRQHandler_20: (+1)
   \   000001FE   0x2003             MOVS     R0,#+3
   \   00000200   0xF108 0x0148      ADD      R1,R8,#+72
   \   00000204   0x7548             STRB     R0,[R1, #+21]
    933              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   00000206   0x2010             MOVS     R0,#+16
   \   00000208   0x60B0             STR      R0,[R6, #+8]
    934            }
    935          }
   \                     ??HCD_HC_IN_IRQHandler_5: (+1)
   \   0000020A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    936          
    937          /**
    938            * @brief  Handle Host Channel OUT interrupt requests.
    939            * @param  hhcd: HCD handle
    940            * @param  chnum: Channel number.
    941            *         This parameter can be a value from 1 to 15
    942            * @retval None
    943            */

   \                                 In section .text, align 2, keep-with-next
    944          static void HCD_HC_OUT_IRQHandler  (HCD_HandleTypeDef *hhcd, uint8_t chnum)
    945          {
   \                     HCD_HC_OUT_IRQHandler: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    946            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
   \   00000008   0x6820             LDR      R0,[R4, #+0]
    947            uint32_t tmpreg = 0U;
    948            
    949            if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_AHBERR)
   \   0000000A   0xEB00 0x1045      ADD      R0,R0,R5, LSL #+5
   \   0000000E   0xF500 0x66A0      ADD      R6,R0,#+1280
   \   00000012   0x68B0             LDR      R0,[R6, #+8]
   \   00000014   0x0740             LSLS     R0,R0,#+29
   \   00000016   0xD506             BPL.N    ??HCD_HC_OUT_IRQHandler_0
    950            {
    951              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x60B0             STR      R0,[R6, #+8]
    952              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   0000001C   0x68F0             LDR      R0,[R6, #+12]
   \   0000001E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000022   0x60F0             STR      R0,[R6, #+12]
   \   00000024   0xE100             B.N      ??HCD_HC_OUT_IRQHandler_1
    953            }  
    954            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_ACK)
   \                     ??HCD_HC_OUT_IRQHandler_0: (+1)
   \   00000026   0x68B0             LDR      R0,[R6, #+8]
   \   00000028   0x0680             LSLS     R0,R0,#+26
   \   0000002A   0xD518             BPL.N    ??HCD_HC_OUT_IRQHandler_2
    955            {
    956              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
   \   0000002C   0x2020             MOVS     R0,#+32
   \   0000002E   0x60B0             STR      R0,[R6, #+8]
    957              
    958              if( hhcd->hc[chnum].do_ping == 1U)
   \   00000030   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000034   0xEB04 0x08C0      ADD      R8,R4,R0, LSL #+3
   \   00000038   0xF898 0x003D      LDRB     R0,[R8, #+61]
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xF040 0x80F3      BNE.W    ??HCD_HC_OUT_IRQHandler_1
    959              {
    960                hhcd->hc[chnum].state = HC_NYET;     
   \   00000042   0xF108 0x0758      ADD      R7,R8,#+88
   \   00000046   0x2004             MOVS     R0,#+4
   \   00000048   0x7178             STRB     R0,[R7, #+5]
    961                __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   0000004A   0x68F0             LDR      R0,[R6, #+12]
   \   0000004C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000050   0x60F0             STR      R0,[R6, #+12]
    962                USB_HC_Halt(hhcd->Instance, chnum); 
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       USB_HC_Halt
    963                hhcd->hc[chnum].urb_state  = URB_NOTREADY;
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0x7138             STRB     R0,[R7, #+4]
   \   0000005C   0xE0E4             B.N      ??HCD_HC_OUT_IRQHandler_1
    964              }
    965            }
    966            
    967            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_NYET)
   \                     ??HCD_HC_OUT_IRQHandler_2: (+1)
   \   0000005E   0x68B0             LDR      R0,[R6, #+8]
   \   00000060   0x0640             LSLS     R0,R0,#+25
   \   00000062   0xD515             BPL.N    ??HCD_HC_OUT_IRQHandler_3
    968            {
    969              hhcd->hc[chnum].state = HC_NYET;
   \   00000064   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000068   0xEB04 0x08C0      ADD      R8,R4,R0, LSL #+3
   \   0000006C   0x2004             MOVS     R0,#+4
   \   0000006E   0xF108 0x0158      ADD      R1,R8,#+88
   \   00000072   0x7148             STRB     R0,[R1, #+5]
    970              hhcd->hc[chnum].ErrCnt= 0U;    
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF8C8 0x0058      STR      R0,[R8, #+88]
    971              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   0000007A   0x68F0             LDR      R0,[R6, #+12]
   \   0000007C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000080   0x60F0             STR      R0,[R6, #+12]
    972              USB_HC_Halt(hhcd->Instance, chnum);      
   \   00000082   0x4629             MOV      R1,R5
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x.... 0x....      BL       USB_HC_Halt
    973              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
   \   0000008A   0x2040             MOVS     R0,#+64
   \   0000008C   0x60B0             STR      R0,[R6, #+8]
   \   0000008E   0xE0CB             B.N      ??HCD_HC_OUT_IRQHandler_1
    974              
    975            }  
    976            
    977            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_FRMOR)
   \                     ??HCD_HC_OUT_IRQHandler_3: (+1)
   \   00000090   0x68B0             LDR      R0,[R6, #+8]
   \   00000092   0x0580             LSLS     R0,R0,#+22
   \   00000094   0xD50A             BPL.N    ??HCD_HC_OUT_IRQHandler_4
    978            {
    979              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000096   0x68F0             LDR      R0,[R6, #+12]
   \   00000098   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000009C   0x60F0             STR      R0,[R6, #+12]
    980              USB_HC_Halt(hhcd->Instance, chnum);  
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x.... 0x....      BL       USB_HC_Halt
    981              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
   \   000000A4   0xF44F 0x7000      MOV      R0,#+512
   \   000000A8   0x60B0             STR      R0,[R6, #+8]
   \   000000AA   0xE0BD             B.N      ??HCD_HC_OUT_IRQHandler_1
    982            }
    983            
    984            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_XFRC)
   \                     ??HCD_HC_OUT_IRQHandler_4: (+1)
   \   000000AC   0x68B0             LDR      R0,[R6, #+8]
   \   000000AE   0x07C0             LSLS     R0,R0,#+31
   \   000000B0   0xD513             BPL.N    ??HCD_HC_OUT_IRQHandler_5
    985            {
    986                hhcd->hc[chnum].ErrCnt = 0U;  
   \   000000B2   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   000000B6   0xEB04 0x08C0      ADD      R8,R4,R0, LSL #+3
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xF8C8 0x0058      STR      R0,[R8, #+88]
    987              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   000000C0   0x68F0             LDR      R0,[R6, #+12]
   \   000000C2   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000C6   0x60F0             STR      R0,[R6, #+12]
    988              USB_HC_Halt(hhcd->Instance, chnum);   
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x.... 0x....      BL       USB_HC_Halt
    989              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0x60B0             STR      R0,[R6, #+8]
    990              hhcd->hc[chnum].state = HC_XFRC;
   \   000000D2   0xF108 0x0158      ADD      R1,R8,#+88
   \   000000D6   0x7148             STRB     R0,[R1, #+5]
   \   000000D8   0xE0A6             B.N      ??HCD_HC_OUT_IRQHandler_1
    991          
    992            }  
    993          
    994            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_STALL)  
   \                     ??HCD_HC_OUT_IRQHandler_5: (+1)
   \   000000DA   0x68B0             LDR      R0,[R6, #+8]
   \   000000DC   0x0700             LSLS     R0,R0,#+28
   \   000000DE   0xD510             BPL.N    ??HCD_HC_OUT_IRQHandler_6
    995            {
    996              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);  
   \   000000E0   0x2008             MOVS     R0,#+8
   \   000000E2   0x60B0             STR      R0,[R6, #+8]
    997              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   000000E4   0x68F0             LDR      R0,[R6, #+12]
   \   000000E6   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000EA   0x60F0             STR      R0,[R6, #+12]
    998              USB_HC_Halt(hhcd->Instance, chnum);   
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x.... 0x....      BL       USB_HC_Halt
    999              hhcd->hc[chnum].state = HC_STALL;    
   \   000000F2   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   000000F6   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   000000FA   0x3058             ADDS     R0,R0,#+88
   \   000000FC   0x2105             MOVS     R1,#+5
   \   000000FE   0x7141             STRB     R1,[R0, #+5]
   \   00000100   0xE092             B.N      ??HCD_HC_OUT_IRQHandler_1
   1000            }
   1001          
   1002            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_NAK)
   \                     ??HCD_HC_OUT_IRQHandler_6: (+1)
   \   00000102   0x68B0             LDR      R0,[R6, #+8]
   \   00000104   0x06C0             LSLS     R0,R0,#+27
   \   00000106   0xD514             BPL.N    ??HCD_HC_OUT_IRQHandler_7
   1003            {  
   1004              hhcd->hc[chnum].ErrCnt = 0U;  
   \   00000108   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   0000010C   0xEB04 0x08C0      ADD      R8,R4,R0, LSL #+3
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0xF8C8 0x0058      STR      R0,[R8, #+88]
   1005              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000116   0x68F0             LDR      R0,[R6, #+12]
   \   00000118   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000011C   0x60F0             STR      R0,[R6, #+12]
   1006              USB_HC_Halt(hhcd->Instance, chnum);   
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0x.... 0x....      BL       USB_HC_Halt
   1007              hhcd->hc[chnum].state = HC_NAK;
   \   00000124   0x2003             MOVS     R0,#+3
   \   00000126   0xF108 0x0158      ADD      R1,R8,#+88
   \   0000012A   0x7148             STRB     R0,[R1, #+5]
   1008              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   0000012C   0x2010             MOVS     R0,#+16
   \   0000012E   0x60B0             STR      R0,[R6, #+8]
   \   00000130   0xE07A             B.N      ??HCD_HC_OUT_IRQHandler_1
   1009            }
   1010          
   1011            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_TXERR)
   \                     ??HCD_HC_OUT_IRQHandler_7: (+1)
   \   00000132   0x68B0             LDR      R0,[R6, #+8]
   \   00000134   0x0600             LSLS     R0,R0,#+24
   \   00000136   0xD510             BPL.N    ??HCD_HC_OUT_IRQHandler_8
   1012            {
   1013              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000138   0x68F0             LDR      R0,[R6, #+12]
   \   0000013A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000013E   0x60F0             STR      R0,[R6, #+12]
   1014              USB_HC_Halt(hhcd->Instance, chnum);      
   \   00000140   0x6820             LDR      R0,[R4, #+0]
   \   00000142   0x.... 0x....      BL       USB_HC_Halt
   1015              hhcd->hc[chnum].state = HC_XACTERR;  
   \   00000146   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   0000014A   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   0000014E   0x3058             ADDS     R0,R0,#+88
   \   00000150   0x2106             MOVS     R1,#+6
   \   00000152   0x7141             STRB     R1,[R0, #+5]
   1016               __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
   \   00000154   0x2080             MOVS     R0,#+128
   \   00000156   0x60B0             STR      R0,[R6, #+8]
   \   00000158   0xE066             B.N      ??HCD_HC_OUT_IRQHandler_1
   1017            }
   1018            
   1019            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_DTERR)
   \                     ??HCD_HC_OUT_IRQHandler_8: (+1)
   \   0000015A   0x68B0             LDR      R0,[R6, #+8]
   \   0000015C   0x0540             LSLS     R0,R0,#+21
   \   0000015E   0xD513             BPL.N    ??HCD_HC_OUT_IRQHandler_9
   1020            {
   1021              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000160   0x68F0             LDR      R0,[R6, #+12]
   \   00000162   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000166   0x60F0             STR      R0,[R6, #+12]
   1022              USB_HC_Halt(hhcd->Instance, chnum);      
   \   00000168   0x6820             LDR      R0,[R4, #+0]
   \   0000016A   0x.... 0x....      BL       USB_HC_Halt
   1023              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   0000016E   0x2010             MOVS     R0,#+16
   \   00000170   0x60B0             STR      R0,[R6, #+8]
   1024              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);    
   \   00000172   0xF44F 0x6080      MOV      R0,#+1024
   \   00000176   0x60B0             STR      R0,[R6, #+8]
   1025              hhcd->hc[chnum].state = HC_DATATGLERR;
   \   00000178   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   0000017C   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   00000180   0x3058             ADDS     R0,R0,#+88
   \   00000182   0x2108             MOVS     R1,#+8
   \   00000184   0x7141             STRB     R1,[R0, #+5]
   \   00000186   0xE04F             B.N      ??HCD_HC_OUT_IRQHandler_1
   1026            }
   1027            
   1028            
   1029            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_CHH)
   \                     ??HCD_HC_OUT_IRQHandler_9: (+1)
   \   00000188   0x68B0             LDR      R0,[R6, #+8]
   \   0000018A   0x0780             LSLS     R0,R0,#+30
   \   0000018C   0xD54C             BPL.N    ??HCD_HC_OUT_IRQHandler_1
   1030            {
   1031              __HAL_HCD_MASK_HALT_HC_INT(chnum); 
   \   0000018E   0x68F0             LDR      R0,[R6, #+12]
   \   00000190   0xF020 0x0002      BIC      R0,R0,#0x2
   \   00000194   0x60F0             STR      R0,[R6, #+12]
   1032              
   1033              if(hhcd->hc[chnum].state == HC_XFRC)
   \   00000196   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   0000019A   0xEB04 0x08C0      ADD      R8,R4,R0, LSL #+3
   \   0000019E   0xF108 0x0758      ADD      R7,R8,#+88
   \   000001A2   0xF997 0x0005      LDRSB    R0,[R7, #+5]
   \   000001A6   0x2801             CMP      R0,#+1
   \   000001A8   0xD10B             BNE.N    ??HCD_HC_OUT_IRQHandler_10
   1034              {
   1035                hhcd->hc[chnum].urb_state  = URB_DONE;
   \   000001AA   0x2001             MOVS     R0,#+1
   \   000001AC   0x7138             STRB     R0,[R7, #+4]
   1036                if (hhcd->hc[chnum].ep_type == EP_TYPE_BULK)
   \   000001AE   0xF208 0x003D      ADDW     R0,R8,#+61
   \   000001B2   0x7881             LDRB     R1,[R0, #+2]
   \   000001B4   0x2902             CMP      R1,#+2
   \   000001B6   0xD12F             BNE.N    ??HCD_HC_OUT_IRQHandler_11
   1037                {
   1038                  hhcd->hc[chnum].toggle_out ^= 1U; 
   \   000001B8   0x7D01             LDRB     R1,[R0, #+20]
   \   000001BA   0xF081 0x0101      EOR      R1,R1,#0x1
   \   000001BE   0x7501             STRB     R1,[R0, #+20]
   \   000001C0   0xE02A             B.N      ??HCD_HC_OUT_IRQHandler_11
   1039                }      
   1040              }
   1041              else if (hhcd->hc[chnum].state == HC_NAK) 
   \                     ??HCD_HC_OUT_IRQHandler_10: (+1)
   \   000001C2   0x2803             CMP      R0,#+3
   \   000001C4   0xD102             BNE.N    ??HCD_HC_OUT_IRQHandler_12
   1042              {
   1043                hhcd->hc[chnum].urb_state  = URB_NOTREADY;
   \   000001C6   0x2002             MOVS     R0,#+2
   \   000001C8   0x7138             STRB     R0,[R7, #+4]
   \   000001CA   0xE025             B.N      ??HCD_HC_OUT_IRQHandler_11
   1044              }  
   1045              
   1046              else if (hhcd->hc[chnum].state == HC_NYET) 
   \                     ??HCD_HC_OUT_IRQHandler_12: (+1)
   \   000001CC   0x2804             CMP      R0,#+4
   \   000001CE   0xD105             BNE.N    ??HCD_HC_OUT_IRQHandler_13
   1047              {
   1048                hhcd->hc[chnum].urb_state  = URB_NOTREADY;
   \   000001D0   0x2002             MOVS     R0,#+2
   \   000001D2   0x7138             STRB     R0,[R7, #+4]
   1049                hhcd->hc[chnum].do_ping = 0U;
   \   000001D4   0x2000             MOVS     R0,#+0
   \   000001D6   0xF888 0x003D      STRB     R0,[R8, #+61]
   \   000001DA   0xE01D             B.N      ??HCD_HC_OUT_IRQHandler_11
   1050              }   
   1051              
   1052              else if (hhcd->hc[chnum].state == HC_STALL) 
   \                     ??HCD_HC_OUT_IRQHandler_13: (+1)
   \   000001DC   0x2805             CMP      R0,#+5
   \   000001DE   0xD102             BNE.N    ??HCD_HC_OUT_IRQHandler_14
   1053              {
   1054                hhcd->hc[chnum].urb_state  = URB_STALL;
   \   000001E0   0x2005             MOVS     R0,#+5
   \   000001E2   0x7138             STRB     R0,[R7, #+4]
   \   000001E4   0xE018             B.N      ??HCD_HC_OUT_IRQHandler_11
   1055              } 
   1056              
   1057              else if((hhcd->hc[chnum].state == HC_XACTERR) ||
   1058                      (hhcd->hc[chnum].state == HC_DATATGLERR))
   \                     ??HCD_HC_OUT_IRQHandler_14: (+1)
   \   000001E6   0x2806             CMP      R0,#+6
   \   000001E8   0xD001             BEQ.N    ??HCD_HC_OUT_IRQHandler_15
   \   000001EA   0x2808             CMP      R0,#+8
   \   000001EC   0xD114             BNE.N    ??HCD_HC_OUT_IRQHandler_11
   1059              {
   1060                if(hhcd->hc[chnum].ErrCnt++ > 3U)
   \                     ??HCD_HC_OUT_IRQHandler_15: (+1)
   \   000001EE   0xF8D8 0x0058      LDR      R0,[R8, #+88]
   \   000001F2   0x1C41             ADDS     R1,R0,#+1
   \   000001F4   0xF8C8 0x1058      STR      R1,[R8, #+88]
   \   000001F8   0x2804             CMP      R0,#+4
   \   000001FA   0xD305             BCC.N    ??HCD_HC_OUT_IRQHandler_16
   1061                {      
   1062                  hhcd->hc[chnum].ErrCnt = 0U;
   \   000001FC   0x2000             MOVS     R0,#+0
   \   000001FE   0xF8C8 0x0058      STR      R0,[R8, #+88]
   1063                  hhcd->hc[chnum].urb_state = URB_ERROR;
   \   00000202   0x2004             MOVS     R0,#+4
   \   00000204   0x7138             STRB     R0,[R7, #+4]
   \   00000206   0xE001             B.N      ??HCD_HC_OUT_IRQHandler_17
   1064                }
   1065                else
   1066                {
   1067                  hhcd->hc[chnum].urb_state = URB_NOTREADY;
   \                     ??HCD_HC_OUT_IRQHandler_16: (+1)
   \   00000208   0x2002             MOVS     R0,#+2
   \   0000020A   0x7138             STRB     R0,[R7, #+4]
   1068                }
   1069                
   1070                /* re-activate the channel  */
   1071                tmpreg = USBx_HC(chnum)->HCCHAR;
   \                     ??HCD_HC_OUT_IRQHandler_17: (+1)
   \   0000020C   0x6830             LDR      R0,[R6, #+0]
   1072                tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   1073                tmpreg |= USB_OTG_HCCHAR_CHENA;
   1074                USBx_HC(chnum)->HCCHAR = tmpreg;
   \   0000020E   0xF020 0x4080      BIC      R0,R0,#0x40000000
   \   00000212   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   00000216   0x6030             STR      R0,[R6, #+0]
   1075              }
   1076              
   1077              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_CHH);
   \                     ??HCD_HC_OUT_IRQHandler_11: (+1)
   \   00000218   0x2002             MOVS     R0,#+2
   \   0000021A   0x60B0             STR      R0,[R6, #+8]
   1078              HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);  
   \   0000021C   0xF997 0x2004      LDRSB    R2,[R7, #+4]
   \   00000220   0x4629             MOV      R1,R5
   \   00000222   0x4620             MOV      R0,R4
   \   00000224   0x.... 0x....      BL       HAL_HCD_HC_NotifyURBChange_Callback
   1079            }
   1080          } 
   \                     ??HCD_HC_OUT_IRQHandler_1: (+1)
   \   00000228   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1081          
   1082          /**
   1083            * @brief  Handle Rx Queue Level interrupt requests.
   1084            * @param  hhcd: HCD handle
   1085            * @retval None
   1086            */

   \                                 In section .text, align 2, keep-with-next
   1087          static void HCD_RXQLVL_IRQHandler(HCD_HandleTypeDef *hhcd)
   1088          {
   \                     HCD_RXQLVL_IRQHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4601             MOV      R1,R0
   1089            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;  
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0x4604             MOV      R4,R0
   1090            uint8_t  channelnum = 0U;  
   1091            uint32_t pktsts;
   1092            uint32_t pktcnt; 
   1093            uint32_t temp = 0U;
   1094            uint32_t tmpreg = 0U;
   1095            
   1096            temp = hhcd->Instance->GRXSTSP;
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   1097            channelnum = temp &  USB_OTG_GRXSTSP_EPNUM;  
   \   0000000A   0xF002 0x050F      AND      R5,R2,#0xF
   1098            pktsts = (temp &  USB_OTG_GRXSTSP_PKTSTS) >> 17U;
   1099            pktcnt = (temp &  USB_OTG_GRXSTSP_BCNT) >> 4U;
   \   0000000E   0xF3C2 0x160A      UBFX     R6,R2,#+4,#+11
   1100            
   1101            switch (pktsts)
   \   00000012   0xF3C2 0x4243      UBFX     R2,R2,#+17,#+4
   \   00000016   0x2A02             CMP      R2,#+2
   \   00000018   0xD125             BNE.N    ??HCD_RXQLVL_IRQHandler_0
   1102            {
   1103            case GRXSTS_PKTSTS_IN:
   1104              /* Read the data into the host buffer. */
   1105              if ((pktcnt > 0U) && (hhcd->hc[channelnum].xfer_buff != (void  *)0U))
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD023             BEQ.N    ??HCD_RXQLVL_IRQHandler_0
   \   0000001E   0xEB05 0x0285      ADD      R2,R5,R5, LSL #+2
   \   00000022   0xEB01 0x07C2      ADD      R7,R1,R2, LSL #+3
   \   00000026   0x6C79             LDR      R1,[R7, #+68]
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD01C             BEQ.N    ??HCD_RXQLVL_IRQHandler_0
   1106              {  
   1107                
   1108                USB_ReadPacket(hhcd->Instance, hhcd->hc[channelnum].xfer_buff, pktcnt);
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x.... 0x....      BL       USB_ReadPacket
   1109                
   1110                /*manage multiple Xfer */
   1111                hhcd->hc[channelnum].xfer_buff += pktcnt;           
   \   00000032   0x6C78             LDR      R0,[R7, #+68]
   \   00000034   0x1830             ADDS     R0,R6,R0
   \   00000036   0x6478             STR      R0,[R7, #+68]
   1112                hhcd->hc[channelnum].xfer_count  += pktcnt;
   \   00000038   0xF107 0x0044      ADD      R0,R7,#+68
   \   0000003C   0x6881             LDR      R1,[R0, #+8]
   \   0000003E   0x1871             ADDS     R1,R6,R1
   \   00000040   0x6081             STR      R1,[R0, #+8]
   1113                
   1114                if((USBx_HC(channelnum)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0U)
   \   00000042   0xEB04 0x1145      ADD      R1,R4,R5, LSL #+5
   \   00000046   0xF501 0x61A0      ADD      R1,R1,#+1280
   \   0000004A   0x690A             LDR      R2,[R1, #+16]
   \   0000004C   0x....             LDR.N    R3,??DataTable0  ;; 0x1ff80000
   \   0000004E   0x421A             TST      R2,R3
   \   00000050   0xD009             BEQ.N    ??HCD_RXQLVL_IRQHandler_0
   1115                {
   1116                  /* re-activate the channel when more packets are expected */
   1117                  tmpreg = USBx_HC(channelnum)->HCCHAR;
   \   00000052   0x680A             LDR      R2,[R1, #+0]
   1118                  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   1119                  tmpreg |= USB_OTG_HCCHAR_CHENA;
   1120                  USBx_HC(channelnum)->HCCHAR = tmpreg;
   \   00000054   0xF022 0x4280      BIC      R2,R2,#0x40000000
   \   00000058   0xF042 0x4200      ORR      R2,R2,#0x80000000
   \   0000005C   0x600A             STR      R2,[R1, #+0]
   1121                  hhcd->hc[channelnum].toggle_in ^= 1U;
   \   0000005E   0x7B01             LDRB     R1,[R0, #+12]
   \   00000060   0xF081 0x0101      EOR      R1,R1,#0x1
   \   00000064   0x7301             STRB     R1,[R0, #+12]
   1122                }
   1123              }
   1124              break;
   1125              
   1126            case GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
   1127              break;
   1128            case GRXSTS_PKTSTS_IN_XFER_COMP:
   1129            case GRXSTS_PKTSTS_CH_HALTED:
   1130            default:
   1131              break;
   1132            }
   1133          }
   \                     ??HCD_RXQLVL_IRQHandler_0: (+1)
   \   00000066   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1134          
   1135          /**
   1136            * @brief  Handle Host Port interrupt requests.
   1137            * @param  hhcd: HCD handle
   1138            * @retval None
   1139            */

   \                                 In section .text, align 2, keep-with-next
   1140          static void HCD_Port_IRQHandler  (HCD_HandleTypeDef *hhcd)
   1141          {
   \                     HCD_Port_IRQHandler: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   1142            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;  
   \   00000004   0x6828             LDR      R0,[R5, #+0]
   1143            __IO uint32_t hprt0, hprt0_dup;
   1144            
   1145            /* Handle Host Port Interrupts */
   1146            hprt0 = USBx_HPRT0;
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0xF506 0x6488      ADD      R4,R6,#+1088
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x9101             STR      R1,[SP, #+4]
   1147            hprt0_dup = USBx_HPRT0;
   \   00000010   0x6821             LDR      R1,[R4, #+0]
   \   00000012   0x9100             STR      R1,[SP, #+0]
   1148            
   1149            hprt0_dup &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |\
   1150                           USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \   00000014   0x9900             LDR      R1,[SP, #+0]
   \   00000016   0xF021 0x012E      BIC      R1,R1,#0x2E
   \   0000001A   0x9100             STR      R1,[SP, #+0]
   1151            
   1152            /* Check whether Port Connect Detected */
   1153            if((hprt0 & USB_OTG_HPRT_PCDET) == USB_OTG_HPRT_PCDET)
   \   0000001C   0x9901             LDR      R1,[SP, #+4]
   \   0000001E   0x0789             LSLS     R1,R1,#+30
   \   00000020   0xD50D             BPL.N    ??HCD_Port_IRQHandler_0
   1154            {  
   1155              if((hprt0 & USB_OTG_HPRT_PCSTS) == USB_OTG_HPRT_PCSTS)
   \   00000022   0x9901             LDR      R1,[SP, #+4]
   \   00000024   0x07C9             LSLS     R1,R1,#+31
   \   00000026   0xD506             BPL.N    ??HCD_Port_IRQHandler_1
   1156              {
   1157                USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_DISCINT);
   \   00000028   0x6981             LDR      R1,[R0, #+24]
   \   0000002A   0xF021 0x5100      BIC      R1,R1,#0x20000000
   \   0000002E   0x6181             STR      R1,[R0, #+24]
   1158                HAL_HCD_Connect_Callback(hhcd);
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x.... 0x....      BL       HAL_HCD_Connect_Callback
   1159              }
   1160              hprt0_dup  |= USB_OTG_HPRT_PCDET;
   \                     ??HCD_Port_IRQHandler_1: (+1)
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000003C   0x9000             STR      R0,[SP, #+0]
   1161              
   1162            }
   1163            
   1164            /* Check whether Port Enable Changed */
   1165            if((hprt0 & USB_OTG_HPRT_PENCHNG) == USB_OTG_HPRT_PENCHNG)
   \                     ??HCD_Port_IRQHandler_0: (+1)
   \   0000003E   0x9801             LDR      R0,[SP, #+4]
   \   00000040   0x0700             LSLS     R0,R0,#+28
   \   00000042   0xD52D             BPL.N    ??HCD_Port_IRQHandler_2
   1166            {
   1167              hprt0_dup |= USB_OTG_HPRT_PENCHNG;
   \   00000044   0x9800             LDR      R0,[SP, #+0]
   \   00000046   0xF040 0x0008      ORR      R0,R0,#0x8
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   1168              
   1169              if((hprt0 & USB_OTG_HPRT_PENA) == USB_OTG_HPRT_PENA)
   \   0000004C   0x9801             LDR      R0,[SP, #+4]
   \   0000004E   0x0740             LSLS     R0,R0,#+29
   \   00000050   0xD51D             BPL.N    ??HCD_Port_IRQHandler_3
   1170              {    
   1171                if(hhcd->Init.phy_itface  == USB_OTG_EMBEDDED_PHY)
   \   00000052   0x69A8             LDR      R0,[R5, #+24]
   \   00000054   0x2802             CMP      R0,#+2
   \   00000056   0xD10E             BNE.N    ??HCD_Port_IRQHandler_4
   1172                {
   1173                  if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17U))
   \   00000058   0x6828             LDR      R0,[R5, #+0]
   \   0000005A   0x9901             LDR      R1,[SP, #+4]
   \   0000005C   0xF401 0x21C0      AND      R1,R1,#0x60000
   \   00000060   0xF5B1 0x2F80      CMP      R1,#+262144
   \   00000064   0xD103             BNE.N    ??HCD_Port_IRQHandler_5
   1174                  {
   1175                    USB_InitFSLSPClkSel(hhcd->Instance ,HCFG_6_MHZ );
   \   00000066   0x2102             MOVS     R1,#+2
   \   00000068   0x.... 0x....      BL       USB_InitFSLSPClkSel
   \   0000006C   0xE00B             B.N      ??HCD_Port_IRQHandler_6
   1176                  }
   1177                  else
   1178                  {
   1179                    USB_InitFSLSPClkSel(hhcd->Instance ,HCFG_48_MHZ );
   \                     ??HCD_Port_IRQHandler_5: (+1)
   \   0000006E   0x2101             MOVS     R1,#+1
   \   00000070   0x.... 0x....      BL       USB_InitFSLSPClkSel
   \   00000074   0xE007             B.N      ??HCD_Port_IRQHandler_6
   1180                  }
   1181                }
   1182                else
   1183                {
   1184                  if(hhcd->Init.speed == HCD_SPEED_FULL)
   \                     ??HCD_Port_IRQHandler_4: (+1)
   \   00000076   0x68E8             LDR      R0,[R5, #+12]
   \   00000078   0x2803             CMP      R0,#+3
   \   0000007A   0xD104             BNE.N    ??HCD_Port_IRQHandler_6
   1185                  {
   1186                    USBx_HOST->HFIR = (uint32_t)60000U;
   \   0000007C   0xF64E 0x2060      MOVW     R0,#+60000
   \   00000080   0xF506 0x6180      ADD      R1,R6,#+1024
   \   00000084   0x6048             STR      R0,[R1, #+4]
   1187                  }
   1188                }
   1189                
   1190                HAL_HCD_Connect_Callback(hhcd);
   \                     ??HCD_Port_IRQHandler_6: (+1)
   \   00000086   0x4628             MOV      R0,R5
   \   00000088   0x.... 0x....      BL       HAL_HCD_Connect_Callback
   \   0000008C   0xE008             B.N      ??HCD_Port_IRQHandler_2
   1191              }
   1192              else
   1193              {
   1194                /* Clean up HPRT */
   1195                USBx_HPRT0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |\
   1196                  USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \                     ??HCD_Port_IRQHandler_3: (+1)
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0xF020 0x002E      BIC      R0,R0,#0x2E
   \   00000094   0x6020             STR      R0,[R4, #+0]
   1197                
   1198                USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_DISCINT); 
   \   00000096   0x6828             LDR      R0,[R5, #+0]
   \   00000098   0x6981             LDR      R1,[R0, #+24]
   \   0000009A   0xF041 0x5100      ORR      R1,R1,#0x20000000
   \   0000009E   0x6181             STR      R1,[R0, #+24]
   1199              }    
   1200            }
   1201            
   1202            /* Check for an over current */
   1203            if((hprt0 & USB_OTG_HPRT_POCCHNG) == USB_OTG_HPRT_POCCHNG)
   \                     ??HCD_Port_IRQHandler_2: (+1)
   \   000000A0   0x9801             LDR      R0,[SP, #+4]
   \   000000A2   0x0680             LSLS     R0,R0,#+26
   \   000000A4   0xD503             BPL.N    ??HCD_Port_IRQHandler_7
   1204            {
   1205              hprt0_dup |= USB_OTG_HPRT_POCCHNG;
   \   000000A6   0x9800             LDR      R0,[SP, #+0]
   \   000000A8   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000AC   0x9000             STR      R0,[SP, #+0]
   1206            }
   1207          
   1208            /* Clear Port Interrupts */
   1209            USBx_HPRT0 = hprt0_dup;
   \                     ??HCD_Port_IRQHandler_7: (+1)
   \   000000AE   0x9800             LDR      R0,[SP, #+0]
   \   000000B0   0x6020             STR      R0,[R4, #+0]
   1210          }
   \   000000B2   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x1FF80000         DC32     0x1ff80000
   1211          
   1212          /**
   1213            * @}
   1214            */
   1215          #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
   1216                    STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx ||
   1217                    STM32F412Vx || STM32F412Cx */
   1218          #endif /* HAL_HCD_MODULE_ENABLED */
   1219          /**
   1220            * @}
   1221            */
   1222          
   1223          /**
   1224            * @}
   1225            */
   1226          
   1227          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HCD_Connect_Callback
       8   HAL_HCD_DeInit
         8   -> HAL_HCD_MspDeInit
         8   -> USB_DisableGlobalInt
       0   HAL_HCD_Disconnect_Callback
       0   HAL_HCD_GetCurrentFrame
         0   -> USB_GetCurrentFrame
       0   HAL_HCD_GetCurrentSpeed
         0   -> USB_GetHostSpeed
       0   HAL_HCD_GetState
       0   HAL_HCD_HC_GetState
       0   HAL_HCD_HC_GetURBState
       0   HAL_HCD_HC_GetXferCount
       8   HAL_HCD_HC_Halt
         8   -> USB_HC_Halt
      32   HAL_HCD_HC_Init
        32   -> USB_HC_Init
       0   HAL_HCD_HC_NotifyURBChange_Callback
      24   HAL_HCD_HC_SubmitRequest
         0   -> USB_HC_StartXfer
      24   HAL_HCD_IRQHandler
        24   -> HAL_HCD_Disconnect_Callback
        24   -> HAL_HCD_SOF_Callback
        24   -> HCD_HC_IN_IRQHandler
        24   -> HCD_HC_OUT_IRQHandler
        24   -> HCD_Port_IRQHandler
        24   -> HCD_RXQLVL_IRQHandler
        24   -> USB_GetMode
        24   -> USB_HC_ReadInterrupt
        24   -> USB_InitFSLSPClkSel
        24   -> USB_ReadInterrupts
      60   HAL_HCD_Init
        48   -> HAL_HCD_MspInit
        48   -> USB_CoreInit
        48   -> USB_DisableGlobalInt
        48   -> USB_HostInit
        48   -> USB_SetCurrentMode
        60   -> __aeabi_memcpy4
       0   HAL_HCD_MspDeInit
       0   HAL_HCD_MspInit
       0   HAL_HCD_ResetPort
         0   -> USB_ResetPort
       0   HAL_HCD_SOF_Callback
       8   HAL_HCD_Start
         8   -> USB_DriveVbus
         8   -> USB_EnableGlobalInt
       8   HAL_HCD_Stop
         8   -> USB_StopHost
      24   HCD_HC_IN_IRQHandler
        24   -> HAL_HCD_HC_NotifyURBChange_Callback
        24   -> USB_HC_Halt
      24   HCD_HC_OUT_IRQHandler
        24   -> HAL_HCD_HC_NotifyURBChange_Callback
        24   -> USB_HC_Halt
      24   HCD_Port_IRQHandler
        24   -> HAL_HCD_Connect_Callback
        24   -> USB_InitFSLSPClkSel
      24   HCD_RXQLVL_IRQHandler
        24   -> USB_ReadPacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       2  HAL_HCD_Connect_Callback
      36  HAL_HCD_DeInit
       2  HAL_HCD_Disconnect_Callback
       6  HAL_HCD_GetCurrentFrame
       6  HAL_HCD_GetCurrentSpeed
       6  HAL_HCD_GetState
      14  HAL_HCD_HC_GetState
      14  HAL_HCD_HC_GetURBState
      12  HAL_HCD_HC_GetXferCount
      36  HAL_HCD_HC_Halt
      82  HAL_HCD_HC_Init
       2  HAL_HCD_HC_NotifyURBChange_Callback
     188  HAL_HCD_HC_SubmitRequest
     296  HAL_HCD_IRQHandler
      90  HAL_HCD_Init
       2  HAL_HCD_MspDeInit
       2  HAL_HCD_MspInit
       6  HAL_HCD_ResetPort
       2  HAL_HCD_SOF_Callback
      44  HAL_HCD_Start
      36  HAL_HCD_Stop
     526  HCD_HC_IN_IRQHandler
     556  HCD_HC_OUT_IRQHandler
     180  HCD_Port_IRQHandler
     104  HCD_RXQLVL_IRQHandler

 
 2 254 bytes in section .text
 
 2 254 bytes of CODE memory

Errors: none
Warnings: none
