###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:31
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\ST\STM32_USB_Host_Library\Core\Src\usbh_core.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\ST\STM32_USB_Host_Library\Core\Src\usbh_core.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\usbh_core.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\usbh_core.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\ST\STM32_USB_Host_Library\Core\Src\usbh_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_core.c 
      4            * @author  MCD Application Team
      5            * @version V3.2.2
      6            * @date    07-July-2015
      7            * @brief   This file implements the functions for the core state machine process
      8            *          the enumeration and the control transfer process
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     13            *
     14            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     15            * You may not use this file except in compliance with the License.
     16            * You may obtain a copy of the License at:
     17            *
     18            *        http://www.st.com/software_license_agreement_liberty_v2
     19            *
     20            * Unless required by applicable law or agreed to in writing, software 
     21            * distributed under the License is distributed on an "AS IS" BASIS, 
     22            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     23            * See the License for the specific language governing permissions and
     24            * limitations under the License.
     25            *
     26            ******************************************************************************
     27            */ 
     28          /* Includes ------------------------------------------------------------------*/
     29          
     30          #include "usbh_core.h"
     31          
     32          
     33          /** @addtogroup USBH_LIB
     34            * @{
     35            */
     36          
     37          /** @addtogroup USBH_LIB_CORE
     38            * @{
     39            */
     40          
     41          /** @defgroup USBH_CORE 
     42            * @brief This file handles the basic enumeration when a device is connected 
     43            *          to the host.
     44            * @{
     45            */ 
     46          
     47          
     48          /** @defgroup USBH_CORE_Private_Defines
     49            * @{
     50            */ 
     51          #define USBH_ADDRESS_DEFAULT                     0
     52          #define USBH_ADDRESS_ASSIGNED                    1      
     53          #define USBH_MPS_DEFAULT                         0x40
     54          /**
     55            * @}
     56            */ 
     57          
     58          /** @defgroup USBH_CORE_Private_Macros
     59            * @{
     60            */ 
     61          /**
     62            * @}
     63            */ 
     64          
     65          
     66          /** @defgroup USBH_CORE_Private_Variables
     67            * @{
     68            */ 
     69          /**
     70            * @}
     71            */ 
     72           
     73          
     74          /** @defgroup USBH_CORE_Private_Functions
     75            * @{
     76            */ 
     77          static USBH_StatusTypeDef  USBH_HandleEnum    (USBH_HandleTypeDef *phost);
     78          static void                USBH_HandleSof     (USBH_HandleTypeDef *phost);
     79          static USBH_StatusTypeDef  DeInitStateMachine(USBH_HandleTypeDef *phost);
     80          
     81          #if (USBH_USE_OS == 1)  
     82          static void USBH_Process_OS(void const * argument);
     83          #endif
     84          
     85          /**
     86            * @brief  HCD_Init 
     87            *         Initialize the HOST Core.
     88            * @param  phost: Host Handle
     89            * @param  pUsrFunc: User Callback
     90            * @retval USBH Status
     91            */

   \                                 In section .text, align 2, keep-with-next
     92          USBH_StatusTypeDef  USBH_Init(USBH_HandleTypeDef *phost, void (*pUsrFunc)(USBH_HandleTypeDef *phost, uint8_t ), uint8_t id)
     93          {
   \                     USBH_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
     94            /* Check whether the USB Host handle is valid */
     95            if(phost == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??USBH_Init_0
     96            {
     97              USBH_ErrLog("Invalid Host handle");
     98              return USBH_FAIL; 
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
     99            }
    100            
    101            /* Set DRiver ID */
    102            phost->id = id;
   \                     ??USBH_Init_0: (+1)
   \   0000000E   0xF884 0x23BC      STRB     R2,[R4, #+956]
    103            
    104            /* Unlink class*/
    105            phost->pActiveClass = NULL;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF8C4 0x0374      STR      R0,[R4, #+884]
    106            phost->ClassNumber = 0;
   \   00000018   0xF8C4 0x0378      STR      R0,[R4, #+888]
    107            
    108            /* Restore default states and prepare EP0 */ 
    109            DeInitStateMachine(phost);
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       DeInitStateMachine
    110            
    111            /* Assign User process */
    112            if(pUsrFunc != NULL)
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xD001             BEQ.N    ??USBH_Init_1
    113            {
    114              phost->pUser = pUsrFunc;
   \   00000026   0xF8C4 0x53C4      STR      R5,[R4, #+964]
    115            }
    116            
    117          #if (USBH_USE_OS == 1) 
    118            
    119            /* Create USB Host Queue */
    120            osMessageQDef(USBH_Queue, 10, uint16_t);
    121            phost->os_event = osMessageCreate (osMessageQ(USBH_Queue), NULL); 
    122            
    123            /*Create USB Host Task */
    124          #if defined (USBH_PROCESS_STACK_SIZE)
    125            osThreadDef(USBH_Thread, USBH_Process_OS, USBH_PROCESS_PRIO, 0, USBH_PROCESS_STACK_SIZE);
    126          #else
    127            osThreadDef(USBH_Thread, USBH_Process_OS, USBH_PROCESS_PRIO, 0, 8 * configMINIMAL_STACK_SIZE);
    128          #endif  
    129            phost->thread = osThreadCreate (osThread(USBH_Thread), phost);
    130          #endif  
    131            
    132            /* Initialize low level driver */
    133            USBH_LL_Init(phost);
   \                     ??USBH_Init_1: (+1)
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       USBH_LL_Init
    134            return USBH_OK;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    135          }
    136          
    137          /**
    138            * @brief  HCD_Init 
    139            *         De-Initialize the Host portion of the driver.
    140            * @param  phost: Host Handle
    141            * @retval USBH Status
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          USBH_StatusTypeDef  USBH_DeInit(USBH_HandleTypeDef *phost)
    144          {
   \                     USBH_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    145            DeInitStateMachine(phost);
   \   00000004   0x.... 0x....      BL       DeInitStateMachine
    146            
    147            if(phost->pData != NULL)
   \   00000008   0xF8D4 0x03C0      LDR      R0,[R4, #+960]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD006             BEQ.N    ??USBH_DeInit_0
    148            {
    149              phost->pActiveClass->pData = NULL;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF8D4 0x1374      LDR      R1,[R4, #+884]
   \   00000016   0x61C8             STR      R0,[R1, #+28]
    150              USBH_LL_Stop(phost);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       USBH_LL_Stop
    151            }
    152          
    153            return USBH_OK;
   \                     ??USBH_DeInit_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    154          }
    155          
    156          /**
    157            * @brief  DeInitStateMachine 
    158            *         De-Initialize the Host state machine.
    159            * @param  phost: Host Handle
    160            * @retval USBH Status
    161            */

   \                                 In section .text, align 2, keep-with-next
    162          static USBH_StatusTypeDef  DeInitStateMachine(USBH_HandleTypeDef *phost)
    163          {
    164            uint32_t i = 0;
   \                     DeInitStateMachine: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0xE004             B.N      ??DeInitStateMachine_0
    165          
    166            /* Clear Pipes flags*/
    167            for ( ; i < USBH_MAX_PIPES_NBR; i++)
    168            {
    169              phost->Pipes[i] = 0;
   \                     ??DeInitStateMachine_1: (+1)
   \   00000006   0xEB00 0x0381      ADD      R3,R0,R1, LSL #+2
   \   0000000A   0xF8C3 0x237C      STR      R2,[R3, #+892]
    170            }
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \                     ??DeInitStateMachine_0: (+1)
   \   00000010   0x290F             CMP      R1,#+15
   \   00000012   0xD3F8             BCC.N    ??DeInitStateMachine_1
    171            
    172            for(i = 0; i< USBH_MAX_DATA_BUFFER; i++)
   \   00000014   0x4611             MOV      R1,R2
   \   00000016   0xE003             B.N      ??DeInitStateMachine_2
    173            {
    174              phost->device.Data[i] = 0;
   \                     ??DeInitStateMachine_3: (+1)
   \   00000018   0x180B             ADDS     R3,R1,R0
   \   0000001A   0xF883 0x211C      STRB     R2,[R3, #+284]
    175            }
   \   0000001E   0x1C49             ADDS     R1,R1,#+1
   \                     ??DeInitStateMachine_2: (+1)
   \   00000020   0xF5B1 0x7F00      CMP      R1,#+512
   \   00000024   0xD3F8             BCC.N    ??DeInitStateMachine_3
    176            
    177            phost->gState = HOST_IDLE;
   \   00000026   0x4611             MOV      R1,R2
   \   00000028   0x7001             STRB     R1,[R0, #+0]
    178            phost->EnumState = ENUM_IDLE;
   \   0000002A   0x7041             STRB     R1,[R0, #+1]
    179            phost->RequestState = CMD_SEND;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x7081             STRB     R1,[R0, #+2]
    180            phost->Timer = 0;  
   \   00000030   0x4611             MOV      R1,R2
   \   00000032   0xF8C0 0x13B8      STR      R1,[R0, #+952]
    181            
    182            phost->Control.state = CTRL_SETUP;
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x7601             STRB     R1,[R0, #+24]
    183            phost->Control.pipe_size = USBH_MPS_DEFAULT;  
   \   0000003A   0x2140             MOVS     R1,#+64
   \   0000003C   0x7181             STRB     R1,[R0, #+6]
    184            phost->Control.errorcount = 0;
   \   0000003E   0x4611             MOV      R1,R2
   \   00000040   0x7641             STRB     R1,[R0, #+25]
    185            
    186            phost->device.address = USBH_ADDRESS_DEFAULT;
   \   00000042   0xF880 0x131C      STRB     R1,[R0, #+796]
    187            phost->device.speed   = USBH_SPEED_FULL;
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0xF880 0x131D      STRB     R1,[R0, #+797]
    188            
    189            return USBH_OK;
   \   0000004C   0x4610             MOV      R0,R2
   \   0000004E   0x4770             BX       LR               ;; return
    190          }
    191          
    192          /**
    193            * @brief  USBH_RegisterClass 
    194            *         Link class driver to Host Core.
    195            * @param  phost : Host Handle
    196            * @param  pclass: Class handle
    197            * @retval USBH Status
    198            */

   \                                 In section .text, align 2, keep-with-next
    199          USBH_StatusTypeDef  USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
    200          {
   \                     USBH_RegisterClass: (+1)
   \   00000000   0xB410             PUSH     {R4}
    201            USBH_StatusTypeDef   status = USBH_OK;
   \   00000002   0x2200             MOVS     R2,#+0
    202            
    203            if(pclass != 0)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD00D             BEQ.N    ??USBH_RegisterClass_0
    204            {
    205              if(phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
   \   00000008   0xF8D0 0x3378      LDR      R3,[R0, #+888]
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD107             BNE.N    ??USBH_RegisterClass_1
    206              {
    207                /* link the class to the USB Host handle */
    208                phost->pClass[phost->ClassNumber++] = pclass;
   \   00000010   0x1C5C             ADDS     R4,R3,#+1
   \   00000012   0xF8C0 0x4378      STR      R4,[R0, #+888]
   \   00000016   0xEB00 0x0083      ADD      R0,R0,R3, LSL #+2
   \   0000001A   0xF8C0 0x1370      STR      R1,[R0, #+880]
    209                status = USBH_OK;
   \   0000001E   0xE002             B.N      ??USBH_RegisterClass_2
    210              }
    211              else
    212              {
    213                USBH_ErrLog("Max Class Number reached");
    214                status = USBH_FAIL; 
   \                     ??USBH_RegisterClass_1: (+1)
   \   00000020   0x2202             MOVS     R2,#+2
   \   00000022   0xE000             B.N      ??USBH_RegisterClass_2
    215              }
    216            }
    217            else
    218            {
    219              USBH_ErrLog("Invalid Class handle");
    220              status = USBH_FAIL; 
   \                     ??USBH_RegisterClass_0: (+1)
   \   00000024   0x2202             MOVS     R2,#+2
    221            }
    222            
    223            return status;
   \                     ??USBH_RegisterClass_2: (+1)
   \   00000026   0x4610             MOV      R0,R2
   \   00000028   0xBC10             POP      {R4}
   \   0000002A   0x4770             BX       LR               ;; return
    224          }
    225          
    226          /**
    227            * @brief  USBH_SelectInterface 
    228            *         Select current interface.
    229            * @param  phost: Host Handle
    230            * @param  interface: Interface number
    231            * @retval USBH Status
    232            */

   \                                 In section .text, align 2, keep-with-next
    233          USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
    234          {
    235            USBH_StatusTypeDef   status = USBH_OK;
   \                     USBH_SelectInterface: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    236            
    237            if(interface < phost->device.CfgDesc.bNumInterfaces)
   \   00000002   0xF890 0x3336      LDRB     R3,[R0, #+822]
   \   00000006   0x4299             CMP      R1,R3
   \   00000008   0xD202             BCS.N    ??USBH_SelectInterface_0
    238            {
    239              phost->device.current_interface = interface;
   \   0000000A   0xF880 0x131F      STRB     R1,[R0, #+799]
   \   0000000E   0xE000             B.N      ??USBH_SelectInterface_1
    240              USBH_UsrLog ("Switching to Interface (#%d)", interface);
    241              USBH_UsrLog ("Class    : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceClass );
    242              USBH_UsrLog ("SubClass : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceSubClass );
    243              USBH_UsrLog ("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol );                 
    244            }
    245            else
    246            {
    247              USBH_ErrLog ("Cannot Select This Interface.");
    248              status = USBH_FAIL; 
   \                     ??USBH_SelectInterface_0: (+1)
   \   00000010   0x2202             MOVS     R2,#+2
    249            }
    250            return status;  
   \                     ??USBH_SelectInterface_1: (+1)
   \   00000012   0x4610             MOV      R0,R2
   \   00000014   0x4770             BX       LR               ;; return
    251          }
    252          
    253          /**
    254            * @brief  USBH_GetActiveClass 
    255            *         Return Device Class.
    256            * @param  phost: Host Handle
    257            * @param  interface: Interface index
    258            * @retval Class Code
    259            */

   \                                 In section .text, align 2, keep-with-next
    260          uint8_t USBH_GetActiveClass(USBH_HandleTypeDef *phost)
    261          {
    262             return (phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass);            
   \                     USBH_GetActiveClass: (+1)
   \   00000000   0xF890 0x0341      LDRB     R0,[R0, #+833]
   \   00000004   0x4770             BX       LR               ;; return
    263          }
    264          /**
    265            * @brief  USBH_FindInterface 
    266            *         Find the interface index for a specific class.
    267            * @param  phost: Host Handle
    268            * @param  Class: Class code
    269            * @param  SubClass: SubClass code
    270            * @param  Protocol: Protocol code
    271            * @retval interface index in the configuration structure
    272            * @note : (1)interface index 0xFF means interface index not found
    273            */

   \                                 In section .text, align 2, keep-with-next
    274          uint8_t  USBH_FindInterface(USBH_HandleTypeDef *phost, uint8_t Class, uint8_t SubClass, uint8_t Protocol)
    275          {
   \                     USBH_FindInterface: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x4604             MOV      R4,R0
    276            USBH_InterfaceDescTypeDef    *pif ;
    277            USBH_CfgDescTypeDef          *pcfg ;
    278            int8_t                        if_ix = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    279            
    280            pif = (USBH_InterfaceDescTypeDef *)0;
    281            pcfg = &phost->device.CfgDesc;  
   \   00000006   0xF204 0x3432      ADDW     R4,R4,#+818
   \   0000000A   0xE000             B.N      ??USBH_FindInterface_0
    282            
    283            while (if_ix < USBH_MAX_NUM_INTERFACES)
    284            {
    285              pif = &pcfg->Itf_Desc[if_ix];
    286              if(((pif->bInterfaceClass == Class) || (Class == 0xFF))&&
    287                 ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFF))&&
    288                   ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFF)))
    289              {
    290                return  if_ix;
    291              }
    292              if_ix++;
   \                     ??USBH_FindInterface_1: (+1)
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \                     ??USBH_FindInterface_0: (+1)
   \   0000000E   0xB240             SXTB     R0,R0
   \   00000010   0x4605             MOV      R5,R0
   \   00000012   0x2D02             CMP      R5,#+2
   \   00000014   0xDA15             BGE.N    ??USBH_FindInterface_2
   \   00000016   0x261A             MOVS     R6,#+26
   \   00000018   0xFB15 0x4506      SMLABB   R5,R5,R6,R4
   \   0000001C   0xF205 0x050A      ADDW     R5,R5,#+10
   \   00000020   0x796E             LDRB     R6,[R5, #+5]
   \   00000022   0x428E             CMP      R6,R1
   \   00000024   0xD001             BEQ.N    ??USBH_FindInterface_3
   \   00000026   0x29FF             CMP      R1,#+255
   \   00000028   0xD1F0             BNE.N    ??USBH_FindInterface_1
   \                     ??USBH_FindInterface_3: (+1)
   \   0000002A   0x79AE             LDRB     R6,[R5, #+6]
   \   0000002C   0x4296             CMP      R6,R2
   \   0000002E   0xD001             BEQ.N    ??USBH_FindInterface_4
   \   00000030   0x2AFF             CMP      R2,#+255
   \   00000032   0xD1EB             BNE.N    ??USBH_FindInterface_1
   \                     ??USBH_FindInterface_4: (+1)
   \   00000034   0x79ED             LDRB     R5,[R5, #+7]
   \   00000036   0x429D             CMP      R5,R3
   \   00000038   0xD001             BEQ.N    ??USBH_FindInterface_5
   \   0000003A   0x2BFF             CMP      R3,#+255
   \   0000003C   0xD1E6             BNE.N    ??USBH_FindInterface_1
   \                     ??USBH_FindInterface_5: (+1)
   \   0000003E   0xB2C0             UXTB     R0,R0
   \   00000040   0xE000             B.N      ??USBH_FindInterface_6
    293            }
    294            return 0xFF;
   \                     ??USBH_FindInterface_2: (+1)
   \   00000042   0x20FF             MOVS     R0,#+255
   \                     ??USBH_FindInterface_6: (+1)
   \   00000044   0xBC70             POP      {R4-R6}
   \   00000046   0x4770             BX       LR               ;; return
    295          }
    296          
    297          /**
    298            * @brief  USBH_FindInterfaceIndex 
    299            *         Find the interface index for a specific class interface and alternate setting number.
    300            * @param  phost: Host Handle
    301            * @param  interface_number: interface number
    302            * @param  alt_settings    : alternate setting number
    303            * @retval interface index in the configuration structure
    304            * @note : (1)interface index 0xFF means interface index not found
    305            */

   \                                 In section .text, align 2, keep-with-next
    306          uint8_t  USBH_FindInterfaceIndex(USBH_HandleTypeDef *phost, uint8_t interface_number, uint8_t alt_settings)
    307          {
   \                     USBH_FindInterfaceIndex: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    308            USBH_InterfaceDescTypeDef    *pif ;
    309            USBH_CfgDescTypeDef          *pcfg ;
    310            int8_t                        if_ix = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    311            
    312            pif = (USBH_InterfaceDescTypeDef *)0;
    313            pcfg = &phost->device.CfgDesc;  
   \   00000004   0xF200 0x3032      ADDW     R0,R0,#+818
   \   00000008   0xE000             B.N      ??USBH_FindInterfaceIndex_0
    314            
    315            while (if_ix < USBH_MAX_NUM_INTERFACES)
    316            {
    317              pif = &pcfg->Itf_Desc[if_ix];
    318              if((pif->bInterfaceNumber == interface_number) && (pif->bAlternateSetting == alt_settings))
    319              {
    320                return  if_ix;
    321              }
    322              if_ix++;
   \                     ??USBH_FindInterfaceIndex_1: (+1)
   \   0000000A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??USBH_FindInterfaceIndex_0: (+1)
   \   0000000C   0xB25B             SXTB     R3,R3
   \   0000000E   0x461C             MOV      R4,R3
   \   00000010   0x2C02             CMP      R4,#+2
   \   00000012   0xDA0D             BGE.N    ??USBH_FindInterfaceIndex_2
   \   00000014   0x251A             MOVS     R5,#+26
   \   00000016   0xFB14 0x0405      SMLABB   R4,R4,R5,R0
   \   0000001A   0xF204 0x040A      ADDW     R4,R4,#+10
   \   0000001E   0x78A5             LDRB     R5,[R4, #+2]
   \   00000020   0x428D             CMP      R5,R1
   \   00000022   0xD1F2             BNE.N    ??USBH_FindInterfaceIndex_1
   \   00000024   0x78E4             LDRB     R4,[R4, #+3]
   \   00000026   0x4294             CMP      R4,R2
   \   00000028   0xD1EF             BNE.N    ??USBH_FindInterfaceIndex_1
   \   0000002A   0x4618             MOV      R0,R3
   \   0000002C   0xB2C0             UXTB     R0,R0
   \   0000002E   0xE000             B.N      ??USBH_FindInterfaceIndex_3
    323            }
    324            return 0xFF;
   \                     ??USBH_FindInterfaceIndex_2: (+1)
   \   00000030   0x20FF             MOVS     R0,#+255
   \                     ??USBH_FindInterfaceIndex_3: (+1)
   \   00000032   0xBC30             POP      {R4,R5}
   \   00000034   0x4770             BX       LR               ;; return
    325          }
    326          
    327          /**
    328            * @brief  USBH_Start 
    329            *         Start the USB Host Core.
    330            * @param  phost: Host Handle
    331            * @retval USBH Status
    332            */

   \                                 In section .text, align 2, keep-with-next
    333          USBH_StatusTypeDef  USBH_Start  (USBH_HandleTypeDef *phost)
    334          {
   \                     USBH_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    335            /* Start the low level driver  */
    336            USBH_LL_Start(phost);
   \   00000004   0x.... 0x....      BL       USBH_LL_Start
    337            
    338            /* Activate VBUS on the port */ 
    339            USBH_LL_DriverVBUS (phost, TRUE);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       USBH_LL_DriverVBUS
    340            
    341            return USBH_OK;  
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    342          }
    343          
    344          /**
    345            * @brief  USBH_Stop 
    346            *         Stop the USB Host Core.
    347            * @param  phost: Host Handle
    348            * @retval USBH Status
    349            */

   \                                 In section .text, align 2, keep-with-next
    350          USBH_StatusTypeDef  USBH_Stop   (USBH_HandleTypeDef *phost)
    351          {
   \                     USBH_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    352            /* Stop and cleanup the low level driver  */
    353            USBH_LL_Stop(phost);  
   \   00000004   0x.... 0x....      BL       USBH_LL_Stop
    354            
    355            /* DeActivate VBUS on the port */ 
    356            USBH_LL_DriverVBUS (phost, FALSE);
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       USBH_LL_DriverVBUS
    357            
    358            /* FRee Control Pipes */
    359            USBH_FreePipe  (phost, phost->Control.pipe_in);
   \   00000010   0x7921             LDRB     R1,[R4, #+4]
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       USBH_FreePipe
    360            USBH_FreePipe  (phost, phost->Control.pipe_out);  
   \   00000018   0x7961             LDRB     R1,[R4, #+5]
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       USBH_FreePipe
    361            
    362            return USBH_OK;  
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    363          }
    364          
    365          /**
    366            * @brief  HCD_ReEnumerate 
    367            *         Perform a new Enumeration phase.
    368            * @param  phost: Host Handle
    369            * @retval USBH Status
    370            */

   \                                 In section .text, align 2, keep-with-next
    371          USBH_StatusTypeDef  USBH_ReEnumerate   (USBH_HandleTypeDef *phost)
    372          {
   \                     USBH_ReEnumerate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    373            /*Stop Host */ 
    374            USBH_Stop(phost);
   \   00000004   0x.... 0x....      BL       USBH_Stop
    375          
    376            /*Device has disconnected, so wait for 200 ms */  
    377            USBH_Delay(200);
   \   00000008   0x20C8             MOVS     R0,#+200
   \   0000000A   0x.... 0x....      BL       USBH_Delay
    378            
    379            /* Set State machines in default state */
    380            DeInitStateMachine(phost);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       DeInitStateMachine
    381             
    382            /* Start again the host */
    383            USBH_Start(phost);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       USBH_Start
    384                
    385          #if (USBH_USE_OS == 1)
    386                osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    387          #endif  
    388            return USBH_OK;  
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    389          }
    390          
    391          /**
    392            * @brief  USBH_Process 
    393            *         Background process of the USB Core.
    394            * @param  phost: Host Handle
    395            * @retval USBH Status
    396            */

   \                                 In section .text, align 4, keep-with-next
    397          USBH_StatusTypeDef  USBH_Process(USBH_HandleTypeDef *phost)
    398          {
   \                     USBH_Process: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4604             MOV      R4,R0
    399            __IO USBH_StatusTypeDef status = USBH_FAIL;
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
    400            uint8_t idx = 0;
    401            
    402            switch (phost->gState)
   \   0000000C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000010   0x280A             CMP      R0,#+10
   \   00000012   0xF200 0x80C0      BHI.W    ??USBH_Process_1
   \   00000016   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??USBH_Process_0:
   \   0000001A   0x06 0xBE          DC8      0x6,0xBE,0x14,0xB1
   \              0x14 0xB1    
   \   0000001E   0xBE 0x45          DC8      0xBE,0x45,0x96,0x57
   \              0x96 0x57    
   \   00000022   0x61 0x6B          DC8      0x61,0x6B,0xA9,0x0
   \              0xA9 0x00    
    403            {
    404            case HOST_IDLE :
    405              
    406              if (phost->device.is_connected)  
   \                     ??USBH_Process_2: (+1)
   \   00000026   0xF894 0x031E      LDRB     R0,[R4, #+798]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xF000 0x80B3      BEQ.W    ??USBH_Process_1
    407              {
    408                /* Wait for 200 ms after connection */
    409                phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT; 
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x7020             STRB     R0,[R4, #+0]
    410                USBH_Delay(200); 
   \   00000034   0x20C8             MOVS     R0,#+200
   \   00000036   0x.... 0x....      BL       USBH_Delay
    411                USBH_LL_ResetPort(phost);
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       USBH_LL_ResetPort
   \   00000040   0xE0A9             B.N      ??USBH_Process_1
    412          #if (USBH_USE_OS == 1)
    413                osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    414          #endif
    415              }
    416              break;
    417              
    418            case HOST_DEV_WAIT_FOR_ATTACHMENT:
    419              break;    
    420              
    421            case HOST_DEV_ATTACHED :
    422              
    423              USBH_UsrLog("USB Device Attached");  
    424                
    425              /* Wait for 100 ms after Reset */
    426              USBH_Delay(100); 
   \                     ??USBH_Process_3: (+1)
   \   00000042   0x2064             MOVS     R0,#+100
   \   00000044   0x.... 0x....      BL       USBH_Delay
    427                    
    428              phost->device.speed = USBH_LL_GetSpeed(phost);
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       USBH_LL_GetSpeed
   \   0000004E   0xF884 0x031D      STRB     R0,[R4, #+797]
    429              
    430              phost->gState = HOST_ENUMERATION;
   \   00000052   0x2005             MOVS     R0,#+5
   \   00000054   0x7020             STRB     R0,[R4, #+0]
    431              
    432              phost->Control.pipe_out = USBH_AllocPipe (phost, 0x00);
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       USBH_AllocPipe
   \   0000005E   0x7160             STRB     R0,[R4, #+5]
    433              phost->Control.pipe_in  = USBH_AllocPipe (phost, 0x80);    
   \   00000060   0x2180             MOVS     R1,#+128
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       USBH_AllocPipe
   \   00000068   0x7120             STRB     R0,[R4, #+4]
    434              
    435              
    436              /* Open Control pipes */
    437              USBH_OpenPipe (phost,
    438                             phost->Control.pipe_in,
    439                             0x80,
    440                             phost->device.address,
    441                             phost->device.speed,
    442                             USBH_EP_CONTROL,
    443                             phost->Control.pipe_size); 
   \   0000006A   0x79A1             LDRB     R1,[R4, #+6]
   \   0000006C   0x9102             STR      R1,[SP, #+8]
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x9101             STR      R1,[SP, #+4]
   \   00000072   0xF894 0x131D      LDRB     R1,[R4, #+797]
   \   00000076   0x9100             STR      R1,[SP, #+0]
   \   00000078   0xF894 0x331C      LDRB     R3,[R4, #+796]
   \   0000007C   0x2280             MOVS     R2,#+128
   \   0000007E   0x4601             MOV      R1,R0
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       USBH_OpenPipe
    444              
    445              /* Open Control pipes */
    446              USBH_OpenPipe (phost,
    447                             phost->Control.pipe_out,
    448                             0x00,
    449                             phost->device.address,
    450                             phost->device.speed,
    451                             USBH_EP_CONTROL,
    452                             phost->Control.pipe_size);
   \   00000086   0x79A0             LDRB     R0,[R4, #+6]
   \   00000088   0x9002             STR      R0,[SP, #+8]
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x9001             STR      R0,[SP, #+4]
   \   0000008E   0xF894 0x031D      LDRB     R0,[R4, #+797]
   \   00000092   0x9000             STR      R0,[SP, #+0]
   \   00000094   0xF894 0x331C      LDRB     R3,[R4, #+796]
   \   00000098   0x2200             MOVS     R2,#+0
   \   0000009A   0x7961             LDRB     R1,[R4, #+5]
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       USBH_OpenPipe
    453              
    454          #if (USBH_USE_OS == 1)
    455              osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    456          #endif    
    457              
    458              break;
   \   000000A2   0xE078             B.N      ??USBH_Process_1
    459              
    460            case HOST_ENUMERATION:     
    461              /* Check for enumeration status */  
    462              if ( USBH_HandleEnum(phost) == USBH_OK)
   \                     ??USBH_Process_4: (+1)
   \   000000A4   0x4620             MOV      R0,R4
   \   000000A6   0x.... 0x....      BL       USBH_HandleEnum
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD173             BNE.N    ??USBH_Process_1
    463              { 
    464                /* The function shall return USBH_OK when full enumeration is complete */
    465                USBH_UsrLog ("Enumeration done.");
    466                phost->device.current_interface = 0;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xF884 0x031F      STRB     R0,[R4, #+799]
    467                if(phost->device.DevDesc.bNumConfigurations == 1)
   \   000000B4   0xF894 0x0331      LDRB     R0,[R4, #+817]
   \   000000B8   0x2801             CMP      R0,#+1
   \   000000BA   0xD102             BNE.N    ??USBH_Process_5
    468                {
    469                  USBH_UsrLog ("This device has only 1 configuration.");
    470                  phost->gState  = HOST_SET_CONFIGURATION;        
   \   000000BC   0x2008             MOVS     R0,#+8
   \   000000BE   0x7020             STRB     R0,[R4, #+0]
   \   000000C0   0xE069             B.N      ??USBH_Process_1
    471                  
    472                }
    473                else
    474                {
    475                  phost->gState  = HOST_INPUT; 
   \                     ??USBH_Process_5: (+1)
   \   000000C2   0x2007             MOVS     R0,#+7
   \   000000C4   0x7020             STRB     R0,[R4, #+0]
   \   000000C6   0xE066             B.N      ??USBH_Process_1
    476                }
    477                    
    478              }
    479              break;
    480              
    481            case HOST_INPUT:
    482              {
    483                /* user callback for end of device basic enumeration */
    484                if(phost->pUser != NULL)
   \                     ??USBH_Process_6: (+1)
   \   000000C8   0xF8D4 0x23C4      LDR      R2,[R4, #+964]
   \   000000CC   0x0010             MOVS     R0,R2
   \   000000CE   0xD062             BEQ.N    ??USBH_Process_1
    485                {
    486                  phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
   \   000000D0   0x2101             MOVS     R1,#+1
   \   000000D2   0x4620             MOV      R0,R4
   \   000000D4   0x4790             BLX      R2
    487                  phost->gState = HOST_SET_CONFIGURATION;
   \   000000D6   0x2008             MOVS     R0,#+8
   \   000000D8   0x7020             STRB     R0,[R4, #+0]
   \   000000DA   0xE05C             B.N      ??USBH_Process_1
    488                  
    489          #if (USBH_USE_OS == 1)
    490                  osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    491          #endif         
    492                }
    493              }
    494              break;
    495              
    496            case HOST_SET_CONFIGURATION:
    497              /* set configuration */
    498              if (USBH_SetCfg(phost, phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
   \                     ??USBH_Process_7: (+1)
   \   000000DC   0xF894 0x1337      LDRB     R1,[R4, #+823]
   \   000000E0   0x4620             MOV      R0,R4
   \   000000E2   0x.... 0x....      BL       USBH_SetCfg
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD155             BNE.N    ??USBH_Process_1
    499              {
    500                phost->gState  = HOST_CHECK_CLASS;
   \   000000EA   0x2009             MOVS     R0,#+9
   \   000000EC   0x7020             STRB     R0,[R4, #+0]
   \   000000EE   0xE052             B.N      ??USBH_Process_1
    501                USBH_UsrLog ("Default configuration set.");
    502                
    503              }      
    504              
    505              break;
    506              
    507            case HOST_CHECK_CLASS:
    508              
    509              if(phost->ClassNumber == 0)
   \                     ??USBH_Process_8: (+1)
   \   000000F0   0xF8D4 0x0378      LDR      R0,[R4, #+888]
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD04E             BEQ.N    ??USBH_Process_1
    510              {
    511                USBH_UsrLog ("No Class has been registered.");
    512              }
    513              else
    514              {
    515                phost->pActiveClass = NULL;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xF8C4 0x0374      STR      R0,[R4, #+884]
    516                
    517                for (idx = 0; idx < USBH_MAX_NUM_SUPPORTED_CLASS ; idx ++)
   \   000000FE   0xE009             B.N      ??USBH_Process_9
    518                {
    519                  if(phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[0].bInterfaceClass)
   \                     ??USBH_Process_10: (+1)
   \   00000100   0xF8D4 0x0370      LDR      R0,[R4, #+880]
   \   00000104   0x7901             LDRB     R1,[R0, #+4]
   \   00000106   0xF894 0x2341      LDRB     R2,[R4, #+833]
   \   0000010A   0x4291             CMP      R1,R2
   \   0000010C   0xD101             BNE.N    ??USBH_Process_11
    520                  {
    521                    phost->pActiveClass = phost->pClass[idx];
   \   0000010E   0xF8C4 0x0374      STR      R0,[R4, #+884]
    522                  }
    523                }
   \                     ??USBH_Process_11: (+1)
   \   00000112   0x2001             MOVS     R0,#+1
   \                     ??USBH_Process_9: (+1)
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD0F3             BEQ.N    ??USBH_Process_10
    524                
    525                if(phost->pActiveClass != NULL)
   \   00000118   0xF8D4 0x1374      LDR      R1,[R4, #+884]
   \   0000011C   0x2900             CMP      R1,#+0
   \   0000011E   0xD00F             BEQ.N    ??USBH_Process_12
    526                {
    527                  if(phost->pActiveClass->Init(phost)== USBH_OK)
   \   00000120   0x4620             MOV      R0,R4
   \   00000122   0x6889             LDR      R1,[R1, #+8]
   \   00000124   0x4788             BLX      R1
   \   00000126   0x2800             CMP      R0,#+0
   \   00000128   0xD107             BNE.N    ??USBH_Process_13
    528                  {
    529                    phost->gState  = HOST_CLASS_REQUEST; 
   \   0000012A   0x2006             MOVS     R0,#+6
   \   0000012C   0x7020             STRB     R0,[R4, #+0]
    530                    USBH_UsrLog ("%s class started.", phost->pActiveClass->Name);
    531                    
    532                    /* Inform user that a class has been activated */
    533                    phost->pUser(phost, HOST_USER_CLASS_SELECTED);   
   \   0000012E   0x2103             MOVS     R1,#+3
   \   00000130   0x4620             MOV      R0,R4
   \   00000132   0xF8D4 0x23C4      LDR      R2,[R4, #+964]
   \   00000136   0x4790             BLX      R2
   \   00000138   0xE02D             B.N      ??USBH_Process_1
    534                  }
    535                  else
    536                  {
    537                    phost->gState  = HOST_ABORT_STATE;
   \                     ??USBH_Process_13: (+1)
   \   0000013A   0x200C             MOVS     R0,#+12
   \   0000013C   0x7020             STRB     R0,[R4, #+0]
   \   0000013E   0xE02A             B.N      ??USBH_Process_1
    538                    USBH_UsrLog ("Device not supporting %s class.", phost->pActiveClass->Name);
    539                  }
    540                }
    541                else
    542                {
    543                  phost->gState  = HOST_ABORT_STATE;
   \                     ??USBH_Process_12: (+1)
   \   00000140   0x200C             MOVS     R0,#+12
   \   00000142   0x7020             STRB     R0,[R4, #+0]
   \   00000144   0xE027             B.N      ??USBH_Process_1
    544                  USBH_UsrLog ("No registered class for this device.");
    545                }
    546              }
    547              
    548          #if (USBH_USE_OS == 1)
    549              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    550          #endif 
    551              break;    
    552              
    553            case HOST_CLASS_REQUEST:  
    554              /* process class standard control requests state machine */
    555              if(phost->pActiveClass != NULL)
   \                     ??USBH_Process_14: (+1)
   \   00000146   0xF8D4 0x1374      LDR      R1,[R4, #+884]
   \   0000014A   0x2900             CMP      R1,#+0
   \   0000014C   0xD00B             BEQ.N    ??USBH_Process_15
    556              {
    557                status = phost->pActiveClass->Requests(phost);
   \   0000014E   0x4620             MOV      R0,R4
   \   00000150   0x6909             LDR      R1,[R1, #+16]
   \   00000152   0x4788             BLX      R1
   \   00000154   0xF88D 0x0000      STRB     R0,[SP, #+0]
    558                
    559                if(status == USBH_OK)
   \   00000158   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   0000015C   0x2800             CMP      R0,#+0
   \   0000015E   0xD11A             BNE.N    ??USBH_Process_1
    560                {
    561                  phost->gState  = HOST_CLASS;        
   \   00000160   0x200A             MOVS     R0,#+10
   \   00000162   0x7020             STRB     R0,[R4, #+0]
   \   00000164   0xE017             B.N      ??USBH_Process_1
    562                }  
    563              }
    564              else
    565              {
    566                phost->gState  = HOST_ABORT_STATE;
   \                     ??USBH_Process_15: (+1)
   \   00000166   0x200C             MOVS     R0,#+12
   \   00000168   0x7020             STRB     R0,[R4, #+0]
   \   0000016A   0xE014             B.N      ??USBH_Process_1
    567                USBH_ErrLog ("Invalid Class Driver.");
    568              
    569          #if (USBH_USE_OS == 1)
    570              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    571          #endif       
    572              }
    573              
    574              break;    
    575            case HOST_CLASS:   
    576              /* process class state machine */
    577              if(phost->pActiveClass != NULL)
   \                     ??USBH_Process_16: (+1)
   \   0000016C   0xF8D4 0x1374      LDR      R1,[R4, #+884]
   \   00000170   0x2900             CMP      R1,#+0
   \   00000172   0xD010             BEQ.N    ??USBH_Process_1
    578              { 
    579                phost->pActiveClass->BgndProcess(phost);
   \   00000174   0x4620             MOV      R0,R4
   \   00000176   0x6949             LDR      R1,[R1, #+20]
   \   00000178   0x4788             BLX      R1
   \   0000017A   0xE00C             B.N      ??USBH_Process_1
    580              }
    581              break;       
    582          
    583            case HOST_DEV_DISCONNECTED :
    584              
    585              DeInitStateMachine(phost);  
   \                     ??USBH_Process_17: (+1)
   \   0000017C   0x4620             MOV      R0,R4
   \   0000017E   0x.... 0x....      BL       DeInitStateMachine
    586              
    587              /* Re-Initilaize Host for new Enumeration */
    588              if(phost->pActiveClass != NULL)
   \   00000182   0xF8D4 0x1374      LDR      R1,[R4, #+884]
   \   00000186   0x2900             CMP      R1,#+0
   \   00000188   0xD005             BEQ.N    ??USBH_Process_1
    589              {
    590                phost->pActiveClass->DeInit(phost); 
   \   0000018A   0x4620             MOV      R0,R4
   \   0000018C   0x68C9             LDR      R1,[R1, #+12]
   \   0000018E   0x4788             BLX      R1
    591                phost->pActiveClass = NULL;
   \   00000190   0x2000             MOVS     R0,#+0
   \   00000192   0xF8C4 0x0374      STR      R0,[R4, #+884]
    592              }     
    593              break;
    594              
    595            case HOST_ABORT_STATE:
    596            default :
    597              break;
    598            }
    599           return USBH_OK;  
   \                     ??USBH_Process_1: (+1)
   \   00000196   0x2000             MOVS     R0,#+0
   \   00000198   0xB004             ADD      SP,SP,#+16
   \   0000019A   0xBD10             POP      {R4,PC}          ;; return
    600          }
    601          
    602          
    603          /**
    604            * @brief  USBH_HandleEnum 
    605            *         This function includes the complete enumeration process
    606            * @param  phost: Host Handle
    607            * @retval USBH_Status
    608            */

   \                                 In section .text, align 4, keep-with-next
    609          static USBH_StatusTypeDef USBH_HandleEnum (USBH_HandleTypeDef *phost)
    610          {
   \                     USBH_HandleEnum: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    611            USBH_StatusTypeDef Status = USBH_BUSY;  
   \   00000004   0x2501             MOVS     R5,#+1
    612            
    613            switch (phost->EnumState)
   \   00000006   0xF994 0x0001      LDRSB    R0,[R4, #+1]
   \   0000000A   0x2807             CMP      R0,#+7
   \   0000000C   0xF200 0x80AE      BHI.W    ??USBH_HandleEnum_1
   \   00000010   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??USBH_HandleEnum_0:
   \   00000014   0x04 0x2D          DC8      0x4,0x2D,0x36,0x62
   \              0x36 0x62    
   \   00000018   0x6B 0x76          DC8      0x6B,0x76,0x89,0x9C
   \              0x89 0x9C    
    614            {
    615            case ENUM_IDLE:  
    616              /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
    617              if ( USBH_Get_DevDesc(phost, 8) == USBH_OK)
   \                     ??USBH_HandleEnum_2: (+1)
   \   0000001C   0x2108             MOVS     R1,#+8
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       USBH_Get_DevDesc
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xF040 0x80A1      BNE.W    ??USBH_HandleEnum_1
    618              {
    619                phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
   \   0000002A   0xF504 0x7647      ADD      R6,R4,#+796
   \   0000002E   0x1C67             ADDS     R7,R4,#+1
   \   00000030   0x7AF0             LDRB     R0,[R6, #+11]
   \   00000032   0x7178             STRB     R0,[R7, #+5]
    620          
    621                phost->EnumState = ENUM_GET_FULL_DEV_DESC;
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x7060             STRB     R0,[R4, #+1]
    622                
    623                /* modify control channels configuration for MaxPacket size */
    624                USBH_OpenPipe (phost,
    625                                     phost->Control.pipe_in,
    626                                     0x80,
    627                                     phost->device.address,
    628                                     phost->device.speed,
    629                                     USBH_EP_CONTROL,
    630                                     phost->Control.pipe_size); 
   \   00000038   0x7978             LDRB     R0,[R7, #+5]
   \   0000003A   0x9002             STR      R0,[SP, #+8]
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   \   00000040   0x7870             LDRB     R0,[R6, #+1]
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0xF894 0x331C      LDRB     R3,[R4, #+796]
   \   00000048   0x2280             MOVS     R2,#+128
   \   0000004A   0x78F9             LDRB     R1,[R7, #+3]
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       USBH_OpenPipe
    631                
    632                /* Open Control pipes */
    633                USBH_OpenPipe (phost,
    634                                     phost->Control.pipe_out,
    635                                     0x00,
    636                                     phost->device.address,
    637                                     phost->device.speed,
    638                                     USBH_EP_CONTROL,
    639                                     phost->Control.pipe_size);           
   \   00000052   0x7978             LDRB     R0,[R7, #+5]
   \   00000054   0x9002             STR      R0,[SP, #+8]
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x9001             STR      R0,[SP, #+4]
   \   0000005A   0x7870             LDRB     R0,[R6, #+1]
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0xF894 0x331C      LDRB     R3,[R4, #+796]
   \   00000062   0x2200             MOVS     R2,#+0
   \   00000064   0x7939             LDRB     R1,[R7, #+4]
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       USBH_OpenPipe
   \   0000006C   0xE07E             B.N      ??USBH_HandleEnum_1
    640                
    641              }
    642              break;
    643              
    644            case ENUM_GET_FULL_DEV_DESC:  
    645              /* Get FULL Device Desc  */
    646              if ( USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE)== USBH_OK)
   \                     ??USBH_HandleEnum_3: (+1)
   \   0000006E   0x2112             MOVS     R1,#+18
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       USBH_Get_DevDesc
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD178             BNE.N    ??USBH_HandleEnum_1
    647              {
    648                USBH_UsrLog("PID: %xh", phost->device.DevDesc.idProduct );  
    649                USBH_UsrLog("VID: %xh", phost->device.DevDesc.idVendor );  
    650                
    651                phost->EnumState = ENUM_SET_ADDR;
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0x7060             STRB     R0,[R4, #+1]
   \   0000007E   0xE075             B.N      ??USBH_HandleEnum_1
    652                 
    653              }
    654              break;
    655             
    656            case ENUM_SET_ADDR: 
    657              /* set address */
    658              if ( USBH_SetAddress(phost, USBH_DEVICE_ADDRESS) == USBH_OK)
   \                     ??USBH_HandleEnum_4: (+1)
   \   00000080   0x4629             MOV      R1,R5
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       USBH_SetAddress
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD16F             BNE.N    ??USBH_HandleEnum_1
    659              {
    660                USBH_Delay(2);
   \   0000008C   0x2002             MOVS     R0,#+2
   \   0000008E   0x.... 0x....      BL       USBH_Delay
    661                phost->device.address = USBH_DEVICE_ADDRESS;
   \   00000092   0x4628             MOV      R0,R5
   \   00000094   0xF884 0x031C      STRB     R0,[R4, #+796]
    662                
    663                /* user callback for device address assigned */
    664                USBH_UsrLog("Address (#%d) assigned.", phost->device.address);
    665                phost->EnumState = ENUM_GET_CFG_DESC;
   \   00000098   0x2003             MOVS     R0,#+3
   \   0000009A   0x7060             STRB     R0,[R4, #+1]
    666                
    667                /* modify control channels to update device address */
    668                USBH_OpenPipe (phost,
    669                                     phost->Control.pipe_in,
    670                                     0x80,
    671                                     phost->device.address,
    672                                     phost->device.speed,
    673                                     USBH_EP_CONTROL,
    674                                     phost->Control.pipe_size); 
   \   0000009C   0xF504 0x7647      ADD      R6,R4,#+796
   \   000000A0   0x1C67             ADDS     R7,R4,#+1
   \   000000A2   0x7978             LDRB     R0,[R7, #+5]
   \   000000A4   0x9002             STR      R0,[SP, #+8]
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x9001             STR      R0,[SP, #+4]
   \   000000AA   0x7870             LDRB     R0,[R6, #+1]
   \   000000AC   0x9000             STR      R0,[SP, #+0]
   \   000000AE   0xF894 0x331C      LDRB     R3,[R4, #+796]
   \   000000B2   0x2280             MOVS     R2,#+128
   \   000000B4   0x78F9             LDRB     R1,[R7, #+3]
   \   000000B6   0x4620             MOV      R0,R4
   \   000000B8   0x.... 0x....      BL       USBH_OpenPipe
    675                
    676                /* Open Control pipes */
    677                USBH_OpenPipe (phost,
    678                                     phost->Control.pipe_out,
    679                                     0x00,
    680                                     phost->device.address,
    681                                     phost->device.speed,
    682                                     USBH_EP_CONTROL,
    683                                     phost->Control.pipe_size);        
   \   000000BC   0x7978             LDRB     R0,[R7, #+5]
   \   000000BE   0x9002             STR      R0,[SP, #+8]
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x9001             STR      R0,[SP, #+4]
   \   000000C4   0x7870             LDRB     R0,[R6, #+1]
   \   000000C6   0x9000             STR      R0,[SP, #+0]
   \   000000C8   0xF894 0x331C      LDRB     R3,[R4, #+796]
   \   000000CC   0x2200             MOVS     R2,#+0
   \   000000CE   0x7939             LDRB     R1,[R7, #+4]
   \   000000D0   0x4620             MOV      R0,R4
   \   000000D2   0x.... 0x....      BL       USBH_OpenPipe
   \   000000D6   0xE049             B.N      ??USBH_HandleEnum_1
    684              }
    685              break;
    686              
    687            case ENUM_GET_CFG_DESC:  
    688              /* get standard configuration descriptor */
    689              if ( USBH_Get_CfgDesc(phost, 
    690                                    USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
   \                     ??USBH_HandleEnum_5: (+1)
   \   000000D8   0x2109             MOVS     R1,#+9
   \   000000DA   0x4620             MOV      R0,R4
   \   000000DC   0x.... 0x....      BL       USBH_Get_CfgDesc
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD143             BNE.N    ??USBH_HandleEnum_1
    691              {
    692                phost->EnumState = ENUM_GET_FULL_CFG_DESC;        
   \   000000E4   0x2004             MOVS     R0,#+4
   \   000000E6   0x7060             STRB     R0,[R4, #+1]
   \   000000E8   0xE040             B.N      ??USBH_HandleEnum_1
    693              }
    694              break;
    695              
    696            case ENUM_GET_FULL_CFG_DESC:  
    697              /* get FULL config descriptor (config, interface, endpoints) */
    698              if (USBH_Get_CfgDesc(phost, 
    699                                   phost->device.CfgDesc.wTotalLength) == USBH_OK)
   \                     ??USBH_HandleEnum_6: (+1)
   \   000000EA   0xF504 0x7047      ADD      R0,R4,#+796
   \   000000EE   0x8B01             LDRH     R1,[R0, #+24]
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0x.... 0x....      BL       USBH_Get_CfgDesc
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD138             BNE.N    ??USBH_HandleEnum_1
    700              {
    701                phost->EnumState = ENUM_GET_MFC_STRING_DESC;       
   \   000000FA   0x2005             MOVS     R0,#+5
   \   000000FC   0x7060             STRB     R0,[R4, #+1]
   \   000000FE   0xE035             B.N      ??USBH_HandleEnum_1
    702              }
    703              break;
    704              
    705            case ENUM_GET_MFC_STRING_DESC:  
    706              if (phost->device.DevDesc.iManufacturer != 0)
   \                     ??USBH_HandleEnum_7: (+1)
   \   00000100   0xF504 0x7647      ADD      R6,R4,#+796
   \   00000104   0x7CB1             LDRB     R1,[R6, #+18]
   \   00000106   0x2900             CMP      R1,#+0
   \   00000108   0xD00A             BEQ.N    ??USBH_HandleEnum_8
    707              { /* Check that Manufacturer String is available */
    708                
    709                if ( USBH_Get_StringDesc(phost,
    710                                         phost->device.DevDesc.iManufacturer, 
    711                                          phost->device.Data , 
    712                                         0xff) == USBH_OK)
   \   0000010A   0x23FF             MOVS     R3,#+255
   \   0000010C   0xF504 0x728E      ADD      R2,R4,#+284
   \   00000110   0x4620             MOV      R0,R4
   \   00000112   0x.... 0x....      BL       USBH_Get_StringDesc
   \   00000116   0x2800             CMP      R0,#+0
   \   00000118   0xD128             BNE.N    ??USBH_HandleEnum_1
    713                {
    714                  /* User callback for Manufacturing string */
    715                  USBH_UsrLog("Manufacturer : %s",  (char *)phost->device.Data);
    716                  phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
   \   0000011A   0x2006             MOVS     R0,#+6
   \   0000011C   0x7060             STRB     R0,[R4, #+1]
   \   0000011E   0xE025             B.N      ??USBH_HandleEnum_1
    717                  
    718          #if (USBH_USE_OS == 1)
    719              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    720          #endif          
    721                }
    722              }
    723              else
    724              {
    725               USBH_UsrLog("Manufacturer : N/A");      
    726               phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC; 
   \                     ??USBH_HandleEnum_8: (+1)
   \   00000120   0x2006             MOVS     R0,#+6
   \   00000122   0x7060             STRB     R0,[R4, #+1]
   \   00000124   0xE022             B.N      ??USBH_HandleEnum_1
    727          #if (USBH_USE_OS == 1)
    728              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    729          #endif       
    730              }
    731              break;
    732              
    733            case ENUM_GET_PRODUCT_STRING_DESC:   
    734              if (phost->device.DevDesc.iProduct != 0)
   \                     ??USBH_HandleEnum_9: (+1)
   \   00000126   0xF504 0x7647      ADD      R6,R4,#+796
   \   0000012A   0x7CF1             LDRB     R1,[R6, #+19]
   \   0000012C   0x2900             CMP      R1,#+0
   \   0000012E   0xD00A             BEQ.N    ??USBH_HandleEnum_10
    735              { /* Check that Product string is available */
    736                if ( USBH_Get_StringDesc(phost,
    737                                         phost->device.DevDesc.iProduct, 
    738                                         phost->device.Data, 
    739                                         0xff) == USBH_OK)
   \   00000130   0x23FF             MOVS     R3,#+255
   \   00000132   0xF504 0x728E      ADD      R2,R4,#+284
   \   00000136   0x4620             MOV      R0,R4
   \   00000138   0x.... 0x....      BL       USBH_Get_StringDesc
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD115             BNE.N    ??USBH_HandleEnum_1
    740                {
    741                  /* User callback for Product string */
    742                  USBH_UsrLog("Product : %s",  (char *)phost->device.Data);
    743                  phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;        
   \   00000140   0x2007             MOVS     R0,#+7
   \   00000142   0x7060             STRB     R0,[R4, #+1]
   \   00000144   0xE012             B.N      ??USBH_HandleEnum_1
    744                }
    745              }
    746              else
    747              {
    748                USBH_UsrLog("Product : N/A");
    749                phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC; 
   \                     ??USBH_HandleEnum_10: (+1)
   \   00000146   0x2007             MOVS     R0,#+7
   \   00000148   0x7060             STRB     R0,[R4, #+1]
   \   0000014A   0xE00F             B.N      ??USBH_HandleEnum_1
    750          #if (USBH_USE_OS == 1)
    751              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    752          #endif        
    753              } 
    754              break;
    755              
    756            case ENUM_GET_SERIALNUM_STRING_DESC:   
    757              if (phost->device.DevDesc.iSerialNumber != 0)
   \                     ??USBH_HandleEnum_11: (+1)
   \   0000014C   0xF504 0x7647      ADD      R6,R4,#+796
   \   00000150   0x7D31             LDRB     R1,[R6, #+20]
   \   00000152   0x2900             CMP      R1,#+0
   \   00000154   0xD009             BEQ.N    ??USBH_HandleEnum_12
    758              { /* Check that Serial number string is available */    
    759                if ( USBH_Get_StringDesc(phost,
    760                                         phost->device.DevDesc.iSerialNumber, 
    761                                         phost->device.Data, 
    762                                         0xff) == USBH_OK)
   \   00000156   0x23FF             MOVS     R3,#+255
   \   00000158   0xF504 0x728E      ADD      R2,R4,#+284
   \   0000015C   0x4620             MOV      R0,R4
   \   0000015E   0x.... 0x....      BL       USBH_Get_StringDesc
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD102             BNE.N    ??USBH_HandleEnum_1
    763                {
    764                  /* User callback for Serial number string */
    765                   USBH_UsrLog("Serial Number : %s",  (char *)phost->device.Data);
    766                  Status = USBH_OK;
   \   00000166   0x2500             MOVS     R5,#+0
   \   00000168   0xE000             B.N      ??USBH_HandleEnum_1
    767                }
    768              }
    769              else
    770              {
    771                USBH_UsrLog("Serial Number : N/A"); 
    772                Status = USBH_OK;
   \                     ??USBH_HandleEnum_12: (+1)
   \   0000016A   0x2500             MOVS     R5,#+0
    773          #if (USBH_USE_OS == 1)
    774              osMessagePut ( phost->os_event, USBH_STATE_CHANGED_EVENT, 0);
    775          #endif        
    776              }  
    777              break;
    778              
    779            default:
    780              break;
    781            }  
    782            return Status;
   \                     ??USBH_HandleEnum_1: (+1)
   \   0000016C   0x4628             MOV      R0,R5
   \   0000016E   0xBDFE             POP      {R1-R7,PC}       ;; return
    783          }
    784          
    785          /**
    786            * @brief  USBH_LL_SetTimer 
    787            *         Set the initial Host Timer tick
    788            * @param  phost: Host Handle
    789            * @retval None
    790            */

   \                                 In section .text, align 2, keep-with-next
    791          void  USBH_LL_SetTimer  (USBH_HandleTypeDef *phost, uint32_t time)
    792          {
    793            phost->Timer = time;
   \                     USBH_LL_SetTimer: (+1)
   \   00000000   0xF8C0 0x13B8      STR      R1,[R0, #+952]
    794          }
   \   00000004   0x4770             BX       LR               ;; return
    795          /**
    796            * @brief  USBH_LL_IncTimer 
    797            *         Increment Host Timer tick
    798            * @param  phost: Host Handle
    799            * @retval None
    800            */

   \                                 In section .text, align 2, keep-with-next
    801          void  USBH_LL_IncTimer  (USBH_HandleTypeDef *phost)
    802          {
    803            phost->Timer ++;
   \                     USBH_LL_IncTimer: (+1)
   \   00000000   0xF8D0 0x13B8      LDR      R1,[R0, #+952]
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \   00000006   0xF8C0 0x13B8      STR      R1,[R0, #+952]
    804            USBH_HandleSof(phost);
   \   0000000A                      REQUIRE USBH_HandleSof
   \   0000000A                      ;; // Fall through to label USBH_HandleSof
    805          }
    806          
    807          /**
    808            * @brief  USBH_HandleSof 
    809            *         Call SOF process
    810            * @param  phost: Host Handle
    811            * @retval None
    812            */

   \                                 In section .text, align 2, keep-with-next
    813          void  USBH_HandleSof  (USBH_HandleTypeDef *phost)
    814          {
    815            if((phost->gState == HOST_CLASS)&&(phost->pActiveClass != NULL))
   \                     USBH_HandleSof: (+1)
   \   00000000   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \   00000004   0x290A             CMP      R1,#+10
   \   00000006   0xD105             BNE.N    ??USBH_HandleSof_0
   \   00000008   0xF8D0 0x1374      LDR      R1,[R0, #+884]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ.N    ??USBH_HandleSof_0
    816            {
    817              phost->pActiveClass->SOFProcess(phost);
   \   00000010   0x6989             LDR      R1,[R1, #+24]
   \   00000012   0x4708             BX       R1
    818            }
    819          }
   \                     ??USBH_HandleSof_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    820          /**
    821            * @brief  USBH_LL_Connect 
    822            *         Handle USB Host connexion event
    823            * @param  phost: Host Handle
    824            * @retval USBH_Status
    825            */

   \                                 In section .text, align 2, keep-with-next
    826          USBH_StatusTypeDef  USBH_LL_Connect  (USBH_HandleTypeDef *phost)
    827          {
   \                     USBH_LL_Connect: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    828            if(phost->gState == HOST_IDLE )
   \   00000002   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD109             BNE.N    ??USBH_LL_Connect_0
    829            {
    830              phost->device.is_connected = 1;
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0xF880 0x131E      STRB     R1,[R0, #+798]
    831              
    832              if(phost->pUser != NULL)
   \   00000010   0xF8D0 0x23C4      LDR      R2,[R0, #+964]
   \   00000014   0x0011             MOVS     R1,R2
   \   00000016   0xD008             BEQ.N    ??USBH_LL_Connect_1
    833              {    
    834                phost->pUser(phost, HOST_USER_CONNECTION);
   \   00000018   0x2104             MOVS     R1,#+4
   \   0000001A   0x4790             BLX      R2
   \   0000001C   0xE005             B.N      ??USBH_LL_Connect_1
    835              }
    836            } 
    837            else if(phost->gState == HOST_DEV_WAIT_FOR_ATTACHMENT )
   \                     ??USBH_LL_Connect_0: (+1)
   \   0000001E   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \   00000022   0x2901             CMP      R1,#+1
   \   00000024   0xD101             BNE.N    ??USBH_LL_Connect_1
    838            {
    839              phost->gState = HOST_DEV_ATTACHED ;
   \   00000026   0x2102             MOVS     R1,#+2
   \   00000028   0x7001             STRB     R1,[R0, #+0]
    840            }
    841          #if (USBH_USE_OS == 1)
    842            osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    843          #endif 
    844            
    845            return USBH_OK;
   \                     ??USBH_LL_Connect_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD02             POP      {R1,PC}          ;; return
    846          }
    847          
    848          /**
    849            * @brief  USBH_LL_Disconnect 
    850            *         Handle USB Host disconnection event
    851            * @param  phost: Host Handle
    852            * @retval USBH_Status
    853            */

   \                                 In section .text, align 2, keep-with-next
    854          USBH_StatusTypeDef  USBH_LL_Disconnect  (USBH_HandleTypeDef *phost)
    855          {
   \                     USBH_LL_Disconnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    856            /*Stop Host */ 
    857            USBH_LL_Stop(phost);  
   \   00000004   0x.... 0x....      BL       USBH_LL_Stop
    858            
    859            /* FRee Control Pipes */
    860            USBH_FreePipe  (phost, phost->Control.pipe_in);
   \   00000008   0x7921             LDRB     R1,[R4, #+4]
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       USBH_FreePipe
    861            USBH_FreePipe  (phost, phost->Control.pipe_out);  
   \   00000010   0x7961             LDRB     R1,[R4, #+5]
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       USBH_FreePipe
    862             
    863            phost->device.is_connected = 0; 
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x031E      STRB     R0,[R4, #+798]
    864             
    865            if(phost->pUser != NULL)
   \   0000001E   0xF8D4 0x23C4      LDR      R2,[R4, #+964]
   \   00000022   0x0010             MOVS     R0,R2
   \   00000024   0xD002             BEQ.N    ??USBH_LL_Disconnect_0
    866            {    
    867              phost->pUser(phost, HOST_USER_DISCONNECTION);
   \   00000026   0x2105             MOVS     R1,#+5
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x4790             BLX      R2
    868            }
    869            USBH_UsrLog("USB Device disconnected"); 
    870            
    871            /* Start the low level driver  */
    872            USBH_LL_Start(phost);
   \                     ??USBH_LL_Disconnect_0: (+1)
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       USBH_LL_Start
    873            
    874            phost->gState = HOST_DEV_DISCONNECTED;
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0x7020             STRB     R0,[R4, #+0]
    875            
    876          #if (USBH_USE_OS == 1)
    877            osMessagePut ( phost->os_event, USBH_PORT_EVENT, 0);
    878          #endif 
    879            
    880            return USBH_OK;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    881          }
    882          
    883          
    884          #if (USBH_USE_OS == 1)  
    885          /**
    886            * @brief  USB Host Thread task
    887            * @param  pvParameters not used
    888            * @retval None
    889            */
    890          static void USBH_Process_OS(void const * argument)
    891          {
    892            osEvent event;
    893            
    894            for(;;)
    895            {
    896              event = osMessageGet(((USBH_HandleTypeDef *)argument)->os_event, osWaitForever );
    897              
    898              if( event.status == osEventMessage )
    899              {
    900                USBH_Process((USBH_HandleTypeDef *)argument);
    901              }
    902             }
    903          }
    904          
    905          /**
    906          * @brief  USBH_LL_NotifyURBChange 
    907          *         Notify URB state Change
    908          * @param  phost: Host handle
    909          * @retval USBH Status
    910          */
    911          USBH_StatusTypeDef  USBH_LL_NotifyURBChange (USBH_HandleTypeDef *phost)
    912          {
    913            osMessagePut ( phost->os_event, USBH_URB_EVENT, 0);
    914            return USBH_OK;
    915          }
    916          #endif  
    917          /**
    918            * @}
    919            */ 
    920          
    921          /**
    922            * @}
    923            */ 
    924          
    925          /**
    926            * @}
    927            */
    928          
    929          /**
    930            * @}
    931            */ 
    932          
    933          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DeInitStateMachine
       8   USBH_DeInit
         8   -> DeInitStateMachine
         8   -> USBH_LL_Stop
      12   USBH_FindInterface
       8   USBH_FindInterfaceIndex
       0   USBH_GetActiveClass
      32   USBH_HandleEnum
        32   -> USBH_Delay
        32   -> USBH_Get_CfgDesc
        32   -> USBH_Get_DevDesc
        32   -> USBH_Get_StringDesc
        32   -> USBH_OpenPipe
        32   -> USBH_SetAddress
       0   USBH_HandleSof
         0   -- Indirect call
      16   USBH_Init
        16   -> DeInitStateMachine
        16   -> USBH_LL_Init
       8   USBH_LL_Connect
         8   -- Indirect call
       8   USBH_LL_Disconnect
         8   -- Indirect call
         8   -> USBH_FreePipe
         8   -> USBH_LL_Start
         8   -> USBH_LL_Stop
       0   USBH_LL_IncTimer
         0   -> USBH_HandleSof
       0   USBH_LL_SetTimer
      24   USBH_Process
        24   -- Indirect call
        24   -> DeInitStateMachine
        24   -> USBH_AllocPipe
        24   -> USBH_Delay
        24   -> USBH_HandleEnum
        24   -> USBH_LL_GetSpeed
        24   -> USBH_LL_ResetPort
        24   -> USBH_OpenPipe
        24   -> USBH_SetCfg
       8   USBH_ReEnumerate
         8   -> DeInitStateMachine
         8   -> USBH_Delay
         8   -> USBH_Start
         8   -> USBH_Stop
       4   USBH_RegisterClass
       0   USBH_SelectInterface
       8   USBH_Start
         8   -> USBH_LL_DriverVBUS
         8   -> USBH_LL_Start
       8   USBH_Stop
         8   -> USBH_FreePipe
         8   -> USBH_LL_DriverVBUS
         8   -> USBH_LL_Stop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      80  DeInitStateMachine
      34  USBH_DeInit
      72  USBH_FindInterface
      54  USBH_FindInterfaceIndex
       6  USBH_GetActiveClass
     368  USBH_HandleEnum
      22  USBH_HandleSof
      52  USBH_Init
      46  USBH_LL_Connect
      58  USBH_LL_Disconnect
      10  USBH_LL_IncTimer
       6  USBH_LL_SetTimer
     412  USBH_Process
      30  USBH_ReEnumerate
      44  USBH_RegisterClass
      22  USBH_SelectInterface
      20  USBH_Start
      36  USBH_Stop

 
 1 372 bytes in section .text
 
 1 372 bytes of CODE memory

Errors: none
Warnings: none
