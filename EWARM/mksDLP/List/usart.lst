###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:30
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  E:\DLP_Proj\DLP_source\branches\DLP_opensource\Src\usart.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Src\usart.c -D
#        USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\usart.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\usart.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Src\usart.c
      1          /**
      2            ******************************************************************************
      3            * File Name          : USART.c
      4            * Description        : This file provides code for the configuration
      5            *                      of the USART instances.
      6            ******************************************************************************
      7            *
      8            * Copyright (c) 2016 STMicroelectronics International N.V. 
      9            * All rights reserved.
     10            *
     11            * Redistribution and use in source and binary forms, with or without 
     12            * modification, are permitted, provided that the following conditions are met:
     13            *
     14            * 1. Redistribution of source code must retain the above copyright notice, 
     15            *    this list of conditions and the following disclaimer.
     16            * 2. Redistributions in binary form must reproduce the above copyright notice,
     17            *    this list of conditions and the following disclaimer in the documentation
     18            *    and/or other materials provided with the distribution.
     19            * 3. Neither the name of STMicroelectronics nor the names of other 
     20            *    contributors to this software may be used to endorse or promote products 
     21            *    derived from this software without specific written permission.
     22            * 4. This software, including modifications and/or derivative works of this 
     23            *    software, must execute solely and exclusively on microcontroller or
     24            *    microprocessor devices manufactured by or for STMicroelectronics.
     25            * 5. Redistribution and use of this software other than as permitted under 
     26            *    this license is void and will automatically terminate your rights under 
     27            *    this license. 
     28            *
     29            * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS" 
     30            * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT 
     31            * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
     32            * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
     33            * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT 
     34            * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
     35            * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     36            * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
     37            * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
     38            * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
     39            * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     40            * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     41            *
     42            ******************************************************************************
     43            */
     44          
     45          /* Includes ------------------------------------------------------------------*/
     46          #include "usart.h"
     47          
     48          #include "gpio.h"
     49          #include "dma.h"
     50          
     51          /* USER CODE BEGIN 0 */
     52          

   \                                 In section .bss, align 4
     53          uint8_t mksRxBuffer[20];
   \                     mksRxBuffer:
   \   00000000                      DS8 20

   \                                 In section .bss, align 1
     54          uint8_t mksUsart3Rx;
   \                     mksUsart3Rx:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     55          uint8_t mksUsart1Rx;
     56          
     57          
     58          /* USER CODE END 0 */
     59          UART_HandleTypeDef huart1;
   \                     huart1:
   \   00000000                      DS8 64
   \                     mksUsart1Rx:
   \   00000040                      DS8 1

   \                                 In section .bss, align 4
     60          UART_HandleTypeDef huart3;
   \                     huart3:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     61          UART_HandleTypeDef huart6;
   \                     huart6:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     62          DMA_HandleTypeDef hdma_usart1_rx;
   \                     hdma_usart1_rx:
   \   00000000                      DS8 96
     63          DMA_HandleTypeDef hdma_usart1_tx;
     64          DMA_HandleTypeDef hdma_usart6_rx;
   \                     hdma_usart6_rx:
   \   00000060                      DS8 96
     65          DMA_HandleTypeDef hdma_usart6_tx;
   \                     hdma_usart6_tx:
   \   000000C0                      DS8 96

   \                                 In section .bss, align 4
   \                     hdma_usart1_tx:
   \   00000000                      DS8 96
     66          /* USART1 init function */
     67          

   \                                 In section .text, align 2, keep-with-next
     68          void MX_USART1_UART_Init(int readId_1)
     69          {
   \                     MX_USART1_UART_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     70            huart1.Instance = USART1;
   \   00000002   0x....             LDR.N    R1,??DataTable5
   \   00000004   0x....             LDR.N    R2,??DataTable5_1  ;; 0x40011000
   \   00000006   0x600A             STR      R2,[R1, #+0]
     71          	switch(readId_1)
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD006             BEQ.N    ??MX_USART1_UART_Init_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD008             BEQ.N    ??MX_USART1_UART_Init_1
   \   00000010   0x2804             CMP      R0,#+4
   \   00000012   0xD00A             BEQ.N    ??MX_USART1_UART_Init_2
   \   00000014   0x2805             CMP      R0,#+5
   \   00000016   0xD00B             BEQ.N    ??MX_USART1_UART_Init_3
   \   00000018   0xE00D             B.N      ??MX_USART1_UART_Init_4
     72          	{
     73          		case 1:huart1.Init.BaudRate = 9600;break;
   \                     ??MX_USART1_UART_Init_0: (+1)
   \   0000001A   0xF44F 0x5016      MOV      R0,#+9600
   \   0000001E   0x6048             STR      R0,[R1, #+4]
   \   00000020   0xE00C             B.N      ??MX_USART1_UART_Init_5
     74          		case 2:huart1.Init.BaudRate = 57600;break;
   \                     ??MX_USART1_UART_Init_1: (+1)
   \   00000022   0xF44F 0x4061      MOV      R0,#+57600
   \   00000026   0x6048             STR      R0,[R1, #+4]
   \   00000028   0xE008             B.N      ??MX_USART1_UART_Init_5
     75          		case 3:huart1.Init.BaudRate = 115200;break;
     76          		case 4:huart1.Init.BaudRate = 250000;break;
   \                     ??MX_USART1_UART_Init_2: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable5_2  ;; 0x3d090
   \   0000002C   0x6048             STR      R0,[R1, #+4]
   \   0000002E   0xE005             B.N      ??MX_USART1_UART_Init_5
     77          		case 5:huart1.Init.BaudRate = 1958400;break;
   \                     ??MX_USART1_UART_Init_3: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable5_3  ;; 0x1de200
   \   00000032   0x6048             STR      R0,[R1, #+4]
   \   00000034   0xE002             B.N      ??MX_USART1_UART_Init_5
     78          		default:huart1.Init.BaudRate = 115200;break;			
   \                     ??MX_USART1_UART_Init_4: (+1)
   \   00000036   0xF44F 0x30E1      MOV      R0,#+115200
   \   0000003A   0x6048             STR      R0,[R1, #+4]
     79          	}
     80          
     81            //huart1.Instance = USART1;
     82            //huart1.Init.BaudRate = 115200;
     83            huart1.Init.WordLength = UART_WORDLENGTH_8B;
   \                     ??MX_USART1_UART_Init_5: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x6088             STR      R0,[R1, #+8]
     84            huart1.Init.StopBits = UART_STOPBITS_1;
   \   00000040   0x60C8             STR      R0,[R1, #+12]
     85            huart1.Init.Parity = UART_PARITY_NONE;
   \   00000042   0x6108             STR      R0,[R1, #+16]
     86            huart1.Init.Mode = UART_MODE_TX_RX;
   \   00000044   0x200C             MOVS     R0,#+12
   \   00000046   0x6148             STR      R0,[R1, #+20]
     87            huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6188             STR      R0,[R1, #+24]
     88            huart1.Init.OverSampling = UART_OVERSAMPLING_16;
   \   0000004C   0x61C8             STR      R0,[R1, #+28]
     89            if (HAL_UART_Init(&huart1) != HAL_OK)
   \   0000004E   0x4608             MOV      R0,R1
   \   00000050   0x.... 0x....      BL       HAL_UART_Init
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD003             BEQ.N    ??MX_USART1_UART_Init_6
     90            {
     91              Error_Handler();
   \   00000058   0xE8BD 0x4001      POP      {R0,LR}
   \   0000005C   0x.... 0x....      B.W      Error_Handler
     92            }
     93          
     94          }
   \                     ??MX_USART1_UART_Init_6: (+1)
   \   00000060   0xBD01             POP      {R0,PC}          ;; return
     95          
     96          /* USART3 init function */
     97          

   \                                 In section .text, align 2, keep-with-next
     98          void MX_USART3_UART_Init(void)
     99          {
   \                     MX_USART3_UART_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    100          
    101            huart3.Instance = USART3;
   \   00000002   0x....             LDR.N    R0,??DataTable5_4
   \   00000004   0x....             LDR.N    R1,??DataTable5_5  ;; 0x40004800
   \   00000006   0x6001             STR      R1,[R0, #+0]
    102            huart3.Init.BaudRate = 115200;
   \   00000008   0xF44F 0x31E1      MOV      R1,#+115200
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    103            huart3.Init.WordLength = UART_WORDLENGTH_8B;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6081             STR      R1,[R0, #+8]
    104            huart3.Init.StopBits = UART_STOPBITS_1;
   \   00000012   0x60C1             STR      R1,[R0, #+12]
    105            huart3.Init.Parity = UART_PARITY_NONE;
   \   00000014   0x6101             STR      R1,[R0, #+16]
    106            huart3.Init.Mode = UART_MODE_TX_RX;
   \   00000016   0x210C             MOVS     R1,#+12
   \   00000018   0x6141             STR      R1,[R0, #+20]
    107            huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6181             STR      R1,[R0, #+24]
    108            huart3.Init.OverSampling = UART_OVERSAMPLING_16;
   \   0000001E   0x61C1             STR      R1,[R0, #+28]
    109            if (HAL_UART_Init(&huart3) != HAL_OK)
   \   00000020   0x.... 0x....      BL       HAL_UART_Init
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD003             BEQ.N    ??MX_USART3_UART_Init_0
    110            {
    111              Error_Handler();
   \   00000028   0xE8BD 0x4001      POP      {R0,LR}
   \   0000002C   0x.... 0x....      B.W      Error_Handler
    112            }
    113          
    114          }
   \                     ??MX_USART3_UART_Init_0: (+1)
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
    115          /* USART6 init function */
    116          

   \                                 In section .text, align 2, keep-with-next
    117          void MX_USART6_UART_Init(void)
    118          {
   \                     MX_USART6_UART_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    119          
    120            huart6.Instance = USART6;
   \   00000002   0x....             LDR.N    R0,??DataTable5_6
   \   00000004   0x....             LDR.N    R1,??DataTable5_7  ;; 0x40011400
   \   00000006   0x6001             STR      R1,[R0, #+0]
    121            huart6.Init.BaudRate = 115200;
   \   00000008   0xF44F 0x31E1      MOV      R1,#+115200
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    122            huart6.Init.WordLength = UART_WORDLENGTH_8B;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6081             STR      R1,[R0, #+8]
    123            huart6.Init.StopBits = UART_STOPBITS_1;
   \   00000012   0x60C1             STR      R1,[R0, #+12]
    124            huart6.Init.Parity = UART_PARITY_NONE;
   \   00000014   0x6101             STR      R1,[R0, #+16]
    125            huart6.Init.Mode = UART_MODE_TX_RX;
   \   00000016   0x210C             MOVS     R1,#+12
   \   00000018   0x6141             STR      R1,[R0, #+20]
    126            huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6181             STR      R1,[R0, #+24]
    127            huart6.Init.OverSampling = UART_OVERSAMPLING_16;
   \   0000001E   0x61C1             STR      R1,[R0, #+28]
    128            if (HAL_UART_Init(&huart6) != HAL_OK)
   \   00000020   0x.... 0x....      BL       HAL_UART_Init
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD003             BEQ.N    ??MX_USART6_UART_Init_0
    129            {
    130              Error_Handler();
   \   00000028   0xE8BD 0x4001      POP      {R0,LR}
   \   0000002C   0x.... 0x....      B.W      Error_Handler
    131            }
    132          
    133          }
   \                     ??MX_USART6_UART_Init_0: (+1)
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
    134          

   \                                 In section .text, align 2, keep-with-next
    135          void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
    136          {
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x4604             MOV      R4,R0
    137          
    138            GPIO_InitTypeDef GPIO_InitStruct;
    139            if(uartHandle->Instance==USART1)
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x....             LDR.N    R1,??DataTable5_1  ;; 0x40011000
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD144             BNE.N    ??HAL_UART_MspInit_0
    140            {
    141            /* USER CODE BEGIN USART1_MspInit 0 */
    142          
    143            /* USER CODE END USART1_MspInit 0 */
    144              /* Peripheral clock enable */
    145              __HAL_RCC_USART1_CLK_ENABLE();
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0x....             LDR.N    R0,??DataTable5_8  ;; 0x40023844
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0xF041 0x0110      ORR      R1,R1,#0x10
   \   0000001C   0x6001             STR      R1,[R0, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF000 0x0010      AND      R0,R0,#0x10
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0x9800             LDR      R0,[SP, #+0]
    146            
    147              /**USART1 GPIO Configuration    
    148              PA9     ------> USART1_TX
    149              PA10     ------> USART1_RX 
    150              */
    151              GPIO_InitStruct.Pin = WIFI_TX_Pin|WIFI_RX_Pin;
   \   00000028   0xF44F 0x60C0      MOV      R0,#+1536
   \   0000002C   0x9001             STR      R0,[SP, #+4]
    152              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x9002             STR      R0,[SP, #+8]
    153              GPIO_InitStruct.Pull = GPIO_PULLUP;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x9003             STR      R0,[SP, #+12]
    154              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \   00000036   0x2003             MOVS     R0,#+3
   \   00000038   0x9004             STR      R0,[SP, #+16]
    155              GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
   \   0000003A   0x2007             MOVS     R0,#+7
   \   0000003C   0x9005             STR      R0,[SP, #+20]
    156              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \   0000003E   0xA901             ADD      R1,SP,#+4
   \   00000040   0x....             LDR.N    R0,??DataTable5_9  ;; 0x40020000
   \   00000042   0x.... 0x....      BL       HAL_GPIO_Init
    157          		if(huart1.Init.BaudRate == 1958400)
   \   00000046   0x....             LDR.N    R0,??DataTable5
   \   00000048   0x6840             LDR      R0,[R0, #+4]
   \   0000004A   0x....             LDR.N    R1,??DataTable5_3  ;; 0x1de200
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD11B             BNE.N    ??HAL_UART_MspInit_1
    158          		{
    159          					/* Peripheral DMA init*/
    160          				
    161          					hdma_usart1_rx.Instance = DMA2_Stream2;
   \   00000050   0x....             LDR.N    R5,??DataTable5_10
   \   00000052   0x....             LDR.N    R0,??DataTable5_11  ;; 0x40026440
   \   00000054   0x6028             STR      R0,[R5, #+0]
    162          					hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
   \   00000056   0xF04F 0x6000      MOV      R0,#+134217728
   \   0000005A   0x6068             STR      R0,[R5, #+4]
    163          					hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x60A8             STR      R0,[R5, #+8]
    164          					hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
   \   00000060   0x60E8             STR      R0,[R5, #+12]
    165          					hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
   \   00000062   0xF44F 0x6080      MOV      R0,#+1024
   \   00000066   0x6128             STR      R0,[R5, #+16]
    166          					hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x6168             STR      R0,[R5, #+20]
    167          					hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
   \   0000006C   0x61A8             STR      R0,[R5, #+24]
    168          					hdma_usart1_rx.Init.Mode = DMA_NORMAL;
   \   0000006E   0x61E8             STR      R0,[R5, #+28]
    169          					hdma_usart1_rx.Init.Priority = DMA_PRIORITY_LOW;
   \   00000070   0x6228             STR      R0,[R5, #+32]
    170          					hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
   \   00000072   0x6268             STR      R0,[R5, #+36]
    171          					if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
   \   00000074   0x4628             MOV      R0,R5
   \   00000076   0x.... 0x....      BL       HAL_DMA_Init
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD001             BEQ.N    ??HAL_UART_MspInit_2
    172          					{
    173          						Error_Handler();
   \   0000007E   0x.... 0x....      BL       Error_Handler
    174          					}
    175          		
    176          					__HAL_LINKDMA(uartHandle,hdmarx,hdma_usart1_rx);
   \                     ??HAL_UART_MspInit_2: (+1)
   \   00000082   0x6365             STR      R5,[R4, #+52]
   \   00000084   0x63AC             STR      R4,[R5, #+56]
   \   00000086   0xE07B             B.N      ??HAL_UART_MspInit_3
    177          		#if 0
    178          	    hdma_usart1_tx.Instance = DMA2_Stream7;
    179          	    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;
    180          	    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    181          	    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    182          	    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
    183          	    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    184          	    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    185          	    hdma_usart1_tx.Init.Mode = DMA_NORMAL;
    186          	    hdma_usart1_tx.Init.Priority = DMA_PRIORITY_LOW;
    187          	    hdma_usart1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    188          	    if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
    189          	    {
    190          	      Error_Handler();
    191          	    }
    192          
    193          	    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart1_tx);
    194          		#endif					
    195          		}
    196          		else
    197          		{
    198              	/* Peripheral interrupt init */
    199              	HAL_NVIC_SetPriority(USART1_IRQn, 3, 0);
   \                     ??HAL_UART_MspInit_1: (+1)
   \   00000088   0x2200             MOVS     R2,#+0
   \   0000008A   0x2103             MOVS     R1,#+3
   \   0000008C   0x2025             MOVS     R0,#+37
   \   0000008E   0x.... 0x....      BL       HAL_NVIC_SetPriority
    200              	HAL_NVIC_EnableIRQ(USART1_IRQn);
   \   00000092   0x2025             MOVS     R0,#+37
   \   00000094   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   \   00000098   0xE072             B.N      ??HAL_UART_MspInit_3
    201          		}
    202            /* USER CODE BEGIN USART1_MspInit 1 */
    203          
    204            /* USER CODE END USART1_MspInit 1 */
    205            }
    206            else if(uartHandle->Instance==USART6)
   \                     ??HAL_UART_MspInit_0: (+1)
   \   0000009A   0x....             LDR.N    R1,??DataTable5_7  ;; 0x40011400
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD16F             BNE.N    ??HAL_UART_MspInit_3
    207            {
    208            /* USER CODE BEGIN USART6_MspInit 0 */
    209          
    210            /* USER CODE END USART6_MspInit 0 */
    211              /* Peripheral clock enable */
    212              __HAL_RCC_USART6_CLK_ENABLE();
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x9000             STR      R0,[SP, #+0]
   \   000000A4   0x....             LDR.N    R0,??DataTable5_8  ;; 0x40023844
   \   000000A6   0x6801             LDR      R1,[R0, #+0]
   \   000000A8   0xF041 0x0120      ORR      R1,R1,#0x20
   \   000000AC   0x6001             STR      R1,[R0, #+0]
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0xF000 0x0020      AND      R0,R0,#0x20
   \   000000B4   0x9000             STR      R0,[SP, #+0]
   \   000000B6   0x9800             LDR      R0,[SP, #+0]
    213            
    214              /**USART6 GPIO Configuration    
    215              PC6     ------> USART6_TX
    216              PC7     ------> USART6_RX 
    217              */
    218              GPIO_InitStruct.Pin = USART6_TX_Pin|USART6_RX_Pin;
   \   000000B8   0x20C0             MOVS     R0,#+192
   \   000000BA   0x9001             STR      R0,[SP, #+4]
    219              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   000000BC   0x2002             MOVS     R0,#+2
   \   000000BE   0x9002             STR      R0,[SP, #+8]
    220              GPIO_InitStruct.Pull = GPIO_PULLUP;
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0x9003             STR      R0,[SP, #+12]
    221              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \   000000C4   0x2003             MOVS     R0,#+3
   \   000000C6   0x9004             STR      R0,[SP, #+16]
    222              GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
   \   000000C8   0x2008             MOVS     R0,#+8
   \   000000CA   0x9005             STR      R0,[SP, #+20]
    223              HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \   000000CC   0xA901             ADD      R1,SP,#+4
   \   000000CE   0x....             LDR.N    R0,??DataTable5_12  ;; 0x40020800
   \   000000D0   0x.... 0x....      BL       HAL_GPIO_Init
    224          
    225              /* Peripheral DMA init*/
    226            
    227              hdma_usart6_rx.Instance = DMA2_Stream2;
   \   000000D4   0x....             LDR.N    R5,??DataTable5_10
   \   000000D6   0x....             LDR.N    R6,??DataTable5_11  ;; 0x40026440
   \   000000D8   0x662E             STR      R6,[R5, #+96]
    228              hdma_usart6_rx.Init.Channel = DMA_CHANNEL_5;
   \   000000DA   0xF04F 0x6720      MOV      R7,#+167772160
   \   000000DE   0x666F             STR      R7,[R5, #+100]
    229              hdma_usart6_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x66A8             STR      R0,[R5, #+104]
    230              hdma_usart6_rx.Init.PeriphInc = DMA_PINC_DISABLE;
   \   000000E4   0x66E8             STR      R0,[R5, #+108]
    231              hdma_usart6_rx.Init.MemInc = DMA_MINC_ENABLE;
   \   000000E6   0xF44F 0x6880      MOV      R8,#+1024
   \   000000EA   0xF8C5 0x8070      STR      R8,[R5, #+112]
    232              hdma_usart6_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
   \   000000EE   0x6768             STR      R0,[R5, #+116]
    233              hdma_usart6_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
   \   000000F0   0x67A8             STR      R0,[R5, #+120]
    234              hdma_usart6_rx.Init.Mode = DMA_NORMAL;
   \   000000F2   0x67E8             STR      R0,[R5, #+124]
    235              hdma_usart6_rx.Init.Priority = DMA_PRIORITY_LOW;
   \   000000F4   0xF8C5 0x0080      STR      R0,[R5, #+128]
    236              hdma_usart6_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
   \   000000F8   0x2004             MOVS     R0,#+4
   \   000000FA   0xF8C5 0x0084      STR      R0,[R5, #+132]
    237              hdma_usart6_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_HALFFULL;
   \   000000FE   0x2001             MOVS     R0,#+1
   \   00000100   0xF8C5 0x0088      STR      R0,[R5, #+136]
    238              hdma_usart6_rx.Init.MemBurst = DMA_MBURST_SINGLE;
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xF8C5 0x008C      STR      R0,[R5, #+140]
    239              hdma_usart6_rx.Init.PeriphBurst = DMA_PBURST_SINGLE;
   \   0000010A   0xF8C5 0x0090      STR      R0,[R5, #+144]
    240              if (HAL_DMA_Init(&hdma_usart6_rx) != HAL_OK)
   \   0000010E   0xF105 0x0060      ADD      R0,R5,#+96
   \   00000112   0x.... 0x....      BL       HAL_DMA_Init
   \   00000116   0x2800             CMP      R0,#+0
   \   00000118   0xD001             BEQ.N    ??HAL_UART_MspInit_4
    241              {
    242                Error_Handler();
   \   0000011A   0x.... 0x....      BL       Error_Handler
    243              }
    244          
    245              __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart6_rx);
   \                     ??HAL_UART_MspInit_4: (+1)
   \   0000011E   0xF105 0x0060      ADD      R0,R5,#+96
   \   00000122   0x6360             STR      R0,[R4, #+52]
   \   00000124   0xF8C5 0x4098      STR      R4,[R5, #+152]
    246          
    247              hdma_usart6_tx.Instance = DMA2_Stream7;
   \   00000128   0xF106 0x0078      ADD      R0,R6,#+120
   \   0000012C   0xF8C5 0x00C0      STR      R0,[R5, #+192]
    248              hdma_usart6_tx.Init.Channel = DMA_CHANNEL_5;
   \   00000130   0xF8C5 0x70C4      STR      R7,[R5, #+196]
    249              hdma_usart6_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
   \   00000134   0x2040             MOVS     R0,#+64
   \   00000136   0xF8C5 0x00C8      STR      R0,[R5, #+200]
    250              hdma_usart6_tx.Init.PeriphInc = DMA_PINC_DISABLE;
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0xF8C5 0x00CC      STR      R0,[R5, #+204]
    251              hdma_usart6_tx.Init.MemInc = DMA_MINC_ENABLE;
   \   00000140   0xF8C5 0x80D0      STR      R8,[R5, #+208]
    252              hdma_usart6_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
   \   00000144   0xF8C5 0x00D4      STR      R0,[R5, #+212]
    253              hdma_usart6_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
   \   00000148   0xF8C5 0x00D8      STR      R0,[R5, #+216]
    254              hdma_usart6_tx.Init.Mode = DMA_NORMAL;
   \   0000014C   0xF8C5 0x00DC      STR      R0,[R5, #+220]
    255              hdma_usart6_tx.Init.Priority = DMA_PRIORITY_LOW;
   \   00000150   0xF8C5 0x00E0      STR      R0,[R5, #+224]
    256              hdma_usart6_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
   \   00000154   0xF8C5 0x00E4      STR      R0,[R5, #+228]
    257              if (HAL_DMA_Init(&hdma_usart6_tx) != HAL_OK)
   \   00000158   0xF105 0x06C0      ADD      R6,R5,#+192
   \   0000015C   0x4630             MOV      R0,R6
   \   0000015E   0x.... 0x....      BL       HAL_DMA_Init
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD001             BEQ.N    ??HAL_UART_MspInit_5
    258              {
    259                Error_Handler();
   \   00000166   0x.... 0x....      BL       Error_Handler
    260              }
    261          
    262              __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart6_tx);
   \                     ??HAL_UART_MspInit_5: (+1)
   \   0000016A   0x6326             STR      R6,[R4, #+48]
   \   0000016C   0xF8C5 0x40F8      STR      R4,[R5, #+248]
    263          
    264              /* Peripheral interrupt init */
    265              HAL_NVIC_SetPriority(USART6_IRQn, 3, 0);
   \   00000170   0x2200             MOVS     R2,#+0
   \   00000172   0x2103             MOVS     R1,#+3
   \   00000174   0x2047             MOVS     R0,#+71
   \   00000176   0x.... 0x....      BL       HAL_NVIC_SetPriority
    266              HAL_NVIC_EnableIRQ(USART6_IRQn);
   \   0000017A   0x2047             MOVS     R0,#+71
   \   0000017C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    267            /* USER CODE BEGIN USART6_MspInit 1 */
    268          
    269            /* USER CODE END USART6_MspInit 1 */
    270            }
    271          }
   \                     ??HAL_UART_MspInit_3: (+1)
   \   00000180   0xB006             ADD      SP,SP,#+24
   \   00000182   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    272          

   \                                 In section .text, align 2, keep-with-next
    273          void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
    274          {
   \                     HAL_UART_MspDeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    275            if(uartHandle->Instance==USART1)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x....             LDR.N    R1,??DataTable5_1  ;; 0x40011000
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD10E             BNE.N    ??HAL_UART_MspDeInit_0
    276            {
    277            /* USER CODE BEGIN USART1_MspDeInit 0 */
    278          
    279            /* USER CODE END USART1_MspDeInit 0 */
    280              /* Peripheral clock disable */
    281              __HAL_RCC_USART1_CLK_DISABLE();
   \   0000000C   0x....             LDR.N    R0,??DataTable5_8  ;; 0x40023844
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000014   0x6001             STR      R1,[R0, #+0]
    282            
    283              /**USART1 GPIO Configuration    
    284              PA9     ------> USART1_TX
    285              PA10     ------> USART1_RX 
    286              */
    287              HAL_GPIO_DeInit(GPIOA, WIFI_TX_Pin|WIFI_RX_Pin);
   \   00000016   0xF44F 0x61C0      MOV      R1,#+1536
   \   0000001A   0x....             LDR.N    R0,??DataTable5_9  ;; 0x40020000
   \   0000001C   0x.... 0x....      BL       HAL_GPIO_DeInit
    288          
    289              /* Peripheral interrupt Deinit*/
    290              HAL_NVIC_DisableIRQ(USART1_IRQn);
   \   00000020   0x2025             MOVS     R0,#+37
   \   00000022   0xE8BD 0x4010      POP      {R4,LR}
   \   00000026   0x.... 0x....      B.W      HAL_NVIC_DisableIRQ
    291          
    292            /* USER CODE BEGIN USART1_MspDeInit 1 */
    293          
    294            /* USER CODE END USART1_MspDeInit 1 */
    295            }
    296          
    297            else if(uartHandle->Instance==USART6)
   \                     ??HAL_UART_MspDeInit_0: (+1)
   \   0000002A   0x....             LDR.N    R1,??DataTable5_7  ;; 0x40011400
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD113             BNE.N    ??HAL_UART_MspDeInit_1
    298            {
    299            /* USER CODE BEGIN USART6_MspDeInit 0 */
    300          
    301            /* USER CODE END USART6_MspDeInit 0 */
    302              /* Peripheral clock disable */
    303              __HAL_RCC_USART6_CLK_DISABLE();
   \   00000030   0x....             LDR.N    R0,??DataTable5_8  ;; 0x40023844
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0xF021 0x0120      BIC      R1,R1,#0x20
   \   00000038   0x6001             STR      R1,[R0, #+0]
    304            
    305              /**USART6 GPIO Configuration    
    306              PC6     ------> USART6_TX
    307              PC7     ------> USART6_RX 
    308              */
    309              HAL_GPIO_DeInit(GPIOC, USART6_TX_Pin|USART6_RX_Pin);
   \   0000003A   0x21C0             MOVS     R1,#+192
   \   0000003C   0x....             LDR.N    R0,??DataTable5_12  ;; 0x40020800
   \   0000003E   0x.... 0x....      BL       HAL_GPIO_DeInit
    310          
    311              /* Peripheral DMA DeInit*/
    312              HAL_DMA_DeInit(uartHandle->hdmarx);
   \   00000042   0x6B60             LDR      R0,[R4, #+52]
   \   00000044   0x.... 0x....      BL       HAL_DMA_DeInit
    313              HAL_DMA_DeInit(uartHandle->hdmatx);
   \   00000048   0x6B20             LDR      R0,[R4, #+48]
   \   0000004A   0x.... 0x....      BL       HAL_DMA_DeInit
    314          
    315              /* Peripheral interrupt Deinit*/
    316              HAL_NVIC_DisableIRQ(USART6_IRQn);
   \   0000004E   0x2047             MOVS     R0,#+71
   \   00000050   0xE8BD 0x4010      POP      {R4,LR}
   \   00000054   0x.... 0x....      B.W      HAL_NVIC_DisableIRQ
    317          
    318            /* USER CODE BEGIN USART6_MspDeInit 1 */
    319          
    320            /* USER CODE END USART6_MspDeInit 1 */
    321            }
    322          } 
   \                     ??HAL_UART_MspDeInit_1: (+1)
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    323          
    324          /* USER CODE BEGIN 1 */
    325          #if 0
    326          int i=0;
    327          void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
    328          {
    329            if(huart->Instance==USART3)
    330            {
    331              mksRxBuffer[i++] = mksUsart3Rx;
    332              HAL_UART_Receive_IT(&huart3,&mksUsart3Rx,1);
    333            }
    334          }
    335          
    336          #endif

   \                                 In section .bss, align 4
    337          int i=0;
   \                     i:
   \   00000000                      DS8 4

   \                                 In section .text, align 2, keep-with-next
    338          void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
    339          {
    340          /*
    341            if(huart->Instance==USART3)
    342            {
    343              mksRxBuffer[i++] = mksUsart3Rx;
    344              HAL_UART_Receive_IT(&huart3,&mksUsart3Rx,1);
    345            }
    346          	else 
    347          	*/
    348          	if(huart->Instance==USART1)
   \                     HAL_UART_RxCpltCallback: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x....             LDR.N    R1,??DataTable5_1  ;; 0x40011000
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD105             BNE.N    ??HAL_UART_RxCpltCallback_0
    349          	{
    350              //mksRxBuffer[i++] = mksUsart1Rx;
    351          		HAL_UART_Receive_IT(&huart1,&mksUsart1Rx,1);
   \   00000008   0x....             LDR.N    R0,??DataTable5
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xF100 0x0140      ADD      R1,R0,#+64
   \   00000010   0x.... 0x....      B.W      HAL_UART_Receive_IT
    352          		//if(i>30)
    353          		//{
    354          		//	i=0;
    355          		//	return;
    356          		//}
    357          	}
    358          }
   \                     ??HAL_UART_RxCpltCallback_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     huart1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x0003D090         DC32     0x3d090

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x001DE200         DC32     0x1de200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     huart3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     huart6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     hdma_usart1_rx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x40026440         DC32     0x40026440

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x40020800         DC32     0x40020800
    359          
    360          /* USER CODE END 1 */
    361          
    362          /**
    363            * @}
    364            */
    365          
    366          /**
    367            * @}
    368            */
    369          
    370          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_UART_MspDeInit
         8   -> HAL_DMA_DeInit
         8   -> HAL_GPIO_DeInit
         0   -> HAL_NVIC_DisableIRQ
      48   HAL_UART_MspInit
        48   -> Error_Handler
        48   -> HAL_DMA_Init
        48   -> HAL_GPIO_Init
        48   -> HAL_NVIC_EnableIRQ
        48   -> HAL_NVIC_SetPriority
       0   HAL_UART_RxCpltCallback
         0   -> HAL_UART_Receive_IT
       8   MX_USART1_UART_Init
         0   -> Error_Handler
         8   -> HAL_UART_Init
       8   MX_USART3_UART_Init
         0   -> Error_Handler
         8   -> HAL_UART_Init
       8   MX_USART6_UART_Init
         0   -> Error_Handler
         8   -> HAL_UART_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      90  HAL_UART_MspDeInit
     390  HAL_UART_MspInit
      22  HAL_UART_RxCpltCallback
      98  MX_USART1_UART_Init
      50  MX_USART3_UART_Init
      50  MX_USART6_UART_Init
     288  hdma_usart1_rx
          hdma_usart6_rx
          hdma_usart6_tx
      96  hdma_usart1_tx
      65  huart1
          mksUsart1Rx
      64  huart3
      64  huart6
       4  i
      20  mksRxBuffer
       1  mksUsart3Rx

 
 602 bytes in section .bss
 752 bytes in section .text
 
 752 bytes of CODE memory
 602 bytes of DATA memory

Errors: none
Warnings: none
