###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:19:57
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\GUIDemo\GUIDEMO_Touch.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\GUIDemo\GUIDEMO_Touch.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\GUIDEMO_Touch.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\GUIDEMO_Touch.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\GUIDemo\GUIDEMO_Touch.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUIDEMO_Touch
     16          Purpose     : Touch demo
     17          ---------------------------END-OF-HEADER------------------------------
     18          */
     19          
     20          #include "GUI.h"
     21          #include "LCD_ConfDefaults.h"      /* valid LCD configuration */
     22          #include "GUIDEMO.h"
     23          
     24          #if (GUI_WINSUPPORT && GUI_SUPPORT_TOUCH)
     25          
     26          #include "BUTTON.h"
     27          #include "EDIT.h"
     28          
     29          #define countof(Obj) (sizeof(Obj)/sizeof(Obj[0]))
     30          
     31          /*********************************************************************
     32          *
     33          *       Static functions
     34          *
     35          **********************************************************************
     36          */
     37          

   \                                 In section .text, align 2, keep-with-next
     38          static int _Log2Phys(int l, I32 l0, I32 l1, I32 p0, I32 p1) {
   \                     _Log2Phys: (+1)
   \   00000000   0xB410             PUSH     {R4}
     39            return p0 + ((p1 - p0) * (l - l0)) / (l1 - l0);
   \   00000002   0x9C01             LDR      R4,[SP, #+4]
   \   00000004   0x1AE4             SUBS     R4,R4,R3
   \   00000006   0x1A40             SUBS     R0,R0,R1
   \   00000008   0x4360             MULS     R0,R0,R4
   \   0000000A   0x1A51             SUBS     R1,R2,R1
   \   0000000C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000010   0x18C0             ADDS     R0,R0,R3
   \   00000012   0xBC10             POP      {R4}
   \   00000014   0x4770             BX       LR               ;; return
     40          }
     41          

   \                                 In section .text, align 2, keep-with-next
     42          static void _Calibrate(int Coord, int Log0, int Log1, int Phys0, int Phys1, int *p0, int *p1) {
   \                     _Calibrate: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x461E             MOV      R6,R3
     43            int l0 = 0;
     44            int l1 = (Coord == GUI_COORD_X) ? LCD_XSIZE - 1 : LCD_YSIZE - 1;
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD102             BNE.N    ??_Calibrate_0
   \   00000010   0xF240 0x18DF      MOVW     R8,#+479
   \   00000014   0xE001             B.N      ??_Calibrate_1
   \                     ??_Calibrate_0: (+1)
   \   00000016   0xF240 0x183F      MOVW     R8,#+319
   \                     ??_Calibrate_1: (+1)
   \   0000001A   0x9F08             LDR      R7,[SP, #+32]
     45            *p0 = _Log2Phys(l0, Log0, Log1, Phys0, Phys1);
   \   0000001C   0x9700             STR      R7,[SP, #+0]
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       _Log2Phys
   \   00000024   0x9909             LDR      R1,[SP, #+36]
   \   00000026   0x6008             STR      R0,[R1, #+0]
     46            *p1 = _Log2Phys(l1, Log0, Log1, Phys0, Phys1);
   \   00000028   0x9700             STR      R7,[SP, #+0]
   \   0000002A   0x4633             MOV      R3,R6
   \   0000002C   0x462A             MOV      R2,R5
   \   0000002E   0x4621             MOV      R1,R4
   \   00000030   0x4640             MOV      R0,R8
   \   00000032   0x.... 0x....      BL       _Log2Phys
   \   00000036   0x990A             LDR      R1,[SP, #+40]
   \   00000038   0x6008             STR      R0,[R1, #+0]
     47          }
   \   0000003A   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
     48          
     49          /*********************************************************************
     50          *
     51          *       _ExecCalibration
     52          *
     53          **********************************************************************
     54          */
     55          

   \                                 In section .text, align 2, keep-with-next
     56          static void _ExecCalibration(void) {
   \                     _ExecCalibration: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
     57            int ax_Phys[2],ay_Phys[2];
     58          /* calculate log. Positions */
     59            int ax[2] = { 15, LCD_XSIZE -1-15};
     60          //  const int ay[2] = { 15, LCD_YSIZE-1-15};
     61            int ay[2] = { LCD_YSIZE-1-15, 15};
     62            GUI_TOUCH_SetDefaultCalibration();
   \   00000004   0x.... 0x....      BL       GUI_TOUCH_SetDefaultCalibration
     63          /* _Calibrate upper left */
     64            GUI_SetBkColor(GUI_RED);  
   \   00000008   0x20FF             MOVS     R0,#+255
   \   0000000A   0x.... 0x....      BL       GUI_SetBkColor
     65            GUI_Clear();
   \   0000000E   0x.... 0x....      BL       GUI_Clear
     66            GUI_SetColor(GUI_WHITE);  GUI_FillCircle(ax[0], ay[0], 10);
   \   00000012   0xF06F 0x467F      MVN      R6,#-16777216
   \   00000016   0x4630             MOV      R0,R6
   \   00000018   0x.... 0x....      BL       GUI_SetColor
   \   0000001C   0x220A             MOVS     R2,#+10
   \   0000001E   0xF44F 0x7198      MOV      R1,#+304
   \   00000022   0x200F             MOVS     R0,#+15
   \   00000024   0x.... 0x....      BL       GUI_FillCircle
     67            GUI_SetColor(GUI_RED);    GUI_FillCircle(ax[0], ay[0], 5);
   \   00000028   0x20FF             MOVS     R0,#+255
   \   0000002A   0x.... 0x....      BL       GUI_SetColor
   \   0000002E   0x2205             MOVS     R2,#+5
   \   00000030   0xF44F 0x7198      MOV      R1,#+304
   \   00000034   0x200F             MOVS     R0,#+15
   \   00000036   0x.... 0x....      BL       GUI_FillCircle
     68            GUI_SetColor(GUI_WHITE);
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0x.... 0x....      BL       GUI_SetColor
     69            GUI_DispStringAt("Press here", ax[0]+20, ay[0]);
   \   00000040   0x.... 0x....      ADR.W    R7,`?<Constant "Press here">`
   \   00000044   0xF44F 0x7298      MOV      R2,#+304
   \   00000048   0x2123             MOVS     R1,#+35
   \   0000004A   0x4638             MOV      R0,R7
   \   0000004C   0x.... 0x....      BL       GUI_DispStringAt
   \   00000050   0xE002             B.N      ??_ExecCalibration_0
     70            do {
     71              GUI_PID_STATE State;
     72              GUI_TOUCH_GetState(&State);
     73              if (State.Pressed) {
     74                ax_Phys[0] = GUI_TOUCH_GetxPhys();
     75                ay_Phys[0] = GUI_TOUCH_GetyPhys();
     76                break;
     77              }
     78              GUI_Delay (100);
   \                     ??_ExecCalibration_1: (+1)
   \   00000052   0x2064             MOVS     R0,#+100
   \   00000054   0x.... 0x....      BL       GUI_Delay
     79            } while (1);
   \                     ??_ExecCalibration_0: (+1)
   \   00000058   0xA800             ADD      R0,SP,#+0
   \   0000005A   0x.... 0x....      BL       GUI_TOUCH_GetState
   \   0000005E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD0F5             BEQ.N    ??_ExecCalibration_1
   \   00000066   0x.... 0x....      BL       GUI_TOUCH_GetxPhys
   \   0000006A   0x4604             MOV      R4,R0
   \   0000006C   0x.... 0x....      BL       GUI_TOUCH_GetyPhys
   \   00000070   0x4605             MOV      R5,R0
     80          /* Tell user to release */
     81            GUI_Clear();
   \   00000072   0x.... 0x....      BL       GUI_Clear
     82            GUI_DispStringAt("OK", ax[0]+20, ay[0]);
   \   00000076   0xF44F 0x7298      MOV      R2,#+304
   \   0000007A   0x2123             MOVS     R1,#+35
   \   0000007C   0x....             ADR.N    R0,??DataTable19  ;; 0x4F, 0x4B, 0x00, 0x00
   \   0000007E   0x.... 0x....      BL       GUI_DispStringAt
   \   00000082   0xE002             B.N      ??_ExecCalibration_2
     83            do {
     84              GUI_PID_STATE State;
     85              GUI_TOUCH_GetState(&State);
     86              if (State.Pressed == 0) {
     87                break;
     88              }
     89              GUI_Delay (100);
   \                     ??_ExecCalibration_3: (+1)
   \   00000084   0x2064             MOVS     R0,#+100
   \   00000086   0x.... 0x....      BL       GUI_Delay
     90            } while (1);
   \                     ??_ExecCalibration_2: (+1)
   \   0000008A   0xA800             ADD      R0,SP,#+0
   \   0000008C   0x.... 0x....      BL       GUI_TOUCH_GetState
   \   00000090   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD1F5             BNE.N    ??_ExecCalibration_3
     91          /* _Calibrate lower right */
     92            GUI_SetBkColor(GUI_RED);  
   \   00000098   0x20FF             MOVS     R0,#+255
   \   0000009A   0x.... 0x....      BL       GUI_SetBkColor
     93            GUI_Clear();
   \   0000009E   0x.... 0x....      BL       GUI_Clear
     94            GUI_SetColor(GUI_WHITE);  GUI_FillCircle(ax[1], ay[1], 10);
   \   000000A2   0x4630             MOV      R0,R6
   \   000000A4   0x.... 0x....      BL       GUI_SetColor
   \   000000A8   0x220A             MOVS     R2,#+10
   \   000000AA   0x210F             MOVS     R1,#+15
   \   000000AC   0xF44F 0x70E8      MOV      R0,#+464
   \   000000B0   0x.... 0x....      BL       GUI_FillCircle
     95            GUI_SetColor(GUI_RED);    GUI_FillCircle(ax[1], ay[1], 5);
   \   000000B4   0x20FF             MOVS     R0,#+255
   \   000000B6   0x.... 0x....      BL       GUI_SetColor
   \   000000BA   0x2205             MOVS     R2,#+5
   \   000000BC   0x210F             MOVS     R1,#+15
   \   000000BE   0xF44F 0x70E8      MOV      R0,#+464
   \   000000C2   0x.... 0x....      BL       GUI_FillCircle
     96            GUI_SetColor(GUI_WHITE);
   \   000000C6   0x4630             MOV      R0,R6
   \   000000C8   0x.... 0x....      BL       GUI_SetColor
     97            GUI_SetTextAlign(GUI_TA_RIGHT);
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x.... 0x....      BL       GUI_SetTextAlign
     98            GUI_DispStringAt("Press here", ax[1]-20, ay[1]);
   \   000000D2   0x220F             MOVS     R2,#+15
   \   000000D4   0xF44F 0x71DE      MOV      R1,#+444
   \   000000D8   0x4638             MOV      R0,R7
   \   000000DA   0x.... 0x....      BL       GUI_DispStringAt
   \   000000DE   0xE002             B.N      ??_ExecCalibration_4
     99            do {
    100              GUI_PID_STATE State;
    101              GUI_TOUCH_GetState(&State);
    102              if (State.Pressed) {
    103                ax_Phys[1] = GUI_TOUCH_GetxPhys();
    104                ay_Phys[1] = GUI_TOUCH_GetyPhys();
    105                break;
    106              }
    107              GUI_Delay (100);
   \                     ??_ExecCalibration_5: (+1)
   \   000000E0   0x2064             MOVS     R0,#+100
   \   000000E2   0x.... 0x....      BL       GUI_Delay
    108            } while (1);
   \                     ??_ExecCalibration_4: (+1)
   \   000000E6   0xA807             ADD      R0,SP,#+28
   \   000000E8   0x.... 0x....      BL       GUI_TOUCH_GetState
   \   000000EC   0xF89D 0x0024      LDRB     R0,[SP, #+36]
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD0F5             BEQ.N    ??_ExecCalibration_5
   \   000000F4   0x.... 0x....      BL       GUI_TOUCH_GetxPhys
   \   000000F8   0x4606             MOV      R6,R0
   \   000000FA   0x.... 0x....      BL       GUI_TOUCH_GetyPhys
   \   000000FE   0x4607             MOV      R7,R0
    109            GUI_TOUCH_Calibrate(GUI_COORD_X, ax[0], ax[1], ax_Phys[0], ax_Phys[1]);
   \   00000100   0x9600             STR      R6,[SP, #+0]
   \   00000102   0x4623             MOV      R3,R4
   \   00000104   0xF44F 0x72E8      MOV      R2,#+464
   \   00000108   0x210F             MOVS     R1,#+15
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x.... 0x....      BL       GUI_TOUCH_Calibrate
    110            GUI_TOUCH_Calibrate(GUI_COORD_Y, ay[0], ay[1], ay_Phys[0], ay_Phys[1]);
   \   00000110   0x9700             STR      R7,[SP, #+0]
   \   00000112   0x462B             MOV      R3,R5
   \   00000114   0x220F             MOVS     R2,#+15
   \   00000116   0xF44F 0x7198      MOV      R1,#+304
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0x.... 0x....      BL       GUI_TOUCH_Calibrate
    111            { /* calculate and display values for configuration file */
    112              int x0, x1;
    113              int y0, y1;
    114              GUI_Clear();
   \   00000120   0x.... 0x....      BL       GUI_Clear
    115              _Calibrate(GUI_COORD_X, ax[0], ax[1], ax_Phys[0], ax_Phys[1], &x0, &x1);
   \   00000124   0xA805             ADD      R0,SP,#+20
   \   00000126   0x9002             STR      R0,[SP, #+8]
   \   00000128   0xA806             ADD      R0,SP,#+24
   \   0000012A   0x9001             STR      R0,[SP, #+4]
   \   0000012C   0x9600             STR      R6,[SP, #+0]
   \   0000012E   0x4623             MOV      R3,R4
   \   00000130   0xF44F 0x72E8      MOV      R2,#+464
   \   00000134   0x210F             MOVS     R1,#+15
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0x.... 0x....      BL       _Calibrate
    116              _Calibrate(GUI_COORD_Y, ay[0], ay[1], ay_Phys[0], ay_Phys[1], &y0, &y1);
   \   0000013C   0xA803             ADD      R0,SP,#+12
   \   0000013E   0x9002             STR      R0,[SP, #+8]
   \   00000140   0xA804             ADD      R0,SP,#+16
   \   00000142   0x9001             STR      R0,[SP, #+4]
   \   00000144   0x9700             STR      R7,[SP, #+0]
   \   00000146   0x462B             MOV      R3,R5
   \   00000148   0x220F             MOVS     R2,#+15
   \   0000014A   0xF44F 0x7198      MOV      R1,#+304
   \   0000014E   0x2001             MOVS     R0,#+1
   \   00000150   0x.... 0x....      BL       _Calibrate
    117              GUI_DispStringAt("x0: ", 0, 0); GUI_DispDec(x0, 4); GUI_DispNextLine();
   \   00000154   0x2200             MOVS     R2,#+0
   \   00000156   0x4611             MOV      R1,R2
   \   00000158   0x.... 0x....      ADR.W    R0,`?<Constant "x0: ">`
   \   0000015C   0x.... 0x....      BL       GUI_DispStringAt
   \   00000160   0x2104             MOVS     R1,#+4
   \   00000162   0x9806             LDR      R0,[SP, #+24]
   \   00000164   0x.... 0x....      BL       GUI_DispDec
   \   00000168   0x.... 0x....      BL       GUI_DispNextLine
    118              GUI_DispString  ("x1: ");       GUI_DispDec(x1, 4); GUI_DispNextLine();
   \   0000016C   0x.... 0x....      ADR.W    R0,`?<Constant "x1: ">`
   \   00000170   0x.... 0x....      BL       GUI_DispString
   \   00000174   0x2104             MOVS     R1,#+4
   \   00000176   0x9805             LDR      R0,[SP, #+20]
   \   00000178   0x.... 0x....      BL       GUI_DispDec
   \   0000017C   0x.... 0x....      BL       GUI_DispNextLine
    119              GUI_DispString  ("y0: ");       GUI_DispDec(y0, 4); GUI_DispNextLine();
   \   00000180   0x.... 0x....      ADR.W    R0,`?<Constant "y0: ">`
   \   00000184   0x.... 0x....      BL       GUI_DispString
   \   00000188   0x2104             MOVS     R1,#+4
   \   0000018A   0x9804             LDR      R0,[SP, #+16]
   \   0000018C   0x.... 0x....      BL       GUI_DispDec
   \   00000190   0x.... 0x....      BL       GUI_DispNextLine
    120              GUI_DispString  ("y1: ");       GUI_DispDec(y1, 4); GUI_DispNextLine();
   \   00000194   0x.... 0x....      ADR.W    R0,`?<Constant "y1: ">`
   \   00000198   0x.... 0x....      BL       GUI_DispString
   \   0000019C   0x2104             MOVS     R1,#+4
   \   0000019E   0x9803             LDR      R0,[SP, #+12]
   \   000001A0   0x.... 0x....      BL       GUI_DispDec
   \   000001A4   0x.... 0x....      BL       GUI_DispNextLine
    121              GUI_DispString  ("Please touch display to continue...");
   \   000001A8   0x.... 0x....      ADR.W    R0,`?<Constant "Please touch display ...">`
   \   000001AC   0x.... 0x....      BL       GUI_DispString
    122              GUI_Delay(1000);
   \   000001B0   0xF44F 0x707A      MOV      R0,#+1000
   \   000001B4   0x.... 0x....      BL       GUI_Delay
   \   000001B8   0xE002             B.N      ??_ExecCalibration_6
    123              do {
    124                GUI_PID_STATE State;
    125                GUI_TOUCH_GetState(&State);
    126                if (State.Pressed)
    127                  break;
    128                GUI_Delay (10);
   \                     ??_ExecCalibration_7: (+1)
   \   000001BA   0x200A             MOVS     R0,#+10
   \   000001BC   0x.... 0x....      BL       GUI_Delay
    129              } while (1);
   \                     ??_ExecCalibration_6: (+1)
   \   000001C0   0xA800             ADD      R0,SP,#+0
   \   000001C2   0x.... 0x....      BL       GUI_TOUCH_GetState
   \   000001C6   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000001CA   0x2800             CMP      R0,#+0
   \   000001CC   0xD0F5             BEQ.N    ??_ExecCalibration_7
    130            }
    131          }
   \   000001CE   0xB00B             ADD      SP,SP,#+44
   \   000001D0   0xBDF0             POP      {R4-R7,PC}       ;; return
    132          
    133          /*********************************************************************
    134          *
    135          *       _TestCalibration
    136          *
    137          **********************************************************************
    138          */
    139          

   \                                 In section .text, align 2, keep-with-next
    140          static void _TestCalibration(void) {
   \                     _TestCalibration: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    141            int IdleCnt=0;
   \   00000004   0x2400             MOVS     R4,#+0
    142            BUTTON_Handle hButton;
    143            GUI_SetBkColor(GUI_RED);  
   \   00000006   0x20FF             MOVS     R0,#+255
   \   00000008   0x.... 0x....      BL       GUI_SetBkColor
    144            GUI_SetColor(GUI_WHITE);  
   \   0000000C   0xF06F 0x407F      MVN      R0,#-16777216
   \   00000010   0x.... 0x....      BL       GUI_SetColor
    145            GUI_Clear();
   \   00000014   0x.... 0x....      BL       GUI_Clear
    146            hButton =  BUTTON_Create( 225, 15, 80, 40, 1, BUTTON_CF_SHOW );
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x2328             MOVS     R3,#+40
   \   00000022   0x2250             MOVS     R2,#+80
   \   00000024   0x210F             MOVS     R1,#+15
   \   00000026   0x20E1             MOVS     R0,#+225
   \   00000028   0x.... 0x....      BL       BUTTON_Create
   \   0000002C   0x4605             MOV      R5,R0
    147            BUTTON_SetText (hButton, "ABORT");
   \   0000002E   0x.... 0x....      ADR.W    R1,`?<Constant "ABORT">`
   \   00000032   0x.... 0x....      BL       BUTTON_SetText
    148            BUTTON_SetFont (hButton, &GUI_FontComic18B_ASCII);
   \   00000036   0x....             LDR.N    R1,??DataTable20_1
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       BUTTON_SetFont
   \   0000003E   0xE003             B.N      ??_TestCalibration_0
    149            while ((IdleCnt<50) && (GUI_GetKey()==0)) {
    150              static GUI_PID_STATE StateLast;
    151              GUI_PID_STATE State;
    152              GUI_TOUCH_GetState(&State);
    153              if ((StateLast.Pressed != State.Pressed) && (State.Pressed == 0)) {
    154                GUI_Clear();
    155              }
    156              if ((StateLast.x != State.x) || ((StateLast.y != State.y))) {
    157                if (State.Pressed) {
    158                  GUI_FillCircle(State.x, State.y, 5);
    159                }
    160                StateLast = State;
    161              }
    162              if (State.Pressed) {
    163                IdleCnt =0;
    164              } else {
    165                IdleCnt++;
   \                     ??_TestCalibration_1: (+1)
   \   00000040   0x1C64             ADDS     R4,R4,#+1
    166              }
    167              GUI_Delay (100);
   \                     ??_TestCalibration_2: (+1)
   \   00000042   0x2064             MOVS     R0,#+100
   \   00000044   0x.... 0x....      BL       GUI_Delay
   \                     ??_TestCalibration_0: (+1)
   \   00000048   0x2C32             CMP      R4,#+50
   \   0000004A   0xDA2A             BGE.N    ??_TestCalibration_3
   \   0000004C   0x.... 0x....      BL       GUI_GetKey
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD126             BNE.N    ??_TestCalibration_3
   \   00000054   0xA800             ADD      R0,SP,#+0
   \   00000056   0x.... 0x....      BL       GUI_TOUCH_GetState
   \   0000005A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000005E   0x....             LDR.N    R6,??DataTable20_2
   \   00000060   0x7A31             LDRB     R1,[R6, #+8]
   \   00000062   0x4281             CMP      R1,R0
   \   00000064   0xD003             BEQ.N    ??_TestCalibration_4
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD101             BNE.N    ??_TestCalibration_4
   \   0000006A   0x.... 0x....      BL       GUI_Clear
   \                     ??_TestCalibration_4: (+1)
   \   0000006E   0x6830             LDR      R0,[R6, #+0]
   \   00000070   0x9900             LDR      R1,[SP, #+0]
   \   00000072   0x4288             CMP      R0,R1
   \   00000074   0xD103             BNE.N    ??_TestCalibration_5
   \   00000076   0x6870             LDR      R0,[R6, #+4]
   \   00000078   0x9901             LDR      R1,[SP, #+4]
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xD00B             BEQ.N    ??_TestCalibration_6
   \                     ??_TestCalibration_5: (+1)
   \   0000007E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD004             BEQ.N    ??_TestCalibration_7
   \   00000086   0x2205             MOVS     R2,#+5
   \   00000088   0x9901             LDR      R1,[SP, #+4]
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0x.... 0x....      BL       GUI_FillCircle
   \                     ??_TestCalibration_7: (+1)
   \   00000090   0xA800             ADD      R0,SP,#+0
   \   00000092   0xC80E             LDM      R0!,{R1-R3}
   \   00000094   0xC60E             STM      R6!,{R1-R3}
   \                     ??_TestCalibration_6: (+1)
   \   00000096   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD0D0             BEQ.N    ??_TestCalibration_1
   \   0000009E   0x2400             MOVS     R4,#+0
   \   000000A0   0xE7CF             B.N      ??_TestCalibration_2
    168            }
    169            EDIT_Delete(hButton);
   \                     ??_TestCalibration_3: (+1)
   \   000000A2   0x4628             MOV      R0,R5
   \   000000A4   0x.... 0x....      BL       WM_DeleteWindow
    170          }
   \   000000A8   0xBD7F             POP      {R0-R6,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??StateLast:
   \   00000000                      DS8 12
    171          
    172          /*********************************************************************
    173          *
    174          *       _ExecKeyboard
    175          *
    176          **********************************************************************
    177          
    178          This creates a sample keyboard.
    179          The routine returns after ENTER or ESC has been pressed.
    180          */
    181          
    182          #if (LCD_XSIZE == 320) && (LCD_YSIZE == 240)
    183          
    184          static char _acText[] = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '='
    185                                  ,0, 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'
    186                                  ,0, 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'Q'
    187                                  ,0, 'Z', 'X', 'C', 'V', 'B', 'N', 'M', 'Ö', 'Ä', 'Ü'
    188                                  ,' ', ' ', ' ', ' ', ' ', 0, 0
    189          };
    190          
    191          static int _ExecKeyboard(void) {
    192            int i;
    193            int Key;
    194            BUTTON_Handle ahButton[52];
    195            BUTTON_Handle hButtonESC;
    196            EDIT_Handle   hEdit;
    197            GUI_RECT rText = {000,0, LCD_XSIZE, 20};
    198            GUI_SetBkColor(GUI_RED);  
    199            GUI_Clear();
    200            GUI_DrawBitmap(&bmSeggerLogoBlue, 0, 0);
    201            GUI_SetFont(&GUI_FontComic18B_ASCII);
    202            GUI_SetColor(GUI_WHITE);
    203            GUI_DispStringInRect("emWin", &rText, GUI_TA_RIGHT | GUI_TA_VCENTER);
    204            rText.y0 +=20;
    205            rText.y1 +=20;
    206            GUI_DispStringInRect("Touch screen demo", &rText, GUI_TA_RIGHT | GUI_TA_VCENTER);
    207            /* Create Keyboard Buttons */
    208            for (i=0; i< 51; i++) {
    209              int Pos = (i < 47) ? i : i+4;
    210              int x0 = 5  + 28*(Pos%11);
    211              int y0 = 100 + 28*(Pos/11);
    212              char c = _acText[i];
    213              int Id = c ? c : 1;
    214              char ac[2] = {0};
    215              char *s= ac;
    216              ac[0] = c;
    217              ahButton[i] = BUTTON_Create( x0, y0, 25, 25, Id,BUTTON_CF_SHOW );
    218              BUTTON_SetText   (ahButton[i], s);
    219              #if GUI_SUPPORT_MEMDEV
    220                BUTTON_EnableMemdev(ahButton[i]);
    221              #endif
    222            }
    223            ahButton[i] = BUTTON_Create( 89, 212, 109, 25, ' ',BUTTON_CF_SHOW );
    224            hButtonESC = BUTTON_Create( 230, 40, 80, 25, GUI_ID_CANCEL,BUTTON_CF_SHOW );
    225            BUTTON_SetText   (hButtonESC, "ESC");
    226            hEdit = EDIT_Create( 5, 70, 310, 25, ' ', 80, 0 );
    227            EDIT_SetFont(hEdit, &GUI_Font8x16);
    228            BUTTON_SetBkColor(ahButton[49], 0, GUI_RED);
    229            BUTTON_SetBkColor(ahButton[50], 0, GUI_BLUE);
    230            /* Handle Keyboard until ESC or ENTER is pressed */
    231            do {
    232              Key = GUIDEMO_WaitKey();
    233              switch (Key) {
    234              case 0:
    235              case GUI_ID_CANCEL:
    236               break;
    237              default:
    238                EDIT_AddKey(hEdit, Key);
    239              }
    240            } while ((Key != 'N') && (Key!=GUI_ID_CANCEL) && (Key!=0));
    241            /* Cleanup */
    242            for (i=0; i< countof(ahButton); i++) {
    243              BUTTON_Delete(ahButton[i]);
    244            }
    245            BUTTON_Delete(hButtonESC);
    246            EDIT_Delete(hEdit);
    247            return Key;
    248          }
    249          
    250          #else
    251          

   \                                 In section .data, align 4
    252          static char _acText[] = {
   \                     _acText:
   \   00000000   0x37 0x38          DC8 55, 56, 57, 47, 52, 53, 54, 42, 49, 50, 51, 45, 48, 44, 43, 61, 0
   \              0x39 0x2F    
   \              0x34 0x35    
   \              0x36 0x2A    
   \              0x31 0x32    
   \              0x33 0x2D    
   \              0x30 0x2C    
   \              0x2B 0x3D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    253            '7','8','9','/',
    254            '4','5','6','*',
    255            '1','2','3','-',
    256            '0',',','+','=',0
    257          };
    258          

   \                                 In section .text, align 2, keep-with-next
    259          static int _ExecKeyboard(void) {
   \                     _ExecKeyboard: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08E             SUB      SP,SP,#+56
    260            int y0 = 75;
    261            int XSize = LCD_GetXSize();
   \   00000006   0x.... 0x....      BL       LCD_GetXSize
   \   0000000A   0x4604             MOV      R4,R0
    262            int YSize = LCD_GetYSize();
   \   0000000C   0x.... 0x....      BL       LCD_GetYSize
    263            int XStep = XSize / 4;
   \   00000010   0x1061             ASRS     R1,R4,#+1
   \   00000012   0xEB04 0x7191      ADD      R1,R4,R1, LSR #+30
   \   00000016   0x108D             ASRS     R5,R1,#+2
    264            int YStep = (YSize - y0) / 4;
   \   00000018   0x384B             SUBS     R0,R0,#+75
   \   0000001A   0x1041             ASRS     R1,R0,#+1
   \   0000001C   0xEB00 0x7091      ADD      R0,R0,R1, LSR #+30
   \   00000020   0x1086             ASRS     R6,R0,#+2
    265            int i;
    266            int Key;
    267            BUTTON_Handle ahButton[16];
    268            BUTTON_Handle hButtonESC;
    269            EDIT_Handle   hEdit;
    270            GUI_RECT rText = {0};
   \   00000022   0x.... 0x....      ADR.W    R0,`?<Constant {0}>`
   \   00000026   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   0000002A   0xE9CD 0x2303      STRD     R2,R3,[SP, #+12]
    271            rText.x1 = LCD_GetXSize() - 3;
   \   0000002E   0x.... 0x....      BL       LCD_GetXSize
   \   00000032   0x1EC0             SUBS     R0,R0,#+3
   \   00000034   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    272            rText.y1 = 20;
   \   00000038   0x2014             MOVS     R0,#+20
   \   0000003A   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    273            GUI_SetBkColor(GUI_RED);  
   \   0000003E   0x20FF             MOVS     R0,#+255
   \   00000040   0x.... 0x....      BL       GUI_SetBkColor
    274            GUI_Clear();
   \   00000044   0x.... 0x....      BL       GUI_Clear
    275            GUI_SetFont(&GUI_FontComic18B_ASCII);
   \   00000048   0x....             LDR.N    R0,??DataTable20_1
   \   0000004A   0x.... 0x....      BL       GUI_SetFont
    276            GUI_SetColor(GUI_WHITE);
   \   0000004E   0xF06F 0x407F      MVN      R0,#-16777216
   \   00000052   0x.... 0x....      BL       GUI_SetColor
    277            GUI_DispStringInRect("emWin", &rText, GUI_TA_RIGHT | GUI_TA_VCENTER);
   \   00000056   0x220D             MOVS     R2,#+13
   \   00000058   0xA903             ADD      R1,SP,#+12
   \   0000005A   0x.... 0x....      ADR.W    R0,`?<Constant "emWin">`
   \   0000005E   0x.... 0x....      BL       GUI_DispStringInRect
    278            rText.y0 +=20;
   \   00000062   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \   00000066   0x3014             ADDS     R0,R0,#+20
   \   00000068   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    279            rText.y1 +=20;
   \   0000006C   0xF8BD 0x0012      LDRH     R0,[SP, #+18]
   \   00000070   0x3014             ADDS     R0,R0,#+20
   \   00000072   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    280            GUI_DispStringInRect("Touch screen demo", &rText, GUI_TA_RIGHT | GUI_TA_VCENTER);
   \   00000076   0x220D             MOVS     R2,#+13
   \   00000078   0xA903             ADD      R1,SP,#+12
   \   0000007A   0x.... 0x....      ADR.W    R0,`?<Constant "Touch screen demo">`
   \   0000007E   0x.... 0x....      BL       GUI_DispStringInRect
    281            /* Create Keyboard Buttons */
    282            for (i=0; _acText[i]; i++) {
   \   00000082   0x2700             MOVS     R7,#+0
   \   00000084   0xE019             B.N      ??_ExecKeyboard_0
    283              int XPos = (i%4) * XStep + 3;
    284              int YPos = (i/4) * YStep + 3 + y0;
    285              char c = _acText[i];
    286              int Id = c ? c : 1;
   \                     ??_ExecKeyboard_1: (+1)
   \   00000086   0x2301             MOVS     R3,#+1
    287              char ac[2] = {0};
   \                     ??_ExecKeyboard_2: (+1)
   \   00000088   0xF04F 0x0C00      MOV      R12,#+0
   \   0000008C   0xF8AD 0xC008      STRH     R12,[SP, #+8]
    288              char *s= ac;
    289              ac[0] = c;
   \   00000090   0xF88D 0x2008      STRB     R2,[SP, #+8]
    290              ahButton[i] = BUTTON_Create( XPos, YPos, XStep - 5, YStep - 5, Id, BUTTON_CF_SHOW );
   \   00000094   0x2202             MOVS     R2,#+2
   \   00000096   0x9201             STR      R2,[SP, #+4]
   \   00000098   0x9300             STR      R3,[SP, #+0]
   \   0000009A   0x1F73             SUBS     R3,R6,#+5
   \   0000009C   0x1F6A             SUBS     R2,R5,#+5
   \   0000009E   0x.... 0x....      BL       BUTTON_Create
   \   000000A2   0x4680             MOV      R8,R0
   \   000000A4   0xA805             ADD      R0,SP,#+20
   \   000000A6   0xF820 0x8017      STRH     R8,[R0, R7, LSL #+1]
    291              BUTTON_SetText(ahButton[i], s);
   \   000000AA   0xA902             ADD      R1,SP,#+8
   \   000000AC   0x4640             MOV      R0,R8
   \   000000AE   0x.... 0x....      BL       BUTTON_SetText
    292              BUTTON_EnableMemdev(ahButton[i]);
   \   000000B2   0x4640             MOV      R0,R8
   \   000000B4   0x.... 0x....      BL       WM_EnableMemdev
   \   000000B8   0x1C7F             ADDS     R7,R7,#+1
   \                     ??_ExecKeyboard_0: (+1)
   \   000000BA   0x....             LDR.N    R0,??DataTable20_3
   \   000000BC   0x563A             LDRSB    R2,[R7, R0]
   \   000000BE   0x2A00             CMP      R2,#+0
   \   000000C0   0xD00D             BEQ.N    ??_ExecKeyboard_3
   \   000000C2   0x1078             ASRS     R0,R7,#+1
   \   000000C4   0xEB07 0x7090      ADD      R0,R7,R0, LSR #+30
   \   000000C8   0x1081             ASRS     R1,R0,#+2
   \   000000CA   0xEBA7 0x0081      SUB      R0,R7,R1, LSL #+2
   \   000000CE   0x4368             MULS     R0,R5,R0
   \   000000D0   0x1CC0             ADDS     R0,R0,#+3
   \   000000D2   0x4371             MULS     R1,R6,R1
   \   000000D4   0x314E             ADDS     R1,R1,#+78
   \   000000D6   0x2A00             CMP      R2,#+0
   \   000000D8   0xD0D5             BEQ.N    ??_ExecKeyboard_1
   \   000000DA   0x4613             MOV      R3,R2
   \   000000DC   0xE7D4             B.N      ??_ExecKeyboard_2
    293            }
    294            hButtonESC = BUTTON_Create( 3, 3, 80, 25, GUI_ID_CANCEL, BUTTON_CF_SHOW );
   \                     ??_ExecKeyboard_3: (+1)
   \   000000DE   0x2002             MOVS     R0,#+2
   \   000000E0   0x9001             STR      R0,[SP, #+4]
   \   000000E2   0x9000             STR      R0,[SP, #+0]
   \   000000E4   0x2319             MOVS     R3,#+25
   \   000000E6   0x2250             MOVS     R2,#+80
   \   000000E8   0x2103             MOVS     R1,#+3
   \   000000EA   0x4608             MOV      R0,R1
   \   000000EC   0x.... 0x....      BL       BUTTON_Create
   \   000000F0   0x4605             MOV      R5,R0
    295            BUTTON_SetText(hButtonESC, "ESC");
   \   000000F2   0x....             ADR.N    R1,??DataTable20  ;; "ESC"
   \   000000F4   0x.... 0x....      BL       BUTTON_SetText
    296            hEdit = EDIT_Create( 5, y0 - 30, XSize - 10, 25, ' ', 80, 0 );
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x9002             STR      R0,[SP, #+8]
   \   000000FC   0x2050             MOVS     R0,#+80
   \   000000FE   0x9001             STR      R0,[SP, #+4]
   \   00000100   0x2020             MOVS     R0,#+32
   \   00000102   0x9000             STR      R0,[SP, #+0]
   \   00000104   0x2319             MOVS     R3,#+25
   \   00000106   0xF1A4 0x020A      SUB      R2,R4,#+10
   \   0000010A   0x212D             MOVS     R1,#+45
   \   0000010C   0x2005             MOVS     R0,#+5
   \   0000010E   0x.... 0x....      BL       EDIT_Create
   \   00000112   0x4604             MOV      R4,R0
    297            EDIT_SetFont(hEdit, &GUI_Font8x16);
   \   00000114   0x....             LDR.N    R1,??DataTable20_4
   \   00000116   0x.... 0x....      BL       EDIT_SetFont
    298            /* Handle Keyboard until ESC or ENTER is pressed */
    299            do {
    300              Key = GUIDEMO_WaitKey();
   \                     ??_ExecKeyboard_4: (+1)
   \   0000011A   0x.... 0x....      BL       GUIDEMO_WaitKey
   \   0000011E   0x0006             MOVS     R6,R0
    301              switch (Key) {
   \   00000120   0xD005             BEQ.N    ??_ExecKeyboard_5
   \   00000122   0x2802             CMP      R0,#+2
   \   00000124   0xD003             BEQ.N    ??_ExecKeyboard_5
    302              case 0:
    303              case GUI_ID_CANCEL:
    304               break;
    305              default:
    306                EDIT_AddKey(hEdit, Key);
   \   00000126   0x4631             MOV      R1,R6
   \   00000128   0x4620             MOV      R0,R4
   \   0000012A   0x.... 0x....      BL       EDIT_AddKey
    307              }
    308            } while ((Key != 'N') && (Key!=GUI_ID_CANCEL) && (Key!=0));
   \                     ??_ExecKeyboard_5: (+1)
   \   0000012E   0x2E4E             CMP      R6,#+78
   \   00000130   0xD003             BEQ.N    ??_ExecKeyboard_6
   \   00000132   0x2E02             CMP      R6,#+2
   \   00000134   0xD001             BEQ.N    ??_ExecKeyboard_6
   \   00000136   0x2E00             CMP      R6,#+0
   \   00000138   0xD1EF             BNE.N    ??_ExecKeyboard_4
    309            /* Cleanup */
    310            for (i=0; i< countof(ahButton); i++) {
   \                     ??_ExecKeyboard_6: (+1)
   \   0000013A   0x2700             MOVS     R7,#+0
   \   0000013C   0xE005             B.N      ??_ExecKeyboard_7
    311              BUTTON_Delete(ahButton[i]);
   \                     ??_ExecKeyboard_8: (+1)
   \   0000013E   0xA805             ADD      R0,SP,#+20
   \   00000140   0xF930 0x0017      LDRSH    R0,[R0, R7, LSL #+1]
   \   00000144   0x.... 0x....      BL       WM_DeleteWindow
    312            }
   \   00000148   0x1C7F             ADDS     R7,R7,#+1
   \                     ??_ExecKeyboard_7: (+1)
   \   0000014A   0x2F10             CMP      R7,#+16
   \   0000014C   0xD3F7             BCC.N    ??_ExecKeyboard_8
    313            BUTTON_Delete(hButtonESC);
   \   0000014E   0x4628             MOV      R0,R5
   \   00000150   0x.... 0x....      BL       WM_DeleteWindow
    314            EDIT_Delete(hEdit);
   \   00000154   0x4620             MOV      R0,R4
   \   00000156   0x.... 0x....      BL       WM_DeleteWindow
    315            return Key;
   \   0000015A   0x4630             MOV      R0,R6
   \   0000015C   0xB00E             ADD      SP,SP,#+56
   \   0000015E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    316          }
    317          
    318          #endif
    319          
    320          /*
    321          **********************************************************************
    322          *
    323          *              USER_Task
    324          *
    325          **********************************************************************
    326          */
    327          
    328          #if GUIDEMO_LARGE
    329          

   \                                 In section .text, align 2, keep-with-next
    330          void GUIDEMO_Touch(void) {
   \                     GUIDEMO_Touch: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
    331            #define ID_KEYBOARD  1
    332            #define ID_TESTCAL   2
    333            #define ID_CALIBRATE 3
    334            int i, r;
    335            int XSize = LCD_GetXSize();
   \   00000006   0x.... 0x....      BL       LCD_GetXSize
   \   0000000A   0x4604             MOV      R4,R0
    336            int YSize = LCD_GetYSize();
   \   0000000C   0x.... 0x....      BL       LCD_GetYSize
    337            int XMid = XSize / 2;
   \   00000010   0xEB04 0x71D4      ADD      R1,R4,R4, LSR #+31
   \   00000014   0x104D             ASRS     R5,R1,#+1
    338            int YMid = YSize / 2;
   \   00000016   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   0000001A   0x1046             ASRS     R6,R0,#+1
    339            GUIDEMO_NotifyStartNext();
   \   0000001C   0x.... 0x....      BL       GUIDEMO_NotifyStartNext
    340            GUIDEMO_HideInfoWin();
   \   00000020   0x.... 0x....      BL       GUIDEMO_HideInfoWin
   \   00000024   0xF10D 0x0908      ADD      R9,SP,#+8
    341            do {
    342              GUI_RECT rText;/*= {0, 80, XSize, 120};*/
    343              BUTTON_Handle ahButton[3];
    344              rText.x0=0;
   \                     ??GUIDEMO_Touch_0: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    345              rText.y0=80;
   \   0000002E   0x2050             MOVS     R0,#+80
   \   00000030   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    346              rText.x1=XSize;
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    347              rText.y1=120;
   \   0000003A   0x2078             MOVS     R0,#+120
   \   0000003C   0xF8AD 0x0016      STRH     R0,[SP, #+22]
    348              GUI_SetBkColor(GUI_BLUE);
   \   00000040   0xF44F 0x007F      MOV      R0,#+16711680
   \   00000044   0x.... 0x....      BL       GUI_SetBkColor
    349              GUI_Clear();
   \   00000048   0x.... 0x....      BL       GUI_Clear
    350              GUI_DrawBitmap(&bmSeggerLogoBlue, (XSize - 1 - bmSeggerLogoBlue.XSize) / 2, 15);
   \   0000004C   0x....             LDR.N    R0,??DataTable20_5
   \   0000004E   0x1E61             SUBS     R1,R4,#+1
   \   00000050   0x8802             LDRH     R2,[R0, #+0]
   \   00000052   0x1A89             SUBS     R1,R1,R2
   \   00000054   0x220F             MOVS     R2,#+15
   \   00000056   0xEB01 0x71D1      ADD      R1,R1,R1, LSR #+31
   \   0000005A   0x1049             ASRS     R1,R1,#+1
   \   0000005C   0x.... 0x....      BL       GUI_DrawBitmap
    351              GUI_SetFont(&GUI_FontComic18B_ASCII);
   \   00000060   0x....             LDR.N    R7,??DataTable20_1
   \   00000062   0x4638             MOV      R0,R7
   \   00000064   0x.... 0x....      BL       GUI_SetFont
    352              GUI_DispStringInRect("emWin Touch screen demo", &rText, GUI_TA_HCENTER | GUI_TA_VCENTER);
   \   00000068   0x220E             MOVS     R2,#+14
   \   0000006A   0xA904             ADD      R1,SP,#+16
   \   0000006C   0x.... 0x....      ADR.W    R0,`?<Constant "emWin Touch screen demo">`
   \   00000070   0x.... 0x....      BL       GUI_DispStringInRect
    353              ahButton[0] =  BUTTON_Create( XMid - 50, YMid - 20, 100, 50, ID_CALIBRATE,BUTTON_CF_SHOW );
   \   00000074   0x2002             MOVS     R0,#+2
   \   00000076   0x9001             STR      R0,[SP, #+4]
   \   00000078   0x2003             MOVS     R0,#+3
   \   0000007A   0x9000             STR      R0,[SP, #+0]
   \   0000007C   0x2332             MOVS     R3,#+50
   \   0000007E   0x2264             MOVS     R2,#+100
   \   00000080   0xF1A6 0x0114      SUB      R1,R6,#+20
   \   00000084   0xF1A5 0x0032      SUB      R0,R5,#+50
   \   00000088   0x.... 0x....      BL       BUTTON_Create
   \   0000008C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    354              ahButton[1] =  BUTTON_Create( XMid - 90, YMid + 40, 80, 30, ID_KEYBOARD, BUTTON_CF_SHOW );
   \   00000090   0xF106 0x0A28      ADD      R10,R6,#+40
   \   00000094   0x2002             MOVS     R0,#+2
   \   00000096   0x9001             STR      R0,[SP, #+4]
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x9000             STR      R0,[SP, #+0]
   \   0000009C   0x231E             MOVS     R3,#+30
   \   0000009E   0x2250             MOVS     R2,#+80
   \   000000A0   0x4651             MOV      R1,R10
   \   000000A2   0xF1A5 0x005A      SUB      R0,R5,#+90
   \   000000A6   0x.... 0x....      BL       BUTTON_Create
   \   000000AA   0x4680             MOV      R8,R0
   \   000000AC   0xF8A9 0x8002      STRH     R8,[R9, #+2]
    355              ahButton[2] =  BUTTON_Create( XMid + 10, YMid + 40, 80, 30, ID_TESTCAL,BUTTON_CF_SHOW );
   \   000000B0   0x2002             MOVS     R0,#+2
   \   000000B2   0x9001             STR      R0,[SP, #+4]
   \   000000B4   0x9000             STR      R0,[SP, #+0]
   \   000000B6   0x231E             MOVS     R3,#+30
   \   000000B8   0x2250             MOVS     R2,#+80
   \   000000BA   0x4651             MOV      R1,R10
   \   000000BC   0xF105 0x000A      ADD      R0,R5,#+10
   \   000000C0   0x.... 0x....      BL       BUTTON_Create
   \   000000C4   0x4682             MOV      R10,R0
   \   000000C6   0xF8A9 0xA004      STRH     R10,[R9, #+4]
    356              BUTTON_SetText (ahButton[0], "Calibrate");
   \   000000CA   0x.... 0x....      ADR.W    R1,`?<Constant "Calibrate">`
   \   000000CE   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   000000D2   0x.... 0x....      BL       BUTTON_SetText
    357              BUTTON_SetBkColor(ahButton[0], 0, GUI_RED);
   \   000000D6   0x22FF             MOVS     R2,#+255
   \   000000D8   0x2100             MOVS     R1,#+0
   \   000000DA   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   000000DE   0x.... 0x....      BL       BUTTON_SetBkColor
    358              BUTTON_SetText (ahButton[1], "Keyboard");
   \   000000E2   0x.... 0x....      ADR.W    R1,`?<Constant "Keyboard">`
   \   000000E6   0x4640             MOV      R0,R8
   \   000000E8   0x.... 0x....      BL       BUTTON_SetText
    359              BUTTON_SetText (ahButton[2], "Test calibration");
   \   000000EC   0x.... 0x....      ADR.W    R1,`?<Constant "Test calibration">`
   \   000000F0   0x4650             MOV      R0,R10
   \   000000F2   0x.... 0x....      BL       BUTTON_SetText
    360              BUTTON_SetFont(ahButton[0], &GUI_FontComic18B_ASCII);
   \   000000F6   0x4639             MOV      R1,R7
   \   000000F8   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   000000FC   0x.... 0x....      BL       BUTTON_SetFont
    361              r = GUIDEMO_WaitKey();
   \   00000100   0x.... 0x....      BL       GUIDEMO_WaitKey
   \   00000104   0x0007             MOVS     R7,R0
    362              if (r==0) {
   \   00000106   0xD109             BNE.N    ??GUIDEMO_Touch_1
    363                r = ID_KEYBOARD;
   \   00000108   0x2701             MOVS     R7,#+1
    364                BUTTON_SetState(ahButton[1], BUTTON_STATE_PRESSED);
   \   0000010A   0xF44F 0x7180      MOV      R1,#+256
   \   0000010E   0x4640             MOV      R0,R8
   \   00000110   0x.... 0x....      BL       BUTTON_SetState
    365                GUIDEMO_Delay(500);
   \   00000114   0xF44F 0x70FA      MOV      R0,#+500
   \   00000118   0x.... 0x....      BL       GUIDEMO_Delay
    366              }
    367              for (i=0; i< countof(ahButton); i++) {
   \                     ??GUIDEMO_Touch_1: (+1)
   \   0000011C   0xF04F 0x0800      MOV      R8,#+0
   \   00000120   0xE005             B.N      ??GUIDEMO_Touch_2
    368                BUTTON_Delete(ahButton[i]);
   \                     ??GUIDEMO_Touch_3: (+1)
   \   00000122   0xF939 0x0018      LDRSH    R0,[R9, R8, LSL #+1]
   \   00000126   0x.... 0x....      BL       WM_DeleteWindow
    369              }
   \   0000012A   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??GUIDEMO_Touch_2: (+1)
   \   0000012E   0xF1B8 0x0F03      CMP      R8,#+3
   \   00000132   0xD3F6             BCC.N    ??GUIDEMO_Touch_3
    370              switch (r) {
   \   00000134   0x2F01             CMP      R7,#+1
   \   00000136   0xD004             BEQ.N    ??GUIDEMO_Touch_4
   \   00000138   0xD30C             BCC.N    ??GUIDEMO_Touch_5
   \   0000013A   0x2F03             CMP      R7,#+3
   \   0000013C   0xD005             BEQ.N    ??GUIDEMO_Touch_6
   \   0000013E   0xD307             BCC.N    ??GUIDEMO_Touch_7
   \   00000140   0xE008             B.N      ??GUIDEMO_Touch_5
    371              case ID_KEYBOARD:  r= _ExecKeyboard(); break;
   \                     ??GUIDEMO_Touch_4: (+1)
   \   00000142   0x.... 0x....      BL       _ExecKeyboard
   \   00000146   0x4607             MOV      R7,R0
   \   00000148   0xE004             B.N      ??GUIDEMO_Touch_5
    372              case ID_CALIBRATE: _ExecCalibration(); break;
   \                     ??GUIDEMO_Touch_6: (+1)
   \   0000014A   0x.... 0x....      BL       _ExecCalibration
   \   0000014E   0xE001             B.N      ??GUIDEMO_Touch_5
    373              case ID_TESTCAL:   _TestCalibration(); break;
   \                     ??GUIDEMO_Touch_7: (+1)
   \   00000150   0x.... 0x....      BL       _TestCalibration
    374              }
    375            } while (r && (r!='n') && (r!='N'));
   \                     ??GUIDEMO_Touch_5: (+1)
   \   00000154   0x2F00             CMP      R7,#+0
   \   00000156   0xD004             BEQ.N    ??GUIDEMO_Touch_8
   \   00000158   0x2F6E             CMP      R7,#+110
   \   0000015A   0xD002             BEQ.N    ??GUIDEMO_Touch_8
   \   0000015C   0x2F4E             CMP      R7,#+78
   \   0000015E   0xF47F 0xAF63      BNE.W    ??GUIDEMO_Touch_0
    376          }
   \                     ??GUIDEMO_Touch_8: (+1)
   \   00000162   0xB006             ADD      SP,SP,#+24
   \   00000164   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x4F 0x4B          DC8      0x4F, 0x4B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x45 0x53          DC8      "ESC"
   \              0x43 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     GUI_FontComic18B_ASCII

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     ??StateLast

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     _acText

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x........         DC32     GUI_Font8x16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x........         DC32     bmSeggerLogoBlue

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "OK">`:
   \   00000000   0x4F 0x4B          DC8 "OK"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Press here">`:
   \   00000000   0x50 0x72          DC8 "Press here"
   \              0x65 0x73    
   \              0x73 0x20    
   \              0x68 0x65    
   \              0x72 0x65    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "x0: ">`:
   \   00000000   0x78 0x30          DC8 "x0: "
   \              0x3A 0x20    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "x1: ">`:
   \   00000000   0x78 0x31          DC8 "x1: "
   \              0x3A 0x20    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "y0: ">`:
   \   00000000   0x79 0x30          DC8 "y0: "
   \              0x3A 0x20    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "y1: ">`:
   \   00000000   0x79 0x31          DC8 "y1: "
   \              0x3A 0x20    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Please touch display ...">`:
   \   00000000   0x50 0x6C          DC8 "Please touch display to continue..."
   \              0x65 0x61    
   \              0x73 0x65    
   \              0x20 0x74    
   \              0x6F 0x75    
   \              0x63 0x68    
   \              0x20 0x64    
   \              0x69 0x73    
   \              0x70 0x6C    
   \              0x61 0x79    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x63 0x6F    
   \              0x6E 0x74    
   \              0x69 0x6E    
   \              0x75 0x65    
   \              0x2E 0x2E    
   \              0x2E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ABORT">`:
   \   00000000   0x41 0x42          DC8 "ABORT"
   \              0x4F 0x52    
   \              0x54 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000   0x0000             DC16 0
   \   00000002   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "emWin">`:
   \   00000000   0x65 0x6D          DC8 "emWin"
   \              0x57 0x69    
   \              0x6E 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Touch screen demo">`:
   \   00000000   0x54 0x6F          DC8 "Touch screen demo"
   \              0x75 0x63    
   \              0x68 0x20    
   \              0x73 0x63    
   \              0x72 0x65    
   \              0x65 0x6E    
   \              0x20 0x64    
   \              0x65 0x6D    
   \              0x6F 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "emWin Touch screen demo">`:
   \   00000000   0x65 0x6D          DC8 "emWin Touch screen demo"
   \              0x57 0x69    
   \              0x6E 0x20    
   \              0x54 0x6F    
   \              0x75 0x63    
   \              0x68 0x20    
   \              0x73 0x63    
   \              0x72 0x65    
   \              0x65 0x6E    
   \              0x20 0x64    
   \              0x65 0x6D    
   \              0x6F 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Calibrate">`:
   \   00000000   0x43 0x61          DC8 "Calibrate"
   \              0x6C 0x69    
   \              0x62 0x72    
   \              0x61 0x74    
   \              0x65 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Keyboard">`:
   \   00000000   0x4B 0x65          DC8 "Keyboard"
   \              0x79 0x62    
   \              0x6F 0x61    
   \              0x72 0x64    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Test calibration">`:
   \   00000000   0x54 0x65          DC8 "Test calibration"
   \              0x73 0x74    
   \              0x20 0x63    
   \              0x61 0x6C    
   \              0x69 0x62    
   \              0x72 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant {0}>_1`:
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "ESC">`:
   \   00000000   0x45 0x53          DC8 "ESC"
   \              0x43 0x00    
    377          
    378          #else
    379          
    380          void GUIDEMO_Touch(void) {}
    381          
    382          #endif
    383          
    384          #else
    385          
    386          void GUIDEMO_Touch(void) {} /* avoid empty object files */
    387          
    388          #endif /* #if GUI_WINSUPPORT */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   GUIDEMO_Touch
        56   -> BUTTON_Create
        56   -> BUTTON_SetBkColor
        56   -> BUTTON_SetFont
        56   -> BUTTON_SetState
        56   -> BUTTON_SetText
        56   -> GUIDEMO_Delay
        56   -> GUIDEMO_HideInfoWin
        56   -> GUIDEMO_NotifyStartNext
        56   -> GUIDEMO_WaitKey
        56   -> GUI_Clear
        56   -> GUI_DispStringInRect
        56   -> GUI_DrawBitmap
        56   -> GUI_SetBkColor
        56   -> GUI_SetFont
        56   -> LCD_GetXSize
        56   -> LCD_GetYSize
        56   -> WM_DeleteWindow
        56   -> _ExecCalibration
        56   -> _ExecKeyboard
        56   -> _TestCalibration
      32   _Calibrate
        32   -> _Log2Phys
      64   _ExecCalibration
        64   -> GUI_Clear
        64   -> GUI_Delay
        64   -> GUI_DispDec
        64   -> GUI_DispNextLine
        64   -> GUI_DispString
        64   -> GUI_DispStringAt
        64   -> GUI_FillCircle
        64   -> GUI_SetBkColor
        64   -> GUI_SetColor
        64   -> GUI_SetTextAlign
        64   -> GUI_TOUCH_Calibrate
        64   -> GUI_TOUCH_GetState
        64   -> GUI_TOUCH_GetxPhys
        64   -> GUI_TOUCH_GetyPhys
        64   -> GUI_TOUCH_SetDefaultCalibration
        64   -> _Calibrate
      80   _ExecKeyboard
        80   -> BUTTON_Create
        80   -> BUTTON_SetText
        80   -> EDIT_AddKey
        80   -> EDIT_Create
        80   -> EDIT_SetFont
        80   -> GUIDEMO_WaitKey
        80   -> GUI_Clear
        80   -> GUI_DispStringInRect
        80   -> GUI_SetBkColor
        80   -> GUI_SetColor
        80   -> GUI_SetFont
        80   -> LCD_GetXSize
        80   -> LCD_GetYSize
        80   -> WM_DeleteWindow
        80   -> WM_EnableMemdev
       4   _Log2Phys
      32   _TestCalibration
        32   -> BUTTON_Create
        32   -> BUTTON_SetFont
        32   -> BUTTON_SetText
        32   -> GUI_Clear
        32   -> GUI_Delay
        32   -> GUI_FillCircle
        32   -> GUI_GetKey
        32   -> GUI_SetBkColor
        32   -> GUI_SetColor
        32   -> GUI_TOUCH_GetState
        32   -> WM_DeleteWindow


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "ABORT">
      12  ?<Constant "Calibrate">
       4  ?<Constant "ESC">
      12  ?<Constant "Keyboard">
       4  ?<Constant "OK">
      36  ?<Constant "Please touch display ...">
      12  ?<Constant "Press here">
      20  ?<Constant "Test calibration">
      20  ?<Constant "Touch screen demo">
      24  ?<Constant "emWin Touch screen demo">
       8  ?<Constant "emWin">
       8  ?<Constant "x0: ">
       8  ?<Constant "x1: ">
       8  ?<Constant "y0: ">
       8  ?<Constant "y1: ">
       8  ?<Constant {0}>
       2  ?<Constant {0}>_1
       4  ??DataTable19
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
     360  GUIDEMO_Touch
      12  StateLast
      62  _Calibrate
     466  _ExecCalibration
     354  _ExecKeyboard
      22  _Log2Phys
     170  _TestCalibration
      20  _acText

 
    12 bytes in section .bss
    20 bytes in section .data
    10 bytes in section .rodata
 1 654 bytes in section .text
 
 1 654 bytes of CODE  memory
    10 bytes of CONST memory
    32 bytes of DATA  memory

Errors: none
Warnings: none
