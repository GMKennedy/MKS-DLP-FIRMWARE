###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:08
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\source\stm32f4xx_gpio.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\source\stm32f4xx_gpio.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\stm32f4xx_gpio.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\stm32f4xx_gpio.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\source\stm32f4xx_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_gpio.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-November-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the GPIO peripheral:           
      9            *           + Initialization and Configuration
     10            *           + GPIO Read and Write
     11            *           + GPIO Alternate functions configuration
     12            * 
     13          @verbatim  
     14           ===============================================================================
     15                                ##### How to use this driver #####
     16           ===============================================================================       
     17           [..]             
     18             (#) Enable the GPIO AHB clock using the following function
     19                 RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
     20                         
     21             (#) Configure the GPIO pin(s) using GPIO_Init()
     22                 Four possible configuration are available for each pin:
     23                 (++) Input: Floating, Pull-up, Pull-down.
     24                 (++) Output: Push-Pull (Pull-up, Pull-down or no Pull)
     25                      Open Drain (Pull-up, Pull-down or no Pull). In output mode, the speed 
     26                      is configurable: 2 MHz, 25 MHz, 50 MHz or 100 MHz.
     27                 (++) Alternate Function: Push-Pull (Pull-up, Pull-down or no Pull) Open 
     28                      Drain (Pull-up, Pull-down or no Pull).
     29                 (++) Analog: required mode when a pin is to be used as ADC channel or DAC 
     30                      output.
     31             
     32             (#) Peripherals alternate function:
     33                 (++) For ADC and DAC, configure the desired pin in analog mode using 
     34                      GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AN;
     35                      (+++) For other peripherals (TIM, USART...):
     36                      (+++) Connect the pin to the desired peripherals' Alternate 
     37                               Function (AF) using GPIO_PinAFConfig() function
     38                      (+++) Configure the desired pin in alternate function mode using
     39                               GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     40                      (+++) Select the type, pull-up/pull-down and output speed via 
     41                               GPIO_PuPd, GPIO_OType and GPIO_Speed members
     42                      (+++) Call GPIO_Init() function
     43                    
     44             (#) To get the level of a pin configured in input mode use GPIO_ReadInputDataBit()
     45                      
     46             (#) To set/reset the level of a pin configured in output mode use 
     47                 GPIO_SetBits()/GPIO_ResetBits()
     48                           
     49             (#) During and just after reset, the alternate functions are not 
     50                 active and the GPIO pins are configured in input floating mode (except JTAG
     51                 pins).
     52            
     53             (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose 
     54                 (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has 
     55                 priority over the GPIO function.
     56            
     57             (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as 
     58                 general purpose PH0 and PH1, respectively, when the HSE oscillator is off. 
     59                 The HSE has priority over the GPIO function.
     60                         
     61          @endverbatim        
     62            *
     63            ******************************************************************************
     64            * @attention
     65            *
     66            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     67            *
     68            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     69            * You may not use this file except in compliance with the License.
     70            * You may obtain a copy of the License at:
     71            *
     72            *        http://www.st.com/software_license_agreement_liberty_v2
     73            *
     74            * Unless required by applicable law or agreed to in writing, software 
     75            * distributed under the License is distributed on an "AS IS" BASIS, 
     76            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     77            * See the License for the specific language governing permissions and
     78            * limitations under the License.
     79            *
     80            ******************************************************************************
     81            */
     82          
     83          /* Includes ------------------------------------------------------------------*/
     84          #include "stm32f4xx_gpio.h"

  #define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN)  || ((MODE) == GPIO_Mode_OUT) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_gpio.h",76  Warning[Pe047]: 
          incompatible redefinition of macro "IS_GPIO_MODE" (declared at line
          284 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_gpio.h")

  #define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Low_Speed) || ((SPEED) == GPIO_Medium_Speed) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_gpio.h",107  Warning[Pe047]: 
          incompatible redefinition of macro "IS_GPIO_SPEED" (declared at line
          296 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_gpio.h")

  #define IS_GPIO_PIN(PIN) ((((PIN) & (uint16_t)0x00) == 0x00) && ((PIN) != (uint16_t)0x00))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_gpio.h",182  Warning[Pe047]: 
          incompatible redefinition of macro "IS_GPIO_PIN" (declared at line
          283 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_gpio.h")

  #define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz)  || ((AF) == GPIO_AF_TIM14)     || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_gpio.h",371  Warning[Pe047]: 
          incompatible redefinition of macro "IS_GPIO_AF" (declared at line
          1262 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_gpio_ex.h")
     85          #include "stm32f4xx_rcc.h"

  #define RCC_HSE_OFF                      ((uint8_t)0x00)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",69  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_HSE_OFF" (declared at line
          138 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_HSE_ON                       ((uint8_t)0x01)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",70  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_HSE_ON" (declared at line
          139 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",72  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_HSE" (declared at line
          1328 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define IS_RCC_PLLM_VALUE(VALUE) ((VALUE) <= 63)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",85  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_PLLM_VALUE" (declared at
          line 1381 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define IS_RCC_PLLN_VALUE(VALUE) ((192 <= (VALUE)) && ((VALUE) <= 432))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",86  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_PLLN_VALUE" (declared at
          line 6363 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc_ex.h")

  #define IS_RCC_PLLP_VALUE(VALUE) (((VALUE) == 2) || ((VALUE) == 4) || ((VALUE) == 6) || ((VALUE) == 8))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_PLLP_VALUE" (declared at
          line 1383 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define IS_RCC_PLLQ_VALUE(VALUE) ((4 <= (VALUE)) && ((VALUE) <= 15))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",88  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_PLLQ_VALUE" (declared at
          line 1385 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define IS_RCC_PLLI2SN_VALUE(VALUE) ((192 <= (VALUE)) && ((VALUE) <= 432))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",90  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_PLLI2SN_VALUE" (declared
          at line 6364 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc_ex.h")

  #define IS_RCC_PLLI2SR_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 7))  
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",91  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_PLLI2SR_VALUE" (declared
          at line 6395 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc_ex.h")

  #define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",139  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_HCLK" (declared at line
          1387 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",156  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_PCLK" (declared at line
          1395 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_IT_LSIRDY                    ((uint8_t)0x01)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",166  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_IT_LSIRDY" (declared at line
          340 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_IT_LSERDY                    ((uint8_t)0x02)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",167  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_IT_LSERDY" (declared at line
          341 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_IT_HSIRDY                    ((uint8_t)0x04)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",168  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_IT_HSIRDY" (declared at line
          342 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_IT_HSERDY                    ((uint8_t)0x08)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",169  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_IT_HSERDY" (declared at line
          343 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_IT_PLLRDY                    ((uint8_t)0x10)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",170  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_IT_PLLRDY" (declared at line
          344 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_IT_PLLI2SRDY                 ((uint8_t)0x20) 
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",171  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_IT_PLLI2SRDY" (declared at
          line 345 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_IT_CSS                       ((uint8_t)0x80)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_IT_CSS" (declared at line
          346 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_LSE_OFF                      ((uint8_t)0x00)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",189  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_LSE_OFF" (declared at line
          148 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_LSE_ON                       ((uint8_t)0x01)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",190  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_LSE_ON" (declared at line
          149 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",192  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_LSE" (declared at line
          1331 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",233  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_RTCCLK_SOURCE" (declared
          at line 2633 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\Legacy/stm32_hal_legacy.h")

  #define IS_RCC_MCO1SOURCE(SOURCE) (((SOURCE) == RCC_MCO1Source_HSI) || ((SOURCE) == RCC_MCO1Source_LSE) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",462  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_MCO1SOURCE" (declared at
          line 1401 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2Source_SYSCLK) || ((SOURCE) == RCC_MCO2Source_PLLI2SCLK)|| \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",484  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_MCO2SOURCE" (declared at
          line 6558 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc_ex.h")

  #define RCC_FLAG_HSIRDY                  ((uint8_t)0x21)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",497  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_HSIRDY" (declared at
          line 361 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_FLAG_HSERDY                  ((uint8_t)0x31)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",498  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_HSERDY" (declared at
          line 362 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_FLAG_PLLRDY                  ((uint8_t)0x39)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",499  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_PLLRDY" (declared at
          line 363 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_FLAG_PLLI2SRDY               ((uint8_t)0x3B)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",500  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_PLLI2SRDY" (declared at
          line 364 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_FLAG_LSERDY                  ((uint8_t)0x41)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",502  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_LSERDY" (declared at
          line 367 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_FLAG_LSIRDY                  ((uint8_t)0x61)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",503  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_LSIRDY" (declared at
          line 370 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_FLAG_BORRST                  ((uint8_t)0x79)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",504  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_BORRST" (declared at
          line 371 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_FLAG_PINRST                  ((uint8_t)0x7A)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",505  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_PINRST" (declared at
          line 372 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_FLAG_PORRST                  ((uint8_t)0x7B)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",506  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_PORRST" (declared at
          line 373 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_FLAG_SFTRST                  ((uint8_t)0x7C)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",507  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_SFTRST" (declared at
          line 374 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_FLAG_IWDGRST                 ((uint8_t)0x7D)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",508  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_IWDGRST" (declared at
          line 375 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_FLAG_WWDGRST                 ((uint8_t)0x7E)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",509  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_WWDGRST" (declared at
          line 376 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define RCC_FLAG_LPWRRST                 ((uint8_t)0x7F)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",510  Warning[Pe047]: 
          incompatible redefinition of macro "RCC_FLAG_LPWRRST" (declared at
          line 377 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")

  #define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_rcc.h",520  Warning[Pe047]: 
          incompatible redefinition of macro "IS_RCC_CALIBRATION_VALUE"
          (declared at line 1407 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_rcc.h")
     86          
     87          /** @addtogroup STM32F4xx_StdPeriph_Driver
     88            * @{
     89            */
     90          
     91          /** @defgroup GPIO 
     92            * @brief GPIO driver modules
     93            * @{
     94            */ 
     95          
     96          /* Private typedef -----------------------------------------------------------*/
     97          /* Private define ------------------------------------------------------------*/
     98          /* Private macro -------------------------------------------------------------*/
     99          /* Private variables ---------------------------------------------------------*/
    100          /* Private function prototypes -----------------------------------------------*/
    101          /* Private functions ---------------------------------------------------------*/
    102          
    103          /** @defgroup GPIO_Private_Functions
    104            * @{
    105            */ 
    106          
    107          /** @defgroup GPIO_Group1 Initialization and Configuration
    108           *  @brief   Initialization and Configuration
    109           *
    110          @verbatim   
    111           ===============================================================================
    112                           ##### Initialization and Configuration #####
    113           ===============================================================================  
    114          
    115          @endverbatim
    116            * @{
    117            */
    118          
    119          /**
    120            * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
    121            * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
    122            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    123            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    124            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices.  
    125            * @retval None
    126            */

   \                                 In section .text, align 2, keep-with-next
    127          void GPIO_DeInit(GPIO_TypeDef* GPIOx)
    128          {
   \                     GPIO_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    129            /* Check the parameters */
    130            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    131          
    132            if (GPIOx == GPIOA)
   \   00000002   0x....             LDR.N    R1,??DataTable0  ;; 0x40020000
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD109             BNE.N    ??GPIO_DeInit_0
    133            {
    134              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x4608             MOV      R0,R1
   \   0000000C   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    135              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE8BD 0x4004      POP      {R2,LR}
   \   00000018   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    136            }
    137            else if (GPIOx == GPIOB)
   \                     ??GPIO_DeInit_0: (+1)
   \   0000001C   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40020400
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD109             BNE.N    ??GPIO_DeInit_1
    138            {
    139              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    140              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xE8BD 0x4004      POP      {R2,LR}
   \   00000032   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    141            }
    142            else if (GPIOx == GPIOC)
   \                     ??GPIO_DeInit_1: (+1)
   \   00000036   0x....             LDR.N    R1,??DataTable0_2  ;; 0x40020800
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD109             BNE.N    ??GPIO_DeInit_2
    143            {
    144              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x2004             MOVS     R0,#+4
   \   00000040   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    145              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x2004             MOVS     R0,#+4
   \   00000048   0xE8BD 0x4004      POP      {R2,LR}
   \   0000004C   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    146            }
    147            else if (GPIOx == GPIOD)
   \                     ??GPIO_DeInit_2: (+1)
   \   00000050   0x....             LDR.N    R1,??DataTable0_3  ;; 0x40020c00
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD109             BNE.N    ??GPIO_DeInit_3
    148            {
    149              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
   \   00000056   0x2101             MOVS     R1,#+1
   \   00000058   0x2008             MOVS     R0,#+8
   \   0000005A   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    150              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x2008             MOVS     R0,#+8
   \   00000062   0xE8BD 0x4004      POP      {R2,LR}
   \   00000066   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    151            }
    152            else if (GPIOx == GPIOE)
   \                     ??GPIO_DeInit_3: (+1)
   \   0000006A   0x....             LDR.N    R1,??DataTable0_4  ;; 0x40021000
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD109             BNE.N    ??GPIO_DeInit_4
    153            {
    154              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x2010             MOVS     R0,#+16
   \   00000074   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    155              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x2010             MOVS     R0,#+16
   \   0000007C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000080   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    156            }
    157            else if (GPIOx == GPIOF)
   \                     ??GPIO_DeInit_4: (+1)
   \   00000084   0x....             LDR.N    R1,??DataTable0_5  ;; 0x40021400
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD109             BNE.N    ??GPIO_DeInit_5
    158            {
    159              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
   \   0000008A   0x2101             MOVS     R1,#+1
   \   0000008C   0x2020             MOVS     R0,#+32
   \   0000008E   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    160              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0x2020             MOVS     R0,#+32
   \   00000096   0xE8BD 0x4004      POP      {R2,LR}
   \   0000009A   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    161            }
    162            else if (GPIOx == GPIOG)
   \                     ??GPIO_DeInit_5: (+1)
   \   0000009E   0x....             LDR.N    R1,??DataTable0_6  ;; 0x40021800
   \   000000A0   0x4288             CMP      R0,R1
   \   000000A2   0xD109             BNE.N    ??GPIO_DeInit_6
    163            {
    164              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
   \   000000A4   0x2101             MOVS     R1,#+1
   \   000000A6   0x2040             MOVS     R0,#+64
   \   000000A8   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    165              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x2040             MOVS     R0,#+64
   \   000000B0   0xE8BD 0x4004      POP      {R2,LR}
   \   000000B4   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    166            }
    167            else if (GPIOx == GPIOH)
   \                     ??GPIO_DeInit_6: (+1)
   \   000000B8   0x....             LDR.N    R1,??DataTable0_7  ;; 0x40021c00
   \   000000BA   0x4288             CMP      R0,R1
   \   000000BC   0xD109             BNE.N    ??GPIO_DeInit_7
    168            {
    169              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0x2080             MOVS     R0,#+128
   \   000000C2   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    170              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
   \   000000C6   0x2100             MOVS     R1,#+0
   \   000000C8   0x2080             MOVS     R0,#+128
   \   000000CA   0xE8BD 0x4004      POP      {R2,LR}
   \   000000CE   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    171            }
    172          
    173            else if (GPIOx == GPIOI)
   \                     ??GPIO_DeInit_7: (+1)
   \   000000D2   0x....             LDR.N    R1,??DataTable0_8  ;; 0x40022000
   \   000000D4   0x4288             CMP      R0,R1
   \   000000D6   0xD10B             BNE.N    ??GPIO_DeInit_8
    174            {
    175              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
   \   000000D8   0x2101             MOVS     R1,#+1
   \   000000DA   0xF44F 0x7080      MOV      R0,#+256
   \   000000DE   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    176              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
   \   000000E2   0x2100             MOVS     R1,#+0
   \   000000E4   0xF44F 0x7080      MOV      R0,#+256
   \   000000E8   0xE8BD 0x4004      POP      {R2,LR}
   \   000000EC   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    177            }
    178          #if 0		//skyblue modidy 2016-11-30
    179            else if (GPIOx == GPIOJ)
    180            {
    181              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOJ, ENABLE);
    182              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOJ, DISABLE);
    183            }
    184            else
    185            {
    186              if (GPIOx == GPIOK)
    187              {
    188                RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
    189                RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
    190              }
    191            }
    192          #endif //skyblue modidy 2016-11-30  
    193          }
   \                     ??GPIO_DeInit_8: (+1)
   \   000000F0   0xBD01             POP      {R0,PC}          ;; return
    194          
    195          /**
    196            * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_InitStruct.
    197            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    198            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    199            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices.   
    200            * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
    201            *         the configuration information for the specified GPIO peripheral.
    202            * @retval None
    203            */

   \                                 In section .text, align 2, keep-with-next
    204          void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
    205          {
    206            uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
                            ^
Warning[Pe177]: variable "pinpos" was declared but never referenced

    uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
                            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\source\stm32f4xx_gpio.c",206  Warning[Pe177]: 
          variable "pos" was declared but never referenced

    uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
                                         ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\source\stm32f4xx_gpio.c",206  Warning[Pe177]: 
          variable "currentpin" was declared but never referenced
    207          
    208            /* Check the parameters */
    209            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    210            assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
    211            assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
    212            assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));
    213          
    214            /* ------------------------- Configure the port pins ---------------- */
    215            /*-- GPIO Mode Configuration --*/
    216          #if 0		//skyblue modidy 2016-11-30
    217            for (pinpos = 0x00; pinpos < 0x10; pinpos++)
    218            {
    219              pos = ((uint32_t)0x01) << pinpos;
    220              /* Get the port pins position */
    221              currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    222          
    223              if (currentpin == pos)
    224              {
    225                GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
    226                GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
    227          
    228                if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
    229                {
    230                  /* Check Speed mode parameters */
    231                  assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    232          
    233                  /* Speed mode configuration */
    234                  GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
    235                  GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
    236          
    237                  /* Check Output mode parameters */
    238                  assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));
    239          
    240                  /* Output mode configuration*/
    241                  GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
    242                  GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
    243                }
    244          
    245                /* Pull-up Pull down resistor configuration*/
    246                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
    247                GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    248              }
    249            }
    250          #endif //skyblue modidy 2016-11-30  
    251          }
   \                     GPIO_Init: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    252          
    253          /**
    254            * @brief  Fills each GPIO_InitStruct member with its default value.
    255            * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will be initialized.
    256            * @retval None
    257            */

   \                                 In section .text, align 2, keep-with-next
    258          void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
    259          {
    260          #if 0		//skyblue modidy 2016-11-30  
    261            /* Reset GPIO init structure parameters values */
    262            GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
    263            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
    264            GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
    265            GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
    266            GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
    267          #endif //skyblue modidy 2016-11-30  
    268          }
   \                     GPIO_StructInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    269          
    270          /**
    271            * @brief  Locks GPIO Pins configuration registers.
    272            * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    273            *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    274            * @note   The configuration of the locked GPIO pins can no longer be modified
    275            *         until the next reset.
    276            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    277            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    278            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    279            * @param  GPIO_Pin: specifies the port bit to be locked.
    280            *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    281            * @retval None
    282            */

   \                                 In section .text, align 2, keep-with-next
    283          void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    284          {
   \                     GPIO_PinLockConfig: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    285            __IO uint32_t tmp = 0x00010000;
   \   00000002   0xF44F 0x3280      MOV      R2,#+65536
   \   00000006   0x9200             STR      R2,[SP, #+0]
    286          
    287            /* Check the parameters */
    288            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    289            assert_param(IS_GPIO_PIN(GPIO_Pin));
    290          
    291            tmp |= GPIO_Pin;
   \   00000008   0x9A00             LDR      R2,[SP, #+0]
   \   0000000A   0x430A             ORRS     R2,R1,R2
   \   0000000C   0x9200             STR      R2,[SP, #+0]
    292            /* Set LCKK bit */
    293            GPIOx->LCKR = tmp;
   \   0000000E   0x9A00             LDR      R2,[SP, #+0]
   \   00000010   0x61C2             STR      R2,[R0, #+28]
    294            /* Reset LCKK bit */
    295            GPIOx->LCKR =  GPIO_Pin;
   \   00000012   0x61C1             STR      R1,[R0, #+28]
    296            /* Set LCKK bit */
    297            GPIOx->LCKR = tmp;
   \   00000014   0x9900             LDR      R1,[SP, #+0]
   \   00000016   0x61C1             STR      R1,[R0, #+28]
    298            /* Read LCKK bit*/
    299            tmp = GPIOx->LCKR;
   \   00000018   0x69C1             LDR      R1,[R0, #+28]
   \   0000001A   0x9100             STR      R1,[SP, #+0]
    300            /* Read LCKK bit*/
    301            tmp = GPIOx->LCKR;
   \   0000001C   0x69C0             LDR      R0,[R0, #+28]
   \   0000001E   0x9000             STR      R0,[SP, #+0]
    302          }
   \   00000020   0xB001             ADD      SP,SP,#+4
   \   00000022   0x4770             BX       LR               ;; return
    303          
    304          /**
    305            * @}
    306            */
    307          
    308          /** @defgroup GPIO_Group2 GPIO Read and Write
    309           *  @brief   GPIO Read and Write
    310           *
    311          @verbatim   
    312           ===============================================================================
    313                                   ##### GPIO Read and Write #####
    314           ===============================================================================  
    315          
    316          @endverbatim
    317            * @{
    318            */
    319          
    320          /**
    321            * @brief  Reads the specified input port pin.
    322            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    323            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    324            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    325            * @param  GPIO_Pin: specifies the port bit to read.
    326            *         This parameter can be GPIO_Pin_x where x can be (0..15).
    327            * @retval The input port pin value.
    328            */

   \                                 In section .text, align 2, keep-with-next
    329          uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    330          {
    331            uint8_t bitstatus = 0x00;
   \                     GPIO_ReadInputDataBit: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    332          
    333            /* Check the parameters */
    334            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    335            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    336          
    337            if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
   \   00000002   0x6900             LDR      R0,[R0, #+16]
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xD000             BEQ.N    ??GPIO_ReadInputDataBit_0
    338            {
    339              bitstatus = (uint8_t)Bit_SET;
   \   00000008   0x2201             MOVS     R2,#+1
    340            }
    341            else
    342            {
    343              bitstatus = (uint8_t)Bit_RESET;
    344            }
    345            return bitstatus;
   \                     ??GPIO_ReadInputDataBit_0: (+1)
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4770             BX       LR               ;; return
    346          }
    347          
    348          /**
    349            * @brief  Reads the specified GPIO input data port.
    350            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    351            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    352            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    353            * @retval GPIO input data port value.
    354            */

   \                                 In section .text, align 2, keep-with-next
    355          uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
    356          {
    357            /* Check the parameters */
    358            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    359          
    360            return ((uint16_t)GPIOx->IDR);
   \                     GPIO_ReadInputData: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0xB280             UXTH     R0,R0
   \   00000004   0x4770             BX       LR               ;; return
    361          }
    362          
    363          /**
    364            * @brief  Reads the specified output data port bit.
    365            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    366            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    367            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    368            * @param  GPIO_Pin: specifies the port bit to read.
    369            *          This parameter can be GPIO_Pin_x where x can be (0..15).
    370            * @retval The output port pin value.
    371            */

   \                                 In section .text, align 2, keep-with-next
    372          uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    373          {
    374            uint8_t bitstatus = 0x00;
   \                     GPIO_ReadOutputDataBit: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    375          
    376            /* Check the parameters */
    377            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    378            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    379          
    380            if (((GPIOx->ODR) & GPIO_Pin) != (uint32_t)Bit_RESET)
   \   00000002   0x6940             LDR      R0,[R0, #+20]
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xD000             BEQ.N    ??GPIO_ReadOutputDataBit_0
    381            {
    382              bitstatus = (uint8_t)Bit_SET;
   \   00000008   0x2201             MOVS     R2,#+1
    383            }
    384            else
    385            {
    386              bitstatus = (uint8_t)Bit_RESET;
    387            }
    388            return bitstatus;
   \                     ??GPIO_ReadOutputDataBit_0: (+1)
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4770             BX       LR               ;; return
    389          }
    390          
    391          /**
    392            * @brief  Reads the specified GPIO output data port.
    393            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    394            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    395            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    396            * @retval GPIO output data port value.
    397            */

   \                                 In section .text, align 2, keep-with-next
    398          uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
    399          {
    400            /* Check the parameters */
    401            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    402          
    403            return ((uint16_t)GPIOx->ODR);
   \                     GPIO_ReadOutputData: (+1)
   \   00000000   0x6940             LDR      R0,[R0, #+20]
   \   00000002   0xB280             UXTH     R0,R0
   \   00000004   0x4770             BX       LR               ;; return
    404          }
    405          
    406          /**
    407            * @brief  Sets the selected data port bits.
    408            * @note   This functions uses GPIOx_BSRR register to allow atomic read/modify 
    409            *         accesses. In this way, there is no risk of an IRQ occurring between
    410            *         the read and the modify access.
    411            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    412            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    413            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    414            * @param  GPIO_Pin: specifies the port bits to be written.
    415            *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    416            * @retval None
    417            */

   \                                 In section .text, align 2, keep-with-next
    418          void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    419          {
    420            /* Check the parameters */
    421            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    422            assert_param(IS_GPIO_PIN(GPIO_Pin));
    423          
    424            //GPIOx->BSRRL = GPIO_Pin;    //skyblue modidy 2016-11-30
    425          }
   \                     GPIO_SetBits: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    426          
    427          /**
    428            * @brief  Clears the selected data port bits.
    429            * @note   This functions uses GPIOx_BSRR register to allow atomic read/modify 
    430            *         accesses. In this way, there is no risk of an IRQ occurring between
    431            *         the read and the modify access.
    432            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    433            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    434            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    435            * @param  GPIO_Pin: specifies the port bits to be written.
    436            *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    437            * @retval None
    438            */

   \                                 In section .text, align 2, keep-with-next
    439          void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    440          {
    441            /* Check the parameters */
    442            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    443            assert_param(IS_GPIO_PIN(GPIO_Pin));
    444          
    445            //GPIOx->BSRRH = GPIO_Pin;      //skyblue modidy 2016-11-30
    446          }
   \                     GPIO_ResetBits: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    447          
    448          /**
    449            * @brief  Sets or clears the selected data port bit.
    450            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    451            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    452            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    453            * @param  GPIO_Pin: specifies the port bit to be written.
    454            *          This parameter can be one of GPIO_Pin_x where x can be (0..15).
    455            * @param  BitVal: specifies the value to be written to the selected bit.
    456            *          This parameter can be one of the BitAction enum values:
    457            *            @arg Bit_RESET: to clear the port pin
    458            *            @arg Bit_SET: to set the port pin
    459            * @retval None
    460            */

   \                                 In section .text, align 2, keep-with-next
    461          void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
    462          {
    463            /* Check the parameters */
    464            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    465            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    466            assert_param(IS_GPIO_BIT_ACTION(BitVal));
    467          #if 0		//skyblue modidy 2016-11-30
    468            if (BitVal != Bit_RESET)
    469            {
    470              GPIOx->BSRRL = GPIO_Pin;
    471            }
    472            else
    473            {
    474              GPIOx->BSRRH = GPIO_Pin ;
    475            }
    476          #endif //skyblue modidy 2016-11-30  
    477          }
   \                     GPIO_WriteBit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    478          
    479          /**
    480            * @brief  Writes data to the specified GPIO data port.
    481            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    482            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    483            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    484            * @param  PortVal: specifies the value to be written to the port output data register.
    485            * @retval None
    486            */

   \                                 In section .text, align 2, keep-with-next
    487          void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
    488          {
    489            /* Check the parameters */
    490            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    491          
    492            GPIOx->ODR = PortVal;
   \                     GPIO_Write: (+1)
   \   00000000   0x6141             STR      R1,[R0, #+20]
    493          }
   \   00000002   0x4770             BX       LR               ;; return
    494          
    495          /**
    496            * @brief  Toggles the specified GPIO pins..
    497            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    498            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    499            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    500            * @param  GPIO_Pin: Specifies the pins to be toggled.
    501            * @retval None
    502            */

   \                                 In section .text, align 2, keep-with-next
    503          void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    504          {
    505            /* Check the parameters */
    506            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    507          
    508            GPIOx->ODR ^= GPIO_Pin;
   \                     GPIO_ToggleBits: (+1)
   \   00000000   0x6942             LDR      R2,[R0, #+20]
   \   00000002   0x4051             EORS     R1,R1,R2
   \   00000004   0x6141             STR      R1,[R0, #+20]
    509          }
   \   00000006   0x4770             BX       LR               ;; return
    510          
    511          /**
    512            * @}
    513            */
    514          
    515          /** @defgroup GPIO_Group3 GPIO Alternate functions configuration function
    516           *  @brief   GPIO Alternate functions configuration function
    517           *
    518          @verbatim   
    519           ===============================================================================
    520                     ##### GPIO Alternate functions configuration function #####
    521           ===============================================================================  
    522          
    523          @endverbatim
    524            * @{
    525            */
    526          
    527          /**
    528            * @brief  Changes the mapping of the specified pin.
    529            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    530            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    531            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    532            * @param  GPIO_PinSource: specifies the pin for the Alternate function.
    533            *         This parameter can be GPIO_PinSourcex where x can be (0..15).
    534            * @param  GPIO_AFSelection: selects the pin to used as Alternate function.
    535            *          This parameter can be one of the following values:
    536            *            @arg GPIO_AF_RTC_50Hz: Connect RTC_50Hz pin to AF0 (default after reset) 
    537            *            @arg GPIO_AF_MCO: Connect MCO pin (MCO1 and MCO2) to AF0 (default after reset) 
    538            *            @arg GPIO_AF_TAMPER: Connect TAMPER pins (TAMPER_1 and TAMPER_2) to AF0 (default after reset) 
    539            *            @arg GPIO_AF_SWJ: Connect SWJ pins (SWD and JTAG)to AF0 (default after reset) 
    540            *            @arg GPIO_AF_TRACE: Connect TRACE pins to AF0 (default after reset)
    541            *            @arg GPIO_AF_TIM1: Connect TIM1 pins to AF1
    542            *            @arg GPIO_AF_TIM2: Connect TIM2 pins to AF1
    543            *            @arg GPIO_AF_TIM3: Connect TIM3 pins to AF2
    544            *            @arg GPIO_AF_TIM4: Connect TIM4 pins to AF2
    545            *            @arg GPIO_AF_TIM5: Connect TIM5 pins to AF2
    546            *            @arg GPIO_AF_TIM8: Connect TIM8 pins to AF3
    547            *            @arg GPIO_AF_TIM9: Connect TIM9 pins to AF3
    548            *            @arg GPIO_AF_TIM10: Connect TIM10 pins to AF3
    549            *            @arg GPIO_AF_TIM11: Connect TIM11 pins to AF3
    550            *            @arg GPIO_AF_I2C1: Connect I2C1 pins to AF4
    551            *            @arg GPIO_AF_I2C2: Connect I2C2 pins to AF4
    552            *            @arg GPIO_AF_I2C3: Connect I2C3 pins to AF4
    553            *            @arg GPIO_AF_SPI1: Connect SPI1 pins to AF5
    554            *            @arg GPIO_AF_SPI2: Connect SPI2/I2S2 pins to AF5
    555            *            @arg GPIO_AF_SPI4: Connect SPI4 pins to AF5 
    556            *            @arg GPIO_AF_SPI5: Connect SPI5 pins to AF5 
    557            *            @arg GPIO_AF_SPI6: Connect SPI6 pins to AF5
    558            *            @arg GPIO_AF_SAI1: Connect SAI1 pins to AF6 for STM32F42xxx/43xxx devices.       
    559            *            @arg GPIO_AF_SPI3: Connect SPI3/I2S3 pins to AF6
    560            *            @arg GPIO_AF_I2S3ext: Connect I2S3ext pins to AF7
    561            *            @arg GPIO_AF_USART1: Connect USART1 pins to AF7
    562            *            @arg GPIO_AF_USART2: Connect USART2 pins to AF7
    563            *            @arg GPIO_AF_USART3: Connect USART3 pins to AF7
    564            *            @arg GPIO_AF_UART4: Connect UART4 pins to AF8
    565            *            @arg GPIO_AF_UART5: Connect UART5 pins to AF8
    566            *            @arg GPIO_AF_USART6: Connect USART6 pins to AF8
    567            *            @arg GPIO_AF_UART7: Connect UART7 pins to AF8
    568            *            @arg GPIO_AF_UART8: Connect UART8 pins to AF8
    569            *            @arg GPIO_AF_CAN1: Connect CAN1 pins to AF9
    570            *            @arg GPIO_AF_CAN2: Connect CAN2 pins to AF9
    571            *            @arg GPIO_AF_TIM12: Connect TIM12 pins to AF9
    572            *            @arg GPIO_AF_TIM13: Connect TIM13 pins to AF9
    573            *            @arg GPIO_AF_TIM14: Connect TIM14 pins to AF9
    574            *            @arg GPIO_AF_OTG_FS: Connect OTG_FS pins to AF10
    575            *            @arg GPIO_AF_OTG_HS: Connect OTG_HS pins to AF10
    576            *            @arg GPIO_AF_ETH: Connect ETHERNET pins to AF11
    577            *            @arg GPIO_AF_FSMC: Connect FSMC pins to AF12 
    578            *            @arg GPIO_AF_FMC: Connect FMC pins to AF12 for STM32F42xxx/43xxx devices.   
    579            *            @arg GPIO_AF_OTG_HS_FS: Connect OTG HS (configured in FS) pins to AF12
    580            *            @arg GPIO_AF_SDIO: Connect SDIO pins to AF12
    581            *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
    582            *            @arg GPIO_AF_LTDC: Connect LTDC pins to AF14 for STM32F429xx/439xx devices. 
    583            *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
    584            * @retval None
    585            */

   \                                 In section .text, align 2, keep-with-next
    586          void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
    587          {
   \                     GPIO_PinAFConfig: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x10CB             ASRS     R3,R1,#+3
   \   00000004   0xEB00 0x0083      ADD      R0,R0,R3, LSL #+2
   \   00000008   0xF001 0x0107      AND      R1,R1,#0x7
   \   0000000C   0x0089             LSLS     R1,R1,#+2
   \   0000000E   0x6A03             LDR      R3,[R0, #+32]
   \   00000010   0x240F             MOVS     R4,#+15
   \   00000012   0x408C             LSLS     R4,R4,R1
   \   00000014   0x43A3             BICS     R3,R3,R4
   \   00000016   0x6203             STR      R3,[R0, #+32]
    588            uint32_t temp = 0x00;
    589            uint32_t temp_2 = 0x00;
    590            
    591            /* Check the parameters */
    592            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    593            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    594            assert_param(IS_GPIO_AF(GPIO_AF));
    595            
    596            temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
    597            GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
    598            temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
   \   00000018   0x6A03             LDR      R3,[R0, #+32]
   \   0000001A   0xFA02 0xF101      LSL      R1,R2,R1
   \   0000001E   0x4319             ORRS     R1,R1,R3
    599            GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
   \   00000020   0x6201             STR      R1,[R0, #+32]
    600          }
   \   00000022   0xBC10             POP      {R4}
   \   00000024   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_5:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_6:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_7:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_8:
   \   00000000   0x40022000         DC32     0x40022000
    601          
    602          /**
    603            * @}
    604            */ 
    605          
    606          /**
    607            * @}
    608            */
    609          
    610          /**
    611            * @}
    612            */ 
    613          
    614          /**
    615            * @}
    616            */ 
    617          
    618          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   GPIO_DeInit
         0   -> RCC_AHB1PeriphResetCmd
         8   -> RCC_AHB1PeriphResetCmd
       0   GPIO_Init
       4   GPIO_PinAFConfig
       4   GPIO_PinLockConfig
       0   GPIO_ReadInputData
       0   GPIO_ReadInputDataBit
       0   GPIO_ReadOutputData
       0   GPIO_ReadOutputDataBit
       0   GPIO_ResetBits
       0   GPIO_SetBits
       0   GPIO_StructInit
       0   GPIO_ToggleBits
       0   GPIO_Write
       0   GPIO_WriteBit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
       4  ??DataTable0_5
       4  ??DataTable0_6
       4  ??DataTable0_7
       4  ??DataTable0_8
     242  GPIO_DeInit
       2  GPIO_Init
      38  GPIO_PinAFConfig
      36  GPIO_PinLockConfig
       6  GPIO_ReadInputData
      14  GPIO_ReadInputDataBit
       6  GPIO_ReadOutputData
      14  GPIO_ReadOutputDataBit
       2  GPIO_ResetBits
       2  GPIO_SetBits
       2  GPIO_StructInit
       8  GPIO_ToggleBits
       4  GPIO_Write
       2  GPIO_WriteBit

 
 414 bytes in section .text
 
 414 bytes of CODE memory

Errors: none
Warnings: 45
