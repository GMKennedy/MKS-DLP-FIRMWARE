###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:19:54
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\GUIDemo\GUIDEMO.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\GUIDemo\GUIDEMO.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\GUIDEMO.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\GUIDEMO.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\GUIDemo\GUIDEMO.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUIDEMO.c
     16          Purpose     : Several GUIDEMO routines
     17          ----------------------------------------------------------------------
     18          */
     19          
     20          #include <stddef.h>
     21          #include "GUI.h"
     22          #if GUI_WINSUPPORT
     23            #include "PROGBAR.h"
     24            #include "LISTBOX.h"
     25            #include "FRAMEWIN.h"
     26            #include "BUTTON.h"
     27          #endif
     28          #include "GUIDEMO.h"
     29          
     30          /*********************************************************************
     31          *
     32          *       Static variables
     33          *
     34          **********************************************************************
     35          */
     36          
     37          #if GUI_WINSUPPORT

   \                                 In section .data, align 4
     38            static BUTTON_Handle   _ahButton[2];
     39            static FRAMEWIN_Handle _ahFrameWin[3];
     40            static int             _ButtonSizeX,      _ButtonSizeY;
     41            #if GUIDEMO_LARGE
     42              static FRAMEWIN_Handle _ahInfoWin[2];
     43              static const char* _sInfo;
     44            #endif
     45          #endif
     46          
     47          static int         _iTest, _iTestMinor;
     48          static char        _CmdNext;
   \                     _CmdNext:
   \   00000000   0x00               DC8 0
   \   00000001   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000010   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000001C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000020   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000002C   0x........         DC32 GUIDEMO_HardwareInfo, GUIDEMO_Speed, GUIDEMO_Bitmap
   \              0x........   
   \              0x........   
   \   00000038   0x........         DC32 GUIDEMO_Cursor, GUIDEMO_ShowInternationalFonts
   \              0x........   
   \   00000040   0x........         DC32 GUIDEMO_ShowColorBar, GUIDEMO_ShowColorList, GUIDEMO_DemoPolygon
   \              0x........   
   \              0x........   
   \   0000004C   0x........         DC32 GUIDEMO_Circle, GUIDEMO_Automotive, GUIDEMO_Navigation
   \              0x........   
   \              0x........   
   \   00000058   0x........         DC32 GUIDEMO_Dialog, GUIDEMO_DemoProgBar, GUIDEMO_DemoFrameWin
   \              0x........   
   \              0x........   
   \   00000064   0x........         DC32 GUIDEMO_Touch, 0H
   \              0x00000000   
     49          static const char* _sExplain;
     50          
     51          #define countof(Obj) (sizeof(Obj)/sizeof(Obj[0]))
     52          
     53          /*********************************************************************
     54          *
     55          *       Routine table
     56          *
     57          **********************************************************************
     58          
     59            The routines to be called are listed here. The advantage to calling
     60            directly is that we can execute some code before and after.
     61          */
     62          
     63          typedef void fVoidVoid(void);
     64          
     65          static fVoidVoid * _apfTest[] = {
     66            GUIDEMO_HardwareInfo,
     67            GUIDEMO_Speed,
     68            #if GUI_SUPPORT_MEMDEV
     69              GUIDEMO_Graph,
     70            #endif
     71            GUIDEMO_Bitmap,
     72            GUIDEMO_Cursor,
     73            GUIDEMO_ShowInternationalFonts,
     74            GUIDEMO_ShowColorBar,
     75            GUIDEMO_ShowColorList,
     76            //GUIDEMO_DemoLUT,
     77            GUIDEMO_DemoPolygon,
     78            GUIDEMO_Circle,
     79            GUIDEMO_Automotive,
     80            GUIDEMO_Navigation,
     81            #if GUI_WINSUPPORT
     82              GUIDEMO_Dialog,
     83              GUIDEMO_DemoProgBar,
     84              GUIDEMO_DemoFrameWin,
     85              #if GUI_SUPPORT_TOUCH
     86                GUIDEMO_Touch,
     87              #endif
     88            #endif
     89            0
     90          };
     91          
     92          /*********************************************************************
     93          *
     94          *       Static routines
     95          *
     96          **********************************************************************
     97          */
     98          

   \                                 In section .text, align 2, keep-with-next
     99          static void _UpdateCmdWin(void) {
    100            #if GUI_WINSUPPORT && GUIDEMO_LARGE
    101              WM_InvalidateWindow(_ahInfoWin[1]);
   \                     _UpdateCmdWin: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000004   0xF9B0 0x0012      LDRSH    R0,[R0, #+18]
   \   00000008   0x.... 0x....      B.W      WM_InvalidateWindow
    102            #endif
    103          }
    104          
    105          #if (GUI_WINSUPPORT && GUIDEMO_LARGE)

   \                                 In section .text, align 2, keep-with-next
    106          static void _cbCmdWin(WM_MESSAGE* pMsg) {
   \                     _cbCmdWin: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    107            switch (pMsg->MsgId) {
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x280F             CMP      R0,#+15
   \   00000008   0xD11D             BNE.N    ??_cbCmdWin_0
    108            case WM_PAINT:
    109              /* Update info in command window */
    110              GUI_SetBkColor(GUI_GRAY);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x808080
   \   0000000E   0x.... 0x....      BL       GUI_SetBkColor
    111              GUI_Clear();
   \   00000012   0x.... 0x....      BL       GUI_Clear
    112              GUI_DispStringAt("Demo ", 0, 0);
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x4611             MOV      R1,R2
   \   0000001A   0x.... 0x....      ADR.W    R0,`?<Constant "Demo ">`
   \   0000001E   0x.... 0x....      BL       GUI_DispStringAt
    113              GUI_DispDecMin(_iTest + 1);
   \   00000022   0x.... 0x....      LDR.W    R5,??DataTable16
   \   00000026   0x6A28             LDR      R0,[R5, #+32]
   \   00000028   0x1C40             ADDS     R0,R0,#+1
   \   0000002A   0x.... 0x....      BL       GUI_DispDecMin
    114              GUI_DispString(".");
   \   0000002E   0x....             ADR.N    R0,??DataTable15  ;; "."
   \   00000030   0x.... 0x....      BL       GUI_DispString
    115              GUI_DispDecMin(_iTestMinor);
   \   00000034   0x6A68             LDR      R0,[R5, #+36]
   \   00000036   0x.... 0x....      BL       GUI_DispDecMin
    116              GUI_DispString("/");
   \   0000003A   0x....             ADR.N    R0,??DataTable15_1  ;; "/"
   \   0000003C   0x.... 0x....      BL       GUI_DispString
    117              GUI_DispDecMin(countof(_apfTest));
   \   00000040   0x2010             MOVS     R0,#+16
   \   00000042   0x.... 0x....      BL       GUI_DispDecMin
    118            default:
    119              WM_DefaultProc(pMsg);
   \                     ??_cbCmdWin_0: (+1)
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000004C   0x.... 0x....      B.W      WM_DefaultProc
    120            }
    121          }
    122          #endif
    123          

   \                                 In section .text, align 2, keep-with-next
    124          static void _UpdateInfoWin(void) {
   \                     _UpdateInfoWin: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB095             SUB      SP,SP,#+84
    125            #if GUI_WINSUPPORT && GUIDEMO_LARGE
    126              GUI_RECT rClient;
    127              WM_HWIN hWin;
    128              GUI_CONTEXT ContextOld;
    129              GUI_SaveContext(&ContextOld);
   \   00000004   0xA802             ADD      R0,SP,#+8
   \   00000006   0x.... 0x....      BL       GUI_SaveContext_W
    130              /* Update info  window */
    131              WM_ShowWindow(_ahInfoWin[0]);
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable16
   \   0000000E   0xF9B4 0x0010      LDRSH    R0,[R4, #+16]
   \   00000012   0x.... 0x....      BL       WM_ShowWindow
    132              WM_ShowWindow(_ahFrameWin[0]);
   \   00000016   0xF9B4 0x0008      LDRSH    R0,[R4, #+8]
   \   0000001A   0x.... 0x....      BL       WM_ShowWindow
    133              hWin = WM_SelectWindow(_ahInfoWin[0]);
   \   0000001E   0xF9B4 0x0010      LDRSH    R0,[R4, #+16]
   \   00000022   0x.... 0x....      BL       WM_SelectWindow
   \   00000026   0x4605             MOV      R5,R0
    134              GUI_GetClientRect(&rClient);
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       GUI_GetClientRect
    135              GUI_SetBkColor(GUI_WHITE);
   \   0000002E   0xF06F 0x407F      MVN      R0,#-16777216
   \   00000032   0x.... 0x....      BL       GUI_SetBkColor
    136              GUI_Clear();
   \   00000036   0x.... 0x....      BL       GUI_Clear
    137              GUI_SetColor(GUI_BLACK);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      BL       GUI_SetColor
    138              GUI_SetFont(&GUI_Font13_1);
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000044   0x.... 0x....      BL       GUI_SetFont
    139              GUI_SetTextAlign(GUI_TA_HCENTER);
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0x.... 0x....      BL       GUI_SetTextAlign
    140              GUI_DispStringHCenterAt(_sInfo, (rClient.x1 - rClient.x0) / 2, 0);
   \   0000004E   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \   00000052   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   00000056   0x1A40             SUBS     R0,R0,R1
   \   00000058   0x2200             MOVS     R2,#+0
   \   0000005A   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   0000005E   0x1041             ASRS     R1,R0,#+1
   \   00000060   0x69E0             LDR      R0,[R4, #+28]
   \   00000062   0x.... 0x....      BL       GUI_DispStringHCenterAt
    141              GUI_SetTextAlign(GUI_TA_LEFT);
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      BL       GUI_SetTextAlign
    142              GUI_SetFont(&GUI_Font8_ASCII);
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000070   0x.... 0x....      BL       GUI_SetFont
    143              GUI_DispStringAt(_sExplain, 0, 20);
   \   00000074   0x2214             MOVS     R2,#+20
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0x6AA0             LDR      R0,[R4, #+40]
   \   0000007A   0x.... 0x....      BL       GUI_DispStringAt
    144              WM_SelectWindow(hWin);
   \   0000007E   0x4628             MOV      R0,R5
   \   00000080   0x.... 0x....      BL       WM_SelectWindow
    145              GUI_RestoreContext(&ContextOld);
   \   00000084   0xA802             ADD      R0,SP,#+8
   \   00000086   0x.... 0x....      BL       GUI_RestoreContext
    146            #endif
    147          }
   \   0000008A   0xB015             ADD      SP,SP,#+84
   \   0000008C   0xBD30             POP      {R4,R5,PC}       ;; return
    148          
    149          /*********************************************************************
    150          *
    151          *       Exported routines
    152          *
    153          **********************************************************************
    154          */
    155          

   \                                 In section .text, align 2, keep-with-next
    156          GUI_COLOR GUIDEMO_SetBkColor(GUI_COLOR Color) {
   \                     GUIDEMO_SetBkColor: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    157            GUI_COLOR r;
    158            if (GUI_ColorIsAvailable(GUI_RED)) {
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0x.... 0x....      BL       GUI_ColorIsAvailable
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD100             BNE.N    ??GUIDEMO_SetBkColor_0
    159              r = Color;
    160            } else {
    161              r = GUI_BLACK;
   \   0000000E   0x2400             MOVS     R4,#+0
    162            }
    163            GUI_SetBkColor(r);
   \                     ??GUIDEMO_SetBkColor_0: (+1)
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       GUI_SetBkColor
    164            return r;
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    165          }
    166          

   \                                 In section .text, align 2, keep-with-next
    167          GUI_COLOR GUIDEMO_SetColor(GUI_COLOR Color) {
   \                     GUIDEMO_SetColor: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    168            GUI_COLOR r;
    169            if (GUI_ColorIsAvailable(GUI_RED)) {
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0x.... 0x....      BL       GUI_ColorIsAvailable
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??GUIDEMO_SetColor_0
    170              r = Color;
    171            } else {
    172              r = GUI_WHITE;
   \   0000000E   0xF06F 0x447F      MVN      R4,#-16777216
    173            }
    174            GUI_SetColor(r);
   \                     ??GUIDEMO_SetColor_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       GUI_SetColor
    175            return r;
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    176          }
    177          

   \                                 In section .text, align 2, keep-with-next
    178          int GUIDEMO_Delay(int t) {
   \                     GUIDEMO_Delay: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    179            int r = 0;
    180            #if GUI_WINSUPPORT
    181              U32 value, tm;
    182              #if GUIDEMO_LARGE
    183                PROGBAR_Handle hProg;
    184              #endif
    185              WM_SetForegroundWindow(_ahButton[0]);
   \   00000004   0x....             LDR.N    R5,??DataTable16
   \   00000006   0xF9B5 0x0004      LDRSH    R0,[R5, #+4]
   \   0000000A   0x.... 0x....      BL       WM_BringToTop
    186              #if GUIDEMO_LARGE
    187                hProg = (t > 100) ? PROGBAR_CreateAsChild(10, 10, 60, 7, _ahInfoWin[1], 0,
    188                                                  WM_CF_SHOW | WM_CF_STAYONTOP| WM_CF_MEMDEV) : 0;
   \   0000000E   0x2C65             CMP      R4,#+101
   \   00000010   0xDB0E             BLT.N    ??GUIDEMO_Delay_0
   \   00000012   0x200E             MOVS     R0,#+14
   \   00000014   0x9002             STR      R0,[SP, #+8]
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x9001             STR      R0,[SP, #+4]
   \   0000001A   0xF9B5 0x0012      LDRSH    R0,[R5, #+18]
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x2307             MOVS     R3,#+7
   \   00000022   0x223C             MOVS     R2,#+60
   \   00000024   0x210A             MOVS     R1,#+10
   \   00000026   0x4608             MOV      R0,R1
   \   00000028   0x.... 0x....      BL       PROGBAR_CreateAsChild
   \   0000002C   0x4605             MOV      R5,R0
   \   0000002E   0xE000             B.N      ??GUIDEMO_Delay_1
   \                     ??GUIDEMO_Delay_0: (+1)
   \   00000030   0x2500             MOVS     R5,#+0
    189                PROGBAR_SetMinMax(hProg, 0, t);
   \                     ??GUIDEMO_Delay_1: (+1)
   \   00000032   0x4622             MOV      R2,R4
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0x.... 0x....      BL       PROGBAR_SetMinMax
    190              #endif
    191              tm = GUI_GetTime();
   \   0000003C   0x.... 0x....      BL       GUI_GetTime
   \   00000040   0x4606             MOV      R6,R0
    192              do {
    193                value = GUI_GetTime() - tm;
   \                     ??GUIDEMO_Delay_2: (+1)
   \   00000042   0x.... 0x....      BL       GUI_GetTime
   \   00000046   0x1B87             SUBS     R7,R0,R6
    194                #if GUIDEMO_LARGE
    195                  PROGBAR_SetValue(hProg, value);
   \   00000048   0x4639             MOV      R1,R7
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       PROGBAR_SetValue
    196                  WM_ExecIdle();
   \   00000050   0x.... 0x....      BL       WM_Exec
    197                #endif
    198                GUI_Delay(10);
   \   00000054   0x200A             MOVS     R0,#+10
   \   00000056   0x.... 0x....      BL       GUI_Delay
    199              } while ((value < (U32)t) && !GUIDEMO_CheckCancel());
   \   0000005A   0x42A7             CMP      R7,R4
   \   0000005C   0xD203             BCS.N    ??GUIDEMO_Delay_3
   \   0000005E   0x.... 0x....      BL       GUIDEMO_CheckCancel
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD0ED             BEQ.N    ??GUIDEMO_Delay_2
    200              #if GUIDEMO_LARGE
    201                PROGBAR_Delete(hProg);
   \                     ??GUIDEMO_Delay_3: (+1)
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x.... 0x....      BL       WM_DeleteWindow
    202              #endif
    203              _UpdateCmdWin();
   \   0000006C   0x.... 0x....      BL       _UpdateCmdWin
    204              WM_ExecIdle();
   \   00000070   0x.... 0x....      BL       WM_Exec
    205            #else
    206              GUI_Delay(t);
    207            #endif
    208            return r;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBDFE             POP      {R1-R7,PC}       ;; return
    209          }
    210          

   \                                 In section .text, align 2, keep-with-next
    211          void GUIDEMO_Wait(void) {
   \                     GUIDEMO_Wait: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    212            GUIDEMO_Delay(4000);
   \   00000002   0xF44F 0x607A      MOV      R0,#+4000
   \   00000006   0x.... 0x....      BL       GUIDEMO_Delay
    213            GUIDEMO_NotifyStartNext();
   \   0000000A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000E   0x....             B.N      GUIDEMO_NotifyStartNext
    214          }
    215          

   \                                 In section .text, align 2, keep-with-next
    216          int GUIDEMO_CheckCancel(void) {
   \                     GUIDEMO_CheckCancel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    217            int c = GUI_GetKey();
   \   00000002   0x.... 0x....      BL       GUI_GetKey
   \   00000006   0x4604             MOV      R4,R0
    218            #if GUI_WINSUPPORT
    219              WM_ExecIdle();
   \   00000008   0x.... 0x....      BL       WM_Exec
    220            #endif
    221            if ((c == 'n') || (c=='N'))
   \   0000000C   0x2C6E             CMP      R4,#+110
   \   0000000E   0xD001             BEQ.N    ??GUIDEMO_CheckCancel_0
   \   00000010   0x2C4E             CMP      R4,#+78
   \   00000012   0xD102             BNE.N    ??GUIDEMO_CheckCancel_1
    222              _CmdNext =1;
   \                     ??GUIDEMO_CheckCancel_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable16
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    223            if ((c == 'h') || (c=='H')) {
   \                     ??GUIDEMO_CheckCancel_1: (+1)
   \   0000001A   0x2C68             CMP      R4,#+104
   \   0000001C   0xD001             BEQ.N    ??GUIDEMO_CheckCancel_2
   \   0000001E   0x2C48             CMP      R4,#+72
   \   00000020   0xD10C             BNE.N    ??GUIDEMO_CheckCancel_3
    224              GUI_Delay(500);
   \                     ??GUIDEMO_CheckCancel_2: (+1)
   \   00000022   0xF44F 0x70FA      MOV      R0,#+500
   \   00000026   0x.... 0x....      BL       GUI_Delay
    225              do {
    226                GUI_Delay(10);
   \                     ??GUIDEMO_CheckCancel_4: (+1)
   \   0000002A   0x200A             MOVS     R0,#+10
   \   0000002C   0x.... 0x....      BL       GUI_Delay
    227                #if GUI_WINSUPPORT
    228                  WM_ExecIdle();
   \   00000030   0x.... 0x....      BL       WM_Exec
    229                #endif
    230                c = GUI_GetKey();
    231              } while (!c);
   \   00000034   0x.... 0x....      BL       GUI_GetKey
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD0F6             BEQ.N    ??GUIDEMO_CheckCancel_4
    232            }
    233            return _CmdNext;
   \                     ??GUIDEMO_CheckCancel_3: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable16
   \   0000003E   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    234          }
    235          

   \                                 In section .text, align 2, keep-with-next
    236          void GUIDEMO_ShowInfo(const char* s) {
    237            _sExplain = s;
   \                     GUIDEMO_ShowInfo: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable16
   \   00000002   0x6288             STR      R0,[R1, #+40]
    238            _UpdateInfoWin();
   \   00000004   0x....             B.N      _UpdateInfoWin
    239          }
    240          

   \                                 In section .text, align 2, keep-with-next
    241          void GUIDEMO_HideInfoWin(void) {
    242            #if GUI_WINSUPPORT
    243              WM_HideWindow(_ahFrameWin[0]);
   \                     GUIDEMO_HideInfoWin: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16
   \   00000002   0xF9B0 0x0008      LDRSH    R0,[R0, #+8]
   \   00000006   0x.... 0x....      B.W      WM_HideWindow
    244            #endif
    245          }
    246          
    247          

   \                                 In section .text, align 2, keep-with-next
    248          void GUIDEMO_NotifyStartNext(void) {
   \                     GUIDEMO_NotifyStartNext: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    249            _CmdNext = 0;
   \   00000002   0x....             LDR.N    R4,??DataTable16
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7020             STRB     R0,[R4, #+0]
    250            _UpdateCmdWin();
   \   00000008   0x.... 0x....      BL       _UpdateCmdWin
    251            _iTestMinor++;
   \   0000000C   0x6A60             LDR      R0,[R4, #+36]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x6260             STR      R0,[R4, #+36]
    252          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    253          

   \                                 In section .text, align 2, keep-with-next
    254          int GUIDEMO_WaitKey(void) {
   \                     GUIDEMO_WaitKey: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    255            int r = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    256            U32 tMax = GUI_GetTime() + 4000;
   \   00000006   0x.... 0x....      BL       GUI_GetTime
   \   0000000A   0xF500 0x657A      ADD      R5,R0,#+4000
    257            U32 tDiff; 
    258            #if GUI_WINSUPPORT
    259              PROGBAR_Handle hProg = PROGBAR_Create(LCD_GetXSize() - 70, 
    260                                                    LCD_GetYSize() - 40, 
    261                                                    80, 5, WM_CF_SHOW);
   \   0000000E   0x.... 0x....      BL       LCD_GetYSize
   \   00000012   0x4606             MOV      R6,R0
   \   00000014   0x.... 0x....      BL       LCD_GetXSize
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0x9100             STR      R1,[SP, #+0]
   \   0000001C   0x2305             MOVS     R3,#+5
   \   0000001E   0x2250             MOVS     R2,#+80
   \   00000020   0xF1A6 0x0128      SUB      R1,R6,#+40
   \   00000024   0x3846             SUBS     R0,R0,#+70
   \   00000026   0x.... 0x....      BL       PROGBAR_Create
   \   0000002A   0x4606             MOV      R6,R0
    262            #endif
    263            while (tDiff = tMax - GUI_GetTime(), (tDiff > 0) && !GUIDEMO_CheckCancel()) {
   \                     ??GUIDEMO_WaitKey_0: (+1)
   \   0000002C   0x.... 0x....      BL       GUI_GetTime
   \   00000030   0x1A28             SUBS     R0,R5,R0
   \   00000032   0xD005             BEQ.N    ??GUIDEMO_WaitKey_1
   \   00000034   0x.... 0x....      BL       GUIDEMO_CheckCancel
   \   00000038   0x1E40             SUBS     R0,R0,#+1
   \   0000003A   0x4180             SBCS     R0,R0,R0
   \   0000003C   0x0FC0             LSRS     R0,R0,#+31
   \   0000003E   0xE000             B.N      ??GUIDEMO_WaitKey_2
   \                     ??GUIDEMO_WaitKey_1: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??GUIDEMO_WaitKey_2: (+1)
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD003             BEQ.N    ??GUIDEMO_WaitKey_3
    264              if ((r = GUI_GetKey()) != 0)
   \   00000046   0x.... 0x....      BL       GUI_GetKey
   \   0000004A   0x0004             MOVS     R4,R0
   \   0000004C   0xD0EE             BEQ.N    ??GUIDEMO_WaitKey_0
    265                break;
    266            }
    267            #if GUI_WINSUPPORT
    268              PROGBAR_Delete(hProg);
   \                     ??GUIDEMO_WaitKey_3: (+1)
   \   0000004E   0x4630             MOV      R0,R6
   \   00000050   0x.... 0x....      BL       WM_DeleteWindow
    269              WM_ExecIdle();
   \   00000054   0x.... 0x....      BL       WM_Exec
    270            #endif
    271            return r;
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    272          }
    273          

   \                                 In section .text, align 2, keep-with-next
    274          void GUIDEMO_ShowIntro(const char * s, const char * sExp) {
   \                     GUIDEMO_ShowIntro: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
    275            GUI_CONTEXT ContextOld;
    276            GUI_SaveContext(&ContextOld);
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x.... 0x....      BL       GUI_SaveContext_W
    277          #if GUI_WINSUPPORT && GUIDEMO_LARGE
    278            _sInfo = s;
   \   0000000E   0x....             LDR.N    R4,??DataTable16
   \   00000010   0x61E5             STR      R5,[R4, #+28]
    279          #endif
    280            _sExplain = sExp;
   \   00000012   0x62A6             STR      R6,[R4, #+40]
    281            GUI_SetDefault();
   \   00000014   0x.... 0x....      BL       GUI_SetDefault
    282            GUIDEMO_HideInfoWin();
   \   00000018   0x.... 0x....      BL       GUIDEMO_HideInfoWin
    283            GUIDEMO_SetBkColor(GUI_BLUE);
   \   0000001C   0xF44F 0x007F      MOV      R0,#+16711680
   \   00000020   0x.... 0x....      BL       GUIDEMO_SetBkColor
    284            GUI_SetColor(GUI_WHITE);
   \   00000024   0xF06F 0x407F      MVN      R0,#-16777216
   \   00000028   0x.... 0x....      BL       GUI_SetColor
    285            GUI_Clear();
   \   0000002C   0x.... 0x....      BL       GUI_Clear
    286            #if !(GUIDEMO_TINY)
    287              GUI_SetFont(&GUI_FontComic18B_ASCII);
   \   00000030   0x....             LDR.N    R0,??DataTable16_4
   \   00000032   0x.... 0x....      BL       GUI_SetFont
    288              GUI_DispStringHCenterAt(s, LCD_GET_XSIZE() / 2, LCD_GET_YSIZE() / 3 - 10);
   \   00000036   0x.... 0x....      BL       LCD_GetYSize
   \   0000003A   0x4606             MOV      R6,R0
   \   0000003C   0x.... 0x....      BL       LCD_GetXSize
   \   00000040   0x2103             MOVS     R1,#+3
   \   00000042   0xFB96 0xF1F1      SDIV     R1,R6,R1
   \   00000046   0xF1A1 0x020A      SUB      R2,R1,#+10
   \   0000004A   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   0000004E   0x1041             ASRS     R1,R0,#+1
   \   00000050   0x4628             MOV      R0,R5
   \   00000052   0x.... 0x....      BL       GUI_DispStringHCenterAt
    289            #else
    290              GUI_SetFont(&GUI_Font13B_ASCII);
    291              GUI_DispStringHCenterAt(s, LCD_GET_XSIZE() / 2, LCD_GET_YSIZE() / 3 - 18);
    292            #endif
    293            if (_sExplain) {
   \   00000056   0x6AA0             LDR      R0,[R4, #+40]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD012             BEQ.N    ??GUIDEMO_ShowIntro_0
    294              GUI_SetFont(&GUI_Font8_ASCII);
   \   0000005C   0x....             LDR.N    R0,??DataTable16_3
   \   0000005E   0x.... 0x....      BL       GUI_SetFont
    295              #if !(GUIDEMO_TINY)
    296                GUI_DispStringHCenterAt(_sExplain, LCD_GET_XSIZE() / 2, LCD_GET_YSIZE() / 2 - 10);
   \   00000062   0x.... 0x....      BL       LCD_GetYSize
   \   00000066   0x4605             MOV      R5,R0
   \   00000068   0x.... 0x....      BL       LCD_GetXSize
   \   0000006C   0xEB05 0x71D5      ADD      R1,R5,R5, LSR #+31
   \   00000070   0x1049             ASRS     R1,R1,#+1
   \   00000072   0xF1A1 0x020A      SUB      R2,R1,#+10
   \   00000076   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   0000007A   0x1041             ASRS     R1,R0,#+1
   \   0000007C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000007E   0x.... 0x....      BL       GUI_DispStringHCenterAt
    297              #else
    298                GUI_DispStringHCenterAt(_sExplain, LCD_GET_XSIZE() / 2, LCD_GET_YSIZE() / 2 - 14);
    299              #endif
    300            }
    301            GUIDEMO_Delay(_sExplain ? 2000 : 4000);
   \                     ??GUIDEMO_ShowIntro_0: (+1)
   \   00000082   0x6AA0             LDR      R0,[R4, #+40]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD002             BEQ.N    ??GUIDEMO_ShowIntro_1
   \   00000088   0xF44F 0x60FA      MOV      R0,#+2000
   \   0000008C   0xE001             B.N      ??GUIDEMO_ShowIntro_2
   \                     ??GUIDEMO_ShowIntro_1: (+1)
   \   0000008E   0xF44F 0x607A      MOV      R0,#+4000
   \                     ??GUIDEMO_ShowIntro_2: (+1)
   \   00000092   0x.... 0x....      BL       GUIDEMO_Delay
    302          #if GUI_WINSUPPORT
    303            _UpdateInfoWin();
   \   00000096   0x.... 0x....      BL       _UpdateInfoWin
    304            _UpdateCmdWin();
   \   0000009A   0x.... 0x....      BL       _UpdateCmdWin
    305          #endif
    306            GUI_RestoreContext(&ContextOld);
   \   0000009E   0xA800             ADD      R0,SP,#+0
   \   000000A0   0x.... 0x....      BL       GUI_RestoreContext
    307            #if GUI_WINSUPPORT
    308              WM_ExecIdle();
   \   000000A4   0x.... 0x....      BL       WM_Exec
    309            #endif
    310            GUIDEMO_NotifyStartNext();
   \   000000A8   0x.... 0x....      BL       GUIDEMO_NotifyStartNext
    311            GUIDEMO_SetBkColor(GUI_RED);
   \   000000AC   0x20FF             MOVS     R0,#+255
   \   000000AE   0x.... 0x....      BL       GUIDEMO_SetBkColor
    312            GUI_Clear();
   \   000000B2   0x.... 0x....      BL       GUI_Clear
    313          }
   \   000000B6   0xB012             ADD      SP,SP,#+72
   \   000000B8   0xBD70             POP      {R4-R6,PC}       ;; return
    314          
    315          /*********************************************************************
    316          *
    317          *       GUIDEMO_main(): Large version of the demo
    318          *
    319          **********************************************************************
    320          */
    321          
    322          #if GUIDEMO_LARGE
    323          

   \                                 In section .text, align 2, keep-with-next
    324          void GUIDEMO_main(void) {
   \                     GUIDEMO_main: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
    325            #if GUI_WINSUPPORT
    326              int i;
    327              int xSize, ySize, xPos, yPos;
    328            #endif
    329            #if (GUI_SUPPORT_CURSOR|GUI_SUPPORT_TOUCH)
    330              GUI_CURSOR_Show();
   \   00000004   0x.... 0x....      BL       GUI_CURSOR_Show
    331            #endif
    332            GUI_Clear();
   \   00000008   0x.... 0x....      BL       GUI_Clear
    333            #if GUI_WINSUPPORT
    334              #if GUI_NUM_LAYERS > 1
    335                _ahFrameWin[2] = FRAMEWIN_CreateAsChild(10, 10, 100, 100, WM_GetDesktopWindowEx(1), "Display 1", NULL, WM_CF_SHOW);
    336                WM_SetDesktopColorEx(GUI_RED, 1);
    337                GUI_Delay(1000);
    338              #endif
    339              WM_SetCreateFlags(WM_CF_MEMDEV);  /* Automatically use memory devices on all windows */
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0x.... 0x....      BL       WM_SetCreateFlags
    340              /* Calculate position and size of FrameWin[1] */
    341              _ButtonSizeX = 30;
   \   00000012   0x....             LDR.N    R4,??DataTable16
   \   00000014   0x201E             MOVS     R0,#+30
   \   00000016   0x6160             STR      R0,[R4, #+20]
    342              _ButtonSizeY = 20;
   \   00000018   0x2014             MOVS     R0,#+20
   \   0000001A   0x61A0             STR      R0,[R4, #+24]
    343              /* Create the control window incl. buttons */
    344              _ahFrameWin[1] = FRAMEWIN_Create("Control", &_cbCmdWin, WM_CF_SHOW | WM_CF_STAYONTOP,
    345                                                          LCD_GetXSize() - 80, LCD_GetYSize() - 60, 80, 60);
   \   0000001C   0x.... 0x....      BL       LCD_GetYSize
   \   00000020   0x4605             MOV      R5,R0
   \   00000022   0x.... 0x....      BL       LCD_GetXSize
   \   00000026   0x213C             MOVS     R1,#+60
   \   00000028   0x9102             STR      R1,[SP, #+8]
   \   0000002A   0x2150             MOVS     R1,#+80
   \   0000002C   0x9101             STR      R1,[SP, #+4]
   \   0000002E   0xF1A5 0x013C      SUB      R1,R5,#+60
   \   00000032   0x9100             STR      R1,[SP, #+0]
   \   00000034   0xF1A0 0x0350      SUB      R3,R0,#+80
   \   00000038   0x220A             MOVS     R2,#+10
   \   0000003A   0x....             LDR.N    R1,??DataTable16_5
   \   0000003C   0x.... 0x....      ADR.W    R0,`?<Constant "Control">`
   \   00000040   0x.... 0x....      BL       FRAMEWIN_Create
   \   00000044   0x8160             STRH     R0,[R4, #+10]
    346              _ahInfoWin[1] = WM_GetClientWindow(_ahFrameWin[1]);
   \   00000046   0x.... 0x....      BL       WM_GetClientWindow
   \   0000004A   0x8260             STRH     R0,[R4, #+18]
    347              _ahButton[0] = BUTTON_CreateAsChild(4, 20, _ButtonSizeX, _ButtonSizeY, _ahInfoWin[1], 
    348                                                  'H' , WM_CF_SHOW | WM_CF_STAYONTOP | WM_CF_MEMDEV);
   \   0000004C   0x210E             MOVS     R1,#+14
   \   0000004E   0x9102             STR      R1,[SP, #+8]
   \   00000050   0x2148             MOVS     R1,#+72
   \   00000052   0x9101             STR      R1,[SP, #+4]
   \   00000054   0x9000             STR      R0,[SP, #+0]
   \   00000056   0x69A3             LDR      R3,[R4, #+24]
   \   00000058   0x6962             LDR      R2,[R4, #+20]
   \   0000005A   0x2114             MOVS     R1,#+20
   \   0000005C   0x2004             MOVS     R0,#+4
   \   0000005E   0x.... 0x....      BL       BUTTON_CreateAsChild
   \   00000062   0x80A0             STRH     R0,[R4, #+4]
    349              _ahButton[1] = BUTTON_CreateAsChild(40, 20, _ButtonSizeX, _ButtonSizeY, _ahInfoWin[1], 
    350                                                  'N' , WM_CF_SHOW | WM_CF_STAYONTOP | WM_CF_MEMDEV);
   \   00000064   0x200E             MOVS     R0,#+14
   \   00000066   0x9002             STR      R0,[SP, #+8]
   \   00000068   0x204E             MOVS     R0,#+78
   \   0000006A   0x9001             STR      R0,[SP, #+4]
   \   0000006C   0xF9B4 0x0012      LDRSH    R0,[R4, #+18]
   \   00000070   0x9000             STR      R0,[SP, #+0]
   \   00000072   0x69A3             LDR      R3,[R4, #+24]
   \   00000074   0x6962             LDR      R2,[R4, #+20]
   \   00000076   0x2114             MOVS     R1,#+20
   \   00000078   0x2028             MOVS     R0,#+40
   \   0000007A   0x.... 0x....      BL       BUTTON_CreateAsChild
   \   0000007E   0x80E0             STRH     R0,[R4, #+6]
    351              BUTTON_SetText(_ahButton[0], "Halt");
   \   00000080   0x.... 0x....      ADR.W    R1,`?<Constant "Halt">`
   \   00000084   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \   00000088   0x.... 0x....      BL       BUTTON_SetText
    352              BUTTON_SetText(_ahButton[1], "Next");
   \   0000008C   0x.... 0x....      ADR.W    R1,`?<Constant "Next">`
   \   00000090   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   00000094   0x.... 0x....      BL       BUTTON_SetText
    353              _UpdateCmdWin();
   \   00000098   0x.... 0x....      BL       _UpdateCmdWin
    354              WM_ExecIdle();
   \   0000009C   0x.... 0x....      BL       WM_Exec
    355            #endif
    356            /* Show Intro */
    357            GUIDEMO_Intro();
   \   000000A0   0x.... 0x....      BL       GUIDEMO_Intro
    358            #if GUI_WINSUPPORT
    359              /* Calculate position and size of FrameWin[0] */
    360              xSize = LCD_GetXSize() / 2;
   \   000000A4   0x.... 0x....      BL       LCD_GetXSize
   \   000000A8   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   000000AC   0x1045             ASRS     R5,R0,#+1
    361              ySize = 65;
    362              xPos  = LCD_GetXSize() - xSize;
   \   000000AE   0x.... 0x....      BL       LCD_GetXSize
   \   000000B2   0x1B43             SUBS     R3,R0,R5
    363              yPos  = 0;
    364              /* Create info window and run the individual demos */
    365              _ahFrameWin[0] = FRAMEWIN_Create("emWin Demo", NULL, WM_CF_STAYONTOP, 
    366                                               xPos, yPos, xSize, ySize);
   \   000000B4   0x2041             MOVS     R0,#+65
   \   000000B6   0x9002             STR      R0,[SP, #+8]
   \   000000B8   0x9501             STR      R5,[SP, #+4]
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x9000             STR      R0,[SP, #+0]
   \   000000BE   0x2208             MOVS     R2,#+8
   \   000000C0   0x4601             MOV      R1,R0
   \   000000C2   0x.... 0x....      ADR.W    R0,`?<Constant "emWin Demo">`
   \   000000C6   0x.... 0x....      BL       FRAMEWIN_Create
   \   000000CA   0x8120             STRH     R0,[R4, #+8]
    367          //    _ahInfoWin[0] = WM_GetFirstChild(_ahFrameWin[0]);
    368              _ahInfoWin[0] = WM_CreateWindowAsChild(0, 0, 0, 0, WM_GetFirstChild(_ahFrameWin[0]), WM_CF_SHOW | WM_CF_STAYONTOP, 0, 0);
   \   000000CC   0x.... 0x....      BL       WM_GetFirstChild
   \   000000D0   0x2100             MOVS     R1,#+0
   \   000000D2   0x9103             STR      R1,[SP, #+12]
   \   000000D4   0x9102             STR      R1,[SP, #+8]
   \   000000D6   0x210A             MOVS     R1,#+10
   \   000000D8   0x9101             STR      R1,[SP, #+4]
   \   000000DA   0x9000             STR      R0,[SP, #+0]
   \   000000DC   0x2300             MOVS     R3,#+0
   \   000000DE   0x461A             MOV      R2,R3
   \   000000E0   0x4611             MOV      R1,R2
   \   000000E2   0x4608             MOV      R0,R1
   \   000000E4   0x.... 0x....      BL       WM_CreateWindowAsChild
   \   000000E8   0x8220             STRH     R0,[R4, #+16]
    369              WM_ExecIdle();
   \   000000EA   0x.... 0x....      BL       WM_Exec
    370            #endif
    371            /* Run the individual demos !  */
    372            for (_iTest = 0; _apfTest[_iTest]; _iTest++) {
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x6220             STR      R0,[R4, #+32]
   \   000000F2   0xE013             B.N      ??GUIDEMO_main_0
    373              GUI_CONTEXT ContextOld;
    374              GUI_SaveContext(&ContextOld);
   \                     ??GUIDEMO_main_1: (+1)
   \   000000F4   0xA800             ADD      R0,SP,#+0
   \   000000F6   0x.... 0x....      BL       GUI_SaveContext_W
    375              _iTestMinor = 0;
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x6260             STR      R0,[R4, #+36]
    376              _UpdateCmdWin();
   \   000000FE   0x.... 0x....      BL       _UpdateCmdWin
    377              (*_apfTest[_iTest])();
   \   00000102   0x6A20             LDR      R0,[R4, #+32]
   \   00000104   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000108   0x6AC0             LDR      R0,[R0, #+44]
   \   0000010A   0x4780             BLX      R0
    378              _CmdNext = 0;
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0x7020             STRB     R0,[R4, #+0]
    379              GUI_RestoreContext(&ContextOld);
   \   00000110   0xA800             ADD      R0,SP,#+0
   \   00000112   0x.... 0x....      BL       GUI_RestoreContext
    380            }
   \   00000116   0x6A20             LDR      R0,[R4, #+32]
   \   00000118   0x1C40             ADDS     R0,R0,#+1
   \   0000011A   0x6220             STR      R0,[R4, #+32]
   \                     ??GUIDEMO_main_0: (+1)
   \   0000011C   0x6A20             LDR      R0,[R4, #+32]
   \   0000011E   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   00000122   0x6AC0             LDR      R0,[R0, #+44]
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD1E5             BNE.N    ??GUIDEMO_main_1
    381            /* Cleanup */
    382            #if GUI_WINSUPPORT
    383              for (i = 0; i < countof(_ahFrameWin); i++) {
   \   00000128   0x2500             MOVS     R5,#+0
   \   0000012A   0xE006             B.N      ??GUIDEMO_main_2
    384                WM_DeleteWindow(_ahFrameWin[i]);
   \                     ??GUIDEMO_main_3: (+1)
   \   0000012C   0xEB04 0x0045      ADD      R0,R4,R5, LSL #+1
   \   00000130   0xF9B0 0x0008      LDRSH    R0,[R0, #+8]
   \   00000134   0x.... 0x....      BL       WM_DeleteWindow
    385              }
   \   00000138   0x1C6D             ADDS     R5,R5,#+1
   \                     ??GUIDEMO_main_2: (+1)
   \   0000013A   0x2D03             CMP      R5,#+3
   \   0000013C   0xD3F6             BCC.N    ??GUIDEMO_main_3
    386            #endif
    387          }
   \   0000013E   0xB013             ADD      SP,SP,#+76
   \   00000140   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x2E 0x00          DC8      ".",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     _CmdNext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x00808080         DC32     0x808080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     GUI_Font13_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     GUI_Font8_ASCII

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     GUI_FontComic18B_ASCII

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     _cbCmdWin

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant ".">`:
   \   00000000   0x2E 0x00          DC8 "."

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "/">`:
   \   00000000   0x2F 0x00          DC8 "/"

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Demo ">`:
   \   00000000   0x44 0x65          DC8 "Demo "
   \              0x6D 0x6F    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Control">`:
   \   00000000   0x43 0x6F          DC8 "Control"
   \              0x6E 0x74    
   \              0x72 0x6F    
   \              0x6C 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Halt">`:
   \   00000000   0x48 0x61          DC8 "Halt"
   \              0x6C 0x74    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Next">`:
   \   00000000   0x4E 0x65          DC8 "Next"
   \              0x78 0x74    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "emWin Demo">`:
   \   00000000   0x65 0x6D          DC8 "emWin Demo"
   \              0x57 0x69    
   \              0x6E 0x20    
   \              0x44 0x65    
   \              0x6D 0x6F    
   \              0x00         
   \   0000000B   0x00               DC8 0
    388          
    389          #else /* GUIDEMO_LARGE */
    390          
    391          /*********************************************************************
    392          *
    393          *       GUIDEMO_main(): Small version of the demo
    394          *
    395          **********************************************************************
    396          */
    397          void GUIDEMO_main(void) {
    398            #if GUI_WINSUPPORT
    399              int i;
    400            #endif
    401            #if GUI_WINSUPPORT
    402              #if GUI_NUM_LAYERS > 1
    403                FRAMEWIN_CreateAsChild(10, 10, 100, 100, WM_GetDesktopWindowEx(1), "Display 1", NULL, WM_CF_SHOW);
    404                GUI_Delay(1000);
    405              #endif
    406              WM_SetCreateFlags(WM_CF_MEMDEV);  /* Automatically use memory devices on all windows */
    407              _ButtonSizeX = 27;
    408              _ButtonSizeY = 14;
    409              _ahButton[0] = BUTTON_Create(LCD_GetXSize() - _ButtonSizeX * 2 - 4,
    410                                           LCD_GetYSize() - _ButtonSizeY - 2,
    411                                           _ButtonSizeX, _ButtonSizeY, 
    412                                           'H' , WM_CF_SHOW | WM_CF_STAYONTOP | WM_CF_MEMDEV);
    413              _ahButton[1] = BUTTON_Create(LCD_GetXSize() - _ButtonSizeX - 2,
    414                                           LCD_GetYSize() - _ButtonSizeY - 2,
    415                                           _ButtonSizeX, _ButtonSizeY, 
    416                                           'N' , WM_CF_SHOW | WM_CF_STAYONTOP | WM_CF_MEMDEV);
    417              BUTTON_SetFont(_ahButton[0], &GUI_Font8_ASCII);
    418              BUTTON_SetFont(_ahButton[1], &GUI_Font8_ASCII);
    419              BUTTON_SetText(_ahButton[0], "Halt");
    420              BUTTON_SetText(_ahButton[1], "Next");
    421              _UpdateCmdWin();
    422              WM_ExecIdle();
    423            #endif
    424            /* Show Intro */
    425            GUIDEMO_Intro();
    426            /* Run the individual demos !  */
    427            for (_iTest = 0; _apfTest[_iTest]; _iTest++) {
    428              GUI_CONTEXT ContextOld;
    429              GUI_SaveContext(&ContextOld);
    430              _iTestMinor = 0;
    431              _UpdateCmdWin();
    432              (*_apfTest[_iTest])();
    433              _CmdNext = 0;
    434              GUI_RestoreContext(&ContextOld);
    435            }
    436            /* Cleanup */
    437            #if GUI_WINSUPPORT
    438              for (i = 0; i < countof(_ahButton); i++) {
    439                BUTTON_Delete(_ahButton[i]);
    440              }
    441            #endif
    442          }
    443          
    444          #endif /* GUIDEMO_LARGE */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   GUIDEMO_CheckCancel
         8   -> GUI_Delay
         8   -> GUI_GetKey
         8   -> WM_Exec
      32   GUIDEMO_Delay
        32   -> GUIDEMO_CheckCancel
        32   -> GUI_Delay
        32   -> GUI_GetTime
        32   -> PROGBAR_CreateAsChild
        32   -> PROGBAR_SetMinMax
        32   -> PROGBAR_SetValue
        32   -> WM_BringToTop
        32   -> WM_DeleteWindow
        32   -> WM_Exec
        32   -> _UpdateCmdWin
       0   GUIDEMO_HideInfoWin
         0   -> WM_HideWindow
       8   GUIDEMO_NotifyStartNext
         8   -> _UpdateCmdWin
       8   GUIDEMO_SetBkColor
         8   -> GUI_ColorIsAvailable
         8   -> GUI_SetBkColor
       8   GUIDEMO_SetColor
         8   -> GUI_ColorIsAvailable
         8   -> GUI_SetColor
       0   GUIDEMO_ShowInfo
         0   -> _UpdateInfoWin
      88   GUIDEMO_ShowIntro
        88   -> GUIDEMO_Delay
        88   -> GUIDEMO_HideInfoWin
        88   -> GUIDEMO_NotifyStartNext
        88   -> GUIDEMO_SetBkColor
        88   -> GUI_Clear
        88   -> GUI_DispStringHCenterAt
        88   -> GUI_RestoreContext
        88   -> GUI_SaveContext_W
        88   -> GUI_SetColor
        88   -> GUI_SetDefault
        88   -> GUI_SetFont
        88   -> LCD_GetXSize
        88   -> LCD_GetYSize
        88   -> WM_Exec
        88   -> _UpdateCmdWin
        88   -> _UpdateInfoWin
       8   GUIDEMO_Wait
         8   -> GUIDEMO_Delay
         0   -> GUIDEMO_NotifyStartNext
      24   GUIDEMO_WaitKey
        24   -> GUIDEMO_CheckCancel
        24   -> GUI_GetKey
        24   -> GUI_GetTime
        24   -> LCD_GetXSize
        24   -> LCD_GetYSize
        24   -> PROGBAR_Create
        24   -> WM_DeleteWindow
        24   -> WM_Exec
      88   GUIDEMO_main
        88   -- Indirect call
        88   -> BUTTON_CreateAsChild
        88   -> BUTTON_SetText
        88   -> FRAMEWIN_Create
        88   -> GUIDEMO_Intro
        88   -> GUI_CURSOR_Show
        88   -> GUI_Clear
        88   -> GUI_RestoreContext
        88   -> GUI_SaveContext_W
        88   -> LCD_GetXSize
        88   -> LCD_GetYSize
        88   -> WM_CreateWindowAsChild
        88   -> WM_DeleteWindow
        88   -> WM_Exec
        88   -> WM_GetClientWindow
        88   -> WM_GetFirstChild
        88   -> WM_SetCreateFlags
        88   -> _UpdateCmdWin
       0   _UpdateCmdWin
         0   -> WM_InvalidateWindow
      96   _UpdateInfoWin
        96   -> GUI_Clear
        96   -> GUI_DispStringAt
        96   -> GUI_DispStringHCenterAt
        96   -> GUI_GetClientRect
        96   -> GUI_RestoreContext
        96   -> GUI_SaveContext_W
        96   -> GUI_SetBkColor
        96   -> GUI_SetColor
        96   -> GUI_SetFont
        96   -> GUI_SetTextAlign
        96   -> WM_SelectWindow
        96   -> WM_ShowWindow
      16   _cbCmdWin
        16   -> GUI_Clear
        16   -> GUI_DispDecMin
        16   -> GUI_DispString
        16   -> GUI_DispStringAt
        16   -> GUI_SetBkColor
         0   -> WM_DefaultProc


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant ".">
       2  ?<Constant "/">
       8  ?<Constant "Control">
       8  ?<Constant "Demo ">
       8  ?<Constant "Halt">
       8  ?<Constant "Next">
      12  ?<Constant "emWin Demo">
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
      68  GUIDEMO_CheckCancel
     120  GUIDEMO_Delay
      10  GUIDEMO_HideInfoWin
      20  GUIDEMO_NotifyStartNext
      26  GUIDEMO_SetBkColor
      28  GUIDEMO_SetColor
       6  GUIDEMO_ShowInfo
     186  GUIDEMO_ShowIntro
      16  GUIDEMO_Wait
      92  GUIDEMO_WaitKey
     322  GUIDEMO_main
     108  _CmdNext
          _ahButton
          _ahFrameWin
          _ahInfoWin
          _ButtonSizeX
          _ButtonSizeY
          _sInfo
          _iTest
          _iTestMinor
          _sExplain
          _apfTest
      12  _UpdateCmdWin
     142  _UpdateInfoWin
      80  _cbCmdWin

 
   108 bytes in section .data
     4 bytes in section .rodata
 1 204 bytes in section .text
 
 1 204 bytes of CODE  memory
     4 bytes of CONST memory
   108 bytes of DATA  memory

Errors: none
Warnings: none
