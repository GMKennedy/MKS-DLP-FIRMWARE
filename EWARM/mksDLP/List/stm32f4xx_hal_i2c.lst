###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:14
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_i2c.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_i2c.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\stm32f4xx_hal_i2c.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\stm32f4xx_hal_i2c.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_i2c.c
      4            * @author  MCD Application Team
      5            * @version V1.5.2
      6            * @date    22-September-2016
      7            * @brief   I2C HAL module driver.
      8            *          This file provides firmware functions to manage the following
      9            *          functionalities of the Inter Integrated Circuit (I2C) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral State, Mode and Error functions
     13            *
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18            [..]
     19              The I2C HAL driver can be used as follows:
     20          
     21              (#) Declare a I2C_HandleTypeDef handle structure, for example:
     22                  I2C_HandleTypeDef  hi2c;
     23          
     24              (#)Initialize the I2C low level resources by implementing the HAL_I2C_MspInit() API:
     25                  (##) Enable the I2Cx interface clock
     26                  (##) I2C pins configuration
     27                      (+++) Enable the clock for the I2C GPIOs
     28                      (+++) Configure I2C pins as alternate function open-drain
     29                  (##) NVIC configuration if you need to use interrupt process
     30                      (+++) Configure the I2Cx interrupt priority
     31                      (+++) Enable the NVIC I2C IRQ Channel
     32                  (##) DMA Configuration if you need to use DMA process
     33                      (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive stream
     34                      (+++) Enable the DMAx interface clock using
     35                      (+++) Configure the DMA handle parameters
     36                      (+++) Configure the DMA Tx or Rx Stream
     37                      (+++) Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle
     38                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on 
     39                            the DMA Tx or Rx Stream
     40          
     41              (#) Configure the Communication Speed, Duty cycle, Addressing mode, Own Address1,
     42                  Dual Addressing mode, Own Address2, General call and Nostretch mode in the hi2c Init structure.
     43          
     44              (#) Initialize the I2C registers by calling the HAL_I2C_Init(), configures also the low level Hardware 
     45                  (GPIO, CLOCK, NVIC...etc) by calling the customized HAL_I2C_MspInit(&hi2c) API.
     46          
     47              (#) To check if target device is ready for communication, use the function HAL_I2C_IsDeviceReady()
     48          
     49              (#) For I2C IO and IO MEM operations, three operation modes are available within this driver :
     50          
     51              *** Polling mode IO operation ***
     52              =================================
     53              [..]
     54                (+) Transmit in master mode an amount of data in blocking mode using HAL_I2C_Master_Transmit()
     55                (+) Receive in master mode an amount of data in blocking mode using HAL_I2C_Master_Receive()
     56                (+) Transmit in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Transmit()
     57                (+) Receive in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Receive()
     58          
     59              *** Polling mode IO MEM operation ***
     60              =====================================
     61              [..]
     62                (+) Write an amount of data in blocking mode to a specific memory address using HAL_I2C_Mem_Write()
     63                (+) Read an amount of data in blocking mode from a specific memory address using HAL_I2C_Mem_Read()
     64          
     65          
     66              *** Interrupt mode IO operation ***
     67              ===================================
     68              [..]
     69                (+) Transmit in master mode an amount of data in non blocking mode using HAL_I2C_Master_Transmit_IT()
     70                (+) At transmission end of transfer HAL_I2C_MasterTxCpltCallback is executed and user can
     71                     add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback
     72                (+) Receive in master mode an amount of data in non blocking mode using HAL_I2C_Master_Receive_IT()
     73                (+) At reception end of transfer HAL_I2C_MasterRxCpltCallback is executed and user can
     74                     add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback
     75                (+) Transmit in slave mode an amount of data in non blocking mode using HAL_I2C_Slave_Transmit_IT()
     76                (+) At transmission end of transfer HAL_I2C_SlaveTxCpltCallback is executed and user can
     77                     add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback
     78                (+) Receive in slave mode an amount of data in non blocking mode using HAL_I2C_Slave_Receive_IT()
     79                (+) At reception end of transfer HAL_I2C_SlaveRxCpltCallback is executed and user can
     80                     add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback
     81                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
     82                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
     83                (+) Abort a master I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT()
     84                (+) End of abort process, HAL_I2C_AbortCpltCallback() is executed and user can
     85                     add his own code by customization of function pointer HAL_I2C_AbortCpltCallback()
     86          
     87              *** Interrupt mode IO sequential operation ***
     88              ==============================================
     89              [..]
     90                (@) These interfaces allow to manage a sequential transfer with a repeated start condition
     91                    when a direction change during transfer
     92              [..]
     93                (+) A specific option field manage the different steps of a sequential transfer
     94                (+) Option field values are defined through @ref I2C_XFEROPTIONS and are listed below:
     95                (++) I2C_FIRST_AND_LAST_FRAME: No sequential usage, functionnal is same as associated interfaces in no sequential mode 
     96                (++) I2C_FIRST_FRAME: Sequential usage, this option allow to manage a sequence with start condition, address
     97                                      and data to transfer without a final stop condition
     98                (++) I2C_NEXT_FRAME: Sequential usage, this option allow to manage a sequence with a restart condition, address
     99                                      and with new data to transfer if the direction change or manage only the new data to transfer
    100                                      if no direction change and without a final stop condition in both cases
    101                (++) I2C_LAST_FRAME: Sequential usage, this option allow to manage a sequance with a restart condition, address
    102                                      and with new data to transfer if the direction change or manage only the new data to transfer
    103                                      if no direction change and with a final stop condition in both cases
    104          
    105                (+) Differents sequential I2C interfaces are listed below:
    106                (++) Sequential transmit in master I2C mode an amount of data in non-blocking mode using HAL_I2C_Master_Sequential_Transmit_IT()
    107                (+++) At transmission end of current frame transfer, HAL_I2C_MasterTxCpltCallback() is executed and user can
    108                     add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback()
    109                (++) Sequential receive in master I2C mode an amount of data in non-blocking mode using HAL_I2C_Master_Sequential_Receive_IT()
    110                (+++) At reception end of current frame transfer, HAL_I2C_MasterRxCpltCallback() is executed and user can
    111                     add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback()
    112                (++) Abort a master I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT()
    113                (+++) End of abort process, HAL_I2C_AbortCpltCallback() is executed and user can
    114                     add his own code by customization of function pointer HAL_I2C_AbortCpltCallback()
    115                (++) Enable/disable the Address listen mode in slave I2C mode using HAL_I2C_EnableListen_IT() HAL_I2C_DisableListen_IT()
    116                (+++) When address slave I2C match, HAL_I2C_AddrCallback() is executed and user can
    117                     add his own code to check the Address Match Code and the transmission direction request by master (Write/Read).
    118                (+++) At Listen mode end HAL_I2C_ListenCpltCallback() is executed and user can
    119                     add his own code by customization of function pointer HAL_I2C_ListenCpltCallback()
    120                (++) Sequential transmit in slave I2C mode an amount of data in non-blocking mode using HAL_I2C_Slave_Sequential_Transmit_IT()
    121                (+++) At transmission end of current frame transfer, HAL_I2C_SlaveTxCpltCallback() is executed and user can
    122                     add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback()
    123                (++) Sequential receive in slave I2C mode an amount of data in non-blocking mode using HAL_I2C_Slave_Sequential_Receive_IT()
    124                (+++) At reception end of current frame transfer, HAL_I2C_SlaveRxCpltCallback() is executed and user can
    125                     add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback()
    126                (++) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    127                     add his own code by customization of function pointer HAL_I2C_ErrorCallback()
    128                (++) Abort a master I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT()
    129                (++) End of abort process, HAL_I2C_AbortCpltCallback() is executed and user can
    130                     add his own code by customization of function pointer HAL_I2C_AbortCpltCallback()
    131          
    132              *** Interrupt mode IO MEM operation ***
    133              =======================================
    134              [..]
    135                (+) Write an amount of data in no-blocking mode with Interrupt to a specific memory address using
    136                    HAL_I2C_Mem_Write_IT()
    137                (+) At MEM end of write transfer HAL_I2C_MemTxCpltCallback is executed and user can
    138                     add his own code by customization of function pointer HAL_I2C_MemTxCpltCallback
    139                (+) Read an amount of data in no-blocking mode with Interrupt from a specific memory address using
    140                    HAL_I2C_Mem_Read_IT()
    141                (+) At MEM end of read transfer HAL_I2C_MemRxCpltCallback is executed and user can
    142                     add his own code by customization of function pointer HAL_I2C_MemRxCpltCallback
    143                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    144                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
    145          
    146              *** DMA mode IO operation ***
    147              ==============================
    148              [..]
    149                (+) Transmit in master mode an amount of data in non blocking mode (DMA) using
    150                    HAL_I2C_Master_Transmit_DMA()
    151                (+) At transmission end of transfer HAL_I2C_MasterTxCpltCallback is executed and user can
    152                     add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback
    153                (+) Receive in master mode an amount of data in non blocking mode (DMA) using
    154                    HAL_I2C_Master_Receive_DMA()
    155                (+) At reception end of transfer HAL_I2C_MasterRxCpltCallback is executed and user can
    156                     add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback
    157                (+) Transmit in slave mode an amount of data in non blocking mode (DMA) using
    158                    HAL_I2C_Slave_Transmit_DMA()
    159                (+) At transmission end of transfer HAL_I2C_SlaveTxCpltCallback is executed and user can
    160                     add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback
    161                (+) Receive in slave mode an amount of data in non blocking mode (DMA) using
    162                    HAL_I2C_Slave_Receive_DMA()
    163                (+) At reception end of transfer HAL_I2C_SlaveRxCpltCallback is executed and user can
    164                     add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback
    165                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    166                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
    167                (+) Abort a master I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT()
    168                (+) End of abort process, HAL_I2C_AbortCpltCallback() is executed and user can
    169                     add his own code by customization of function pointer HAL_I2C_AbortCpltCallback()
    170          
    171              *** DMA mode IO MEM operation ***
    172              =================================
    173              [..]
    174                (+) Write an amount of data in no-blocking mode with DMA to a specific memory address using
    175                    HAL_I2C_Mem_Write_DMA()
    176                (+) At MEM end of write transfer HAL_I2C_MemTxCpltCallback is executed and user can
    177                     add his own code by customization of function pointer HAL_I2C_MemTxCpltCallback
    178                (+) Read an amount of data in no-blocking mode with DMA from a specific memory address using
    179                    HAL_I2C_Mem_Read_DMA()
    180                (+) At MEM end of read transfer HAL_I2C_MemRxCpltCallback is executed and user can
    181                     add his own code by customization of function pointer HAL_I2C_MemRxCpltCallback
    182                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    183                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
    184          
    185          
    186               *** I2C HAL driver macros list ***
    187               ==================================
    188               [..]
    189                 Below the list of most used macros in I2C HAL driver.
    190          
    191                (+) __HAL_I2C_ENABLE: Enable the I2C peripheral
    192                (+) __HAL_I2C_DISABLE: Disable the I2C peripheral
    193                (+) __HAL_I2C_GET_FLAG : Checks whether the specified I2C flag is set or not
    194                (+) __HAL_I2C_CLEAR_FLAG : Clear the specified I2C pending flag
    195                (+) __HAL_I2C_ENABLE_IT: Enable the specified I2C interrupt
    196                (+) __HAL_I2C_DISABLE_IT: Disable the specified I2C interrupt
    197          
    198               [..]
    199                 (@) You can refer to the I2C HAL driver header file for more useful macros
    200          
    201          
    202            @endverbatim
    203            ******************************************************************************
    204            * @attention
    205            *
    206            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    207            *
    208            * Redistribution and use in source and binary forms, with or without modification,
    209            * are permitted provided that the following conditions are met:
    210            *   1. Redistributions of source code must retain the above copyright notice,
    211            *      this list of conditions and the following disclaimer.
    212            *   2. Redistributions in binary form must reproduce the above copyright notice,
    213            *      this list of conditions and the following disclaimer in the documentation
    214            *      and/or other materials provided with the distribution.
    215            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    216            *      may be used to endorse or promote products derived from this software
    217            *      without specific prior written permission.
    218            *
    219            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    220            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    221            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    222            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    223            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    224            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    225            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    226            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    227            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    228            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    229            *
    230            ******************************************************************************
    231            */
    232          
    233          /* Includes ------------------------------------------------------------------*/
    234          #include "stm32f4xx_hal.h"
    235          
    236          /** @addtogroup STM32F4xx_HAL_Driver
    237            * @{
    238            */
    239          
    240          /** @defgroup I2C I2C
    241            * @brief I2C HAL module driver
    242            * @{
    243            */
    244          
    245          #ifdef HAL_I2C_MODULE_ENABLED
    246          
    247          /* Private typedef -----------------------------------------------------------*/
    248          /* Private define ------------------------------------------------------------*/
    249          /** @addtogroup I2C_Private_Define
    250            * @{
    251            */    
    252          #define I2C_TIMEOUT_FLAG          ((uint32_t)35U)         /*!< Timeout 35 ms             */
    253          #define I2C_TIMEOUT_BUSY_FLAG     ((uint32_t)25U)         /*!< Timeout 25 ms             */
    254          #define I2C_NO_OPTION_FRAME       ((uint32_t)0xFFFF0000U) /*!< XferOptions default value */
    255          
    256          /* Private define for @ref PreviousState usage */
    257          #define I2C_STATE_MSK             ((uint32_t)((HAL_I2C_STATE_BUSY_TX | HAL_I2C_STATE_BUSY_RX) & (~(uint32_t)HAL_I2C_STATE_READY))) /*!< Mask State define, keep only RX and TX bits            */
    258          #define I2C_STATE_NONE            ((uint32_t)(HAL_I2C_MODE_NONE))                                                        /*!< Default Value                                          */
    259          #define I2C_STATE_MASTER_BUSY_TX  ((uint32_t)((HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | HAL_I2C_MODE_MASTER))            /*!< Master Busy TX, combinaison of State LSB and Mode enum */
    260          #define I2C_STATE_MASTER_BUSY_RX  ((uint32_t)((HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | HAL_I2C_MODE_MASTER))            /*!< Master Busy RX, combinaison of State LSB and Mode enum */
    261          #define I2C_STATE_SLAVE_BUSY_TX   ((uint32_t)((HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | HAL_I2C_MODE_SLAVE))             /*!< Slave Busy TX, combinaison of State LSB and Mode enum  */
    262          #define I2C_STATE_SLAVE_BUSY_RX   ((uint32_t)((HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | HAL_I2C_MODE_SLAVE))             /*!< Slave Busy RX, combinaison of State LSB and Mode enum  */
    263          
    264          /**
    265            * @}
    266            */
    267          
    268          /* Private macro -------------------------------------------------------------*/
    269          /* Private variables ---------------------------------------------------------*/
    270          /* Private function prototypes -----------------------------------------------*/
    271          /** @addtogroup I2C_Private_Functions
    272            * @{
    273            */
    274          /* Private functions to handle DMA transfer */
    275          static void I2C_DMAXferCplt(DMA_HandleTypeDef *hdma);
    276          static void I2C_DMAError(DMA_HandleTypeDef *hdma);
    277          static void I2C_DMAAbort(DMA_HandleTypeDef *hdma);
    278          
    279          static void I2C_ITError(I2C_HandleTypeDef *hi2c);
    280          
    281          static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart);
    282          static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart);
    283          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart);
    284          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart);
    285          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart);
    286          static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout, uint32_t Tickstart);
    287          static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    288          static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    289          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    290          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    291          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c);
    292          
    293          /* Private functions for I2C transfer IRQ handler */
    294          static HAL_StatusTypeDef I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c);
    295          static HAL_StatusTypeDef I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c);
    296          static HAL_StatusTypeDef I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c);
    297          static HAL_StatusTypeDef I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c);
    298          static HAL_StatusTypeDef I2C_Master_SB(I2C_HandleTypeDef *hi2c);
    299          static HAL_StatusTypeDef I2C_Master_ADD10(I2C_HandleTypeDef *hi2c);
    300          static HAL_StatusTypeDef I2C_Master_ADDR(I2C_HandleTypeDef *hi2c);
    301          
    302          static HAL_StatusTypeDef I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c);
    303          static HAL_StatusTypeDef I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c);
    304          static HAL_StatusTypeDef I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c);
    305          static HAL_StatusTypeDef I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c);
    306          static HAL_StatusTypeDef I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c);
    307          static HAL_StatusTypeDef I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c);
    308          static HAL_StatusTypeDef I2C_Slave_AF(I2C_HandleTypeDef *hi2c);
    309          /**
    310            * @}
    311            */
    312          
    313          /* Exported functions --------------------------------------------------------*/
    314          /** @defgroup I2C_Exported_Functions I2C Exported Functions
    315            * @{
    316            */
    317          
    318          /** @defgroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
    319           *  @brief    Initialization and Configuration functions
    320           *
    321          @verbatim
    322           ===============================================================================
    323                        ##### Initialization and de-initialization functions #####
    324           ===============================================================================
    325              [..]  This subsection provides a set of functions allowing to initialize and
    326                    de-initialize the I2Cx peripheral:
    327          
    328                (+) User must Implement HAL_I2C_MspInit() function in which he configures
    329                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC).
    330          
    331                (+) Call the function HAL_I2C_Init() to configure the selected device with
    332                    the selected configuration:
    333                  (++) Communication Speed
    334                  (++) Duty cycle
    335                  (++) Addressing mode
    336                  (++) Own Address 1
    337                  (++) Dual Addressing mode
    338                  (++) Own Address 2
    339                  (++) General call mode
    340                  (++) Nostretch mode
    341          
    342                (+) Call the function HAL_I2C_DeInit() to restore the default configuration
    343                    of the selected I2Cx peripheral.
    344          
    345          @endverbatim
    346            * @{
    347            */
    348          
    349          /**
    350            * @brief  Initializes the I2C according to the specified parameters
    351            *         in the I2C_InitTypeDef and create the associated handle.
    352            * @param  hi2c: pointer to a I2C_HandleTypeDef structure that contains
    353            *         the configuration information for I2C module
    354            * @retval HAL status
    355            */

   \                                 In section .text, align 2, keep-with-next
    356          HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
    357          {
   \                     HAL_I2C_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    358            uint32_t freqrange = 0U;
    359            uint32_t pclk1 = 0U;
    360          
    361            /* Check the I2C handle allocation */
    362            if(hi2c == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_I2C_Init_0
    363            {
    364              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    365            }
    366          
    367            /* Check the parameters */
    368            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    369            assert_param(IS_I2C_CLOCK_SPEED(hi2c->Init.ClockSpeed));
    370            assert_param(IS_I2C_DUTY_CYCLE(hi2c->Init.DutyCycle));
    371            assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    372            assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    373            assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    374            assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    375            assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    376            assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    377          
    378            if(hi2c->State == HAL_I2C_STATE_RESET)
   \                     ??HAL_I2C_Init_0: (+1)
   \   0000000A   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE.N    ??HAL_I2C_Init_1
    379            {
    380              /* Allocate lock resource and initialize it */
    381              hi2c->Lock = HAL_UNLOCKED;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF884 0x003C      STRB     R0,[R4, #+60]
    382              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    383              HAL_I2C_MspInit(hi2c);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_I2C_MspInit
    384            }
    385          
    386            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_Init_1: (+1)
   \   0000001E   0x2024             MOVS     R0,#+36
   \   00000020   0xF884 0x003D      STRB     R0,[R4, #+61]
    387          
    388            /* Disable the selected I2C peripheral */
    389            __HAL_I2C_DISABLE(hi2c);
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x0849             LSRS     R1,R1,#+1
   \   0000002A   0x0049             LSLS     R1,R1,#+1
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    390          
    391            /* Get PCLK1 frequency */
    392            pclk1 = HAL_RCC_GetPCLK1Freq();
   \   0000002E   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
    393          
    394            /* Calculate frequency range */
    395            freqrange = I2C_FREQRANGE(pclk1);
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0xf4240
   \   00000036   0xFBB0 0xF1F1      UDIV     R1,R0,R1
    396          
    397            /*---------------------------- I2Cx CR2 Configuration ----------------------*/
    398            /* Configure I2Cx: Frequency range */
    399            hi2c->Instance->CR2 = freqrange;
   \   0000003A   0x6822             LDR      R2,[R4, #+0]
   \   0000003C   0x6051             STR      R1,[R2, #+4]
    400          
    401            /*---------------------------- I2Cx TRISE Configuration --------------------*/
    402            /* Configure I2Cx: Rise Time */
    403            hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
   \   0000003E   0x.... 0x....      LDR.W    R2,??DataTable10_1  ;; 0x186a1
   \   00000042   0x6863             LDR      R3,[R4, #+4]
   \   00000044   0x4293             CMP      R3,R2
   \   00000046   0xD201             BCS.N    ??HAL_I2C_Init_2
   \   00000048   0x1C49             ADDS     R1,R1,#+1
   \   0000004A   0xE007             B.N      ??HAL_I2C_Init_3
   \                     ??HAL_I2C_Init_2: (+1)
   \   0000004C   0xF44F 0x7396      MOV      R3,#+300
   \   00000050   0x4359             MULS     R1,R3,R1
   \   00000052   0xF44F 0x737A      MOV      R3,#+1000
   \   00000056   0xFBB1 0xF1F3      UDIV     R1,R1,R3
   \   0000005A   0x1C49             ADDS     R1,R1,#+1
   \                     ??HAL_I2C_Init_3: (+1)
   \   0000005C   0x6823             LDR      R3,[R4, #+0]
   \   0000005E   0x6219             STR      R1,[R3, #+32]
    404          
    405            /*---------------------------- I2Cx CCR Configuration ----------------------*/
    406            /* Configure I2Cx: Speed */
    407            hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
   \   00000060   0x6861             LDR      R1,[R4, #+4]
   \   00000062   0x4291             CMP      R1,R2
   \   00000064   0xD208             BCS.N    ??HAL_I2C_Init_4
   \   00000066   0x0049             LSLS     R1,R1,#+1
   \   00000068   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000006C   0x0501             LSLS     R1,R0,#+20
   \   0000006E   0x0D09             LSRS     R1,R1,#+20
   \   00000070   0x2904             CMP      R1,#+4
   \   00000072   0xD222             BCS.N    ??HAL_I2C_Init_5
   \   00000074   0x2004             MOVS     R0,#+4
   \   00000076   0xE020             B.N      ??HAL_I2C_Init_5
   \                     ??HAL_I2C_Init_4: (+1)
   \   00000078   0x68A2             LDR      R2,[R4, #+8]
   \   0000007A   0x2A00             CMP      R2,#+0
   \   0000007C   0xD104             BNE.N    ??HAL_I2C_Init_6
   \   0000007E   0xEB01 0x0341      ADD      R3,R1,R1, LSL #+1
   \   00000082   0xFBB0 0xF3F3      UDIV     R3,R0,R3
   \   00000086   0xE005             B.N      ??HAL_I2C_Init_7
   \                     ??HAL_I2C_Init_6: (+1)
   \   00000088   0x2319             MOVS     R3,#+25
   \   0000008A   0x434B             MULS     R3,R3,R1
   \   0000008C   0xFBB0 0xF3F3      UDIV     R3,R0,R3
   \   00000090   0xF443 0x4380      ORR      R3,R3,#0x4000
   \                     ??HAL_I2C_Init_7: (+1)
   \   00000094   0x051B             LSLS     R3,R3,#+20
   \   00000096   0xD101             BNE.N    ??HAL_I2C_Init_8
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xE00E             B.N      ??HAL_I2C_Init_5
   \                     ??HAL_I2C_Init_8: (+1)
   \   0000009C   0x2A00             CMP      R2,#+0
   \   0000009E   0xD104             BNE.N    ??HAL_I2C_Init_9
   \   000000A0   0xEB01 0x0141      ADD      R1,R1,R1, LSL #+1
   \   000000A4   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000A8   0xE005             B.N      ??HAL_I2C_Init_10
   \                     ??HAL_I2C_Init_9: (+1)
   \   000000AA   0x2219             MOVS     R2,#+25
   \   000000AC   0x4351             MULS     R1,R2,R1
   \   000000AE   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000B2   0xF440 0x4080      ORR      R0,R0,#0x4000
   \                     ??HAL_I2C_Init_10: (+1)
   \   000000B6   0xF440 0x4000      ORR      R0,R0,#0x8000
   \                     ??HAL_I2C_Init_5: (+1)
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x61C8             STR      R0,[R1, #+28]
    408          
    409            /*---------------------------- I2Cx CR1 Configuration ----------------------*/
    410            /* Configure I2Cx: Generalcall and NoStretch mode */
    411            hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
   \   000000BE   0x69E0             LDR      R0,[R4, #+28]
   \   000000C0   0x6A21             LDR      R1,[R4, #+32]
   \   000000C2   0x4308             ORRS     R0,R1,R0
   \   000000C4   0x6821             LDR      R1,[R4, #+0]
   \   000000C6   0x6008             STR      R0,[R1, #+0]
    412          
    413            /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
    414            /* Configure I2Cx: Own Address1 and addressing mode */
    415            hi2c->Instance->OAR1 = (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1);
   \   000000C8   0x6920             LDR      R0,[R4, #+16]
   \   000000CA   0x68E1             LDR      R1,[R4, #+12]
   \   000000CC   0x4308             ORRS     R0,R1,R0
   \   000000CE   0x6821             LDR      R1,[R4, #+0]
   \   000000D0   0x6088             STR      R0,[R1, #+8]
    416          
    417            /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
    418            /* Configure I2Cx: Dual mode and Own Address2 */
    419            hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);
   \   000000D2   0x6960             LDR      R0,[R4, #+20]
   \   000000D4   0x69A1             LDR      R1,[R4, #+24]
   \   000000D6   0x4308             ORRS     R0,R1,R0
   \   000000D8   0x6821             LDR      R1,[R4, #+0]
   \   000000DA   0x60C8             STR      R0,[R1, #+12]
    420          
    421            /* Enable the selected I2C peripheral */
    422            __HAL_I2C_ENABLE(hi2c);
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x6801             LDR      R1,[R0, #+0]
   \   000000E0   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000E4   0x6001             STR      R1,[R0, #+0]
    423          
    424            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x6420             STR      R0,[R4, #+64]
    425            hi2c->State = HAL_I2C_STATE_READY;
   \   000000EA   0x2020             MOVS     R0,#+32
   \   000000EC   0xF884 0x003D      STRB     R0,[R4, #+61]
    426            hi2c->PreviousState = I2C_STATE_NONE;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x6320             STR      R0,[R4, #+48]
    427            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   000000F4   0xF884 0x003E      STRB     R0,[R4, #+62]
    428          
    429            return HAL_OK;
   \   000000F8   0xBD10             POP      {R4,PC}          ;; return
    430          }
    431          
    432          /**
    433            * @brief  DeInitializes the I2C peripheral.
    434            * @param  hi2c: pointer to a I2C_HandleTypeDef structure that contains
    435            *         the configuration information for I2C module
    436            * @retval HAL status
    437            */

   \                                 In section .text, align 2, keep-with-next
    438          HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
    439          {
   \                     HAL_I2C_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    440            /* Check the I2C handle allocation */
    441            if(hi2c == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_I2C_DeInit_0
    442            {
    443              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    444            }
    445          
    446            /* Check the parameters */
    447            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    448          
    449            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_DeInit_0: (+1)
   \   0000000A   0x2024             MOVS     R0,#+36
   \   0000000C   0xF884 0x003D      STRB     R0,[R4, #+61]
    450          
    451            /* Disable the I2C Peripheral Clock */
    452            __HAL_I2C_DISABLE(hi2c);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x0849             LSRS     R1,R1,#+1
   \   00000016   0x0049             LSLS     R1,R1,#+1
   \   00000018   0x6001             STR      R1,[R0, #+0]
    453          
    454            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    455            HAL_I2C_MspDeInit(hi2c);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_I2C_MspDeInit
    456          
    457            hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6420             STR      R0,[R4, #+64]
    458            hi2c->State         = HAL_I2C_STATE_RESET;
   \   00000024   0xF884 0x003D      STRB     R0,[R4, #+61]
    459            hi2c->PreviousState = I2C_STATE_NONE;
   \   00000028   0x6320             STR      R0,[R4, #+48]
    460            hi2c->Mode          = HAL_I2C_MODE_NONE;
   \   0000002A   0xF884 0x003E      STRB     R0,[R4, #+62]
    461          
    462            /* Release Lock */
    463            __HAL_UNLOCK(hi2c);
   \   0000002E   0xF884 0x003C      STRB     R0,[R4, #+60]
    464          
    465            return HAL_OK;
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
    466          }
    467          
    468          /**
    469            * @brief I2C MSP Init.
    470            * @param  hi2c: pointer to a I2C_HandleTypeDef structure that contains
    471            *         the configuration information for I2C module
    472            * @retval None
    473            */

   \                                 In section .text, align 2, keep-with-next
    474           __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
    475          {
    476            /* Prevent unused argument(s) compilation warning */
    477            UNUSED(hi2c);
    478            /* NOTE : This function Should not be modified, when the callback is needed,
    479                      the HAL_I2C_MspInit could be implemented in the user file
    480             */
    481          }
   \                     HAL_I2C_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    482          
    483          /**
    484            * @brief I2C MSP DeInit
    485            * @param  hi2c: pointer to a I2C_HandleTypeDef structure that contains
    486            *         the configuration information for I2C module
    487            * @retval None
    488            */

   \                                 In section .text, align 2, keep-with-next
    489           __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
    490          {
    491            /* Prevent unused argument(s) compilation warning */
    492            UNUSED(hi2c);
    493            /* NOTE : This function Should not be modified, when the callback is needed,
    494                      the HAL_I2C_MspDeInit could be implemented in the user file
    495             */
    496          }
   \                     HAL_I2C_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    497          
    498          /**
    499            * @}
    500            */
    501          
    502          /** @defgroup I2C_Exported_Functions_Group2 IO operation functions
    503           *  @brief   Data transfers functions
    504           *
    505          @verbatim
    506           ===============================================================================
    507                                ##### IO operation functions #####
    508           ===============================================================================
    509              [..]
    510              This subsection provides a set of functions allowing to manage the I2C data
    511              transfers.
    512          
    513              (#) There are two modes of transfer:
    514                 (++) Blocking mode : The communication is performed in the polling mode.
    515                      The status of all data processing is returned by the same function
    516                      after finishing transfer.
    517                 (++) No-Blocking mode : The communication is performed using Interrupts
    518                      or DMA. These functions return the status of the transfer startup.
    519                      The end of the data processing will be indicated through the
    520                      dedicated I2C IRQ when using Interrupt mode or the DMA IRQ when
    521                      using DMA mode.
    522          
    523              (#) Blocking mode functions are :
    524                  (++) HAL_I2C_Master_Transmit()
    525                  (++) HAL_I2C_Master_Receive()
    526                  (++) HAL_I2C_Slave_Transmit()
    527                  (++) HAL_I2C_Slave_Receive()
    528                  (++) HAL_I2C_Mem_Write()
    529                  (++) HAL_I2C_Mem_Read()
    530                  (++) HAL_I2C_IsDeviceReady()
    531          
    532              (#) No-Blocking mode functions with Interrupt are :
    533                  (++) HAL_I2C_Master_Transmit_IT()
    534                  (++) HAL_I2C_Master_Receive_IT()
    535                  (++) HAL_I2C_Slave_Transmit_IT()
    536                  (++) HAL_I2C_Slave_Receive_IT()
    537                  (++) HAL_I2C_Master_Sequential_Transmit_IT()
    538                  (++) HAL_I2C_Master_Sequential_Receive_IT()
    539                  (++) HAL_I2C_Slave_Sequential_Transmit_IT()
    540                  (++) HAL_I2C_Slave_Sequential_Receive_IT()
    541                  (++) HAL_I2C_Mem_Write_IT()
    542                  (++) HAL_I2C_Mem_Read_IT()
    543          
    544              (#) No-Blocking mode functions with DMA are :
    545                  (++) HAL_I2C_Master_Transmit_DMA()
    546                  (++) HAL_I2C_Master_Receive_DMA()
    547                  (++) HAL_I2C_Slave_Transmit_DMA()
    548                  (++) HAL_I2C_Slave_Receive_DMA()
    549                  (++) HAL_I2C_Mem_Write_DMA()
    550                  (++) HAL_I2C_Mem_Read_DMA()
    551          
    552              (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
    553                  (++) HAL_I2C_MemTxCpltCallback()
    554                  (++) HAL_I2C_MemRxCpltCallback()
    555                  (++) HAL_I2C_MasterTxCpltCallback()
    556                  (++) HAL_I2C_MasterRxCpltCallback()
    557                  (++) HAL_I2C_SlaveTxCpltCallback()
    558                  (++) HAL_I2C_SlaveRxCpltCallback()
    559                  (++) HAL_I2C_ErrorCallback()
    560                  (++) HAL_I2C_AbortCpltCallback()
    561          
    562          @endverbatim
    563            * @{
    564            */
    565          
    566          /**
    567            * @brief  Transmits in master mode an amount of data in blocking mode.
    568            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    569            *                the configuration information for the specified I2C.
    570            * @param  DevAddress Target device address: The device 7 bits address value
    571            *         in datasheet must be shift at right before call interface
    572            * @param  pData Pointer to data buffer
    573            * @param  Size Amount of data to be sent
    574            * @param  Timeout Timeout duration
    575            * @retval HAL status
    576            */

   \                                 In section .text, align 2, keep-with-next
    577          HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    578          {
   \                     HAL_I2C_Master_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x4617             MOV      R7,R2
   \   0000000C   0x461D             MOV      R5,R3
    579            uint32_t tickstart = 0x00U;
    580          
    581            /* Init tickstart for timeout management*/
    582            tickstart = HAL_GetTick();
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x4606             MOV      R6,R0
    583          
    584            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000014   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000018   0x2820             CMP      R0,#+32
   \   0000001A   0xF040 0x80A2      BNE.W    ??HAL_I2C_Master_Transmit_0
    585            {
    586              /* Wait until BUSY flag is reset */
    587              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \   0000001E   0x9600             STR      R6,[SP, #+0]
   \   00000020   0x2319             MOVS     R3,#+25
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x100002
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xF040 0x8097      BNE.W    ??HAL_I2C_Master_Transmit_0
    588              {
    589                return HAL_BUSY;
    590              }
    591          
    592              /* Process Locked */
    593              __HAL_LOCK(hi2c);
   \   00000034   0xF994 0x003C      LDRSB    R0,[R4, #+60]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xF000 0x8092      BEQ.W    ??HAL_I2C_Master_Transmit_0
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF884 0x003C      STRB     R0,[R4, #+60]
    594          
    595              /* Check if the I2C is already enabled */
    596              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x07C9             LSLS     R1,R1,#+31
   \   0000004A   0xD403             BMI.N    ??HAL_I2C_Master_Transmit_1
    597              {
    598                /* Enable I2C peripheral */
    599                __HAL_I2C_ENABLE(hi2c);
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000052   0x6001             STR      R1,[R0, #+0]
    600              }
    601          
    602              /* Disable Pos */
    603              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Master_Transmit_1: (+1)
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6801             LDR      R1,[R0, #+0]
   \   00000058   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000005C   0x6001             STR      R1,[R0, #+0]
    604          
    605              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \   0000005E   0x2021             MOVS     R0,#+33
   \   00000060   0xF884 0x003D      STRB     R0,[R4, #+61]
    606              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \   00000064   0x2010             MOVS     R0,#+16
   \   00000066   0xF884 0x003E      STRB     R0,[R4, #+62]
    607              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x6420             STR      R0,[R4, #+64]
    608          
    609              /* Prepare transfer parameters */
    610              hi2c->pBuffPtr    = pData;
   \   0000006E   0x6267             STR      R7,[R4, #+36]
    611              hi2c->XferCount   = Size;
   \   00000070   0x8565             STRH     R5,[R4, #+42]
    612              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0xffff0000
   \   00000076   0x62E0             STR      R0,[R4, #+44]
    613              hi2c->XferSize    = hi2c->XferCount;
   \   00000078   0x8D60             LDRH     R0,[R4, #+42]
   \   0000007A   0x8520             STRH     R0,[R4, #+40]
   \   0000007C   0x9F08             LDR      R7,[SP, #+32]
    614          
    615              /* Send Slave Address */
    616              if(I2C_MasterRequestWrite(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
   \   0000007E   0x4633             MOV      R3,R6
   \   00000080   0x463A             MOV      R2,R7
   \   00000082   0x4641             MOV      R1,R8
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       I2C_MasterRequestWrite
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD00C             BEQ.N    ??HAL_I2C_Master_Transmit_2
    617              {
    618                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000008E   0x6C20             LDR      R0,[R4, #+64]
   \   00000090   0x2804             CMP      R0,#+4
   \   00000092   0xD104             BNE.N    ??HAL_I2C_Master_Transmit_3
    619                {
    620                  /* Process Unlocked */
    621                  __HAL_UNLOCK(hi2c);
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xF884 0x003C      STRB     R0,[R4, #+60]
    622                  return HAL_ERROR;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0xE062             B.N      ??HAL_I2C_Master_Transmit_4
    623                }
    624                else
    625                {
    626                  /* Process Unlocked */
    627                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Transmit_3: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xF884 0x003C      STRB     R0,[R4, #+60]
    628                  return HAL_TIMEOUT;
   \   000000A4   0x2003             MOVS     R0,#+3
   \   000000A6   0xE05D             B.N      ??HAL_I2C_Master_Transmit_4
    629                }
    630              }
    631          
    632              /* Clear ADDR flag */
    633              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Master_Transmit_2: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x9000             STR      R0,[SP, #+0]
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6941             LDR      R1,[R0, #+20]
   \   000000B0   0x9100             STR      R1,[SP, #+0]
   \   000000B2   0x6980             LDR      R0,[R0, #+24]
   \   000000B4   0x9000             STR      R0,[SP, #+0]
   \   000000B6   0x9800             LDR      R0,[SP, #+0]
    634          
    635              while(hi2c->XferSize > 0U)
   \                     ??HAL_I2C_Master_Transmit_5: (+1)
   \   000000B8   0x8D20             LDRH     R0,[R4, #+40]
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD043             BEQ.N    ??HAL_I2C_Master_Transmit_6
    636              {
    637                /* Wait until TXE flag is set */
    638                if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \   000000BE   0x4632             MOV      R2,R6
   \   000000C0   0x4639             MOV      R1,R7
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD00B             BEQ.N    ??HAL_I2C_Master_Transmit_7
    639                {
    640                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000CC   0x6C20             LDR      R0,[R4, #+64]
   \   000000CE   0x2804             CMP      R0,#+4
   \   000000D0   0xD106             BNE.N    ??HAL_I2C_Master_Transmit_8
    641                  {
    642                    /* Generate Stop */
    643                    hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6801             LDR      R1,[R0, #+0]
   \   000000D6   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000DA   0x6001             STR      R1,[R0, #+0]
    644                    return HAL_ERROR;
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0xE041             B.N      ??HAL_I2C_Master_Transmit_4
    645                  }
    646                  else
    647                  {
    648                    return HAL_TIMEOUT;
   \                     ??HAL_I2C_Master_Transmit_8: (+1)
   \   000000E0   0x2003             MOVS     R0,#+3
   \   000000E2   0xE03F             B.N      ??HAL_I2C_Master_Transmit_4
    649                  }
    650                }
    651          
    652                /* Write data to DR */
    653                hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \                     ??HAL_I2C_Master_Transmit_7: (+1)
   \   000000E4   0x6A60             LDR      R0,[R4, #+36]
   \   000000E6   0x1C41             ADDS     R1,R0,#+1
   \   000000E8   0x6261             STR      R1,[R4, #+36]
   \   000000EA   0x7800             LDRB     R0,[R0, #+0]
   \   000000EC   0x6821             LDR      R1,[R4, #+0]
   \   000000EE   0x6108             STR      R0,[R1, #+16]
    654                hi2c->XferCount--;
   \   000000F0   0x8D60             LDRH     R0,[R4, #+42]
   \   000000F2   0x1E40             SUBS     R0,R0,#+1
   \   000000F4   0x8560             STRH     R0,[R4, #+42]
    655                hi2c->XferSize--;
   \   000000F6   0x8D20             LDRH     R0,[R4, #+40]
   \   000000F8   0x1E40             SUBS     R0,R0,#+1
   \   000000FA   0x8520             STRH     R0,[R4, #+40]
    656          
    657                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0U))
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x6940             LDR      R0,[R0, #+20]
   \   00000100   0x0740             LSLS     R0,R0,#+29
   \   00000102   0xD50D             BPL.N    ??HAL_I2C_Master_Transmit_9
   \   00000104   0x2D00             CMP      R5,#+0
   \   00000106   0xD00B             BEQ.N    ??HAL_I2C_Master_Transmit_9
    658                {
    659                  /* Write data to DR */
    660                  hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \   00000108   0x6A60             LDR      R0,[R4, #+36]
   \   0000010A   0x1C41             ADDS     R1,R0,#+1
   \   0000010C   0x6261             STR      R1,[R4, #+36]
   \   0000010E   0x7800             LDRB     R0,[R0, #+0]
   \   00000110   0x6821             LDR      R1,[R4, #+0]
   \   00000112   0x6108             STR      R0,[R1, #+16]
    661                  hi2c->XferCount--;
   \   00000114   0x8D60             LDRH     R0,[R4, #+42]
   \   00000116   0x1E40             SUBS     R0,R0,#+1
   \   00000118   0x8560             STRH     R0,[R4, #+42]
    662                  hi2c->XferSize--;
   \   0000011A   0x8D20             LDRH     R0,[R4, #+40]
   \   0000011C   0x1E40             SUBS     R0,R0,#+1
   \   0000011E   0x8520             STRH     R0,[R4, #+40]
    663                }
    664                
    665                /* Wait until BTF flag is set */
    666                if(I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Master_Transmit_9: (+1)
   \   00000120   0x4632             MOV      R2,R6
   \   00000122   0x4639             MOV      R1,R7
   \   00000124   0x4620             MOV      R0,R4
   \   00000126   0x.... 0x....      BL       I2C_WaitOnBTFFlagUntilTimeout
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD0C4             BEQ.N    ??HAL_I2C_Master_Transmit_5
    667                {
    668                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000012E   0x6C20             LDR      R0,[R4, #+64]
   \   00000130   0x2804             CMP      R0,#+4
   \   00000132   0xD106             BNE.N    ??HAL_I2C_Master_Transmit_10
    669                  {
    670                    /* Generate Stop */
    671                    hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   00000134   0x6820             LDR      R0,[R4, #+0]
   \   00000136   0x6801             LDR      R1,[R0, #+0]
   \   00000138   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000013C   0x6001             STR      R1,[R0, #+0]
    672                    return HAL_ERROR;
   \   0000013E   0x2001             MOVS     R0,#+1
   \   00000140   0xE010             B.N      ??HAL_I2C_Master_Transmit_4
    673                  }
    674                  else
    675                  {
    676                    return HAL_TIMEOUT;
   \                     ??HAL_I2C_Master_Transmit_10: (+1)
   \   00000142   0x2003             MOVS     R0,#+3
   \   00000144   0xE00E             B.N      ??HAL_I2C_Master_Transmit_4
    677                  }
    678                }
    679              }
    680          
    681              /* Generate Stop */
    682              hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \                     ??HAL_I2C_Master_Transmit_6: (+1)
   \   00000146   0x6820             LDR      R0,[R4, #+0]
   \   00000148   0x6801             LDR      R1,[R0, #+0]
   \   0000014A   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000014E   0x6001             STR      R1,[R0, #+0]
    683          
    684              hi2c->State = HAL_I2C_STATE_READY;
   \   00000150   0x2020             MOVS     R0,#+32
   \   00000152   0xF884 0x003D      STRB     R0,[R4, #+61]
    685              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0xF884 0x003E      STRB     R0,[R4, #+62]
    686              
    687              /* Process Unlocked */
    688              __HAL_UNLOCK(hi2c);
   \   0000015C   0xF884 0x003C      STRB     R0,[R4, #+60]
    689          
    690              return HAL_OK;
   \   00000160   0xE000             B.N      ??HAL_I2C_Master_Transmit_4
    691            }
    692            else
    693            {
    694              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_0: (+1)
   \   00000162   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_4: (+1)
   \   00000164   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    695            }
    696          }
    697          
    698          /**
    699            * @brief  Receives in master mode an amount of data in blocking mode. 
    700            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    701            *                the configuration information for the specified I2C.
    702            * @param  DevAddress Target device address: The device 7 bits address value
    703            *         in datasheet must be shift at right before call interface
    704            * @param  pData Pointer to data buffer
    705            * @param  Size Amount of data to be sent
    706            * @param  Timeout Timeout duration
    707            * @retval HAL status
    708            */

   \                                 In section .text, align 2, keep-with-next
    709          HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    710          {
   \                     HAL_I2C_Master_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460F             MOV      R7,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x4698             MOV      R8,R3
    711            uint32_t tickstart = 0x00U;
    712          
    713            /* Init tickstart for timeout management*/
    714            tickstart = HAL_GetTick();
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x4606             MOV      R6,R0
    715          
    716            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000014   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000018   0x2820             CMP      R0,#+32
   \   0000001A   0xF040 0x8151      BNE.W    ??HAL_I2C_Master_Receive_0
    717            {
    718              /* Wait until BUSY flag is reset */
    719              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \   0000001E   0x9600             STR      R6,[SP, #+0]
   \   00000020   0x2319             MOVS     R3,#+25
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x100002
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xF040 0x8146      BNE.W    ??HAL_I2C_Master_Receive_0
    720              {
    721                return HAL_BUSY;
    722              }
    723          
    724              /* Process Locked */
    725              __HAL_LOCK(hi2c);
   \   00000034   0xF994 0x003C      LDRSB    R0,[R4, #+60]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xF000 0x8141      BEQ.W    ??HAL_I2C_Master_Receive_0
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF884 0x003C      STRB     R0,[R4, #+60]
    726          
    727              /* Check if the I2C is already enabled */
    728              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x07C9             LSLS     R1,R1,#+31
   \   0000004A   0xD403             BMI.N    ??HAL_I2C_Master_Receive_1
    729              {
    730                /* Enable I2C peripheral */
    731                __HAL_I2C_ENABLE(hi2c);
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000052   0x6001             STR      R1,[R0, #+0]
    732              }
    733          
    734              /* Disable Pos */
    735              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Master_Receive_1: (+1)
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6801             LDR      R1,[R0, #+0]
   \   00000058   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000005C   0x6001             STR      R1,[R0, #+0]
    736          
    737              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \   0000005E   0x2022             MOVS     R0,#+34
   \   00000060   0xF884 0x003D      STRB     R0,[R4, #+61]
    738              hi2c->Mode        = HAL_I2C_MODE_MASTER;
   \   00000064   0x2010             MOVS     R0,#+16
   \   00000066   0xF884 0x003E      STRB     R0,[R4, #+62]
    739              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x6420             STR      R0,[R4, #+64]
    740          
    741              /* Prepare transfer parameters */
    742              hi2c->pBuffPtr    = pData;
   \   0000006E   0x6265             STR      R5,[R4, #+36]
    743              hi2c->XferCount   = Size;
   \   00000070   0xF8A4 0x802A      STRH     R8,[R4, #+42]
    744              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0xffff0000
   \   00000078   0x62E0             STR      R0,[R4, #+44]
    745              hi2c->XferSize    = hi2c->XferCount;
   \   0000007A   0x8D60             LDRH     R0,[R4, #+42]
   \   0000007C   0x8520             STRH     R0,[R4, #+40]
   \   0000007E   0x9D08             LDR      R5,[SP, #+32]
    746          
    747              /* Send Slave Address */
    748              if(I2C_MasterRequestRead(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
   \   00000080   0x4633             MOV      R3,R6
   \   00000082   0x462A             MOV      R2,R5
   \   00000084   0x4639             MOV      R1,R7
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       I2C_MasterRequestRead
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD00C             BEQ.N    ??HAL_I2C_Master_Receive_2
    749              {
    750                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000090   0x6C20             LDR      R0,[R4, #+64]
   \   00000092   0x2804             CMP      R0,#+4
   \   00000094   0xD104             BNE.N    ??HAL_I2C_Master_Receive_3
    751                {
    752                  /* Process Unlocked */
    753                  __HAL_UNLOCK(hi2c);
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xF884 0x003C      STRB     R0,[R4, #+60]
    754                  return HAL_ERROR;
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xE110             B.N      ??HAL_I2C_Master_Receive_4
    755                }
    756                else
    757                {
    758                  /* Process Unlocked */
    759                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_3: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xF884 0x003C      STRB     R0,[R4, #+60]
    760                  return HAL_TIMEOUT;
   \   000000A6   0x2003             MOVS     R0,#+3
   \   000000A8   0xE10B             B.N      ??HAL_I2C_Master_Receive_4
    761                }
    762              }
    763          
    764              if(hi2c->XferSize == 0U)
   \                     ??HAL_I2C_Master_Receive_2: (+1)
   \   000000AA   0x8D21             LDRH     R1,[R4, #+40]
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x2900             CMP      R1,#+0
   \   000000B0   0xD10B             BNE.N    ??HAL_I2C_Master_Receive_5
    765              {
    766                /* Clear ADDR flag */
    767                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000B2   0x2100             MOVS     R1,#+0
   \   000000B4   0x9100             STR      R1,[SP, #+0]
   \   000000B6   0x6941             LDR      R1,[R0, #+20]
   \   000000B8   0x9100             STR      R1,[SP, #+0]
   \   000000BA   0x6981             LDR      R1,[R0, #+24]
   \   000000BC   0x9100             STR      R1,[SP, #+0]
   \   000000BE   0x9900             LDR      R1,[SP, #+0]
    768          
    769                /* Generate Stop */
    770                hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   000000C0   0x6801             LDR      R1,[R0, #+0]
   \   000000C2   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000C6   0x6001             STR      R1,[R0, #+0]
   \   000000C8   0xE03E             B.N      ??HAL_I2C_Master_Receive_6
    771              }
    772              else if(hi2c->XferSize == 1U)
   \                     ??HAL_I2C_Master_Receive_5: (+1)
   \   000000CA   0x2901             CMP      R1,#+1
   \   000000CC   0xD110             BNE.N    ??HAL_I2C_Master_Receive_7
    773              {
    774                /* Disable Acknowledge */
    775                hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   000000CE   0x6801             LDR      R1,[R0, #+0]
   \   000000D0   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000D4   0x6001             STR      R1,[R0, #+0]
    776          
    777                /* Clear ADDR flag */
    778                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x9000             STR      R0,[SP, #+0]
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x6941             LDR      R1,[R0, #+20]
   \   000000DE   0x9100             STR      R1,[SP, #+0]
   \   000000E0   0x6981             LDR      R1,[R0, #+24]
   \   000000E2   0x9100             STR      R1,[SP, #+0]
   \   000000E4   0x9900             LDR      R1,[SP, #+0]
    779          
    780                /* Generate Stop */
    781                hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   000000E6   0x6801             LDR      R1,[R0, #+0]
   \   000000E8   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000EC   0x6001             STR      R1,[R0, #+0]
   \   000000EE   0xE02B             B.N      ??HAL_I2C_Master_Receive_6
    782              }
    783              else if(hi2c->XferSize == 2U)
   \                     ??HAL_I2C_Master_Receive_7: (+1)
   \   000000F0   0x2902             CMP      R1,#+2
   \   000000F2   0x6801             LDR      R1,[R0, #+0]
   \   000000F4   0xD110             BNE.N    ??HAL_I2C_Master_Receive_8
    784              {
    785                /* Disable Acknowledge */
    786                hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   000000F6   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000FA   0x6001             STR      R1,[R0, #+0]
    787          
    788                /* Enable Pos */
    789                hi2c->Instance->CR1 |= I2C_CR1_POS;
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x6801             LDR      R1,[R0, #+0]
   \   00000100   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000104   0x6001             STR      R1,[R0, #+0]
    790          
    791                /* Clear ADDR flag */
    792                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x9000             STR      R0,[SP, #+0]
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0x6941             LDR      R1,[R0, #+20]
   \   0000010E   0x9100             STR      R1,[SP, #+0]
   \   00000110   0x6980             LDR      R0,[R0, #+24]
   \   00000112   0x9000             STR      R0,[SP, #+0]
   \   00000114   0x9800             LDR      R0,[SP, #+0]
   \   00000116   0xE017             B.N      ??HAL_I2C_Master_Receive_6
    793              }
    794              else
    795              {
    796                /* Enable Acknowledge */
    797                hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \                     ??HAL_I2C_Master_Receive_8: (+1)
   \   00000118   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000011C   0x6001             STR      R1,[R0, #+0]
    798          
    799                /* Clear ADDR flag */
    800                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x9000             STR      R0,[SP, #+0]
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x6941             LDR      R1,[R0, #+20]
   \   00000126   0x9100             STR      R1,[SP, #+0]
   \   00000128   0x6980             LDR      R0,[R0, #+24]
   \   0000012A   0x9000             STR      R0,[SP, #+0]
   \   0000012C   0x9800             LDR      R0,[SP, #+0]
   \   0000012E   0xE00B             B.N      ??HAL_I2C_Master_Receive_6
    801              }
    802          
    803              while(hi2c->XferSize > 0U)
    804              {
    805                if(hi2c->XferSize <= 3U)
    806                {
    807                  /* One byte */
    808                  if(hi2c->XferSize == 1U)
    809                  {
    810                    /* Wait until RXNE flag is set */
    811                    if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)      
    812                    {
    813                      if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
    814                      {
    815                        return HAL_TIMEOUT;
    816                      }
    817                      else
    818                      {
    819                        return HAL_ERROR;
    820                      }
    821                    }
    822          
    823                    /* Read data from DR */
    824                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Master_Receive_9: (+1)
   \   00000130   0x6A60             LDR      R0,[R4, #+36]
   \   00000132   0x1C41             ADDS     R1,R0,#+1
   \   00000134   0x6261             STR      R1,[R4, #+36]
   \   00000136   0x6821             LDR      R1,[R4, #+0]
   \   00000138   0x6909             LDR      R1,[R1, #+16]
   \   0000013A   0x7001             STRB     R1,[R0, #+0]
    825                    hi2c->XferSize--;
   \   0000013C   0x8D20             LDRH     R0,[R4, #+40]
   \   0000013E   0x1E40             SUBS     R0,R0,#+1
   \   00000140   0x8520             STRH     R0,[R4, #+40]
    826                    hi2c->XferCount--;
   \   00000142   0x8D60             LDRH     R0,[R4, #+42]
   \   00000144   0x1E40             SUBS     R0,R0,#+1
   \   00000146   0x8560             STRH     R0,[R4, #+42]
   \                     ??HAL_I2C_Master_Receive_6: (+1)
   \   00000148   0x8D20             LDRH     R0,[R4, #+40]
   \   0000014A   0x2800             CMP      R0,#+0
   \   0000014C   0xF000 0x80AF      BEQ.W    ??HAL_I2C_Master_Receive_10
   \   00000150   0x2804             CMP      R0,#+4
   \   00000152   0xF080 0x8080      BCS.W    ??HAL_I2C_Master_Receive_11
   \   00000156   0x2801             CMP      R0,#+1
   \   00000158   0xD10D             BNE.N    ??HAL_I2C_Master_Receive_12
   \   0000015A   0x4632             MOV      R2,R6
   \   0000015C   0x4629             MOV      R1,R5
   \   0000015E   0x4620             MOV      R0,R4
   \   00000160   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD0E3             BEQ.N    ??HAL_I2C_Master_Receive_9
   \   00000168   0x6C20             LDR      R0,[R4, #+64]
   \   0000016A   0x2820             CMP      R0,#+32
   \   0000016C   0xD101             BNE.N    ??HAL_I2C_Master_Receive_13
   \   0000016E   0x2003             MOVS     R0,#+3
   \   00000170   0xE0A7             B.N      ??HAL_I2C_Master_Receive_4
   \                     ??HAL_I2C_Master_Receive_13: (+1)
   \   00000172   0x2001             MOVS     R0,#+1
   \   00000174   0xE0A5             B.N      ??HAL_I2C_Master_Receive_4
    827                  }
    828                  /* Two bytes */
    829                  else if(hi2c->XferSize == 2U)
   \                     ??HAL_I2C_Master_Receive_12: (+1)
   \   00000176   0x.... 0x....      LDR.W    R7,??DataTable12  ;; 0x10004
   \   0000017A   0x2802             CMP      R0,#+2
   \   0000017C   0x9600             STR      R6,[SP, #+0]
   \   0000017E   0x462B             MOV      R3,R5
   \   00000180   0xD126             BNE.N    ??HAL_I2C_Master_Receive_14
    830                  {
    831                    /* Wait until BTF flag is set */
    832                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \   00000182   0x2200             MOVS     R2,#+0
   \   00000184   0x4639             MOV      R1,R7
   \   00000186   0x4620             MOV      R0,R4
   \   00000188   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_15
    833                    {
    834                      return HAL_TIMEOUT;
   \   00000190   0x2003             MOVS     R0,#+3
   \   00000192   0xE096             B.N      ??HAL_I2C_Master_Receive_4
    835                    }
    836          
    837                    /* Generate Stop */
    838                    hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \                     ??HAL_I2C_Master_Receive_15: (+1)
   \   00000194   0x6820             LDR      R0,[R4, #+0]
   \   00000196   0x6801             LDR      R1,[R0, #+0]
   \   00000198   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000019C   0x6001             STR      R1,[R0, #+0]
    839          
    840                    /* Read data from DR */
    841                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   0000019E   0x6A60             LDR      R0,[R4, #+36]
   \   000001A0   0x1C41             ADDS     R1,R0,#+1
   \   000001A2   0x6261             STR      R1,[R4, #+36]
   \   000001A4   0x6821             LDR      R1,[R4, #+0]
   \   000001A6   0x6909             LDR      R1,[R1, #+16]
   \   000001A8   0x7001             STRB     R1,[R0, #+0]
    842                    hi2c->XferSize--;
   \   000001AA   0x8D20             LDRH     R0,[R4, #+40]
   \   000001AC   0x1E40             SUBS     R0,R0,#+1
   \   000001AE   0x8520             STRH     R0,[R4, #+40]
    843                    hi2c->XferCount--;
   \   000001B0   0x8D60             LDRH     R0,[R4, #+42]
   \   000001B2   0x1E40             SUBS     R0,R0,#+1
   \   000001B4   0x8560             STRH     R0,[R4, #+42]
    844          
    845                    /* Read data from DR */
    846                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   000001B6   0x6A60             LDR      R0,[R4, #+36]
   \   000001B8   0x1C41             ADDS     R1,R0,#+1
   \   000001BA   0x6261             STR      R1,[R4, #+36]
   \   000001BC   0x6821             LDR      R1,[R4, #+0]
   \   000001BE   0x6909             LDR      R1,[R1, #+16]
   \   000001C0   0x7001             STRB     R1,[R0, #+0]
    847                    hi2c->XferSize--;
   \   000001C2   0x8D20             LDRH     R0,[R4, #+40]
   \   000001C4   0x1E40             SUBS     R0,R0,#+1
   \   000001C6   0x8520             STRH     R0,[R4, #+40]
    848                    hi2c->XferCount--;
   \   000001C8   0x8D60             LDRH     R0,[R4, #+42]
   \   000001CA   0x1E40             SUBS     R0,R0,#+1
   \   000001CC   0x8560             STRH     R0,[R4, #+42]
   \   000001CE   0xE7BB             B.N      ??HAL_I2C_Master_Receive_6
    849                  }
    850                  /* 3 Last bytes */
    851                  else
    852                  {
    853                    /* Wait until BTF flag is set */
    854                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Master_Receive_14: (+1)
   \   000001D0   0x2200             MOVS     R2,#+0
   \   000001D2   0x4639             MOV      R1,R7
   \   000001D4   0x4620             MOV      R0,R4
   \   000001D6   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000001DA   0x2800             CMP      R0,#+0
   \   000001DC   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_16
    855                    {
    856                      return HAL_TIMEOUT;
   \   000001DE   0x2003             MOVS     R0,#+3
   \   000001E0   0xE06F             B.N      ??HAL_I2C_Master_Receive_4
    857                    }
    858          
    859                    /* Disable Acknowledge */
    860                    hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \                     ??HAL_I2C_Master_Receive_16: (+1)
   \   000001E2   0x6820             LDR      R0,[R4, #+0]
   \   000001E4   0x6801             LDR      R1,[R0, #+0]
   \   000001E6   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000001EA   0x6001             STR      R1,[R0, #+0]
    861          
    862                    /* Read data from DR */
    863                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   000001EC   0x6A60             LDR      R0,[R4, #+36]
   \   000001EE   0x1C41             ADDS     R1,R0,#+1
   \   000001F0   0x6261             STR      R1,[R4, #+36]
   \   000001F2   0x6821             LDR      R1,[R4, #+0]
   \   000001F4   0x6909             LDR      R1,[R1, #+16]
   \   000001F6   0x7001             STRB     R1,[R0, #+0]
    864                    hi2c->XferSize--;
   \   000001F8   0x8D20             LDRH     R0,[R4, #+40]
   \   000001FA   0x1E40             SUBS     R0,R0,#+1
   \   000001FC   0x8520             STRH     R0,[R4, #+40]
    865                    hi2c->XferCount--;
   \   000001FE   0x8D60             LDRH     R0,[R4, #+42]
   \   00000200   0x1E40             SUBS     R0,R0,#+1
   \   00000202   0x8560             STRH     R0,[R4, #+42]
    866          
    867                    /* Wait until BTF flag is set */
    868                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \   00000204   0x9600             STR      R6,[SP, #+0]
   \   00000206   0x462B             MOV      R3,R5
   \   00000208   0x2200             MOVS     R2,#+0
   \   0000020A   0x4639             MOV      R1,R7
   \   0000020C   0x4620             MOV      R0,R4
   \   0000020E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000212   0x2800             CMP      R0,#+0
   \   00000214   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_17
    869                    {
    870                      return HAL_TIMEOUT;
   \   00000216   0x2003             MOVS     R0,#+3
   \   00000218   0xE053             B.N      ??HAL_I2C_Master_Receive_4
    871                    }
    872          
    873                    /* Generate Stop */
    874                    hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \                     ??HAL_I2C_Master_Receive_17: (+1)
   \   0000021A   0x6820             LDR      R0,[R4, #+0]
   \   0000021C   0x6801             LDR      R1,[R0, #+0]
   \   0000021E   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000222   0x6001             STR      R1,[R0, #+0]
    875          
    876                    /* Read data from DR */
    877                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000224   0x6A60             LDR      R0,[R4, #+36]
   \   00000226   0x1C41             ADDS     R1,R0,#+1
   \   00000228   0x6261             STR      R1,[R4, #+36]
   \   0000022A   0x6821             LDR      R1,[R4, #+0]
   \   0000022C   0x6909             LDR      R1,[R1, #+16]
   \   0000022E   0x7001             STRB     R1,[R0, #+0]
    878                    hi2c->XferSize--;
   \   00000230   0x8D20             LDRH     R0,[R4, #+40]
   \   00000232   0x1E40             SUBS     R0,R0,#+1
   \   00000234   0x8520             STRH     R0,[R4, #+40]
    879                    hi2c->XferCount--;
   \   00000236   0x8D60             LDRH     R0,[R4, #+42]
   \   00000238   0x1E40             SUBS     R0,R0,#+1
   \   0000023A   0x8560             STRH     R0,[R4, #+42]
    880          
    881                    /* Read data from DR */
    882                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   0000023C   0x6A60             LDR      R0,[R4, #+36]
   \   0000023E   0x1C41             ADDS     R1,R0,#+1
   \   00000240   0x6261             STR      R1,[R4, #+36]
   \   00000242   0x6821             LDR      R1,[R4, #+0]
   \   00000244   0x6909             LDR      R1,[R1, #+16]
   \   00000246   0x7001             STRB     R1,[R0, #+0]
    883                    hi2c->XferSize--;
   \   00000248   0x8D20             LDRH     R0,[R4, #+40]
   \   0000024A   0x1E40             SUBS     R0,R0,#+1
   \   0000024C   0x8520             STRH     R0,[R4, #+40]
    884                    hi2c->XferCount--;
   \   0000024E   0x8D60             LDRH     R0,[R4, #+42]
   \   00000250   0x1E40             SUBS     R0,R0,#+1
   \   00000252   0x8560             STRH     R0,[R4, #+42]
   \   00000254   0xE778             B.N      ??HAL_I2C_Master_Receive_6
    885                  }
    886                }
    887                else
    888                {
    889                  /* Wait until RXNE flag is set */
    890                  if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)      
   \                     ??HAL_I2C_Master_Receive_11: (+1)
   \   00000256   0x4632             MOV      R2,R6
   \   00000258   0x4629             MOV      R1,R5
   \   0000025A   0x4620             MOV      R0,R4
   \   0000025C   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   00000260   0x2800             CMP      R0,#+0
   \   00000262   0xD006             BEQ.N    ??HAL_I2C_Master_Receive_18
    891                  {
    892                    if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   \   00000264   0x6C20             LDR      R0,[R4, #+64]
   \   00000266   0x2820             CMP      R0,#+32
   \   00000268   0xD101             BNE.N    ??HAL_I2C_Master_Receive_19
    893                    {
    894                      return HAL_TIMEOUT;
   \   0000026A   0x2003             MOVS     R0,#+3
   \   0000026C   0xE029             B.N      ??HAL_I2C_Master_Receive_4
    895                    }
    896                    else
    897                    {
    898                      return HAL_ERROR;
   \                     ??HAL_I2C_Master_Receive_19: (+1)
   \   0000026E   0x2001             MOVS     R0,#+1
   \   00000270   0xE027             B.N      ??HAL_I2C_Master_Receive_4
    899                    }
    900                  }
    901          
    902                  /* Read data from DR */
    903                  (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Master_Receive_18: (+1)
   \   00000272   0x6A60             LDR      R0,[R4, #+36]
   \   00000274   0x1C41             ADDS     R1,R0,#+1
   \   00000276   0x6261             STR      R1,[R4, #+36]
   \   00000278   0x6821             LDR      R1,[R4, #+0]
   \   0000027A   0x6909             LDR      R1,[R1, #+16]
   \   0000027C   0x7001             STRB     R1,[R0, #+0]
    904                  hi2c->XferSize--;
   \   0000027E   0x8D20             LDRH     R0,[R4, #+40]
   \   00000280   0x1E40             SUBS     R0,R0,#+1
   \   00000282   0x8520             STRH     R0,[R4, #+40]
    905                  hi2c->XferCount--;
   \   00000284   0x8D60             LDRH     R0,[R4, #+42]
   \   00000286   0x1E40             SUBS     R0,R0,#+1
   \   00000288   0x8560             STRH     R0,[R4, #+42]
    906          
    907                  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
   \   0000028A   0x6820             LDR      R0,[R4, #+0]
   \   0000028C   0x6940             LDR      R0,[R0, #+20]
   \   0000028E   0x0740             LSLS     R0,R0,#+29
   \   00000290   0xF57F 0xAF5A      BPL.W    ??HAL_I2C_Master_Receive_6
    908                  {
    909                    /* Read data from DR */
    910                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000294   0x6A60             LDR      R0,[R4, #+36]
   \   00000296   0x1C41             ADDS     R1,R0,#+1
   \   00000298   0x6261             STR      R1,[R4, #+36]
   \   0000029A   0x6821             LDR      R1,[R4, #+0]
   \   0000029C   0x6909             LDR      R1,[R1, #+16]
   \   0000029E   0x7001             STRB     R1,[R0, #+0]
    911                    hi2c->XferSize--;
   \   000002A0   0x8D20             LDRH     R0,[R4, #+40]
   \   000002A2   0x1E40             SUBS     R0,R0,#+1
   \   000002A4   0x8520             STRH     R0,[R4, #+40]
    912                    hi2c->XferCount--;
   \   000002A6   0x8D60             LDRH     R0,[R4, #+42]
   \   000002A8   0x1E40             SUBS     R0,R0,#+1
   \   000002AA   0x8560             STRH     R0,[R4, #+42]
   \   000002AC   0xE74C             B.N      ??HAL_I2C_Master_Receive_6
    913                  }
    914                }
    915              }
    916          
    917              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Receive_10: (+1)
   \   000002AE   0x2020             MOVS     R0,#+32
   \   000002B0   0xF884 0x003D      STRB     R0,[R4, #+61]
    918              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   000002B4   0x2000             MOVS     R0,#+0
   \   000002B6   0xF884 0x003E      STRB     R0,[R4, #+62]
    919          
    920              /* Process Unlocked */
    921              __HAL_UNLOCK(hi2c);
   \   000002BA   0xF884 0x003C      STRB     R0,[R4, #+60]
    922          
    923              return HAL_OK;
   \   000002BE   0xE000             B.N      ??HAL_I2C_Master_Receive_4
    924            }
    925            else
    926            {
    927              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_0: (+1)
   \   000002C0   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_4: (+1)
   \   000002C2   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    928            }
    929          }
    930          
    931          /**
    932            * @brief  Transmits in slave mode an amount of data in blocking mode. 
    933            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    934            *                the configuration information for the specified I2C.
    935            * @param  pData Pointer to data buffer
    936            * @param  Size Amount of data to be sent
    937            * @param  Timeout Timeout duration
    938            * @retval HAL status
    939            */

   \                                 In section .text, align 2, keep-with-next
    940          HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    941          {
   \                     HAL_I2C_Slave_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
    942            uint32_t tickstart = 0x00U;
    943            
    944            /* Init tickstart for timeout management*/
    945            tickstart = HAL_GetTick();
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x4607             MOV      R7,R0
    946            
    947            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000014   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000018   0x2820             CMP      R0,#+32
   \   0000001A   0xF040 0x80B0      BNE.W    ??HAL_I2C_Slave_Transmit_0
    948            {
    949              if((pData == NULL) || (Size == 0U))
   \   0000001E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000022   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_1
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_2
    950              {
    951                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Transmit_1: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE0A9             B.N      ??HAL_I2C_Slave_Transmit_3
    952              }
    953          
    954              /* Process Locked */
    955              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_2: (+1)
   \   0000002C   0xF994 0x003C      LDRSB    R0,[R4, #+60]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xF000 0x80A4      BEQ.W    ??HAL_I2C_Slave_Transmit_0
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF884 0x003C      STRB     R0,[R4, #+60]
    956              
    957              /* Check if the I2C is already enabled */
    958              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0x07C9             LSLS     R1,R1,#+31
   \   00000042   0xD403             BMI.N    ??HAL_I2C_Slave_Transmit_4
    959              {
    960                /* Enable I2C peripheral */
    961                __HAL_I2C_ENABLE(hi2c);
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000004A   0x6001             STR      R1,[R0, #+0]
    962              }
    963          
    964              /* Disable Pos */
    965              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Slave_Transmit_4: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000054   0x6001             STR      R1,[R0, #+0]
    966          
    967              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \   00000056   0x2021             MOVS     R0,#+33
   \   00000058   0xF884 0x003D      STRB     R0,[R4, #+61]
    968              hi2c->Mode        = HAL_I2C_MODE_SLAVE;
   \   0000005C   0x2020             MOVS     R0,#+32
   \   0000005E   0xF884 0x003E      STRB     R0,[R4, #+62]
    969              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x6420             STR      R0,[R4, #+64]
    970          
    971              /* Prepare transfer parameters */
    972              hi2c->pBuffPtr    = pData;
   \   00000066   0xF8C4 0x8024      STR      R8,[R4, #+36]
    973              hi2c->XferCount   = Size;
   \   0000006A   0x8565             STRH     R5,[R4, #+42]
    974              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0xffff0000
   \   00000070   0x62E0             STR      R0,[R4, #+44]
    975              hi2c->XferSize    = hi2c->XferCount;
   \   00000072   0x8D60             LDRH     R0,[R4, #+42]
   \   00000074   0x8520             STRH     R0,[R4, #+40]
    976          
    977              /* Enable Address Acknowledge */
    978              hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6801             LDR      R1,[R0, #+0]
   \   0000007A   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000007E   0x6001             STR      R1,[R0, #+0]
    979          
    980              /* Wait until ADDR flag is set */
    981              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \   00000080   0x.... 0x....      LDR.W    R8,??DataTable14  ;; 0x10002
   \   00000084   0x9700             STR      R7,[SP, #+0]
   \   00000086   0x4633             MOV      R3,R6
   \   00000088   0x2200             MOVS     R2,#+0
   \   0000008A   0x4641             MOV      R1,R8
   \   0000008C   0x4620             MOV      R0,R4
   \   0000008E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_5
    982              {
    983                return HAL_TIMEOUT;
   \   00000096   0x2003             MOVS     R0,#+3
   \   00000098   0xE072             B.N      ??HAL_I2C_Slave_Transmit_3
    984              }
    985          
    986              /* Clear ADDR flag */
    987              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_5: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6941             LDR      R1,[R0, #+20]
   \   000000A2   0x9100             STR      R1,[SP, #+0]
   \   000000A4   0x6980             LDR      R0,[R0, #+24]
   \   000000A6   0x9000             STR      R0,[SP, #+0]
   \   000000A8   0x9800             LDR      R0,[SP, #+0]
    988          
    989              /* If 10bit addressing mode is selected */
    990              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \   000000AA   0x6920             LDR      R0,[R4, #+16]
   \   000000AC   0xF5B0 0x4F40      CMP      R0,#+49152
   \   000000B0   0xD131             BNE.N    ??HAL_I2C_Slave_Transmit_6
    991              {
    992                /* Wait until ADDR flag is set */
    993                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \   000000B2   0x9700             STR      R7,[SP, #+0]
   \   000000B4   0x4633             MOV      R3,R6
   \   000000B6   0x2200             MOVS     R2,#+0
   \   000000B8   0x4641             MOV      R1,R8
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_7
    994                {
    995                  return HAL_TIMEOUT;
   \   000000C4   0x2003             MOVS     R0,#+3
   \   000000C6   0xE05B             B.N      ??HAL_I2C_Slave_Transmit_3
    996                }
    997          
    998                /* Clear ADDR flag */
    999                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_7: (+1)
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x9000             STR      R0,[SP, #+0]
   \   000000CC   0x6820             LDR      R0,[R4, #+0]
   \   000000CE   0x6941             LDR      R1,[R0, #+20]
   \   000000D0   0x9100             STR      R1,[SP, #+0]
   \   000000D2   0x6980             LDR      R0,[R0, #+24]
   \   000000D4   0x9000             STR      R0,[SP, #+0]
   \   000000D6   0x9800             LDR      R0,[SP, #+0]
   \   000000D8   0xE01D             B.N      ??HAL_I2C_Slave_Transmit_6
   1000              }
   1001          
   1002              while(hi2c->XferSize > 0U)
   1003              {
   1004                /* Wait until TXE flag is set */
   1005                if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1006                {
   1007                  /* Disable Address Acknowledge */
   1008                  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   1009          
   1010                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   1011                  {
   1012                    return HAL_ERROR;
   1013                  }
   1014                  else
   1015                  {
   1016                    return HAL_TIMEOUT;
   1017                  }
   1018                }
   1019          
   1020                /* Write data to DR */
   1021                hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \                     ??HAL_I2C_Slave_Transmit_8: (+1)
   \   000000DA   0x6A60             LDR      R0,[R4, #+36]
   \   000000DC   0x1C41             ADDS     R1,R0,#+1
   \   000000DE   0x6261             STR      R1,[R4, #+36]
   \   000000E0   0x7800             LDRB     R0,[R0, #+0]
   \   000000E2   0x6821             LDR      R1,[R4, #+0]
   \   000000E4   0x6108             STR      R0,[R1, #+16]
   1022                hi2c->XferCount--;
   \   000000E6   0x8D60             LDRH     R0,[R4, #+42]
   \   000000E8   0x1E40             SUBS     R0,R0,#+1
   \   000000EA   0x8560             STRH     R0,[R4, #+42]
   1023                hi2c->XferSize--;
   \   000000EC   0x8D20             LDRH     R0,[R4, #+40]
   \   000000EE   0x1E40             SUBS     R0,R0,#+1
   \   000000F0   0x8520             STRH     R0,[R4, #+40]
   1024          
   1025                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0U))
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x6940             LDR      R0,[R0, #+20]
   \   000000F6   0x0740             LSLS     R0,R0,#+29
   \   000000F8   0xD50D             BPL.N    ??HAL_I2C_Slave_Transmit_6
   \   000000FA   0x2D00             CMP      R5,#+0
   \   000000FC   0xD00B             BEQ.N    ??HAL_I2C_Slave_Transmit_6
   1026                {
   1027                  /* Write data to DR */
   1028                  hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \   000000FE   0x6A60             LDR      R0,[R4, #+36]
   \   00000100   0x1C41             ADDS     R1,R0,#+1
   \   00000102   0x6261             STR      R1,[R4, #+36]
   \   00000104   0x7800             LDRB     R0,[R0, #+0]
   \   00000106   0x6821             LDR      R1,[R4, #+0]
   \   00000108   0x6108             STR      R0,[R1, #+16]
   1029                  hi2c->XferCount--;
   \   0000010A   0x8D60             LDRH     R0,[R4, #+42]
   \   0000010C   0x1E40             SUBS     R0,R0,#+1
   \   0000010E   0x8560             STRH     R0,[R4, #+42]
   1030                  hi2c->XferSize--;
   \   00000110   0x8D20             LDRH     R0,[R4, #+40]
   \   00000112   0x1E40             SUBS     R0,R0,#+1
   \   00000114   0x8520             STRH     R0,[R4, #+40]
   1031                }
   \                     ??HAL_I2C_Slave_Transmit_6: (+1)
   \   00000116   0x8D20             LDRH     R0,[R4, #+40]
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD012             BEQ.N    ??HAL_I2C_Slave_Transmit_9
   \   0000011C   0x463A             MOV      R2,R7
   \   0000011E   0x4631             MOV      R1,R6
   \   00000120   0x4620             MOV      R0,R4
   \   00000122   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   00000126   0x2800             CMP      R0,#+0
   \   00000128   0xD0D7             BEQ.N    ??HAL_I2C_Slave_Transmit_8
   \   0000012A   0x6820             LDR      R0,[R4, #+0]
   \   0000012C   0x6801             LDR      R1,[R0, #+0]
   \   0000012E   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000132   0x6001             STR      R1,[R0, #+0]
   \   00000134   0x6C20             LDR      R0,[R4, #+64]
   \   00000136   0x2804             CMP      R0,#+4
   \   00000138   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_10
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0xE020             B.N      ??HAL_I2C_Slave_Transmit_3
   \                     ??HAL_I2C_Slave_Transmit_10: (+1)
   \   0000013E   0x2003             MOVS     R0,#+3
   \   00000140   0xE01E             B.N      ??HAL_I2C_Slave_Transmit_3
   1032              }
   1033          
   1034              /* Wait until AF flag is set */
   1035              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Slave_Transmit_9: (+1)
   \   00000142   0x9700             STR      R7,[SP, #+0]
   \   00000144   0x4633             MOV      R3,R6
   \   00000146   0x2200             MOVS     R2,#+0
   \   00000148   0xF44F 0x3182      MOV      R1,#+66560
   \   0000014C   0x4620             MOV      R0,R4
   \   0000014E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_11
   1036              {
   1037                return HAL_TIMEOUT;
   \   00000156   0x2003             MOVS     R0,#+3
   \   00000158   0xE012             B.N      ??HAL_I2C_Slave_Transmit_3
   1038              }
   1039          
   1040              /* Clear AF flag */
   1041              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??HAL_I2C_Slave_Transmit_11: (+1)
   \   0000015A   0xF46F 0x6080      MVN      R0,#+1024
   \   0000015E   0x6821             LDR      R1,[R4, #+0]
   \   00000160   0x6148             STR      R0,[R1, #+20]
   1042          
   1043              /* Disable Address Acknowledge */
   1044              hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   00000162   0x6820             LDR      R0,[R4, #+0]
   \   00000164   0x6801             LDR      R1,[R0, #+0]
   \   00000166   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000016A   0x6001             STR      R1,[R0, #+0]
   1045          
   1046              hi2c->State = HAL_I2C_STATE_READY;
   \   0000016C   0x2020             MOVS     R0,#+32
   \   0000016E   0xF884 0x003D      STRB     R0,[R4, #+61]
   1047              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0xF884 0x003E      STRB     R0,[R4, #+62]
   1048          
   1049              /* Process Unlocked */
   1050              __HAL_UNLOCK(hi2c);
   \   00000178   0xF884 0x003C      STRB     R0,[R4, #+60]
   1051          
   1052              return HAL_OK;
   \   0000017C   0xE000             B.N      ??HAL_I2C_Slave_Transmit_3
   1053            }
   1054            else
   1055            {
   1056              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_0: (+1)
   \   0000017E   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_3: (+1)
   \   00000180   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1057            }
   1058          }
   1059          
   1060          /**
   1061            * @brief  Receive in slave mode an amount of data in blocking mode 
   1062            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1063            *         the configuration information for the specified I2C.
   1064            * @param  pData Pointer to data buffer
   1065            * @param  Size Amount of data to be sent
   1066            * @param  Timeout Timeout duration
   1067            * @retval HAL status
   1068            */

   \                                 In section .text, align 2, keep-with-next
   1069          HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1070          {
   \                     HAL_I2C_Slave_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x4617             MOV      R7,R2
   \   0000000C   0x461D             MOV      R5,R3
   1071            uint32_t tickstart = 0x00U;
   1072          
   1073            /* Init tickstart for timeout management*/
   1074            tickstart = HAL_GetTick();
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x4606             MOV      R6,R0
   1075          
   1076            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000014   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000018   0x2820             CMP      R0,#+32
   \   0000001A   0xF040 0x80A4      BNE.W    ??HAL_I2C_Slave_Receive_0
   1077            {
   1078              if((pData == NULL) || (Size == 0U))
   \   0000001E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000022   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_1
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_2
   1079              {
   1080                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_1: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE09D             B.N      ??HAL_I2C_Slave_Receive_3
   1081              }
   1082          
   1083              /* Process Locked */
   1084              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_2: (+1)
   \   0000002C   0xF994 0x003C      LDRSB    R0,[R4, #+60]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xF000 0x8098      BEQ.W    ??HAL_I2C_Slave_Receive_0
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF884 0x003C      STRB     R0,[R4, #+60]
   1085          
   1086              /* Check if the I2C is already enabled */
   1087              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0x07C9             LSLS     R1,R1,#+31
   \   00000042   0xD403             BMI.N    ??HAL_I2C_Slave_Receive_4
   1088              {
   1089                /* Enable I2C peripheral */
   1090                __HAL_I2C_ENABLE(hi2c);
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000004A   0x6001             STR      R1,[R0, #+0]
   1091              }
   1092          
   1093              /* Disable Pos */
   1094              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Slave_Receive_4: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000054   0x6001             STR      R1,[R0, #+0]
   1095          
   1096              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \   00000056   0x2022             MOVS     R0,#+34
   \   00000058   0xF884 0x003D      STRB     R0,[R4, #+61]
   1097              hi2c->Mode        = HAL_I2C_MODE_SLAVE;
   \   0000005C   0x2020             MOVS     R0,#+32
   \   0000005E   0xF884 0x003E      STRB     R0,[R4, #+62]
   1098              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x6420             STR      R0,[R4, #+64]
   1099          
   1100              /* Prepare transfer parameters */
   1101              hi2c->pBuffPtr    = pData;
   \   00000066   0xF8C4 0x8024      STR      R8,[R4, #+36]
   1102              hi2c->XferCount   = Size;
   \   0000006A   0x8567             STRH     R7,[R4, #+42]
   1103              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0xffff0000
   \   00000070   0x62E0             STR      R0,[R4, #+44]
   1104              hi2c->XferSize    = hi2c->XferCount;
   \   00000072   0x8D60             LDRH     R0,[R4, #+42]
   \   00000074   0x8520             STRH     R0,[R4, #+40]
   1105          
   1106              /* Enable Address Acknowledge */
   1107              hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6801             LDR      R1,[R0, #+0]
   \   0000007A   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000007E   0x6001             STR      R1,[R0, #+0]
   1108          
   1109              /* Wait until ADDR flag is set */
   1110              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \   00000080   0x9600             STR      R6,[SP, #+0]
   \   00000082   0x462B             MOV      R3,R5
   \   00000084   0x2200             MOVS     R2,#+0
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x10002
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_5
   1111              {
   1112                return HAL_TIMEOUT;
   \   00000094   0x2003             MOVS     R0,#+3
   \   00000096   0xE067             B.N      ??HAL_I2C_Slave_Receive_3
   1113              }
   1114          
   1115              /* Clear ADDR flag */
   1116              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Receive_5: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x9000             STR      R0,[SP, #+0]
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x6941             LDR      R1,[R0, #+20]
   \   000000A0   0x9100             STR      R1,[SP, #+0]
   \   000000A2   0x6980             LDR      R0,[R0, #+24]
   \   000000A4   0x9000             STR      R0,[SP, #+0]
   \   000000A6   0x9800             LDR      R0,[SP, #+0]
   \   000000A8   0xE01D             B.N      ??HAL_I2C_Slave_Receive_6
   1117          
   1118              while(hi2c->XferSize > 0U)
   1119              {
   1120                /* Wait until RXNE flag is set */
   1121                if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)      
   1122                {
   1123                  /* Disable Address Acknowledge */
   1124                  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   1125          
   1126                  if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   1127                  {
   1128                    return HAL_TIMEOUT;
   1129                  }
   1130                  else
   1131                  {
   1132                    return HAL_ERROR;
   1133                  }
   1134                }
   1135          
   1136                /* Read data from DR */
   1137                (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Slave_Receive_7: (+1)
   \   000000AA   0x6A60             LDR      R0,[R4, #+36]
   \   000000AC   0x1C41             ADDS     R1,R0,#+1
   \   000000AE   0x6261             STR      R1,[R4, #+36]
   \   000000B0   0x6821             LDR      R1,[R4, #+0]
   \   000000B2   0x6909             LDR      R1,[R1, #+16]
   \   000000B4   0x7001             STRB     R1,[R0, #+0]
   1138                hi2c->XferSize--;
   \   000000B6   0x8D20             LDRH     R0,[R4, #+40]
   \   000000B8   0x1E40             SUBS     R0,R0,#+1
   \   000000BA   0x8520             STRH     R0,[R4, #+40]
   1139                hi2c->XferCount--;
   \   000000BC   0x8D60             LDRH     R0,[R4, #+42]
   \   000000BE   0x1E40             SUBS     R0,R0,#+1
   \   000000C0   0x8560             STRH     R0,[R4, #+42]
   1140          
   1141                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0U))
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x6940             LDR      R0,[R0, #+20]
   \   000000C6   0x0740             LSLS     R0,R0,#+29
   \   000000C8   0xD50D             BPL.N    ??HAL_I2C_Slave_Receive_6
   \   000000CA   0x2F00             CMP      R7,#+0
   \   000000CC   0xD00B             BEQ.N    ??HAL_I2C_Slave_Receive_6
   1142                {
   1143                  /* Read data from DR */
   1144                (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   000000CE   0x6A60             LDR      R0,[R4, #+36]
   \   000000D0   0x1C41             ADDS     R1,R0,#+1
   \   000000D2   0x6261             STR      R1,[R4, #+36]
   \   000000D4   0x6821             LDR      R1,[R4, #+0]
   \   000000D6   0x6909             LDR      R1,[R1, #+16]
   \   000000D8   0x7001             STRB     R1,[R0, #+0]
   1145                hi2c->XferSize--;
   \   000000DA   0x8D20             LDRH     R0,[R4, #+40]
   \   000000DC   0x1E40             SUBS     R0,R0,#+1
   \   000000DE   0x8520             STRH     R0,[R4, #+40]
   1146                hi2c->XferCount--;
   \   000000E0   0x8D60             LDRH     R0,[R4, #+42]
   \   000000E2   0x1E40             SUBS     R0,R0,#+1
   \   000000E4   0x8560             STRH     R0,[R4, #+42]
   1147                }
   \                     ??HAL_I2C_Slave_Receive_6: (+1)
   \   000000E6   0x8D20             LDRH     R0,[R4, #+40]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD012             BEQ.N    ??HAL_I2C_Slave_Receive_8
   \   000000EC   0x4632             MOV      R2,R6
   \   000000EE   0x4629             MOV      R1,R5
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD0D7             BEQ.N    ??HAL_I2C_Slave_Receive_7
   \   000000FA   0x6820             LDR      R0,[R4, #+0]
   \   000000FC   0x6801             LDR      R1,[R0, #+0]
   \   000000FE   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000102   0x6001             STR      R1,[R0, #+0]
   \   00000104   0x6C20             LDR      R0,[R4, #+64]
   \   00000106   0x2820             CMP      R0,#+32
   \   00000108   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_9
   \   0000010A   0x2003             MOVS     R0,#+3
   \   0000010C   0xE02C             B.N      ??HAL_I2C_Slave_Receive_3
   \                     ??HAL_I2C_Slave_Receive_9: (+1)
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0xE02A             B.N      ??HAL_I2C_Slave_Receive_3
   1148              }
   1149          
   1150              /* Wait until STOP flag is set */
   1151              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Slave_Receive_8: (+1)
   \   00000112   0x6827             LDR      R7,[R4, #+0]
   \   00000114   0x4632             MOV      R2,R6
   \   00000116   0x4629             MOV      R1,R5
   \   00000118   0x4620             MOV      R0,R4
   \   0000011A   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD00A             BEQ.N    ??HAL_I2C_Slave_Receive_10
   1152              {
   1153                /* Disable Address Acknowledge */
   1154                hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   00000122   0x6838             LDR      R0,[R7, #+0]
   \   00000124   0xF420 0x6080      BIC      R0,R0,#0x400
   \   00000128   0x6038             STR      R0,[R7, #+0]
   1155          
   1156                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000012A   0x6C20             LDR      R0,[R4, #+64]
   \   0000012C   0x2804             CMP      R0,#+4
   \   0000012E   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_11
   1157                {
   1158                  return HAL_ERROR;
   \   00000130   0x2001             MOVS     R0,#+1
   \   00000132   0xE019             B.N      ??HAL_I2C_Slave_Receive_3
   1159                }
   1160                else
   1161                {
   1162                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Slave_Receive_11: (+1)
   \   00000134   0x2003             MOVS     R0,#+3
   \   00000136   0xE017             B.N      ??HAL_I2C_Slave_Receive_3
   1163                }
   1164              }
   1165          
   1166              /* Clear STOP flag */
   1167              __HAL_I2C_CLEAR_STOPFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Receive_10: (+1)
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x9000             STR      R0,[SP, #+0]
   \   0000013C   0x6978             LDR      R0,[R7, #+20]
   \   0000013E   0x9000             STR      R0,[SP, #+0]
   \   00000140   0x6838             LDR      R0,[R7, #+0]
   \   00000142   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000146   0x6038             STR      R0,[R7, #+0]
   \   00000148   0x9800             LDR      R0,[SP, #+0]
   1168          
   1169              /* Disable Address Acknowledge */
   1170              hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   0000014A   0x6820             LDR      R0,[R4, #+0]
   \   0000014C   0x6801             LDR      R1,[R0, #+0]
   \   0000014E   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000152   0x6001             STR      R1,[R0, #+0]
   1171          
   1172              hi2c->State = HAL_I2C_STATE_READY;
   \   00000154   0x2020             MOVS     R0,#+32
   \   00000156   0xF884 0x003D      STRB     R0,[R4, #+61]
   1173              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000015A   0x2000             MOVS     R0,#+0
   \   0000015C   0xF884 0x003E      STRB     R0,[R4, #+62]
   1174          
   1175              /* Process Unlocked */
   1176              __HAL_UNLOCK(hi2c);
   \   00000160   0xF884 0x003C      STRB     R0,[R4, #+60]
   1177          
   1178              return HAL_OK;
   \   00000164   0xE000             B.N      ??HAL_I2C_Slave_Receive_3
   1179            }
   1180            else
   1181            {
   1182              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_0: (+1)
   \   00000166   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_3: (+1)
   \   00000168   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1183            }
   1184          }
   1185          
   1186          /**
   1187            * @brief  Transmit in master mode an amount of data in non-blocking mode with Interrupt
   1188            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1189            *                the configuration information for the specified I2C.
   1190            * @param  DevAddress Target device address: The device 7 bits address value
   1191            *         in datasheet must be shift at right before call interface
   1192            * @param  pData Pointer to data buffer
   1193            * @param  Size Amount of data to be sent
   1194            * @retval HAL status
   1195            */

   \                                 In section .text, align 2, keep-with-next
   1196          HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1197          {
   \                     HAL_I2C_Master_Transmit_IT: (+1)
   \   00000000   0xB438             PUSH     {R3-R5}
   1198            __IO uint32_t count = 0U;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x9400             STR      R4,[SP, #+0]
   1199          
   1200            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF890 0x403D      LDRB     R4,[R0, #+61]
   \   0000000A   0x2C20             CMP      R4,#+32
   \   0000000C   0xD152             BNE.N    ??HAL_I2C_Master_Transmit_IT_0
   1201            {
   1202              /* Wait until BUSY flag is reset */
   1203              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable15
   \   00000012   0x6824             LDR      R4,[R4, #+0]
   \   00000014   0x2519             MOVS     R5,#+25
   \   00000016   0xFBB4 0xF4F5      UDIV     R4,R4,R5
   \   0000001A   0xF44F 0x757A      MOV      R5,#+1000
   \   0000001E   0xFBB4 0xF4F5      UDIV     R4,R4,R5
   \   00000022   0x2519             MOVS     R5,#+25
   \   00000024   0x436C             MULS     R4,R5,R4
   \   00000026   0x9400             STR      R4,[SP, #+0]
   1204              do
   1205              {
   1206                if(count-- == 0U)
   \                     ??HAL_I2C_Master_Transmit_IT_1: (+1)
   \   00000028   0x9C00             LDR      R4,[SP, #+0]
   \   0000002A   0x1E65             SUBS     R5,R4,#+1
   \   0000002C   0x9500             STR      R5,[SP, #+0]
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD109             BNE.N    ??HAL_I2C_Master_Transmit_IT_2
   1207                {
   1208                  hi2c->PreviousState = I2C_STATE_NONE;
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x6301             STR      R1,[R0, #+48]
   1209                  hi2c->State= HAL_I2C_STATE_READY;
   \   00000036   0x2120             MOVS     R1,#+32
   \   00000038   0xF880 0x103D      STRB     R1,[R0, #+61]
   1210          
   1211                  /* Process Unlocked */
   1212                  __HAL_UNLOCK(hi2c);
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0xF880 0x103C      STRB     R1,[R0, #+60]
   1213          
   1214                  return HAL_TIMEOUT;
   \   00000042   0x2003             MOVS     R0,#+3
   \   00000044   0xE037             B.N      ??HAL_I2C_Master_Transmit_IT_3
   1215                }
   1216              }
   1217              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Master_Transmit_IT_2: (+1)
   \   00000046   0x6804             LDR      R4,[R0, #+0]
   \   00000048   0x69A4             LDR      R4,[R4, #+24]
   \   0000004A   0x07A4             LSLS     R4,R4,#+30
   \   0000004C   0xD4EC             BMI.N    ??HAL_I2C_Master_Transmit_IT_1
   1218          
   1219              /* Process Locked */
   1220              __HAL_LOCK(hi2c);
   \   0000004E   0xF990 0x403C      LDRSB    R4,[R0, #+60]
   \   00000052   0x2C01             CMP      R4,#+1
   \   00000054   0xD02E             BEQ.N    ??HAL_I2C_Master_Transmit_IT_0
   \   00000056   0x2401             MOVS     R4,#+1
   \   00000058   0xF880 0x403C      STRB     R4,[R0, #+60]
   1221              
   1222              /* Check if the I2C is already enabled */
   1223              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   0000005C   0x6804             LDR      R4,[R0, #+0]
   \   0000005E   0x6825             LDR      R5,[R4, #+0]
   \   00000060   0x07ED             LSLS     R5,R5,#+31
   \   00000062   0xD403             BMI.N    ??HAL_I2C_Master_Transmit_IT_4
   1224              {
   1225                /* Enable I2C peripheral */
   1226                __HAL_I2C_ENABLE(hi2c);
   \   00000064   0x6825             LDR      R5,[R4, #+0]
   \   00000066   0xF045 0x0501      ORR      R5,R5,#0x1
   \   0000006A   0x6025             STR      R5,[R4, #+0]
   1227              }
   1228          
   1229              /* Disable Pos */
   1230              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Master_Transmit_IT_4: (+1)
   \   0000006C   0x6804             LDR      R4,[R0, #+0]
   \   0000006E   0x6825             LDR      R5,[R4, #+0]
   \   00000070   0xF425 0x6500      BIC      R5,R5,#0x800
   \   00000074   0x6025             STR      R5,[R4, #+0]
   1231          
   1232              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \   00000076   0x2421             MOVS     R4,#+33
   \   00000078   0xF880 0x403D      STRB     R4,[R0, #+61]
   1233              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \   0000007C   0x2410             MOVS     R4,#+16
   \   0000007E   0xF880 0x403E      STRB     R4,[R0, #+62]
   1234              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000082   0x2400             MOVS     R4,#+0
   \   00000084   0x6404             STR      R4,[R0, #+64]
   1235          
   1236              /* Prepare transfer parameters */
   1237              hi2c->pBuffPtr    = pData;
   \   00000086   0x6242             STR      R2,[R0, #+36]
   1238              hi2c->XferCount   = Size;
   \   00000088   0x8543             STRH     R3,[R0, #+42]
   1239              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   0000008A   0x.... 0x....      LDR.W    R2,??DataTable11  ;; 0xffff0000
   \   0000008E   0x62C2             STR      R2,[R0, #+44]
   1240              hi2c->XferSize    = hi2c->XferCount;
   \   00000090   0x8D42             LDRH     R2,[R0, #+42]
   \   00000092   0x8502             STRH     R2,[R0, #+40]
   1241              hi2c->Devaddress  = DevAddress;
   \   00000094   0x6441             STR      R1,[R0, #+68]
   1242          
   1243              /* Generate Start */
   1244              hi2c->Instance->CR1 |= I2C_CR1_START;
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x680A             LDR      R2,[R1, #+0]
   \   0000009A   0xF442 0x7280      ORR      R2,R2,#0x100
   \   0000009E   0x600A             STR      R2,[R1, #+0]
   1245          
   1246              /* Process Unlocked */
   1247              __HAL_UNLOCK(hi2c);
   \   000000A0   0x4621             MOV      R1,R4
   \   000000A2   0xF880 0x103C      STRB     R1,[R0, #+60]
   1248          
   1249              /* Note : The I2C interrupts must be enabled after unlocking current process
   1250                        to avoid the risk of I2C interrupt handle execution before current
   1251                        process unlock */
   1252              /* Enable EVT, BUF and ERR interrupt */
   1253              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0x6841             LDR      R1,[R0, #+4]
   \   000000AA   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   000000AE   0x6041             STR      R1,[R0, #+4]
   1254          
   1255              return HAL_OK;
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0xE000             B.N      ??HAL_I2C_Master_Transmit_IT_3
   1256            }
   1257            else
   1258            {
   1259              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_IT_0: (+1)
   \   000000B4   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_IT_3: (+1)
   \   000000B6   0xBC32             POP      {R1,R4,R5}
   \   000000B8   0x4770             BX       LR               ;; return
   1260            }
   1261          }
   1262          
   1263          /**
   1264            * @brief  Receive in master mode an amount of data in non-blocking mode with Interrupt
   1265            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1266            *                the configuration information for the specified I2C.
   1267            * @param  DevAddress Target device address: The device 7 bits address value
   1268            *         in datasheet must be shift at right before call interface
   1269            * @param  pData Pointer to data buffer
   1270            * @param  Size Amount of data to be sent
   1271            * @retval HAL status
   1272            */

   \                                 In section .text, align 2, keep-with-next
   1273          HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1274          {
   \                     HAL_I2C_Master_Receive_IT: (+1)
   \   00000000   0xB438             PUSH     {R3-R5}
   1275            __IO uint32_t count = 0U;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x9400             STR      R4,[SP, #+0]
   1276          
   1277            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF890 0x403D      LDRB     R4,[R0, #+61]
   \   0000000A   0x2C20             CMP      R4,#+32
   \   0000000C   0xD157             BNE.N    ??HAL_I2C_Master_Receive_IT_0
   1278            {
   1279              /* Wait until BUSY flag is reset */
   1280              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable15
   \   00000012   0x6824             LDR      R4,[R4, #+0]
   \   00000014   0x2519             MOVS     R5,#+25
   \   00000016   0xFBB4 0xF4F5      UDIV     R4,R4,R5
   \   0000001A   0xF44F 0x757A      MOV      R5,#+1000
   \   0000001E   0xFBB4 0xF4F5      UDIV     R4,R4,R5
   \   00000022   0x2519             MOVS     R5,#+25
   \   00000024   0x436C             MULS     R4,R5,R4
   \   00000026   0x9400             STR      R4,[SP, #+0]
   1281              do
   1282              {
   1283                if(count-- == 0U)
   \                     ??HAL_I2C_Master_Receive_IT_1: (+1)
   \   00000028   0x9C00             LDR      R4,[SP, #+0]
   \   0000002A   0x1E65             SUBS     R5,R4,#+1
   \   0000002C   0x9500             STR      R5,[SP, #+0]
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD109             BNE.N    ??HAL_I2C_Master_Receive_IT_2
   1284                {
   1285                  hi2c->PreviousState = I2C_STATE_NONE;
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x6301             STR      R1,[R0, #+48]
   1286                  hi2c->State= HAL_I2C_STATE_READY;
   \   00000036   0x2120             MOVS     R1,#+32
   \   00000038   0xF880 0x103D      STRB     R1,[R0, #+61]
   1287          
   1288                  /* Process Unlocked */
   1289                  __HAL_UNLOCK(hi2c);
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0xF880 0x103C      STRB     R1,[R0, #+60]
   1290          
   1291                  return HAL_TIMEOUT; 
   \   00000042   0x2003             MOVS     R0,#+3
   \   00000044   0xE03C             B.N      ??HAL_I2C_Master_Receive_IT_3
   1292                }
   1293              }
   1294              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Master_Receive_IT_2: (+1)
   \   00000046   0x6804             LDR      R4,[R0, #+0]
   \   00000048   0x69A4             LDR      R4,[R4, #+24]
   \   0000004A   0x07A4             LSLS     R4,R4,#+30
   \   0000004C   0xD4EC             BMI.N    ??HAL_I2C_Master_Receive_IT_1
   1295          
   1296              /* Process Locked */
   1297              __HAL_LOCK(hi2c);
   \   0000004E   0xF990 0x403C      LDRSB    R4,[R0, #+60]
   \   00000052   0x2C01             CMP      R4,#+1
   \   00000054   0xD033             BEQ.N    ??HAL_I2C_Master_Receive_IT_0
   \   00000056   0x2401             MOVS     R4,#+1
   \   00000058   0xF880 0x403C      STRB     R4,[R0, #+60]
   1298              
   1299              /* Check if the I2C is already enabled */
   1300              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   0000005C   0x6804             LDR      R4,[R0, #+0]
   \   0000005E   0x6825             LDR      R5,[R4, #+0]
   \   00000060   0x07ED             LSLS     R5,R5,#+31
   \   00000062   0xD403             BMI.N    ??HAL_I2C_Master_Receive_IT_4
   1301              {
   1302                /* Enable I2C peripheral */
   1303                __HAL_I2C_ENABLE(hi2c);
   \   00000064   0x6825             LDR      R5,[R4, #+0]
   \   00000066   0xF045 0x0501      ORR      R5,R5,#0x1
   \   0000006A   0x6025             STR      R5,[R4, #+0]
   1304              }
   1305          
   1306              /* Disable Pos */
   1307              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Master_Receive_IT_4: (+1)
   \   0000006C   0x6804             LDR      R4,[R0, #+0]
   \   0000006E   0x6825             LDR      R5,[R4, #+0]
   \   00000070   0xF425 0x6500      BIC      R5,R5,#0x800
   \   00000074   0x6025             STR      R5,[R4, #+0]
   1308          
   1309              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \   00000076   0x2422             MOVS     R4,#+34
   \   00000078   0xF880 0x403D      STRB     R4,[R0, #+61]
   1310              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \   0000007C   0x2410             MOVS     R4,#+16
   \   0000007E   0xF880 0x403E      STRB     R4,[R0, #+62]
   1311              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000082   0x2400             MOVS     R4,#+0
   \   00000084   0x6404             STR      R4,[R0, #+64]
   1312          
   1313              /* Prepare transfer parameters */
   1314              hi2c->pBuffPtr    = pData;
   \   00000086   0x6242             STR      R2,[R0, #+36]
   1315              hi2c->XferCount   = Size;
   \   00000088   0x8543             STRH     R3,[R0, #+42]
   1316              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   0000008A   0x.... 0x....      LDR.W    R2,??DataTable11  ;; 0xffff0000
   \   0000008E   0x62C2             STR      R2,[R0, #+44]
   1317              hi2c->XferSize    = hi2c->XferCount;
   \   00000090   0x8D42             LDRH     R2,[R0, #+42]
   \   00000092   0x8502             STRH     R2,[R0, #+40]
   1318              hi2c->Devaddress  = DevAddress;
   \   00000094   0x6441             STR      R1,[R0, #+68]
   1319          
   1320              /* Enable Acknowledge */
   1321              hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x680A             LDR      R2,[R1, #+0]
   \   0000009A   0xF442 0x6280      ORR      R2,R2,#0x400
   \   0000009E   0x600A             STR      R2,[R1, #+0]
   1322          
   1323              /* Generate Start */
   1324              hi2c->Instance->CR1 |= I2C_CR1_START;
   \   000000A0   0x6801             LDR      R1,[R0, #+0]
   \   000000A2   0x680A             LDR      R2,[R1, #+0]
   \   000000A4   0xF442 0x7280      ORR      R2,R2,#0x100
   \   000000A8   0x600A             STR      R2,[R1, #+0]
   1325          
   1326              /* Process Unlocked */
   1327              __HAL_UNLOCK(hi2c);
   \   000000AA   0x4621             MOV      R1,R4
   \   000000AC   0xF880 0x103C      STRB     R1,[R0, #+60]
   1328          
   1329              /* Note : The I2C interrupts must be enabled after unlocking current process
   1330              to avoid the risk of I2C interrupt handle execution before current
   1331              process unlock */
   1332          
   1333              /* Enable EVT, BUF and ERR interrupt */
   1334              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x6841             LDR      R1,[R0, #+4]
   \   000000B4   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   000000B8   0x6041             STR      R1,[R0, #+4]
   1335          
   1336              return HAL_OK;
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0xE000             B.N      ??HAL_I2C_Master_Receive_IT_3
   1337            }
   1338            else
   1339            {
   1340              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_IT_0: (+1)
   \   000000BE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_IT_3: (+1)
   \   000000C0   0xBC32             POP      {R1,R4,R5}
   \   000000C2   0x4770             BX       LR               ;; return
   1341            }
   1342          }
   1343          
   1344          /**
   1345            * @brief  Sequential transmit in master mode an amount of data in non-blocking mode with Interrupt
   1346            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   1347            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1348            *         the configuration information for the specified I2C.
   1349            * @param  DevAddress Target device address: The device 7 bits address value
   1350            *         in datasheet must be shift at right before call interface
   1351            * @param  pData Pointer to data buffer
   1352            * @param  Size Amount of data to be sent
   1353            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   1354            * @retval HAL status
   1355            */

   \                                 In section .text, align 2, keep-with-next
   1356          HAL_StatusTypeDef HAL_I2C_Master_Sequential_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   1357          {
   \                     HAL_I2C_Master_Sequential_Transmit_IT: (+1)
   \   00000000   0xB47C             PUSH     {R2-R6}
   1358            __IO uint32_t Prev_State = 0x00U;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x9400             STR      R4,[SP, #+0]
   1359            __IO uint32_t count      = 0x00U;
   \   00000006   0x9401             STR      R4,[SP, #+4]
   1360            
   1361            /* Check the parameters */
   1362            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   1363          
   1364            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000008   0xF890 0x403D      LDRB     R4,[R0, #+61]
   \   0000000C   0x2C20             CMP      R4,#+32
   \   0000000E   0xD16A             BNE.N    ??HAL_I2C_Master_Sequential_Transmit_IT_0
   \   00000010   0x9C05             LDR      R4,[SP, #+20]
   1365            {
   1366              /* Check Busy Flag only if FIRST call of Master interface */
   1367              if((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
   \   00000012   0x2C04             CMP      R4,#+4
   \   00000014   0xD001             BEQ.N    ??HAL_I2C_Master_Sequential_Transmit_IT_1
   \   00000016   0x2C01             CMP      R4,#+1
   \   00000018   0xD11F             BNE.N    ??HAL_I2C_Master_Sequential_Transmit_IT_2
   1368              {
   1369                /* Wait until BUSY flag is reset */
   1370                count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
   \                     ??HAL_I2C_Master_Sequential_Transmit_IT_1: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R5,??DataTable15
   \   0000001E   0x682D             LDR      R5,[R5, #+0]
   \   00000020   0x2619             MOVS     R6,#+25
   \   00000022   0xFBB5 0xF5F6      UDIV     R5,R5,R6
   \   00000026   0xF44F 0x767A      MOV      R6,#+1000
   \   0000002A   0xFBB5 0xF5F6      UDIV     R5,R5,R6
   \   0000002E   0x2619             MOVS     R6,#+25
   \   00000030   0x4375             MULS     R5,R6,R5
   \   00000032   0x9501             STR      R5,[SP, #+4]
   1371                do
   1372                {
   1373                  if(count-- == 0U)
   \                     ??HAL_I2C_Master_Sequential_Transmit_IT_3: (+1)
   \   00000034   0x9D01             LDR      R5,[SP, #+4]
   \   00000036   0x1E6E             SUBS     R6,R5,#+1
   \   00000038   0x9601             STR      R6,[SP, #+4]
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD109             BNE.N    ??HAL_I2C_Master_Sequential_Transmit_IT_4
   1374                  {
   1375                    hi2c->PreviousState = I2C_STATE_NONE;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x6301             STR      R1,[R0, #+48]
   1376                    hi2c->State= HAL_I2C_STATE_READY;
   \   00000042   0x2120             MOVS     R1,#+32
   \   00000044   0xF880 0x103D      STRB     R1,[R0, #+61]
   1377                    
   1378                    /* Process Unlocked */
   1379                    __HAL_UNLOCK(hi2c);
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xF880 0x103C      STRB     R1,[R0, #+60]
   1380                    
   1381                    return HAL_TIMEOUT; 
   \   0000004E   0x2003             MOVS     R0,#+3
   \   00000050   0xE04A             B.N      ??HAL_I2C_Master_Sequential_Transmit_IT_5
   1382                  }
   1383                }
   1384                while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Master_Sequential_Transmit_IT_4: (+1)
   \   00000052   0x6805             LDR      R5,[R0, #+0]
   \   00000054   0x69AD             LDR      R5,[R5, #+24]
   \   00000056   0x07AD             LSLS     R5,R5,#+30
   \   00000058   0xD4EC             BMI.N    ??HAL_I2C_Master_Sequential_Transmit_IT_3
   1385              }
   1386          
   1387              /* Process Locked */
   1388              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Sequential_Transmit_IT_2: (+1)
   \   0000005A   0xF990 0x503C      LDRSB    R5,[R0, #+60]
   \   0000005E   0x2D01             CMP      R5,#+1
   \   00000060   0xD041             BEQ.N    ??HAL_I2C_Master_Sequential_Transmit_IT_0
   \   00000062   0x2501             MOVS     R5,#+1
   \   00000064   0xF880 0x503C      STRB     R5,[R0, #+60]
   1389          
   1390              /* Check if the I2C is already enabled */
   1391              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   00000068   0x6805             LDR      R5,[R0, #+0]
   \   0000006A   0x682E             LDR      R6,[R5, #+0]
   \   0000006C   0x07F6             LSLS     R6,R6,#+31
   \   0000006E   0xD403             BMI.N    ??HAL_I2C_Master_Sequential_Transmit_IT_6
   1392              {
   1393                /* Enable I2C peripheral */
   1394                __HAL_I2C_ENABLE(hi2c);
   \   00000070   0x682E             LDR      R6,[R5, #+0]
   \   00000072   0xF046 0x0601      ORR      R6,R6,#0x1
   \   00000076   0x602E             STR      R6,[R5, #+0]
   1395              }
   1396          
   1397              /* Disable Pos */
   1398              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Master_Sequential_Transmit_IT_6: (+1)
   \   00000078   0x6805             LDR      R5,[R0, #+0]
   \   0000007A   0x682E             LDR      R6,[R5, #+0]
   \   0000007C   0xF426 0x6600      BIC      R6,R6,#0x800
   \   00000080   0x602E             STR      R6,[R5, #+0]
   1399          
   1400              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \   00000082   0x2521             MOVS     R5,#+33
   \   00000084   0xF880 0x503D      STRB     R5,[R0, #+61]
   1401              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \   00000088   0x2510             MOVS     R5,#+16
   \   0000008A   0xF880 0x503E      STRB     R5,[R0, #+62]
   1402              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000008E   0x2500             MOVS     R5,#+0
   \   00000090   0x6405             STR      R5,[R0, #+64]
   1403          
   1404              /* Prepare transfer parameters */
   1405              hi2c->pBuffPtr    = pData;
   \   00000092   0x6242             STR      R2,[R0, #+36]
   1406              hi2c->XferCount   = Size;
   \   00000094   0x8543             STRH     R3,[R0, #+42]
   1407              hi2c->XferOptions = XferOptions;
   \   00000096   0x62C4             STR      R4,[R0, #+44]
   1408              hi2c->XferSize    = hi2c->XferCount;
   \   00000098   0x8D42             LDRH     R2,[R0, #+42]
   \   0000009A   0x8502             STRH     R2,[R0, #+40]
   1409              hi2c->Devaddress  = DevAddress;
   \   0000009C   0x6441             STR      R1,[R0, #+68]
   1410          
   1411              Prev_State = hi2c->PreviousState;
   \   0000009E   0x6B01             LDR      R1,[R0, #+48]
   \   000000A0   0x9100             STR      R1,[SP, #+0]
   1412              
   1413              /* Generate Start */    
   1414              if((Prev_State == I2C_STATE_MASTER_BUSY_RX) || (Prev_State == I2C_STATE_NONE))
   \   000000A2   0x9900             LDR      R1,[SP, #+0]
   \   000000A4   0x2912             CMP      R1,#+18
   \   000000A6   0xD002             BEQ.N    ??HAL_I2C_Master_Sequential_Transmit_IT_7
   \   000000A8   0x9900             LDR      R1,[SP, #+0]
   \   000000AA   0x2900             CMP      R1,#+0
   \   000000AC   0xD111             BNE.N    ??HAL_I2C_Master_Sequential_Transmit_IT_8
   1415              {
   1416                /* Generate Start condition if first transfer */
   1417                if((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
   \                     ??HAL_I2C_Master_Sequential_Transmit_IT_7: (+1)
   \   000000AE   0x2C04             CMP      R4,#+4
   \   000000B0   0xD001             BEQ.N    ??HAL_I2C_Master_Sequential_Transmit_IT_9
   \   000000B2   0x2C01             CMP      R4,#+1
   \   000000B4   0xD105             BNE.N    ??HAL_I2C_Master_Sequential_Transmit_IT_10
   1418                {
   1419                  /* Generate Start */
   1420                  hi2c->Instance->CR1 |= I2C_CR1_START;
   \                     ??HAL_I2C_Master_Sequential_Transmit_IT_9: (+1)
   \   000000B6   0x6801             LDR      R1,[R0, #+0]
   \   000000B8   0x680A             LDR      R2,[R1, #+0]
   \   000000BA   0xF442 0x7280      ORR      R2,R2,#0x100
   \   000000BE   0x600A             STR      R2,[R1, #+0]
   \   000000C0   0xE007             B.N      ??HAL_I2C_Master_Sequential_Transmit_IT_8
   1421                }
   1422                else if(Prev_State == I2C_STATE_MASTER_BUSY_RX)
   \                     ??HAL_I2C_Master_Sequential_Transmit_IT_10: (+1)
   \   000000C2   0x9900             LDR      R1,[SP, #+0]
   \   000000C4   0x2912             CMP      R1,#+18
   \   000000C6   0xD104             BNE.N    ??HAL_I2C_Master_Sequential_Transmit_IT_8
   1423                {
   1424                  /* Generate ReStart */
   1425                  hi2c->Instance->CR1 |= I2C_CR1_START;
   \   000000C8   0x6801             LDR      R1,[R0, #+0]
   \   000000CA   0x680A             LDR      R2,[R1, #+0]
   \   000000CC   0xF442 0x7280      ORR      R2,R2,#0x100
   \   000000D0   0x600A             STR      R2,[R1, #+0]
   1426                }
   1427              }
   1428          
   1429              /* Process Unlocked */
   1430              __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Sequential_Transmit_IT_8: (+1)
   \   000000D2   0x4629             MOV      R1,R5
   \   000000D4   0xF880 0x103C      STRB     R1,[R0, #+60]
   1431          
   1432              /* Note : The I2C interrupts must be enabled after unlocking current process
   1433              to avoid the risk of I2C interrupt handle execution before current
   1434              process unlock */
   1435          
   1436              /* Enable EVT, BUF and ERR interrupt */
   1437              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0x6841             LDR      R1,[R0, #+4]
   \   000000DC   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   000000E0   0x6041             STR      R1,[R0, #+4]
   1438          
   1439              return HAL_OK;
   \   000000E2   0x4628             MOV      R0,R5
   \   000000E4   0xE000             B.N      ??HAL_I2C_Master_Sequential_Transmit_IT_5
   1440            }
   1441            else
   1442            {
   1443              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Sequential_Transmit_IT_0: (+1)
   \   000000E6   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Sequential_Transmit_IT_5: (+1)
   \   000000E8   0xBC76             POP      {R1,R2,R4-R6}
   \   000000EA   0x4770             BX       LR               ;; return
   1444            }
   1445          }
   1446          
   1447          /**
   1448            * @brief  Sequential receive in master mode an amount of data in non-blocking mode with Interrupt
   1449            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   1450            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1451            *         the configuration information for the specified I2C.
   1452            * @param  DevAddress Target device address: The device 7 bits address value
   1453            *         in datasheet must be shift at right before call interface
   1454            * @param  pData Pointer to data buffer
   1455            * @param  Size Amount of data to be sent
   1456            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   1457            * @retval HAL status
   1458            */

   \                                 In section .text, align 2, keep-with-next
   1459          HAL_StatusTypeDef HAL_I2C_Master_Sequential_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   1460          {
   \                     HAL_I2C_Master_Sequential_Receive_IT: (+1)
   \   00000000   0xB478             PUSH     {R3-R6}
   1461            __IO uint32_t count = 0U;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x9400             STR      R4,[SP, #+0]
   1462              
   1463            /* Check the parameters */
   1464            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   1465          
   1466            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF890 0x403D      LDRB     R4,[R0, #+61]
   \   0000000A   0x2C20             CMP      R4,#+32
   \   0000000C   0xD176             BNE.N    ??HAL_I2C_Master_Sequential_Receive_IT_0
   \   0000000E   0x9C04             LDR      R4,[SP, #+16]
   1467            {
   1468              /* Check Busy Flag only if FIRST call of Master interface */
   1469              if((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
   \   00000010   0x2C04             CMP      R4,#+4
   \   00000012   0xD001             BEQ.N    ??HAL_I2C_Master_Sequential_Receive_IT_1
   \   00000014   0x2C01             CMP      R4,#+1
   \   00000016   0xD11F             BNE.N    ??HAL_I2C_Master_Sequential_Receive_IT_2
   1470              {
   1471                /* Wait until BUSY flag is reset */
   1472                count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
   \                     ??HAL_I2C_Master_Sequential_Receive_IT_1: (+1)
   \   00000018   0x.... 0x....      LDR.W    R5,??DataTable15
   \   0000001C   0x682D             LDR      R5,[R5, #+0]
   \   0000001E   0x2619             MOVS     R6,#+25
   \   00000020   0xFBB5 0xF5F6      UDIV     R5,R5,R6
   \   00000024   0xF44F 0x767A      MOV      R6,#+1000
   \   00000028   0xFBB5 0xF5F6      UDIV     R5,R5,R6
   \   0000002C   0x2619             MOVS     R6,#+25
   \   0000002E   0x4375             MULS     R5,R6,R5
   \   00000030   0x9500             STR      R5,[SP, #+0]
   1473                do
   1474                {
   1475                  if(count-- == 0U)
   \                     ??HAL_I2C_Master_Sequential_Receive_IT_3: (+1)
   \   00000032   0x9D00             LDR      R5,[SP, #+0]
   \   00000034   0x1E6E             SUBS     R6,R5,#+1
   \   00000036   0x9600             STR      R6,[SP, #+0]
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD109             BNE.N    ??HAL_I2C_Master_Sequential_Receive_IT_4
   1476                  {
   1477                    hi2c->PreviousState = I2C_STATE_NONE;
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x6301             STR      R1,[R0, #+48]
   1478                    hi2c->State= HAL_I2C_STATE_READY;
   \   00000040   0x2120             MOVS     R1,#+32
   \   00000042   0xF880 0x103D      STRB     R1,[R0, #+61]
   1479          
   1480                    /* Process Unlocked */
   1481                    __HAL_UNLOCK(hi2c);
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0xF880 0x103C      STRB     R1,[R0, #+60]
   1482          
   1483                    return HAL_TIMEOUT; 
   \   0000004C   0x2003             MOVS     R0,#+3
   \   0000004E   0xE056             B.N      ??HAL_I2C_Master_Sequential_Receive_IT_5
   1484                  }
   1485                }
   1486                while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Master_Sequential_Receive_IT_4: (+1)
   \   00000050   0x6805             LDR      R5,[R0, #+0]
   \   00000052   0x69AD             LDR      R5,[R5, #+24]
   \   00000054   0x07AD             LSLS     R5,R5,#+30
   \   00000056   0xD4EC             BMI.N    ??HAL_I2C_Master_Sequential_Receive_IT_3
   1487              }
   1488          
   1489              /* Process Locked */
   1490              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Sequential_Receive_IT_2: (+1)
   \   00000058   0xF990 0x503C      LDRSB    R5,[R0, #+60]
   \   0000005C   0x2D01             CMP      R5,#+1
   \   0000005E   0xD04D             BEQ.N    ??HAL_I2C_Master_Sequential_Receive_IT_0
   \   00000060   0x2501             MOVS     R5,#+1
   \   00000062   0xF880 0x503C      STRB     R5,[R0, #+60]
   1491          
   1492              /* Check if the I2C is already enabled */
   1493              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   00000066   0x6805             LDR      R5,[R0, #+0]
   \   00000068   0x682E             LDR      R6,[R5, #+0]
   \   0000006A   0x07F6             LSLS     R6,R6,#+31
   \   0000006C   0xD403             BMI.N    ??HAL_I2C_Master_Sequential_Receive_IT_6
   1494              {
   1495                /* Enable I2C peripheral */
   1496                __HAL_I2C_ENABLE(hi2c);
   \   0000006E   0x682E             LDR      R6,[R5, #+0]
   \   00000070   0xF046 0x0601      ORR      R6,R6,#0x1
   \   00000074   0x602E             STR      R6,[R5, #+0]
   1497              }
   1498          
   1499              /* Disable Pos */
   1500              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Master_Sequential_Receive_IT_6: (+1)
   \   00000076   0x6805             LDR      R5,[R0, #+0]
   \   00000078   0x682E             LDR      R6,[R5, #+0]
   \   0000007A   0xF426 0x6600      BIC      R6,R6,#0x800
   \   0000007E   0x602E             STR      R6,[R5, #+0]
   1501          
   1502              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \   00000080   0x2522             MOVS     R5,#+34
   \   00000082   0xF880 0x503D      STRB     R5,[R0, #+61]
   1503              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \   00000086   0x2510             MOVS     R5,#+16
   \   00000088   0xF880 0x503E      STRB     R5,[R0, #+62]
   1504              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000008C   0x2500             MOVS     R5,#+0
   \   0000008E   0x6405             STR      R5,[R0, #+64]
   1505          
   1506              /* Prepare transfer parameters */
   1507              hi2c->pBuffPtr = pData;
   \   00000090   0x6242             STR      R2,[R0, #+36]
   1508              hi2c->XferCount = Size;
   \   00000092   0x8543             STRH     R3,[R0, #+42]
   1509              hi2c->XferOptions = XferOptions;
   \   00000094   0x62C4             STR      R4,[R0, #+44]
   1510              hi2c->XferSize    = hi2c->XferCount;
   \   00000096   0x8D42             LDRH     R2,[R0, #+42]
   \   00000098   0x8502             STRH     R2,[R0, #+40]
   1511              hi2c->Devaddress = DevAddress;
   \   0000009A   0x6441             STR      R1,[R0, #+68]
   1512              
   1513              if((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) || (hi2c->PreviousState == I2C_STATE_NONE))
   \   0000009C   0x6B01             LDR      R1,[R0, #+48]
   \   0000009E   0x2911             CMP      R1,#+17
   \   000000A0   0xD002             BEQ.N    ??HAL_I2C_Master_Sequential_Receive_IT_7
   \   000000A2   0x6B01             LDR      R1,[R0, #+48]
   \   000000A4   0x2900             CMP      R1,#+0
   \   000000A6   0xD11F             BNE.N    ??HAL_I2C_Master_Sequential_Receive_IT_8
   1514              {
   1515                /* Generate Start condition if first transfer */
   1516                if((XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME)  || (XferOptions == I2C_NO_OPTION_FRAME))
   \                     ??HAL_I2C_Master_Sequential_Receive_IT_7: (+1)
   \   000000A8   0x2C04             CMP      R4,#+4
   \   000000AA   0xD005             BEQ.N    ??HAL_I2C_Master_Sequential_Receive_IT_9
   \   000000AC   0x2C01             CMP      R4,#+1
   \   000000AE   0xD003             BEQ.N    ??HAL_I2C_Master_Sequential_Receive_IT_9
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable11  ;; 0xffff0000
   \   000000B4   0x428C             CMP      R4,R1
   \   000000B6   0xD10A             BNE.N    ??HAL_I2C_Master_Sequential_Receive_IT_10
   1517                {
   1518                  /* Enable Acknowledge */
   1519                  hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \                     ??HAL_I2C_Master_Sequential_Receive_IT_9: (+1)
   \   000000B8   0x6801             LDR      R1,[R0, #+0]
   \   000000BA   0x680A             LDR      R2,[R1, #+0]
   \   000000BC   0xF442 0x6280      ORR      R2,R2,#0x400
   \   000000C0   0x600A             STR      R2,[R1, #+0]
   1520                  
   1521                  /* Generate Start */
   1522                  hi2c->Instance->CR1 |= I2C_CR1_START;
   \   000000C2   0x6801             LDR      R1,[R0, #+0]
   \   000000C4   0x680A             LDR      R2,[R1, #+0]
   \   000000C6   0xF442 0x7280      ORR      R2,R2,#0x100
   \   000000CA   0x600A             STR      R2,[R1, #+0]
   \   000000CC   0xE00C             B.N      ??HAL_I2C_Master_Sequential_Receive_IT_8
   1523                }
   1524                else if(hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX)
   \                     ??HAL_I2C_Master_Sequential_Receive_IT_10: (+1)
   \   000000CE   0x6B01             LDR      R1,[R0, #+48]
   \   000000D0   0x2911             CMP      R1,#+17
   \   000000D2   0xD109             BNE.N    ??HAL_I2C_Master_Sequential_Receive_IT_8
   1525                {
   1526                  /* Enable Acknowledge */
   1527                  hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \   000000D4   0x6801             LDR      R1,[R0, #+0]
   \   000000D6   0x680A             LDR      R2,[R1, #+0]
   \   000000D8   0xF442 0x6280      ORR      R2,R2,#0x400
   \   000000DC   0x600A             STR      R2,[R1, #+0]
   1528                  
   1529                  /* Generate ReStart */
   1530                  hi2c->Instance->CR1 |= I2C_CR1_START;
   \   000000DE   0x6801             LDR      R1,[R0, #+0]
   \   000000E0   0x680A             LDR      R2,[R1, #+0]
   \   000000E2   0xF442 0x7280      ORR      R2,R2,#0x100
   \   000000E6   0x600A             STR      R2,[R1, #+0]
   1531                }
   1532              }
   1533          
   1534              /* Process Unlocked */
   1535              __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Sequential_Receive_IT_8: (+1)
   \   000000E8   0x4629             MOV      R1,R5
   \   000000EA   0xF880 0x103C      STRB     R1,[R0, #+60]
   1536          
   1537              /* Note : The I2C interrupts must be enabled after unlocking current process
   1538              to avoid the risk of I2C interrupt handle execution before current
   1539              process unlock */
   1540          
   1541              /* Enable EVT, BUF and ERR interrupt */
   1542              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0x6841             LDR      R1,[R0, #+4]
   \   000000F2   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   000000F6   0x6041             STR      R1,[R0, #+4]
   1543          
   1544              return HAL_OK;
   \   000000F8   0x4628             MOV      R0,R5
   \   000000FA   0xE000             B.N      ??HAL_I2C_Master_Sequential_Receive_IT_5
   1545            }
   1546            else
   1547            {
   1548              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Sequential_Receive_IT_0: (+1)
   \   000000FC   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Sequential_Receive_IT_5: (+1)
   \   000000FE   0xBC72             POP      {R1,R4-R6}
   \   00000100   0x4770             BX       LR               ;; return
   1549            }
   1550          }
   1551          
   1552          /**
   1553            * @brief  Transmit in slave mode an amount of data in non-blocking mode with Interrupt
   1554            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1555            *         the configuration information for the specified I2C.
   1556            * @param  pData Pointer to data buffer
   1557            * @param  Size Amount of data to be sent
   1558            * @retval HAL status
   1559            */

   \                                 In section .text, align 2, keep-with-next
   1560          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1561          {
   \                     HAL_I2C_Slave_Transmit_IT: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   1562            __IO uint32_t count = 0U;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x9300             STR      R3,[SP, #+0]
   1563          
   1564            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF890 0x303D      LDRB     R3,[R0, #+61]
   \   0000000A   0x2B20             CMP      R3,#+32
   \   0000000C   0xD157             BNE.N    ??HAL_I2C_Slave_Transmit_IT_0
   1565            {
   1566              if((pData == NULL) || (Size == 0U))
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_IT_1
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_IT_2
   1567              {
   1568                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Transmit_IT_1: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE052             B.N      ??HAL_I2C_Slave_Transmit_IT_3
   1569              }
   1570          
   1571              /* Wait until BUSY flag is reset */
   1572              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
   \                     ??HAL_I2C_Slave_Transmit_IT_2: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R3,??DataTable15
   \   0000001E   0x681B             LDR      R3,[R3, #+0]
   \   00000020   0x2419             MOVS     R4,#+25
   \   00000022   0xFBB3 0xF3F4      UDIV     R3,R3,R4
   \   00000026   0xF44F 0x747A      MOV      R4,#+1000
   \   0000002A   0xFBB3 0xF3F4      UDIV     R3,R3,R4
   \   0000002E   0x2419             MOVS     R4,#+25
   \   00000030   0x4363             MULS     R3,R4,R3
   \   00000032   0x9300             STR      R3,[SP, #+0]
   1573              do
   1574              {
   1575                if(count-- == 0U)
   \                     ??HAL_I2C_Slave_Transmit_IT_4: (+1)
   \   00000034   0x9B00             LDR      R3,[SP, #+0]
   \   00000036   0x1E5C             SUBS     R4,R3,#+1
   \   00000038   0x9400             STR      R4,[SP, #+0]
   \   0000003A   0x2B00             CMP      R3,#+0
   \   0000003C   0xD109             BNE.N    ??HAL_I2C_Slave_Transmit_IT_5
   1576                {
   1577                  hi2c->PreviousState = I2C_STATE_NONE;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x6301             STR      R1,[R0, #+48]
   1578                  hi2c->State= HAL_I2C_STATE_READY;
   \   00000042   0x2120             MOVS     R1,#+32
   \   00000044   0xF880 0x103D      STRB     R1,[R0, #+61]
   1579          
   1580                  /* Process Unlocked */
   1581                  __HAL_UNLOCK(hi2c);
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xF880 0x103C      STRB     R1,[R0, #+60]
   1582          
   1583                  return HAL_TIMEOUT; 
   \   0000004E   0x2003             MOVS     R0,#+3
   \   00000050   0xE036             B.N      ??HAL_I2C_Slave_Transmit_IT_3
   1584                }
   1585              }
   1586              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Slave_Transmit_IT_5: (+1)
   \   00000052   0x6803             LDR      R3,[R0, #+0]
   \   00000054   0x699B             LDR      R3,[R3, #+24]
   \   00000056   0x079B             LSLS     R3,R3,#+30
   \   00000058   0xD4EC             BMI.N    ??HAL_I2C_Slave_Transmit_IT_4
   1587          
   1588              /* Process Locked */
   1589              __HAL_LOCK(hi2c);
   \   0000005A   0xF990 0x303C      LDRSB    R3,[R0, #+60]
   \   0000005E   0x2B01             CMP      R3,#+1
   \   00000060   0xD02D             BEQ.N    ??HAL_I2C_Slave_Transmit_IT_0
   \   00000062   0x2301             MOVS     R3,#+1
   \   00000064   0xF880 0x303C      STRB     R3,[R0, #+60]
   1590          
   1591              /* Check if the I2C is already enabled */
   1592              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   00000068   0x6803             LDR      R3,[R0, #+0]
   \   0000006A   0x681C             LDR      R4,[R3, #+0]
   \   0000006C   0x07E4             LSLS     R4,R4,#+31
   \   0000006E   0xD403             BMI.N    ??HAL_I2C_Slave_Transmit_IT_6
   1593              {
   1594                /* Enable I2C peripheral */
   1595                __HAL_I2C_ENABLE(hi2c);
   \   00000070   0x681C             LDR      R4,[R3, #+0]
   \   00000072   0xF044 0x0401      ORR      R4,R4,#0x1
   \   00000076   0x601C             STR      R4,[R3, #+0]
   1596              }
   1597          
   1598              /* Disable Pos */
   1599              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Slave_Transmit_IT_6: (+1)
   \   00000078   0x6803             LDR      R3,[R0, #+0]
   \   0000007A   0x681C             LDR      R4,[R3, #+0]
   \   0000007C   0xF424 0x6400      BIC      R4,R4,#0x800
   \   00000080   0x601C             STR      R4,[R3, #+0]
   1600          
   1601              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \   00000082   0x2321             MOVS     R3,#+33
   \   00000084   0xF880 0x303D      STRB     R3,[R0, #+61]
   1602              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \   00000088   0x2320             MOVS     R3,#+32
   \   0000008A   0xF880 0x303E      STRB     R3,[R0, #+62]
   1603              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000008E   0x2300             MOVS     R3,#+0
   \   00000090   0x6403             STR      R3,[R0, #+64]
   1604          
   1605              /* Prepare transfer parameters */
   1606              hi2c->pBuffPtr    = pData;
   \   00000092   0x6241             STR      R1,[R0, #+36]
   1607              hi2c->XferCount   = Size;
   \   00000094   0x8542             STRH     R2,[R0, #+42]
   1608              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable11  ;; 0xffff0000
   \   0000009A   0x62C1             STR      R1,[R0, #+44]
   1609              hi2c->XferSize    = hi2c->XferCount;
   \   0000009C   0x8D41             LDRH     R1,[R0, #+42]
   \   0000009E   0x8501             STRH     R1,[R0, #+40]
   1610          
   1611              /* Enable Address Acknowledge */
   1612              hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \   000000A0   0x6801             LDR      R1,[R0, #+0]
   \   000000A2   0x680A             LDR      R2,[R1, #+0]
   \   000000A4   0xF442 0x6280      ORR      R2,R2,#0x400
   \   000000A8   0x600A             STR      R2,[R1, #+0]
   1613          
   1614              /* Process Unlocked */
   1615              __HAL_UNLOCK(hi2c);
   \   000000AA   0x4619             MOV      R1,R3
   \   000000AC   0xF880 0x103C      STRB     R1,[R0, #+60]
   1616          
   1617              /* Note : The I2C interrupts must be enabled after unlocking current process
   1618                        to avoid the risk of I2C interrupt handle execution before current
   1619                        process unlock */
   1620          
   1621              /* Enable EVT, BUF and ERR interrupt */
   1622              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x6841             LDR      R1,[R0, #+4]
   \   000000B4   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   000000B8   0x6041             STR      R1,[R0, #+4]
   1623          
   1624              return HAL_OK;
   \   000000BA   0x4618             MOV      R0,R3
   \   000000BC   0xE000             B.N      ??HAL_I2C_Slave_Transmit_IT_3
   1625            }
   1626            else
   1627            {
   1628              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_IT_0: (+1)
   \   000000BE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_IT_3: (+1)
   \   000000C0   0xBC12             POP      {R1,R4}
   \   000000C2   0x4770             BX       LR               ;; return
   1629            }
   1630          }
   1631          
   1632          /**
   1633            * @brief  Receive in slave mode an amount of data in non-blocking mode with Interrupt 
   1634            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1635            *                the configuration information for the specified I2C.
   1636            * @param  pData Pointer to data buffer
   1637            * @param  Size Amount of data to be sent
   1638            * @retval HAL status
   1639            */

   \                                 In section .text, align 2, keep-with-next
   1640          HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1641          {
   \                     HAL_I2C_Slave_Receive_IT: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   1642            __IO uint32_t count = 0U;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x9300             STR      R3,[SP, #+0]
   1643          
   1644            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF890 0x303D      LDRB     R3,[R0, #+61]
   \   0000000A   0x2B20             CMP      R3,#+32
   \   0000000C   0xD155             BNE.N    ??HAL_I2C_Slave_Receive_IT_0
   1645            {
   1646              if((pData == NULL) || (Size == 0U))
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_IT_1
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_IT_2
   1647              {
   1648                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_IT_1: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE050             B.N      ??HAL_I2C_Slave_Receive_IT_3
   1649              }
   1650          
   1651              /* Wait until BUSY flag is reset */
   1652              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
   \                     ??HAL_I2C_Slave_Receive_IT_2: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R3,??DataTable15
   \   0000001E   0x681B             LDR      R3,[R3, #+0]
   \   00000020   0x2419             MOVS     R4,#+25
   \   00000022   0xFBB3 0xF3F4      UDIV     R3,R3,R4
   \   00000026   0xF44F 0x747A      MOV      R4,#+1000
   \   0000002A   0xFBB3 0xF3F4      UDIV     R3,R3,R4
   \   0000002E   0x2419             MOVS     R4,#+25
   \   00000030   0x4363             MULS     R3,R4,R3
   \   00000032   0x9300             STR      R3,[SP, #+0]
   1653              do
   1654              {
   1655                if(count-- == 0U)
   \                     ??HAL_I2C_Slave_Receive_IT_4: (+1)
   \   00000034   0x9B00             LDR      R3,[SP, #+0]
   \   00000036   0x1E5C             SUBS     R4,R3,#+1
   \   00000038   0x9400             STR      R4,[SP, #+0]
   \   0000003A   0x2B00             CMP      R3,#+0
   \   0000003C   0xD109             BNE.N    ??HAL_I2C_Slave_Receive_IT_5
   1656                {
   1657                  hi2c->PreviousState = I2C_STATE_NONE;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x6301             STR      R1,[R0, #+48]
   1658                  hi2c->State= HAL_I2C_STATE_READY;
   \   00000042   0x2120             MOVS     R1,#+32
   \   00000044   0xF880 0x103D      STRB     R1,[R0, #+61]
   1659          
   1660                  /* Process Unlocked */
   1661                  __HAL_UNLOCK(hi2c);
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xF880 0x103C      STRB     R1,[R0, #+60]
   1662          
   1663                  return HAL_TIMEOUT; 
   \   0000004E   0x2003             MOVS     R0,#+3
   \   00000050   0xE034             B.N      ??HAL_I2C_Slave_Receive_IT_3
   1664                }
   1665              }
   1666              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Slave_Receive_IT_5: (+1)
   \   00000052   0x6803             LDR      R3,[R0, #+0]
   \   00000054   0x699B             LDR      R3,[R3, #+24]
   \   00000056   0x079B             LSLS     R3,R3,#+30
   \   00000058   0xD4EC             BMI.N    ??HAL_I2C_Slave_Receive_IT_4
   1667          
   1668              /* Process Locked */
   1669              __HAL_LOCK(hi2c);
   \   0000005A   0xF990 0x303C      LDRSB    R3,[R0, #+60]
   \   0000005E   0x2B01             CMP      R3,#+1
   \   00000060   0xD02B             BEQ.N    ??HAL_I2C_Slave_Receive_IT_0
   \   00000062   0x2301             MOVS     R3,#+1
   \   00000064   0xF880 0x303C      STRB     R3,[R0, #+60]
   1670          
   1671              /* Check if the I2C is already enabled */
   1672              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   00000068   0x6803             LDR      R3,[R0, #+0]
   \   0000006A   0x681C             LDR      R4,[R3, #+0]
   \   0000006C   0x07E4             LSLS     R4,R4,#+31
   \   0000006E   0xD403             BMI.N    ??HAL_I2C_Slave_Receive_IT_6
   1673              {
   1674                /* Enable I2C peripheral */
   1675                __HAL_I2C_ENABLE(hi2c);
   \   00000070   0x681C             LDR      R4,[R3, #+0]
   \   00000072   0xF044 0x0401      ORR      R4,R4,#0x1
   \   00000076   0x601C             STR      R4,[R3, #+0]
   1676              }
   1677          
   1678              /* Disable Pos */
   1679              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Slave_Receive_IT_6: (+1)
   \   00000078   0x6803             LDR      R3,[R0, #+0]
   \   0000007A   0x681C             LDR      R4,[R3, #+0]
   \   0000007C   0xF424 0x6400      BIC      R4,R4,#0x800
   \   00000080   0x601C             STR      R4,[R3, #+0]
   1680          
   1681              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \   00000082   0x2322             MOVS     R3,#+34
   \   00000084   0xF880 0x303D      STRB     R3,[R0, #+61]
   1682              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \   00000088   0x2320             MOVS     R3,#+32
   \   0000008A   0xF880 0x303E      STRB     R3,[R0, #+62]
   1683              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000008E   0x2300             MOVS     R3,#+0
   \   00000090   0x6403             STR      R3,[R0, #+64]
   1684          
   1685              /* Prepare transfer parameters */
   1686              hi2c->pBuffPtr = pData;
   \   00000092   0x6241             STR      R1,[R0, #+36]
   1687              hi2c->XferSize = Size;
   \   00000094   0x8502             STRH     R2,[R0, #+40]
   1688              hi2c->XferCount = Size;
   \   00000096   0x8542             STRH     R2,[R0, #+42]
   1689              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   00000098   0x....             LDR.N    R1,??DataTable11  ;; 0xffff0000
   \   0000009A   0x62C1             STR      R1,[R0, #+44]
   1690          
   1691              /* Enable Address Acknowledge */
   1692              hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \   0000009C   0x6801             LDR      R1,[R0, #+0]
   \   0000009E   0x680A             LDR      R2,[R1, #+0]
   \   000000A0   0xF442 0x6280      ORR      R2,R2,#0x400
   \   000000A4   0x600A             STR      R2,[R1, #+0]
   1693          
   1694              /* Process Unlocked */
   1695              __HAL_UNLOCK(hi2c);
   \   000000A6   0x4619             MOV      R1,R3
   \   000000A8   0xF880 0x103C      STRB     R1,[R0, #+60]
   1696          
   1697              /* Note : The I2C interrupts must be enabled after unlocking current process
   1698                        to avoid the risk of I2C interrupt handle execution before current
   1699                        process unlock */
   1700          
   1701              /* Enable EVT, BUF and ERR interrupt */
   1702              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x6841             LDR      R1,[R0, #+4]
   \   000000B0   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   000000B4   0x6041             STR      R1,[R0, #+4]
   1703          
   1704              return HAL_OK;
   \   000000B6   0x4618             MOV      R0,R3
   \   000000B8   0xE000             B.N      ??HAL_I2C_Slave_Receive_IT_3
   1705            }
   1706            else
   1707            {
   1708              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_IT_0: (+1)
   \   000000BA   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_IT_3: (+1)
   \   000000BC   0xBC12             POP      {R1,R4}
   \   000000BE   0x4770             BX       LR               ;; return
   1709            }
   1710          }
   1711          
   1712          /**
   1713            * @brief  Sequential transmit in slave mode an amount of data in no-blocking mode with Interrupt
   1714            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   1715            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1716            *         the configuration information for I2C module
   1717            * @param  pData Pointer to data buffer
   1718            * @param  Size Amount of data to be sent
   1719            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   1720            * @retval HAL status
   1721            */

   \                                 In section .text, align 2, keep-with-next
   1722          HAL_StatusTypeDef HAL_I2C_Slave_Sequential_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   1723          {
   \                     HAL_I2C_Slave_Sequential_Transmit_IT: (+1)
   \   00000000   0xB438             PUSH     {R3-R5}
   1724            /* Check the parameters */
   1725            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   1726          
   1727            if(hi2c->State == HAL_I2C_STATE_LISTEN)
   \   00000002   0xF890 0x403D      LDRB     R4,[R0, #+61]
   \   00000006   0x2C28             CMP      R4,#+40
   \   00000008   0xD138             BNE.N    ??HAL_I2C_Slave_Sequential_Transmit_IT_0
   1728            {
   1729              if((pData == NULL) || (Size == 0U))
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD001             BEQ.N    ??HAL_I2C_Slave_Sequential_Transmit_IT_1
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD101             BNE.N    ??HAL_I2C_Slave_Sequential_Transmit_IT_2
   1730              {
   1731                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Sequential_Transmit_IT_1: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE033             B.N      ??HAL_I2C_Slave_Sequential_Transmit_IT_3
   1732              }
   1733          
   1734              /* Process Locked */
   1735              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Sequential_Transmit_IT_2: (+1)
   \   00000016   0xF990 0x403C      LDRSB    R4,[R0, #+60]
   \   0000001A   0x2C01             CMP      R4,#+1
   \   0000001C   0xD02E             BEQ.N    ??HAL_I2C_Slave_Sequential_Transmit_IT_0
   \   0000001E   0x2401             MOVS     R4,#+1
   \   00000020   0xF880 0x403C      STRB     R4,[R0, #+60]
   1736          
   1737              /* Check if the I2C is already enabled */
   1738              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   00000024   0x6804             LDR      R4,[R0, #+0]
   \   00000026   0x6825             LDR      R5,[R4, #+0]
   \   00000028   0x07ED             LSLS     R5,R5,#+31
   \   0000002A   0xD403             BMI.N    ??HAL_I2C_Slave_Sequential_Transmit_IT_4
   1739              {
   1740                /* Enable I2C peripheral */
   1741                __HAL_I2C_ENABLE(hi2c);
   \   0000002C   0x6825             LDR      R5,[R4, #+0]
   \   0000002E   0xF045 0x0501      ORR      R5,R5,#0x1
   \   00000032   0x6025             STR      R5,[R4, #+0]
   1742              }
   1743          
   1744              /* Disable Pos */
   1745              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Slave_Sequential_Transmit_IT_4: (+1)
   \   00000034   0x6804             LDR      R4,[R0, #+0]
   \   00000036   0x6825             LDR      R5,[R4, #+0]
   \   00000038   0xF425 0x6500      BIC      R5,R5,#0x800
   \   0000003C   0x6025             STR      R5,[R4, #+0]
   1746          
   1747              hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
   \   0000003E   0x2429             MOVS     R4,#+41
   \   00000040   0xF880 0x403D      STRB     R4,[R0, #+61]
   1748              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \   00000044   0x2420             MOVS     R4,#+32
   \   00000046   0xF880 0x403E      STRB     R4,[R0, #+62]
   1749              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000004A   0x2400             MOVS     R4,#+0
   \   0000004C   0x6404             STR      R4,[R0, #+64]
   1750          
   1751              /* Prepare transfer parameters */
   1752              hi2c->pBuffPtr    = pData;
   \   0000004E   0x6241             STR      R1,[R0, #+36]
   1753              hi2c->XferCount   = Size;
   \   00000050   0x8542             STRH     R2,[R0, #+42]
   1754              hi2c->XferOptions = XferOptions;
   \   00000052   0x62C3             STR      R3,[R0, #+44]
   1755              hi2c->XferSize    = hi2c->XferCount;
   \   00000054   0x8D41             LDRH     R1,[R0, #+42]
   \   00000056   0x8501             STRH     R1,[R0, #+40]
   1756          
   1757              /* Clear ADDR flag */
   1758              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   00000058   0x4621             MOV      R1,R4
   \   0000005A   0x9100             STR      R1,[SP, #+0]
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0x694A             LDR      R2,[R1, #+20]
   \   00000060   0x9200             STR      R2,[SP, #+0]
   \   00000062   0x6989             LDR      R1,[R1, #+24]
   \   00000064   0x9100             STR      R1,[SP, #+0]
   \   00000066   0x9900             LDR      R1,[SP, #+0]
   1759          
   1760              /* Process Unlocked */
   1761              __HAL_UNLOCK(hi2c);
   \   00000068   0x4621             MOV      R1,R4
   \   0000006A   0xF880 0x103C      STRB     R1,[R0, #+60]
   1762          
   1763              /* Note : The I2C interrupts must be enabled after unlocking current process
   1764                        to avoid the risk of I2C interrupt handle execution before current
   1765                        process unlock */
   1766          
   1767              /* Enable EVT, BUF and ERR interrupt */
   1768              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x6841             LDR      R1,[R0, #+4]
   \   00000072   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   00000076   0x6041             STR      R1,[R0, #+4]
   1769          
   1770              return HAL_OK;
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0xE000             B.N      ??HAL_I2C_Slave_Sequential_Transmit_IT_3
   1771            }
   1772            else
   1773            {
   1774              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Sequential_Transmit_IT_0: (+1)
   \   0000007C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Sequential_Transmit_IT_3: (+1)
   \   0000007E   0xBC32             POP      {R1,R4,R5}
   \   00000080   0x4770             BX       LR               ;; return
   1775            }
   1776          }
   1777          
   1778          /**
   1779            * @brief  Sequential receive in slave mode an amount of data in non-blocking mode with Interrupt
   1780            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   1781            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1782            *         the configuration information for the specified I2C.
   1783            * @param  pData Pointer to data buffer
   1784            * @param  Size Amount of data to be sent
   1785            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   1786            * @retval HAL status
   1787            */

   \                                 In section .text, align 2, keep-with-next
   1788          HAL_StatusTypeDef HAL_I2C_Slave_Sequential_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   1789          {
   \                     HAL_I2C_Slave_Sequential_Receive_IT: (+1)
   \   00000000   0xB438             PUSH     {R3-R5}
   1790            /* Check the parameters */
   1791            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   1792          
   1793            if(hi2c->State == HAL_I2C_STATE_LISTEN)
   \   00000002   0xF890 0x403D      LDRB     R4,[R0, #+61]
   \   00000006   0x2C28             CMP      R4,#+40
   \   00000008   0xD138             BNE.N    ??HAL_I2C_Slave_Sequential_Receive_IT_0
   1794            {
   1795              if((pData == NULL) || (Size == 0U))
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD001             BEQ.N    ??HAL_I2C_Slave_Sequential_Receive_IT_1
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD101             BNE.N    ??HAL_I2C_Slave_Sequential_Receive_IT_2
   1796              {
   1797                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Sequential_Receive_IT_1: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE033             B.N      ??HAL_I2C_Slave_Sequential_Receive_IT_3
   1798              }
   1799          
   1800              /* Process Locked */
   1801              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Sequential_Receive_IT_2: (+1)
   \   00000016   0xF990 0x403C      LDRSB    R4,[R0, #+60]
   \   0000001A   0x2C01             CMP      R4,#+1
   \   0000001C   0xD02E             BEQ.N    ??HAL_I2C_Slave_Sequential_Receive_IT_0
   \   0000001E   0x2401             MOVS     R4,#+1
   \   00000020   0xF880 0x403C      STRB     R4,[R0, #+60]
   1802          
   1803              /* Check if the I2C is already enabled */
   1804              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   00000024   0x6804             LDR      R4,[R0, #+0]
   \   00000026   0x6825             LDR      R5,[R4, #+0]
   \   00000028   0x07ED             LSLS     R5,R5,#+31
   \   0000002A   0xD403             BMI.N    ??HAL_I2C_Slave_Sequential_Receive_IT_4
   1805              {
   1806                /* Enable I2C peripheral */
   1807                __HAL_I2C_ENABLE(hi2c);
   \   0000002C   0x6825             LDR      R5,[R4, #+0]
   \   0000002E   0xF045 0x0501      ORR      R5,R5,#0x1
   \   00000032   0x6025             STR      R5,[R4, #+0]
   1808              }
   1809          
   1810              /* Disable Pos */
   1811              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Slave_Sequential_Receive_IT_4: (+1)
   \   00000034   0x6804             LDR      R4,[R0, #+0]
   \   00000036   0x6825             LDR      R5,[R4, #+0]
   \   00000038   0xF425 0x6500      BIC      R5,R5,#0x800
   \   0000003C   0x6025             STR      R5,[R4, #+0]
   1812          
   1813              hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
   \   0000003E   0x242A             MOVS     R4,#+42
   \   00000040   0xF880 0x403D      STRB     R4,[R0, #+61]
   1814              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \   00000044   0x2420             MOVS     R4,#+32
   \   00000046   0xF880 0x403E      STRB     R4,[R0, #+62]
   1815              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000004A   0x2400             MOVS     R4,#+0
   \   0000004C   0x6404             STR      R4,[R0, #+64]
   1816          
   1817              /* Prepare transfer parameters */
   1818              hi2c->pBuffPtr   = pData;
   \   0000004E   0x6241             STR      R1,[R0, #+36]
   1819              hi2c->XferCount   = Size;
   \   00000050   0x8542             STRH     R2,[R0, #+42]
   1820              hi2c->XferOptions = XferOptions;
   \   00000052   0x62C3             STR      R3,[R0, #+44]
   1821              hi2c->XferSize    = hi2c->XferCount;
   \   00000054   0x8D41             LDRH     R1,[R0, #+42]
   \   00000056   0x8501             STRH     R1,[R0, #+40]
   1822          
   1823              /* Clear ADDR flag */
   1824              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   00000058   0x4621             MOV      R1,R4
   \   0000005A   0x9100             STR      R1,[SP, #+0]
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0x694A             LDR      R2,[R1, #+20]
   \   00000060   0x9200             STR      R2,[SP, #+0]
   \   00000062   0x6989             LDR      R1,[R1, #+24]
   \   00000064   0x9100             STR      R1,[SP, #+0]
   \   00000066   0x9900             LDR      R1,[SP, #+0]
   1825          
   1826              /* Process Unlocked */
   1827              __HAL_UNLOCK(hi2c);
   \   00000068   0x4621             MOV      R1,R4
   \   0000006A   0xF880 0x103C      STRB     R1,[R0, #+60]
   1828          
   1829              /* Note : The I2C interrupts must be enabled after unlocking current process
   1830                        to avoid the risk of I2C interrupt handle execution before current
   1831                        process unlock */
   1832          
   1833              /* Enable EVT, BUF and ERR interrupt */
   1834              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x6841             LDR      R1,[R0, #+4]
   \   00000072   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   00000076   0x6041             STR      R1,[R0, #+4]
   1835          
   1836              return HAL_OK;
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0xE000             B.N      ??HAL_I2C_Slave_Sequential_Receive_IT_3
   1837            }
   1838            else
   1839            {
   1840              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Sequential_Receive_IT_0: (+1)
   \   0000007C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Sequential_Receive_IT_3: (+1)
   \   0000007E   0xBC32             POP      {R1,R4,R5}
   \   00000080   0x4770             BX       LR               ;; return
   1841            }
   1842          }
   1843          
   1844          /**
   1845            * @brief  Enable the Address listen mode with Interrupt.
   1846            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1847            *                the configuration information for the specified I2C.
   1848            * @retval HAL status
   1849            */

   \                                 In section .text, align 2, keep-with-next
   1850          HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
   1851          {
   1852            if(hi2c->State == HAL_I2C_STATE_READY)
   \                     HAL_I2C_EnableListen_IT: (+1)
   \   00000000   0xF890 0x103D      LDRB     R1,[R0, #+61]
   \   00000004   0x2920             CMP      R1,#+32
   \   00000006   0xD116             BNE.N    ??HAL_I2C_EnableListen_IT_0
   1853            {
   1854              hi2c->State = HAL_I2C_STATE_LISTEN;
   \   00000008   0x2128             MOVS     R1,#+40
   \   0000000A   0xF880 0x103D      STRB     R1,[R0, #+61]
   1855              
   1856              /* Check if the I2C is already enabled */
   1857              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0x07D2             LSLS     R2,R2,#+31
   \   00000014   0xD403             BMI.N    ??HAL_I2C_EnableListen_IT_1
   1858              {
   1859                /* Enable I2C peripheral */
   1860                __HAL_I2C_ENABLE(hi2c);
   \   00000016   0x680A             LDR      R2,[R1, #+0]
   \   00000018   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000001C   0x600A             STR      R2,[R1, #+0]
   1861              }
   1862          
   1863              /* Enable Address Acknowledge */
   1864              hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \                     ??HAL_I2C_EnableListen_IT_1: (+1)
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x680A             LDR      R2,[R1, #+0]
   \   00000022   0xF442 0x6280      ORR      R2,R2,#0x400
   \   00000026   0x600A             STR      R2,[R1, #+0]
   1865          
   1866              /* Enable EVT and ERR interrupt */
   1867              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x6841             LDR      R1,[R0, #+4]
   \   0000002C   0xF441 0x7140      ORR      R1,R1,#0x300
   \   00000030   0x6041             STR      R1,[R0, #+4]
   1868          
   1869              return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x4770             BX       LR
   1870            }
   1871            else
   1872            {
   1873              return HAL_BUSY;
   \                     ??HAL_I2C_EnableListen_IT_0: (+1)
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0x4770             BX       LR               ;; return
   1874            }
   1875          }
   1876          
   1877          /**
   1878            * @brief  Disable the Address listen mode with Interrupt.
   1879            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1880            *                the configuration information for the specified I2C.
   1881            * @retval HAL status
   1882            */

   \                                 In section .text, align 2, keep-with-next
   1883          HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
   1884          {
   1885            /* Declaration of tmp to prevent undefined behavior of volatile usage */
   1886            uint32_t tmp;
   1887          
   1888            /* Disable Address listen mode only if a transfer is not ongoing */
   1889            if(hi2c->State == HAL_I2C_STATE_LISTEN)
   \                     HAL_I2C_DisableListen_IT: (+1)
   \   00000000   0xF890 0x103D      LDRB     R1,[R0, #+61]
   \   00000004   0x2928             CMP      R1,#+40
   \   00000006   0xD119             BNE.N    ??HAL_I2C_DisableListen_IT_0
   1890            {
   1891              tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
   \   00000008   0xF890 0x103D      LDRB     R1,[R0, #+61]
   \   0000000C   0xF001 0x0103      AND      R1,R1,#0x3
   1892              hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
   \   00000010   0xF990 0x203E      LDRSB    R2,[R0, #+62]
   \   00000014   0x4311             ORRS     R1,R2,R1
   \   00000016   0x6301             STR      R1,[R0, #+48]
   1893              hi2c->State = HAL_I2C_STATE_READY;
   \   00000018   0x2120             MOVS     R1,#+32
   \   0000001A   0xF880 0x103D      STRB     R1,[R0, #+61]
   1894              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xF880 0x103E      STRB     R1,[R0, #+62]
   1895          
   1896              /* Disable Address Acknowledge */
   1897              hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x680A             LDR      R2,[R1, #+0]
   \   00000028   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000002C   0x600A             STR      R2,[R1, #+0]
   1898          
   1899              /* Disable EVT and ERR interrupt */
   1900              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x6841             LDR      R1,[R0, #+4]
   \   00000032   0xF421 0x7140      BIC      R1,R1,#0x300
   \   00000036   0x6041             STR      R1,[R0, #+4]
   1901            
   1902              return HAL_OK;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x4770             BX       LR
   1903            }
   1904            else
   1905            {
   1906              return HAL_BUSY;
   \                     ??HAL_I2C_DisableListen_IT_0: (+1)
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0x4770             BX       LR               ;; return
   1907            }
   1908          }
   1909          
   1910          /**
   1911            * @brief  Transmit in master mode an amount of data in non-blocking mode with DMA
   1912            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1913            *                the configuration information for the specified I2C.
   1914            * @param  DevAddress Target device address: The device 7 bits address value
   1915            *         in datasheet must be shift at right before call interface
   1916            * @param  pData Pointer to data buffer
   1917            * @param  Size Amount of data to be sent
   1918            * @retval HAL status
   1919            */

   \                                 In section .text, align 2, keep-with-next
   1920          HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1921          {
   \                     HAL_I2C_Master_Transmit_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1922            __IO uint32_t count = 0U;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
   1923          
   1924            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000008   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000C   0x2820             CMP      R0,#+32
   \   0000000E   0xF040 0x808B      BNE.W    ??HAL_I2C_Master_Transmit_DMA_0
   1925            {
   1926              /* Wait until BUSY flag is reset */
   1927              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x2519             MOVS     R5,#+25
   \   0000001A   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   0000001E   0xF44F 0x757A      MOV      R5,#+1000
   \   00000022   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   00000026   0x2519             MOVS     R5,#+25
   \   00000028   0x4368             MULS     R0,R5,R0
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   1928              do
   1929              {
   1930                if(count-- == 0U)
   \                     ??HAL_I2C_Master_Transmit_DMA_1: (+1)
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0x1E45             SUBS     R5,R0,#+1
   \   00000030   0x9500             STR      R5,[SP, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD109             BNE.N    ??HAL_I2C_Master_Transmit_DMA_2
   1931                {
   1932                  hi2c->PreviousState = I2C_STATE_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6320             STR      R0,[R4, #+48]
   1933                  hi2c->State= HAL_I2C_STATE_READY;
   \   0000003A   0x2020             MOVS     R0,#+32
   \   0000003C   0xF884 0x003D      STRB     R0,[R4, #+61]
   1934          
   1935                  /* Process Unlocked */
   1936                  __HAL_UNLOCK(hi2c);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x003C      STRB     R0,[R4, #+60]
   1937          
   1938                  return HAL_TIMEOUT; 
   \   00000046   0x2003             MOVS     R0,#+3
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}
   1939                }
   1940              }
   1941              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Master_Transmit_DMA_2: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6980             LDR      R0,[R0, #+24]
   \   0000004E   0x0780             LSLS     R0,R0,#+30
   \   00000050   0xD4EC             BMI.N    ??HAL_I2C_Master_Transmit_DMA_1
   1942          
   1943              /* Process Locked */
   1944              __HAL_LOCK(hi2c);
   \   00000052   0xF994 0x003C      LDRSB    R0,[R4, #+60]
   \   00000056   0x2801             CMP      R0,#+1
   \   00000058   0xD066             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_0
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xF884 0x003C      STRB     R0,[R4, #+60]
   1945          
   1946              /* Check if the I2C is already enabled */
   1947              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6805             LDR      R5,[R0, #+0]
   \   00000064   0x07ED             LSLS     R5,R5,#+31
   \   00000066   0xD403             BMI.N    ??HAL_I2C_Master_Transmit_DMA_3
   1948              {
   1949                /* Enable I2C peripheral */
   1950                __HAL_I2C_ENABLE(hi2c);
   \   00000068   0x6805             LDR      R5,[R0, #+0]
   \   0000006A   0xF045 0x0501      ORR      R5,R5,#0x1
   \   0000006E   0x6005             STR      R5,[R0, #+0]
   1951              }
   1952          
   1953              /* Disable Pos */
   1954              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Master_Transmit_DMA_3: (+1)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6805             LDR      R5,[R0, #+0]
   \   00000074   0xF425 0x6500      BIC      R5,R5,#0x800
   \   00000078   0x6005             STR      R5,[R0, #+0]
   1955          
   1956              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \   0000007A   0x2021             MOVS     R0,#+33
   \   0000007C   0xF884 0x003D      STRB     R0,[R4, #+61]
   1957              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \   00000080   0x2010             MOVS     R0,#+16
   \   00000082   0xF884 0x003E      STRB     R0,[R4, #+62]
   1958              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x6420             STR      R0,[R4, #+64]
   1959          
   1960              /* Prepare transfer parameters */
   1961              hi2c->pBuffPtr    = pData;
   \   0000008A   0x6262             STR      R2,[R4, #+36]
   1962              hi2c->XferCount   = Size;
   \   0000008C   0x8563             STRH     R3,[R4, #+42]
   1963              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   0000008E   0x....             LDR.N    R0,??DataTable11  ;; 0xffff0000
   \   00000090   0x62E0             STR      R0,[R4, #+44]
   1964              hi2c->XferSize    = hi2c->XferCount;
   \   00000092   0x8D60             LDRH     R0,[R4, #+42]
   \   00000094   0x8520             STRH     R0,[R4, #+40]
   1965              hi2c->Devaddress  = DevAddress;
   \   00000096   0x6461             STR      R1,[R4, #+68]
   1966          
   1967              if(hi2c->XferSize > 0U)
   \   00000098   0x8D20             LDRH     R0,[R4, #+40]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD030             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_4
   1968              {
   1969                /* Set the I2C DMA transfer complete callback */
   1970                hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000A2   0x6B61             LDR      R1,[R4, #+52]
   \   000000A4   0x63C8             STR      R0,[R1, #+60]
   1971          
   1972                /* Set the DMA error callback */      
   1973                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   000000AA   0x6B61             LDR      R1,[R4, #+52]
   \   000000AC   0x64C8             STR      R0,[R1, #+76]
   1974          
   1975                /* Set the unused DMA callbacks to NULL */
   1976                hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x6B61             LDR      R1,[R4, #+52]
   \   000000B2   0x6408             STR      R0,[R1, #+64]
   1977                hi2c->hdmatx->XferM1CpltCallback = NULL;
   \   000000B4   0x6B61             LDR      R1,[R4, #+52]
   \   000000B6   0x6448             STR      R0,[R1, #+68]
   1978                hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
   \   000000B8   0x6B61             LDR      R1,[R4, #+52]
   \   000000BA   0x6488             STR      R0,[R1, #+72]
   1979                hi2c->hdmatx->XferAbortCallback = NULL;
   \   000000BC   0x6B61             LDR      R1,[R4, #+52]
   \   000000BE   0x6508             STR      R0,[R1, #+80]
   1980          
   1981                /* Enable the DMA Stream */
   1982                HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
   \   000000C0   0x8D23             LDRH     R3,[R4, #+40]
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0xF100 0x0210      ADD      R2,R0,#+16
   \   000000C8   0x6A61             LDR      R1,[R4, #+36]
   \   000000CA   0x6B60             LDR      R0,[R4, #+52]
   \   000000CC   0x.... 0x....      BL       HAL_DMA_Start_IT
   1983          
   1984                /* Enable Acknowledge */
   1985                hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6801             LDR      R1,[R0, #+0]
   \   000000D4   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000D8   0x6001             STR      R1,[R0, #+0]
   1986          
   1987                /* Generate Start */
   1988                hi2c->Instance->CR1 |= I2C_CR1_START;
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x6801             LDR      R1,[R0, #+0]
   \   000000DE   0xF441 0x7180      ORR      R1,R1,#0x100
   \   000000E2   0x6001             STR      R1,[R0, #+0]
   1989          
   1990                /* Process Unlocked */
   1991                __HAL_UNLOCK(hi2c);
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0xF884 0x003C      STRB     R0,[R4, #+60]
   1992          
   1993                /* Note : The I2C interrupts must be enabled after unlocking current process
   1994                to avoid the risk of I2C interrupt handle execution before current
   1995                process unlock */
   1996          
   1997                /* Enable EVT and ERR interrupt */
   1998                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x6841             LDR      R1,[R0, #+4]
   \   000000EE   0xF441 0x7140      ORR      R1,R1,#0x300
   \   000000F2   0x6041             STR      R1,[R0, #+4]
   1999          
   2000                /* Enable DMA Request */
   2001                hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0x6841             LDR      R1,[R0, #+4]
   \   000000F8   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000FC   0x6041             STR      R1,[R0, #+4]
   \   000000FE   0xE011             B.N      ??HAL_I2C_Master_Transmit_DMA_5
   2002              }
   2003              else
   2004              {
   2005                /* Enable Acknowledge */
   2006                hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \                     ??HAL_I2C_Master_Transmit_DMA_4: (+1)
   \   00000100   0x6820             LDR      R0,[R4, #+0]
   \   00000102   0x6801             LDR      R1,[R0, #+0]
   \   00000104   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000108   0x6001             STR      R1,[R0, #+0]
   2007          
   2008                /* Generate Start */
   2009                hi2c->Instance->CR1 |= I2C_CR1_START;
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0x6801             LDR      R1,[R0, #+0]
   \   0000010E   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000112   0x6001             STR      R1,[R0, #+0]
   2010          
   2011                /* Process Unlocked */
   2012                __HAL_UNLOCK(hi2c);
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0xF884 0x003C      STRB     R0,[R4, #+60]
   2013          
   2014                /* Note : The I2C interrupts must be enabled after unlocking current process
   2015                to avoid the risk of I2C interrupt handle execution before current
   2016                process unlock */
   2017          
   2018               /* Enable EVT, BUF and ERR interrupt */
   2019              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0x6841             LDR      R1,[R0, #+4]
   \   0000011E   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   00000122   0x6041             STR      R1,[R0, #+4]
   2020              }
   2021          
   2022              return HAL_OK;
   \                     ??HAL_I2C_Master_Transmit_DMA_5: (+1)
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0xBD32             POP      {R1,R4,R5,PC}
   2023            }
   2024            else
   2025            {
   2026              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_DMA_0: (+1)
   \   00000128   0x2002             MOVS     R0,#+2
   \   0000012A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2027            }
   2028          }
   2029          
   2030          /**
   2031            * @brief  Receive in master mode an amount of data in non-blocking mode with DMA 
   2032            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2033            *                the configuration information for the specified I2C.
   2034            * @param  DevAddress Target device address: The device 7 bits address value
   2035            *         in datasheet must be shift at right before call interface
   2036            * @param  pData Pointer to data buffer
   2037            * @param  Size Amount of data to be sent
   2038            * @retval HAL status
   2039            */

   \                                 In section .text, align 2, keep-with-next
   2040          HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   2041          {
   \                     HAL_I2C_Master_Receive_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   2042            __IO uint32_t count = 0U;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
   2043          
   2044            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000008   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000C   0x2820             CMP      R0,#+32
   \   0000000E   0xF040 0x808C      BNE.W    ??HAL_I2C_Master_Receive_DMA_0
   2045            {
   2046              /* Wait until BUSY flag is reset */
   2047              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x2519             MOVS     R5,#+25
   \   0000001A   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   0000001E   0xF44F 0x757A      MOV      R5,#+1000
   \   00000022   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   00000026   0x2519             MOVS     R5,#+25
   \   00000028   0x4368             MULS     R0,R5,R0
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   2048              do
   2049              {
   2050                if(count-- == 0U)
   \                     ??HAL_I2C_Master_Receive_DMA_1: (+1)
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0x1E45             SUBS     R5,R0,#+1
   \   00000030   0x9500             STR      R5,[SP, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD109             BNE.N    ??HAL_I2C_Master_Receive_DMA_2
   2051                {
   2052                  hi2c->PreviousState = I2C_STATE_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6320             STR      R0,[R4, #+48]
   2053                  hi2c->State= HAL_I2C_STATE_READY;
   \   0000003A   0x2020             MOVS     R0,#+32
   \   0000003C   0xF884 0x003D      STRB     R0,[R4, #+61]
   2054          
   2055                  /* Process Unlocked */
   2056                  __HAL_UNLOCK(hi2c);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x003C      STRB     R0,[R4, #+60]
   2057          
   2058                  return HAL_TIMEOUT; 
   \   00000046   0x2003             MOVS     R0,#+3
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}
   2059                }
   2060              }
   2061              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Master_Receive_DMA_2: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6980             LDR      R0,[R0, #+24]
   \   0000004E   0x0780             LSLS     R0,R0,#+30
   \   00000050   0xD4EC             BMI.N    ??HAL_I2C_Master_Receive_DMA_1
   2062          
   2063              /* Process Locked */
   2064              __HAL_LOCK(hi2c);
   \   00000052   0xF994 0x003C      LDRSB    R0,[R4, #+60]
   \   00000056   0x2801             CMP      R0,#+1
   \   00000058   0xD067             BEQ.N    ??HAL_I2C_Master_Receive_DMA_0
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xF884 0x003C      STRB     R0,[R4, #+60]
   2065              
   2066              /* Check if the I2C is already enabled */
   2067              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6805             LDR      R5,[R0, #+0]
   \   00000064   0x07ED             LSLS     R5,R5,#+31
   \   00000066   0xD403             BMI.N    ??HAL_I2C_Master_Receive_DMA_3
   2068              {
   2069                /* Enable I2C peripheral */
   2070                __HAL_I2C_ENABLE(hi2c);
   \   00000068   0x6805             LDR      R5,[R0, #+0]
   \   0000006A   0xF045 0x0501      ORR      R5,R5,#0x1
   \   0000006E   0x6005             STR      R5,[R0, #+0]
   2071              }
   2072          
   2073              /* Disable Pos */
   2074              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Master_Receive_DMA_3: (+1)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6805             LDR      R5,[R0, #+0]
   \   00000074   0xF425 0x6500      BIC      R5,R5,#0x800
   \   00000078   0x6005             STR      R5,[R0, #+0]
   2075              
   2076              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \   0000007A   0x2022             MOVS     R0,#+34
   \   0000007C   0xF884 0x003D      STRB     R0,[R4, #+61]
   2077              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \   00000080   0x2010             MOVS     R0,#+16
   \   00000082   0xF884 0x003E      STRB     R0,[R4, #+62]
   2078              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x6420             STR      R0,[R4, #+64]
   2079              
   2080              /* Prepare transfer parameters */
   2081              hi2c->pBuffPtr    = pData;
   \   0000008A   0x6262             STR      R2,[R4, #+36]
   2082              hi2c->XferCount   = Size;
   \   0000008C   0x8563             STRH     R3,[R4, #+42]
   2083              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0xffff0000
   \   00000092   0x62E0             STR      R0,[R4, #+44]
   2084              hi2c->XferSize    = hi2c->XferCount;
   \   00000094   0x8D60             LDRH     R0,[R4, #+42]
   \   00000096   0x8520             STRH     R0,[R4, #+40]
   2085              hi2c->Devaddress  = DevAddress;
   \   00000098   0x6461             STR      R1,[R4, #+68]
   2086              
   2087              if(hi2c->XferSize > 0U)
   \   0000009A   0x8D20             LDRH     R0,[R4, #+40]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD030             BEQ.N    ??HAL_I2C_Master_Receive_DMA_4
   2088              {
   2089                /* Set the I2C DMA transfer complete callback */
   2090                hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000A4   0x6BA1             LDR      R1,[R4, #+56]
   \   000000A6   0x63C8             STR      R0,[R1, #+60]
   2091          
   2092                /* Set the DMA error callback */
   2093                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   000000AC   0x6BA1             LDR      R1,[R4, #+56]
   \   000000AE   0x64C8             STR      R0,[R1, #+76]
   2094          
   2095                /* Set the unused DMA callbacks to NULL */
   2096                hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x6BA1             LDR      R1,[R4, #+56]
   \   000000B4   0x6408             STR      R0,[R1, #+64]
   2097                hi2c->hdmarx->XferM1CpltCallback = NULL;
   \   000000B6   0x6BA1             LDR      R1,[R4, #+56]
   \   000000B8   0x6448             STR      R0,[R1, #+68]
   2098                hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
   \   000000BA   0x6BA1             LDR      R1,[R4, #+56]
   \   000000BC   0x6488             STR      R0,[R1, #+72]
   2099                hi2c->hdmarx->XferAbortCallback = NULL;
   \   000000BE   0x6BA1             LDR      R1,[R4, #+56]
   \   000000C0   0x6508             STR      R0,[R1, #+80]
   2100          
   2101                /* Enable the DMA Stream */
   2102                HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   \   000000C2   0x8D23             LDRH     R3,[R4, #+40]
   \   000000C4   0x6A62             LDR      R2,[R4, #+36]
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0xF100 0x0110      ADD      R1,R0,#+16
   \   000000CC   0x6BA0             LDR      R0,[R4, #+56]
   \   000000CE   0x.... 0x....      BL       HAL_DMA_Start_IT
   2103          
   2104                /* Enable Acknowledge */
   2105                hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6801             LDR      R1,[R0, #+0]
   \   000000D6   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000DA   0x6001             STR      R1,[R0, #+0]
   2106          
   2107                /* Generate Start */
   2108                hi2c->Instance->CR1 |= I2C_CR1_START;
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x6801             LDR      R1,[R0, #+0]
   \   000000E0   0xF441 0x7180      ORR      R1,R1,#0x100
   \   000000E4   0x6001             STR      R1,[R0, #+0]
   2109          
   2110                /* Process Unlocked */
   2111                __HAL_UNLOCK(hi2c);
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xF884 0x003C      STRB     R0,[R4, #+60]
   2112          
   2113                /* Note : The I2C interrupts must be enabled after unlocking current process
   2114                          to avoid the risk of I2C interrupt handle execution before current
   2115                          process unlock */
   2116          
   2117                /* Enable EVT and ERR interrupt */
   2118                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x6841             LDR      R1,[R0, #+4]
   \   000000F0   0xF441 0x7140      ORR      R1,R1,#0x300
   \   000000F4   0x6041             STR      R1,[R0, #+4]
   2119          
   2120                /* Enable DMA Request */
   2121                hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x6841             LDR      R1,[R0, #+4]
   \   000000FA   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000FE   0x6041             STR      R1,[R0, #+4]
   \   00000100   0xE011             B.N      ??HAL_I2C_Master_Receive_DMA_5
   2122              }
   2123              else
   2124              {
   2125                /* Enable Acknowledge */
   2126                hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \                     ??HAL_I2C_Master_Receive_DMA_4: (+1)
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x6801             LDR      R1,[R0, #+0]
   \   00000106   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000010A   0x6001             STR      R1,[R0, #+0]
   2127          
   2128                /* Generate Start */
   2129                hi2c->Instance->CR1 |= I2C_CR1_START;
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x6801             LDR      R1,[R0, #+0]
   \   00000110   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000114   0x6001             STR      R1,[R0, #+0]
   2130          
   2131                /* Process Unlocked */
   2132                __HAL_UNLOCK(hi2c);
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xF884 0x003C      STRB     R0,[R4, #+60]
   2133          
   2134                /* Note : The I2C interrupts must be enabled after unlocking current process
   2135                to avoid the risk of I2C interrupt handle execution before current
   2136                process unlock */
   2137          
   2138                /* Enable EVT, BUF and ERR interrupt */
   2139                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   0000011C   0x6820             LDR      R0,[R4, #+0]
   \   0000011E   0x6841             LDR      R1,[R0, #+4]
   \   00000120   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   00000124   0x6041             STR      R1,[R0, #+4]
   2140              }
   2141              
   2142              return HAL_OK;
   \                     ??HAL_I2C_Master_Receive_DMA_5: (+1)
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xBD32             POP      {R1,R4,R5,PC}
   2143            }
   2144            else
   2145            {
   2146              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_DMA_0: (+1)
   \   0000012A   0x2002             MOVS     R0,#+2
   \   0000012C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2147            }
   2148          }
   2149          
   2150          /**
   2151            * @brief  Abort a master I2C process communication with Interrupt.
   2152            * @note   This abort can be called only if state is ready
   2153            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2154            *         the configuration information for the specified I2C.
   2155            * @param  DevAddress Target device address: The device 7 bits address value
   2156            *         in datasheet must be shift at right before call interface
   2157            * @retval HAL status
   2158            */

   \                                 In section .text, align 2, keep-with-next
   2159          HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
   2160          {
   \                     HAL_I2C_Master_Abort_IT: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2161            /* Abort Master transfer during Receive or Transmit process    */
   2162            if(hi2c->Mode == HAL_I2C_MODE_MASTER)
   \   00000002   0xF990 0x103E      LDRSB    R1,[R0, #+62]
   \   00000006   0x2910             CMP      R1,#+16
   \   00000008   0xD125             BNE.N    ??HAL_I2C_Master_Abort_IT_0
   2163            {
   2164              /* Process Locked */
   2165              __HAL_LOCK(hi2c);
   \   0000000A   0xF990 0x103C      LDRSB    R1,[R0, #+60]
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD101             BNE.N    ??HAL_I2C_Master_Abort_IT_1
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xBD02             POP      {R1,PC}
   \                     ??HAL_I2C_Master_Abort_IT_1: (+1)
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0xF880 0x103C      STRB     R1,[R0, #+60]
   2166          
   2167              hi2c->PreviousState = I2C_STATE_NONE;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6301             STR      R1,[R0, #+48]
   2168              hi2c->State = HAL_I2C_STATE_ABORT;
   \   00000020   0x2160             MOVS     R1,#+96
   \   00000022   0xF880 0x103D      STRB     R1,[R0, #+61]
   2169          
   2170              /* Disable Acknowledge */
   2171              hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000002E   0x600A             STR      R2,[R1, #+0]
   2172          
   2173              /* Generate Stop */
   2174              hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0x680A             LDR      R2,[R1, #+0]
   \   00000034   0xF442 0x7200      ORR      R2,R2,#0x200
   \   00000038   0x600A             STR      R2,[R1, #+0]
   2175          
   2176              hi2c->XferCount = 0U;
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x8541             STRH     R1,[R0, #+42]
   2177          
   2178              /* Disable EVT, BUF and ERR interrupt */
   2179              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0x684A             LDR      R2,[R1, #+4]
   \   00000042   0xF422 0x62E0      BIC      R2,R2,#0x700
   \   00000046   0x604A             STR      R2,[R1, #+4]
   2180          
   2181              /* Process Unlocked */
   2182              __HAL_UNLOCK(hi2c);
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xF880 0x103C      STRB     R1,[R0, #+60]
   2183          
   2184              /* Call the corresponding callback to inform upper layer of End of Transfer */
   2185              I2C_ITError(hi2c);
   \   0000004E   0x.... 0x....      BL       I2C_ITError
   2186          
   2187              return HAL_OK;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xBD02             POP      {R1,PC}
   2188            }
   2189            else
   2190            {
   2191              /* Wrong usage of abort function */
   2192              /* This function should be used only in case of abort monitored by master device */
   2193              return HAL_ERROR;
   \                     ??HAL_I2C_Master_Abort_IT_0: (+1)
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0xBD02             POP      {R1,PC}          ;; return
   2194            }
   2195          }
   2196          
   2197          /**
   2198            * @brief  Transmit in slave mode an amount of data in non-blocking mode with DMA 
   2199            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2200            *                the configuration information for the specified I2C.
   2201            * @param  pData Pointer to data buffer
   2202            * @param  Size Amount of data to be sent
   2203            * @retval HAL status
   2204            */

   \                                 In section .text, align 2, keep-with-next
   2205          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   2206          {
   \                     HAL_I2C_Slave_Transmit_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   2207            __IO uint32_t count = 0U;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   2208            
   2209            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xD174             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_0
   2210            {
   2211              if((pData == NULL) || (Size == 0U))
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_1
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_2
   2212              {
   2213                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Transmit_DMA_1: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBD16             POP      {R1,R2,R4,PC}
   2214              }
   2215          
   2216              /* Wait until BUSY flag is reset */
   2217              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
   \                     ??HAL_I2C_Slave_Transmit_DMA_2: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable15
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x2319             MOVS     R3,#+25
   \   00000024   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000028   0xF44F 0x737A      MOV      R3,#+1000
   \   0000002C   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000030   0x2319             MOVS     R3,#+25
   \   00000032   0x4358             MULS     R0,R3,R0
   \   00000034   0x9000             STR      R0,[SP, #+0]
   2218              do
   2219              {
   2220                if(count-- == 0U)
   \                     ??HAL_I2C_Slave_Transmit_DMA_3: (+1)
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0x1E43             SUBS     R3,R0,#+1
   \   0000003A   0x9300             STR      R3,[SP, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD109             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_4
   2221                {
   2222                  hi2c->PreviousState = I2C_STATE_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6320             STR      R0,[R4, #+48]
   2223                  hi2c->State= HAL_I2C_STATE_READY;
   \   00000044   0x2020             MOVS     R0,#+32
   \   00000046   0xF884 0x003D      STRB     R0,[R4, #+61]
   2224          
   2225                  /* Process Unlocked */
   2226                  __HAL_UNLOCK(hi2c);
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF884 0x003C      STRB     R0,[R4, #+60]
   2227          
   2228                  return HAL_TIMEOUT; 
   \   00000050   0x2003             MOVS     R0,#+3
   \   00000052   0xBD16             POP      {R1,R2,R4,PC}
   2229                }
   2230              }
   2231              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Slave_Transmit_DMA_4: (+1)
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6980             LDR      R0,[R0, #+24]
   \   00000058   0x0780             LSLS     R0,R0,#+30
   \   0000005A   0xD4EC             BMI.N    ??HAL_I2C_Slave_Transmit_DMA_3
   2232          
   2233              /* Process Locked */
   2234              __HAL_LOCK(hi2c);
   \   0000005C   0xF994 0x003C      LDRSB    R0,[R4, #+60]
   \   00000060   0x2801             CMP      R0,#+1
   \   00000062   0xD04B             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_0
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xF884 0x003C      STRB     R0,[R4, #+60]
   2235          
   2236              /* Check if the I2C is already enabled */
   2237              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6803             LDR      R3,[R0, #+0]
   \   0000006E   0x07DB             LSLS     R3,R3,#+31
   \   00000070   0xD403             BMI.N    ??HAL_I2C_Slave_Transmit_DMA_5
   2238              {
   2239                /* Enable I2C peripheral */
   2240                __HAL_I2C_ENABLE(hi2c);
   \   00000072   0x6803             LDR      R3,[R0, #+0]
   \   00000074   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000078   0x6003             STR      R3,[R0, #+0]
   2241              }
   2242          
   2243              /* Disable Pos */
   2244              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Slave_Transmit_DMA_5: (+1)
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6803             LDR      R3,[R0, #+0]
   \   0000007E   0xF423 0x6300      BIC      R3,R3,#0x800
   \   00000082   0x6003             STR      R3,[R0, #+0]
   2245          
   2246              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \   00000084   0x2021             MOVS     R0,#+33
   \   00000086   0xF884 0x003D      STRB     R0,[R4, #+61]
   2247              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \   0000008A   0x2020             MOVS     R0,#+32
   \   0000008C   0xF884 0x003E      STRB     R0,[R4, #+62]
   2248              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x6420             STR      R0,[R4, #+64]
   2249          
   2250              /* Prepare transfer parameters */
   2251              hi2c->pBuffPtr    = pData;
   \   00000094   0x6261             STR      R1,[R4, #+36]
   2252              hi2c->XferCount   = Size;
   \   00000096   0x8562             STRH     R2,[R4, #+42]
   2253              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0xffff0000
   \   0000009C   0x62E0             STR      R0,[R4, #+44]
   2254              hi2c->XferSize    = hi2c->XferCount;
   \   0000009E   0x8D60             LDRH     R0,[R4, #+42]
   \   000000A0   0x8520             STRH     R0,[R4, #+40]
   2255          
   2256              /* Set the I2C DMA transfer complete callback */
   2257              hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000A6   0x6B61             LDR      R1,[R4, #+52]
   \   000000A8   0x63C8             STR      R0,[R1, #+60]
   2258              
   2259              /* Set the DMA error callback */
   2260              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   000000AE   0x6B61             LDR      R1,[R4, #+52]
   \   000000B0   0x64C8             STR      R0,[R1, #+76]
   2261          
   2262              /* Set the unused DMA callbacks to NULL */
   2263              hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x6B61             LDR      R1,[R4, #+52]
   \   000000B6   0x6408             STR      R0,[R1, #+64]
   2264              hi2c->hdmatx->XferM1CpltCallback = NULL;
   \   000000B8   0x6B61             LDR      R1,[R4, #+52]
   \   000000BA   0x6448             STR      R0,[R1, #+68]
   2265              hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
   \   000000BC   0x6B61             LDR      R1,[R4, #+52]
   \   000000BE   0x6488             STR      R0,[R1, #+72]
   2266              hi2c->hdmatx->XferAbortCallback = NULL;
   \   000000C0   0x6B61             LDR      R1,[R4, #+52]
   \   000000C2   0x6508             STR      R0,[R1, #+80]
   2267          
   2268              /* Enable the DMA Stream */
   2269              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
   \   000000C4   0x8D23             LDRH     R3,[R4, #+40]
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0xF100 0x0210      ADD      R2,R0,#+16
   \   000000CC   0x6A61             LDR      R1,[R4, #+36]
   \   000000CE   0x6B60             LDR      R0,[R4, #+52]
   \   000000D0   0x.... 0x....      BL       HAL_DMA_Start_IT
   2270          
   2271              /* Enable Address Acknowledge */
   2272              hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x6801             LDR      R1,[R0, #+0]
   \   000000D8   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000DC   0x6001             STR      R1,[R0, #+0]
   2273          
   2274              /* Process Unlocked */
   2275              __HAL_UNLOCK(hi2c);
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xF884 0x003C      STRB     R0,[R4, #+60]
   2276          
   2277                /* Note : The I2C interrupts must be enabled after unlocking current process
   2278                          to avoid the risk of I2C interrupt handle execution before current
   2279                          process unlock */
   2280              /* Enable EVT and ERR interrupt */
   2281              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6841             LDR      R1,[R0, #+4]
   \   000000E8   0xF441 0x7140      ORR      R1,R1,#0x300
   \   000000EC   0x6041             STR      R1,[R0, #+4]
   2282          
   2283              /* Enable DMA Request */
   2284              hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x6841             LDR      R1,[R0, #+4]
   \   000000F2   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000F6   0x6041             STR      R1,[R0, #+4]
   2285          
   2286              return HAL_OK;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xBD16             POP      {R1,R2,R4,PC}
   2287            }
   2288            else
   2289            {
   2290              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_DMA_0: (+1)
   \   000000FC   0x2002             MOVS     R0,#+2
   \   000000FE   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2291            }
   2292          }
   2293          
   2294          /**
   2295            * @brief  Receive in slave mode an amount of data in non-blocking mode with DMA 
   2296            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2297            *                the configuration information for the specified I2C.
   2298            * @param  pData Pointer to data buffer
   2299            * @param  Size Amount of data to be sent
   2300            * @retval HAL status
   2301            */

   \                                 In section .text, align 2, keep-with-next
   2302          HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   2303          {
   \                     HAL_I2C_Slave_Receive_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   2304            __IO uint32_t count = 0U;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   2305          
   2306            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xD174             BNE.N    ??HAL_I2C_Slave_Receive_DMA_0
   2307            {
   2308              if((pData == NULL) || (Size == 0U))
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_1
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_DMA_2
   2309              {
   2310                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_DMA_1: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBD16             POP      {R1,R2,R4,PC}
   2311              }
   2312          
   2313              /* Wait until BUSY flag is reset */
   2314              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
   \                     ??HAL_I2C_Slave_Receive_DMA_2: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable15
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x2319             MOVS     R3,#+25
   \   00000024   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000028   0xF44F 0x737A      MOV      R3,#+1000
   \   0000002C   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000030   0x2319             MOVS     R3,#+25
   \   00000032   0x4358             MULS     R0,R3,R0
   \   00000034   0x9000             STR      R0,[SP, #+0]
   2315              do
   2316              {
   2317                if(count-- == 0U)
   \                     ??HAL_I2C_Slave_Receive_DMA_3: (+1)
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0x1E43             SUBS     R3,R0,#+1
   \   0000003A   0x9300             STR      R3,[SP, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD109             BNE.N    ??HAL_I2C_Slave_Receive_DMA_4
   2318                {
   2319                  hi2c->PreviousState = I2C_STATE_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6320             STR      R0,[R4, #+48]
   2320                  hi2c->State= HAL_I2C_STATE_READY;
   \   00000044   0x2020             MOVS     R0,#+32
   \   00000046   0xF884 0x003D      STRB     R0,[R4, #+61]
   2321          
   2322                  /* Process Unlocked */
   2323                  __HAL_UNLOCK(hi2c);
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF884 0x003C      STRB     R0,[R4, #+60]
   2324          
   2325                  return HAL_TIMEOUT; 
   \   00000050   0x2003             MOVS     R0,#+3
   \   00000052   0xBD16             POP      {R1,R2,R4,PC}
   2326                }
   2327              }
   2328              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Slave_Receive_DMA_4: (+1)
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6980             LDR      R0,[R0, #+24]
   \   00000058   0x0780             LSLS     R0,R0,#+30
   \   0000005A   0xD4EC             BMI.N    ??HAL_I2C_Slave_Receive_DMA_3
   2329          
   2330              /* Process Locked */
   2331              __HAL_LOCK(hi2c);
   \   0000005C   0xF994 0x003C      LDRSB    R0,[R4, #+60]
   \   00000060   0x2801             CMP      R0,#+1
   \   00000062   0xD04B             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_0
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xF884 0x003C      STRB     R0,[R4, #+60]
   2332          
   2333              /* Check if the I2C is already enabled */
   2334              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6803             LDR      R3,[R0, #+0]
   \   0000006E   0x07DB             LSLS     R3,R3,#+31
   \   00000070   0xD403             BMI.N    ??HAL_I2C_Slave_Receive_DMA_5
   2335              {
   2336                /* Enable I2C peripheral */
   2337                __HAL_I2C_ENABLE(hi2c);
   \   00000072   0x6803             LDR      R3,[R0, #+0]
   \   00000074   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000078   0x6003             STR      R3,[R0, #+0]
   2338              }
   2339          
   2340              /* Disable Pos */
   2341              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Slave_Receive_DMA_5: (+1)
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6803             LDR      R3,[R0, #+0]
   \   0000007E   0xF423 0x6300      BIC      R3,R3,#0x800
   \   00000082   0x6003             STR      R3,[R0, #+0]
   2342          
   2343              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \   00000084   0x2022             MOVS     R0,#+34
   \   00000086   0xF884 0x003D      STRB     R0,[R4, #+61]
   2344              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \   0000008A   0x2020             MOVS     R0,#+32
   \   0000008C   0xF884 0x003E      STRB     R0,[R4, #+62]
   2345              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x6420             STR      R0,[R4, #+64]
   2346          
   2347              /* Prepare transfer parameters */
   2348              hi2c->pBuffPtr    = pData;
   \   00000094   0x6261             STR      R1,[R4, #+36]
   2349              hi2c->XferCount   = Size;
   \   00000096   0x8562             STRH     R2,[R4, #+42]
   2350              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0xffff0000
   \   0000009C   0x62E0             STR      R0,[R4, #+44]
   2351              hi2c->XferSize    = hi2c->XferCount;
   \   0000009E   0x8D60             LDRH     R0,[R4, #+42]
   \   000000A0   0x8520             STRH     R0,[R4, #+40]
   2352          
   2353              /* Set the I2C DMA transfer complete callback */
   2354              hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000A6   0x6BA1             LDR      R1,[R4, #+56]
   \   000000A8   0x63C8             STR      R0,[R1, #+60]
   2355          
   2356              /* Set the DMA error callback */
   2357              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   000000AE   0x6BA1             LDR      R1,[R4, #+56]
   \   000000B0   0x64C8             STR      R0,[R1, #+76]
   2358          
   2359              /* Set the unused DMA callbacks to NULL */
   2360              hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x6BA1             LDR      R1,[R4, #+56]
   \   000000B6   0x6408             STR      R0,[R1, #+64]
   2361              hi2c->hdmarx->XferM1CpltCallback = NULL;
   \   000000B8   0x6BA1             LDR      R1,[R4, #+56]
   \   000000BA   0x6448             STR      R0,[R1, #+68]
   2362              hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
   \   000000BC   0x6BA1             LDR      R1,[R4, #+56]
   \   000000BE   0x6488             STR      R0,[R1, #+72]
   2363              hi2c->hdmarx->XferAbortCallback = NULL;
   \   000000C0   0x6BA1             LDR      R1,[R4, #+56]
   \   000000C2   0x6508             STR      R0,[R1, #+80]
   2364          
   2365              /* Enable the DMA Stream */
   2366              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   \   000000C4   0x8D23             LDRH     R3,[R4, #+40]
   \   000000C6   0x6A62             LDR      R2,[R4, #+36]
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0xF100 0x0110      ADD      R1,R0,#+16
   \   000000CE   0x6BA0             LDR      R0,[R4, #+56]
   \   000000D0   0x.... 0x....      BL       HAL_DMA_Start_IT
   2367          
   2368              /* Enable Address Acknowledge */
   2369              hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x6801             LDR      R1,[R0, #+0]
   \   000000D8   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000DC   0x6001             STR      R1,[R0, #+0]
   2370          
   2371              /* Process Unlocked */
   2372              __HAL_UNLOCK(hi2c);
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xF884 0x003C      STRB     R0,[R4, #+60]
   2373          
   2374              /* Note : The I2C interrupts must be enabled after unlocking current process
   2375                        to avoid the risk of I2C interrupt handle execution before current
   2376                        process unlock */
   2377              /* Enable EVT and ERR interrupt */
   2378              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6841             LDR      R1,[R0, #+4]
   \   000000E8   0xF441 0x7140      ORR      R1,R1,#0x300
   \   000000EC   0x6041             STR      R1,[R0, #+4]
   2379          
   2380              /* Enable DMA Request */
   2381              hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x6841             LDR      R1,[R0, #+4]
   \   000000F2   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000F6   0x6041             STR      R1,[R0, #+4]
   2382          
   2383              return HAL_OK;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xBD16             POP      {R1,R2,R4,PC}
   2384            }
   2385            else
   2386            {
   2387              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_DMA_0: (+1)
   \   000000FC   0x2002             MOVS     R0,#+2
   \   000000FE   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2388            }
   2389          }
   2390          /**
   2391            * @brief  Write an amount of data in blocking mode to a specific memory address
   2392            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2393            *                the configuration information for the specified I2C.
   2394            * @param  DevAddress Target device address
   2395            * @param  MemAddress Internal memory address
   2396            * @param  MemAddSize Size of internal memory address
   2397            * @param  pData Pointer to data buffer
   2398            * @param  Size Amount of data to be sent
   2399            * @param  Timeout Timeout duration
   2400            * @retval HAL status
   2401            */

   \                                 In section .text, align 2, keep-with-next
   2402          HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   2403          {
   \                     HAL_I2C_Mem_Write: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
   2404            uint32_t tickstart = 0x00U;
   2405          
   2406            /* Init tickstart for timeout management*/
   2407            tickstart = HAL_GetTick();
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x4680             MOV      R8,R0
   2408            
   2409            /* Check the parameters */
   2410            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2411          
   2412            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000014   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000018   0x2820             CMP      R0,#+32
   \   0000001A   0xF040 0x80A0      BNE.W    ??HAL_I2C_Mem_Write_0
   2413            {
   2414              /* Wait until BUSY flag is reset */
   2415              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \   0000001E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000022   0x2319             MOVS     R3,#+25
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable23  ;; 0x100002
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xF040 0x8094      BNE.W    ??HAL_I2C_Mem_Write_0
   2416              {
   2417                return HAL_BUSY;
   2418              }
   2419          
   2420              /* Process Locked */
   2421              __HAL_LOCK(hi2c);
   \   00000036   0xF994 0x003C      LDRSB    R0,[R4, #+60]
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xF000 0x808F      BEQ.W    ??HAL_I2C_Mem_Write_0
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF884 0x003C      STRB     R0,[R4, #+60]
   2422              
   2423              /* Check if the I2C is already enabled */
   2424              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0x07C9             LSLS     R1,R1,#+31
   \   0000004C   0xD403             BMI.N    ??HAL_I2C_Mem_Write_1
   2425              {
   2426                /* Enable I2C peripheral */
   2427                __HAL_I2C_ENABLE(hi2c);
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000054   0x6001             STR      R1,[R0, #+0]
   2428              }
   2429          
   2430              /* Disable Pos */
   2431              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Mem_Write_1: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000005E   0x6001             STR      R1,[R0, #+0]
   2432          
   2433              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \   00000060   0x2021             MOVS     R0,#+33
   \   00000062   0xF884 0x003D      STRB     R0,[R4, #+61]
   2434              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \   00000066   0x2040             MOVS     R0,#+64
   \   00000068   0xF884 0x003E      STRB     R0,[R4, #+62]
   2435              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x6420             STR      R0,[R4, #+64]
   2436          
   2437              /* Prepare transfer parameters */
   2438              hi2c->pBuffPtr    = pData;
   \   00000070   0x980A             LDR      R0,[SP, #+40]
   \   00000072   0x6260             STR      R0,[R4, #+36]
   2439              hi2c->XferCount   = Size;
   \   00000074   0x980B             LDR      R0,[SP, #+44]
   \   00000076   0x8560             STRH     R0,[R4, #+42]
   2440              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0xffff0000
   \   0000007C   0x62E0             STR      R0,[R4, #+44]
   2441              hi2c->XferSize    = hi2c->XferCount;
   \   0000007E   0x8D60             LDRH     R0,[R4, #+42]
   \   00000080   0x8520             STRH     R0,[R4, #+40]
   \   00000082   0xF8DD 0x9030      LDR      R9,[SP, #+48]
   2442              
   2443              /* Send Slave Address and Memory Address */
   2444              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
   \   00000086   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   0000008A   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   0000008E   0x463B             MOV      R3,R7
   \   00000090   0x4632             MOV      R2,R6
   \   00000092   0x4629             MOV      R1,R5
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD02B             BEQ.N    ??HAL_I2C_Mem_Write_2
   2445              {
   2446                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000009E   0x6C20             LDR      R0,[R4, #+64]
   \   000000A0   0x2804             CMP      R0,#+4
   \   000000A2   0xD104             BNE.N    ??HAL_I2C_Mem_Write_3
   2447                {
   2448                  /* Process Unlocked */
   2449                  __HAL_UNLOCK(hi2c);
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xF884 0x003C      STRB     R0,[R4, #+60]
   2450                  return HAL_ERROR;
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0xE058             B.N      ??HAL_I2C_Mem_Write_4
   2451                }
   2452                else
   2453                {
   2454                  /* Process Unlocked */
   2455                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_3: (+1)
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xF884 0x003C      STRB     R0,[R4, #+60]
   2456                  return HAL_TIMEOUT;
   \   000000B4   0x2003             MOVS     R0,#+3
   \   000000B6   0xE053             B.N      ??HAL_I2C_Mem_Write_4
   2457                }
   2458              }
   2459          
   2460              while(hi2c->XferSize > 0U)
   2461              {
   2462                /* Wait until TXE flag is set */
   2463                if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   2464                {
   2465                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   2466                  {
   2467                    /* Generate Stop */
   2468                    hi2c->Instance->CR1 |= I2C_CR1_STOP;
   2469                    return HAL_ERROR;
   2470                  }
   2471                  else
   2472                  {
   2473                    return HAL_TIMEOUT;
   2474                  }
   2475                }
   2476          
   2477                /* Write data to DR */
   2478                hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \                     ??HAL_I2C_Mem_Write_5: (+1)
   \   000000B8   0x6A60             LDR      R0,[R4, #+36]
   \   000000BA   0x1C41             ADDS     R1,R0,#+1
   \   000000BC   0x6261             STR      R1,[R4, #+36]
   \   000000BE   0x7800             LDRB     R0,[R0, #+0]
   \   000000C0   0x6821             LDR      R1,[R4, #+0]
   \   000000C2   0x6108             STR      R0,[R1, #+16]
   2479                hi2c->XferSize--;
   \   000000C4   0x8D20             LDRH     R0,[R4, #+40]
   \   000000C6   0x1E40             SUBS     R0,R0,#+1
   \   000000C8   0x8520             STRH     R0,[R4, #+40]
   2480                hi2c->XferCount--;
   \   000000CA   0x8D60             LDRH     R0,[R4, #+42]
   \   000000CC   0x1E40             SUBS     R0,R0,#+1
   \   000000CE   0x8560             STRH     R0,[R4, #+42]
   2481          
   2482                if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6940             LDR      R0,[R0, #+20]
   \   000000D4   0x0740             LSLS     R0,R0,#+29
   \   000000D6   0xD50E             BPL.N    ??HAL_I2C_Mem_Write_2
   \   000000D8   0x8D20             LDRH     R0,[R4, #+40]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD00B             BEQ.N    ??HAL_I2C_Mem_Write_2
   2483                {
   2484                  /* Write data to DR */
   2485                  hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \   000000DE   0x6A60             LDR      R0,[R4, #+36]
   \   000000E0   0x1C41             ADDS     R1,R0,#+1
   \   000000E2   0x6261             STR      R1,[R4, #+36]
   \   000000E4   0x7800             LDRB     R0,[R0, #+0]
   \   000000E6   0x6821             LDR      R1,[R4, #+0]
   \   000000E8   0x6108             STR      R0,[R1, #+16]
   2486                  hi2c->XferSize--;
   \   000000EA   0x8D20             LDRH     R0,[R4, #+40]
   \   000000EC   0x1E40             SUBS     R0,R0,#+1
   \   000000EE   0x8520             STRH     R0,[R4, #+40]
   2487                  hi2c->XferCount--;
   \   000000F0   0x8D60             LDRH     R0,[R4, #+42]
   \   000000F2   0x1E40             SUBS     R0,R0,#+1
   \   000000F4   0x8560             STRH     R0,[R4, #+42]
   2488                }
   \                     ??HAL_I2C_Mem_Write_2: (+1)
   \   000000F6   0x8D20             LDRH     R0,[R4, #+40]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0x4642             MOV      R2,R8
   \   000000FC   0x4649             MOV      R1,R9
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0xD00F             BEQ.N    ??HAL_I2C_Mem_Write_6
   \   00000102   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD0D6             BEQ.N    ??HAL_I2C_Mem_Write_5
   \   0000010A   0x6C20             LDR      R0,[R4, #+64]
   \   0000010C   0x2804             CMP      R0,#+4
   \   0000010E   0xD106             BNE.N    ??HAL_I2C_Mem_Write_7
   \   00000110   0x6820             LDR      R0,[R4, #+0]
   \   00000112   0x6801             LDR      R1,[R0, #+0]
   \   00000114   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000118   0x6001             STR      R1,[R0, #+0]
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0xE020             B.N      ??HAL_I2C_Mem_Write_4
   \                     ??HAL_I2C_Mem_Write_7: (+1)
   \   0000011E   0x2003             MOVS     R0,#+3
   \   00000120   0xE01E             B.N      ??HAL_I2C_Mem_Write_4
   2489              }
   2490              
   2491              /* Wait until BTF flag is set */
   2492              if(I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Write_6: (+1)
   \   00000122   0x.... 0x....      BL       I2C_WaitOnBTFFlagUntilTimeout
   \   00000126   0x2800             CMP      R0,#+0
   \   00000128   0xD00B             BEQ.N    ??HAL_I2C_Mem_Write_8
   2493              {
   2494                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000012A   0x6C20             LDR      R0,[R4, #+64]
   \   0000012C   0x2804             CMP      R0,#+4
   \   0000012E   0xD106             BNE.N    ??HAL_I2C_Mem_Write_9
   2495                {
   2496                  /* Generate Stop */
   2497                  hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   00000130   0x6820             LDR      R0,[R4, #+0]
   \   00000132   0x6801             LDR      R1,[R0, #+0]
   \   00000134   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000138   0x6001             STR      R1,[R0, #+0]
   2498                  return HAL_ERROR;
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0xE010             B.N      ??HAL_I2C_Mem_Write_4
   2499                }
   2500                else
   2501                {
   2502                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Mem_Write_9: (+1)
   \   0000013E   0x2003             MOVS     R0,#+3
   \   00000140   0xE00E             B.N      ??HAL_I2C_Mem_Write_4
   2503                }
   2504              }
   2505          
   2506              /* Generate Stop */
   2507              hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \                     ??HAL_I2C_Mem_Write_8: (+1)
   \   00000142   0x6820             LDR      R0,[R4, #+0]
   \   00000144   0x6801             LDR      R1,[R0, #+0]
   \   00000146   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000014A   0x6001             STR      R1,[R0, #+0]
   2508          
   2509              hi2c->State = HAL_I2C_STATE_READY;
   \   0000014C   0x2020             MOVS     R0,#+32
   \   0000014E   0xF884 0x003D      STRB     R0,[R4, #+61]
   2510              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0xF884 0x003E      STRB     R0,[R4, #+62]
   2511              
   2512              /* Process Unlocked */
   2513              __HAL_UNLOCK(hi2c);
   \   00000158   0xF884 0x003C      STRB     R0,[R4, #+60]
   2514          
   2515              return HAL_OK;
   \   0000015C   0xE000             B.N      ??HAL_I2C_Mem_Write_4
   2516            }
   2517            else
   2518            {
   2519              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_0: (+1)
   \   0000015E   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_4: (+1)
   \   00000160   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   2520            }
   2521          }
   2522          
   2523          /**
   2524            * @brief  Read an amount of data in blocking mode from a specific memory address
   2525            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2526            *                the configuration information for the specified I2C.
   2527            * @param  DevAddress Target device address
   2528            * @param  MemAddress Internal memory address
   2529            * @param  MemAddSize Size of internal memory address
   2530            * @param  pData Pointer to data buffer
   2531            * @param  Size Amount of data to be sent
   2532            * @param  Timeout Timeout duration
   2533            * @retval HAL status
   2534            */

   \                                 In section .text, align 2, keep-with-next
   2535          HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   2536          {
   \                     HAL_I2C_Mem_Read: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4691             MOV      R9,R2
   \   0000000A   0x469A             MOV      R10,R3
   2537            uint32_t tickstart = 0x00U;
   2538          
   2539            /* Init tickstart for timeout management*/
   2540            tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   \   00000010   0x4607             MOV      R7,R0
   2541            
   2542            /* Check the parameters */
   2543            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2544          
   2545            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000012   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \   00000016   0x2820             CMP      R0,#+32
   \   00000018   0xF040 0x8150      BNE.W    ??HAL_I2C_Mem_Read_0
   2546            {
   2547              /* Wait until BUSY flag is reset */
   2548              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \   0000001C   0x9700             STR      R7,[SP, #+0]
   \   0000001E   0x2319             MOVS     R3,#+25
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable23  ;; 0x100002
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xF040 0x8145      BNE.W    ??HAL_I2C_Mem_Read_0
   2549              {
   2550                return HAL_BUSY;
   2551              }
   2552          
   2553              /* Process Locked */
   2554              __HAL_LOCK(hi2c);
   \   00000032   0xF995 0x003C      LDRSB    R0,[R5, #+60]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xF000 0x8140      BEQ.W    ??HAL_I2C_Mem_Read_0
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xF885 0x003C      STRB     R0,[R5, #+60]
   2555              
   2556              /* Check if the I2C is already enabled */
   2557              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   00000042   0x6828             LDR      R0,[R5, #+0]
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0x07C9             LSLS     R1,R1,#+31
   \   00000048   0xD403             BMI.N    ??HAL_I2C_Mem_Read_1
   2558              {
   2559                /* Enable I2C peripheral */
   2560                __HAL_I2C_ENABLE(hi2c);
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000050   0x6001             STR      R1,[R0, #+0]
   2561              }
   2562          
   2563              /* Disable Pos */
   2564              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Mem_Read_1: (+1)
   \   00000052   0x6828             LDR      R0,[R5, #+0]
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000005A   0x6001             STR      R1,[R0, #+0]
   2565          
   2566              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \   0000005C   0x2022             MOVS     R0,#+34
   \   0000005E   0xF885 0x003D      STRB     R0,[R5, #+61]
   2567              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \   00000062   0x2040             MOVS     R0,#+64
   \   00000064   0xF885 0x003E      STRB     R0,[R5, #+62]
   2568              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x6428             STR      R0,[R5, #+64]
   2569          
   2570              /* Prepare transfer parameters */
   2571              hi2c->pBuffPtr    = pData;
   \   0000006C   0x980A             LDR      R0,[SP, #+40]
   \   0000006E   0x6268             STR      R0,[R5, #+36]
   \   00000070   0x9C0B             LDR      R4,[SP, #+44]
   2572              hi2c->XferCount   = Size;
   \   00000072   0x856C             STRH     R4,[R5, #+42]
   2573              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0xffff0000
   \   00000078   0x62E8             STR      R0,[R5, #+44]
   2574              hi2c->XferSize    = hi2c->XferCount;
   \   0000007A   0x8D68             LDRH     R0,[R5, #+42]
   \   0000007C   0x8528             STRH     R0,[R5, #+40]
   \   0000007E   0x9E0C             LDR      R6,[SP, #+48]
   2575          
   2576              /* Send Slave Address and Memory Address */
   2577              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
   \   00000080   0x9701             STR      R7,[SP, #+4]
   \   00000082   0x9600             STR      R6,[SP, #+0]
   \   00000084   0x4653             MOV      R3,R10
   \   00000086   0x464A             MOV      R2,R9
   \   00000088   0x4641             MOV      R1,R8
   \   0000008A   0x4628             MOV      R0,R5
   \   0000008C   0x.... 0x....      BL       I2C_RequestMemoryRead
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD00C             BEQ.N    ??HAL_I2C_Mem_Read_2
   2578              {
   2579                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000094   0x6C28             LDR      R0,[R5, #+64]
   \   00000096   0x2804             CMP      R0,#+4
   \   00000098   0xD104             BNE.N    ??HAL_I2C_Mem_Read_3
   2580                {
   2581                  /* Process Unlocked */
   2582                  __HAL_UNLOCK(hi2c);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF885 0x003C      STRB     R0,[R5, #+60]
   2583                  return HAL_ERROR;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xE10C             B.N      ??HAL_I2C_Mem_Read_4
   2584                }
   2585                else
   2586                {
   2587                  /* Process Unlocked */
   2588                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_3: (+1)
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xF885 0x003C      STRB     R0,[R5, #+60]
   2589                  return HAL_TIMEOUT;
   \   000000AA   0x2003             MOVS     R0,#+3
   \   000000AC   0xE107             B.N      ??HAL_I2C_Mem_Read_4
   2590                }
   2591              }
   2592          
   2593              if(hi2c->XferSize == 0U)
   \                     ??HAL_I2C_Mem_Read_2: (+1)
   \   000000AE   0x8D29             LDRH     R1,[R5, #+40]
   \   000000B0   0x6828             LDR      R0,[R5, #+0]
   \   000000B2   0x2900             CMP      R1,#+0
   \   000000B4   0xD10B             BNE.N    ??HAL_I2C_Mem_Read_5
   2594              {
   2595                /* Clear ADDR flag */
   2596                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0x9100             STR      R1,[SP, #+0]
   \   000000BA   0x6941             LDR      R1,[R0, #+20]
   \   000000BC   0x9100             STR      R1,[SP, #+0]
   \   000000BE   0x6981             LDR      R1,[R0, #+24]
   \   000000C0   0x9100             STR      R1,[SP, #+0]
   \   000000C2   0x9900             LDR      R1,[SP, #+0]
   2597                
   2598                /* Generate Stop */
   2599                hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   000000C4   0x6801             LDR      R1,[R0, #+0]
   \   000000C6   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000CA   0x6001             STR      R1,[R0, #+0]
   \   000000CC   0xE03A             B.N      ??HAL_I2C_Mem_Read_6
   2600              }
   2601              else if(hi2c->XferSize == 1U)
   \                     ??HAL_I2C_Mem_Read_5: (+1)
   \   000000CE   0x2901             CMP      R1,#+1
   \   000000D0   0xD110             BNE.N    ??HAL_I2C_Mem_Read_7
   2602              {
   2603                /* Disable Acknowledge */
   2604                hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   000000D2   0x6801             LDR      R1,[R0, #+0]
   \   000000D4   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000D8   0x6001             STR      R1,[R0, #+0]
   2605          
   2606                /* Clear ADDR flag */
   2607                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x9000             STR      R0,[SP, #+0]
   \   000000DE   0x6828             LDR      R0,[R5, #+0]
   \   000000E0   0x6941             LDR      R1,[R0, #+20]
   \   000000E2   0x9100             STR      R1,[SP, #+0]
   \   000000E4   0x6981             LDR      R1,[R0, #+24]
   \   000000E6   0x9100             STR      R1,[SP, #+0]
   \   000000E8   0x9900             LDR      R1,[SP, #+0]
   2608          
   2609                /* Generate Stop */
   2610                hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   000000EA   0x6801             LDR      R1,[R0, #+0]
   \   000000EC   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000F0   0x6001             STR      R1,[R0, #+0]
   \   000000F2   0xE027             B.N      ??HAL_I2C_Mem_Read_6
   2611              }
   2612              else if(hi2c->XferSize == 2U)
   \                     ??HAL_I2C_Mem_Read_7: (+1)
   \   000000F4   0x2902             CMP      R1,#+2
   \   000000F6   0xD111             BNE.N    ??HAL_I2C_Mem_Read_8
   2613              {
   2614                /* Disable Acknowledge */
   2615                hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   000000F8   0x6801             LDR      R1,[R0, #+0]
   \   000000FA   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000FE   0x6001             STR      R1,[R0, #+0]
   2616          
   2617                /* Enable Pos */
   2618                hi2c->Instance->CR1 |= I2C_CR1_POS;
   \   00000100   0x6828             LDR      R0,[R5, #+0]
   \   00000102   0x6801             LDR      R1,[R0, #+0]
   \   00000104   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000108   0x6001             STR      R1,[R0, #+0]
   2619          
   2620                /* Clear ADDR flag */
   2621                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x9000             STR      R0,[SP, #+0]
   \   0000010E   0x6828             LDR      R0,[R5, #+0]
   \   00000110   0x6941             LDR      R1,[R0, #+20]
   \   00000112   0x9100             STR      R1,[SP, #+0]
   \   00000114   0x6980             LDR      R0,[R0, #+24]
   \   00000116   0x9000             STR      R0,[SP, #+0]
   \   00000118   0x9800             LDR      R0,[SP, #+0]
   \   0000011A   0xE013             B.N      ??HAL_I2C_Mem_Read_6
   2622              }
   2623              else
   2624              {
   2625                /* Clear ADDR flag */
   2626                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Mem_Read_8: (+1)
   \   0000011C   0x2100             MOVS     R1,#+0
   \   0000011E   0x9100             STR      R1,[SP, #+0]
   \   00000120   0x6941             LDR      R1,[R0, #+20]
   \   00000122   0x9100             STR      R1,[SP, #+0]
   \   00000124   0x6980             LDR      R0,[R0, #+24]
   \   00000126   0x9000             STR      R0,[SP, #+0]
   \   00000128   0x9800             LDR      R0,[SP, #+0]
   \   0000012A   0xE00B             B.N      ??HAL_I2C_Mem_Read_6
   2627              }
   2628          
   2629              while(hi2c->XferSize > 0U)
   2630              {
   2631                if(hi2c->XferSize <= 3U)
   2632                {
   2633                  /* One byte */
   2634                  if(hi2c->XferSize== 1U)
   2635                  {
   2636                    /* Wait until RXNE flag is set */
   2637                    if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)      
   2638                    {
   2639                      if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   2640                      {
   2641                        return HAL_TIMEOUT;
   2642                      }
   2643                      else
   2644                      {
   2645                        return HAL_ERROR;
   2646                      }
   2647                    }
   2648          
   2649                    /* Read data from DR */
   2650                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Mem_Read_9: (+1)
   \   0000012C   0x6A68             LDR      R0,[R5, #+36]
   \   0000012E   0x1C41             ADDS     R1,R0,#+1
   \   00000130   0x6269             STR      R1,[R5, #+36]
   \   00000132   0x6829             LDR      R1,[R5, #+0]
   \   00000134   0x6909             LDR      R1,[R1, #+16]
   \   00000136   0x7001             STRB     R1,[R0, #+0]
   2651                    hi2c->XferSize--;
   \   00000138   0x8D28             LDRH     R0,[R5, #+40]
   \   0000013A   0x1E40             SUBS     R0,R0,#+1
   \   0000013C   0x8528             STRH     R0,[R5, #+40]
   2652                    hi2c->XferCount--;
   \   0000013E   0x8D68             LDRH     R0,[R5, #+42]
   \   00000140   0x1E40             SUBS     R0,R0,#+1
   \   00000142   0x8568             STRH     R0,[R5, #+42]
   \                     ??HAL_I2C_Mem_Read_6: (+1)
   \   00000144   0x8D28             LDRH     R0,[R5, #+40]
   \   00000146   0x2800             CMP      R0,#+0
   \   00000148   0xF000 0x80AF      BEQ.W    ??HAL_I2C_Mem_Read_10
   \   0000014C   0x2804             CMP      R0,#+4
   \   0000014E   0xF080 0x8080      BCS.W    ??HAL_I2C_Mem_Read_11
   \   00000152   0x2801             CMP      R0,#+1
   \   00000154   0xD10D             BNE.N    ??HAL_I2C_Mem_Read_12
   \   00000156   0x463A             MOV      R2,R7
   \   00000158   0x4631             MOV      R1,R6
   \   0000015A   0x4628             MOV      R0,R5
   \   0000015C   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   00000160   0x2800             CMP      R0,#+0
   \   00000162   0xD0E3             BEQ.N    ??HAL_I2C_Mem_Read_9
   \   00000164   0x6C28             LDR      R0,[R5, #+64]
   \   00000166   0x2820             CMP      R0,#+32
   \   00000168   0xD101             BNE.N    ??HAL_I2C_Mem_Read_13
   \   0000016A   0x2003             MOVS     R0,#+3
   \   0000016C   0xE0A7             B.N      ??HAL_I2C_Mem_Read_4
   \                     ??HAL_I2C_Mem_Read_13: (+1)
   \   0000016E   0x2001             MOVS     R0,#+1
   \   00000170   0xE0A5             B.N      ??HAL_I2C_Mem_Read_4
   2653                  }
   2654                  /* Two bytes */
   2655                  else if(Size == 2U)
   \                     ??HAL_I2C_Mem_Read_12: (+1)
   \   00000172   0x.... 0x....      LDR.W    R8,??DataTable26  ;; 0x10004
   \   00000176   0x2C02             CMP      R4,#+2
   \   00000178   0x9700             STR      R7,[SP, #+0]
   \   0000017A   0x4633             MOV      R3,R6
   \   0000017C   0xD126             BNE.N    ??HAL_I2C_Mem_Read_14
   2656                  {
   2657                    /* Wait until BTF flag is set */
   2658                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \   0000017E   0x2200             MOVS     R2,#+0
   \   00000180   0x4641             MOV      R1,R8
   \   00000182   0x4628             MOV      R0,R5
   \   00000184   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000188   0x2800             CMP      R0,#+0
   \   0000018A   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_15
   2659                    {
   2660                      return HAL_TIMEOUT;
   \   0000018C   0x2003             MOVS     R0,#+3
   \   0000018E   0xE096             B.N      ??HAL_I2C_Mem_Read_4
   2661                    }
   2662          
   2663                    /* Generate Stop */
   2664                    hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \                     ??HAL_I2C_Mem_Read_15: (+1)
   \   00000190   0x6828             LDR      R0,[R5, #+0]
   \   00000192   0x6801             LDR      R1,[R0, #+0]
   \   00000194   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000198   0x6001             STR      R1,[R0, #+0]
   2665          
   2666                    /* Read data from DR */
   2667                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   0000019A   0x6A68             LDR      R0,[R5, #+36]
   \   0000019C   0x1C41             ADDS     R1,R0,#+1
   \   0000019E   0x6269             STR      R1,[R5, #+36]
   \   000001A0   0x6829             LDR      R1,[R5, #+0]
   \   000001A2   0x6909             LDR      R1,[R1, #+16]
   \   000001A4   0x7001             STRB     R1,[R0, #+0]
   2668                    hi2c->XferSize--;
   \   000001A6   0x8D28             LDRH     R0,[R5, #+40]
   \   000001A8   0x1E40             SUBS     R0,R0,#+1
   \   000001AA   0x8528             STRH     R0,[R5, #+40]
   2669                    hi2c->XferCount--;
   \   000001AC   0x8D68             LDRH     R0,[R5, #+42]
   \   000001AE   0x1E40             SUBS     R0,R0,#+1
   \   000001B0   0x8568             STRH     R0,[R5, #+42]
   2670          
   2671                    /* Read data from DR */
   2672                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   000001B2   0x6A68             LDR      R0,[R5, #+36]
   \   000001B4   0x1C41             ADDS     R1,R0,#+1
   \   000001B6   0x6269             STR      R1,[R5, #+36]
   \   000001B8   0x6829             LDR      R1,[R5, #+0]
   \   000001BA   0x6909             LDR      R1,[R1, #+16]
   \   000001BC   0x7001             STRB     R1,[R0, #+0]
   2673                    hi2c->XferSize--;
   \   000001BE   0x8D28             LDRH     R0,[R5, #+40]
   \   000001C0   0x1E40             SUBS     R0,R0,#+1
   \   000001C2   0x8528             STRH     R0,[R5, #+40]
   2674                    hi2c->XferCount--;
   \   000001C4   0x8D68             LDRH     R0,[R5, #+42]
   \   000001C6   0x1E40             SUBS     R0,R0,#+1
   \   000001C8   0x8568             STRH     R0,[R5, #+42]
   \   000001CA   0xE7BB             B.N      ??HAL_I2C_Mem_Read_6
   2675                  }
   2676                  /* 3 Last bytes */
   2677                  else
   2678                  {
   2679                    /* Wait until BTF flag is set */
   2680                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_14: (+1)
   \   000001CC   0x2200             MOVS     R2,#+0
   \   000001CE   0x4641             MOV      R1,R8
   \   000001D0   0x4628             MOV      R0,R5
   \   000001D2   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000001D6   0x2800             CMP      R0,#+0
   \   000001D8   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_16
   2681                    {
   2682                      return HAL_TIMEOUT;
   \   000001DA   0x2003             MOVS     R0,#+3
   \   000001DC   0xE06F             B.N      ??HAL_I2C_Mem_Read_4
   2683                    }
   2684          
   2685                    /* Disable Acknowledge */
   2686                    hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \                     ??HAL_I2C_Mem_Read_16: (+1)
   \   000001DE   0x6828             LDR      R0,[R5, #+0]
   \   000001E0   0x6801             LDR      R1,[R0, #+0]
   \   000001E2   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000001E6   0x6001             STR      R1,[R0, #+0]
   2687          
   2688                    /* Read data from DR */
   2689                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   000001E8   0x6A68             LDR      R0,[R5, #+36]
   \   000001EA   0x1C41             ADDS     R1,R0,#+1
   \   000001EC   0x6269             STR      R1,[R5, #+36]
   \   000001EE   0x6829             LDR      R1,[R5, #+0]
   \   000001F0   0x6909             LDR      R1,[R1, #+16]
   \   000001F2   0x7001             STRB     R1,[R0, #+0]
   2690                    hi2c->XferSize--;
   \   000001F4   0x8D28             LDRH     R0,[R5, #+40]
   \   000001F6   0x1E40             SUBS     R0,R0,#+1
   \   000001F8   0x8528             STRH     R0,[R5, #+40]
   2691                    hi2c->XferCount--;
   \   000001FA   0x8D68             LDRH     R0,[R5, #+42]
   \   000001FC   0x1E40             SUBS     R0,R0,#+1
   \   000001FE   0x8568             STRH     R0,[R5, #+42]
   2692          
   2693                    /* Wait until BTF flag is set */
   2694                    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \   00000200   0x9700             STR      R7,[SP, #+0]
   \   00000202   0x4633             MOV      R3,R6
   \   00000204   0x2200             MOVS     R2,#+0
   \   00000206   0x4641             MOV      R1,R8
   \   00000208   0x4628             MOV      R0,R5
   \   0000020A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000020E   0x2800             CMP      R0,#+0
   \   00000210   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_17
   2695                    {
   2696                      return HAL_TIMEOUT;
   \   00000212   0x2003             MOVS     R0,#+3
   \   00000214   0xE053             B.N      ??HAL_I2C_Mem_Read_4
   2697                    }
   2698          
   2699                    /* Generate Stop */
   2700                    hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \                     ??HAL_I2C_Mem_Read_17: (+1)
   \   00000216   0x6828             LDR      R0,[R5, #+0]
   \   00000218   0x6801             LDR      R1,[R0, #+0]
   \   0000021A   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000021E   0x6001             STR      R1,[R0, #+0]
   2701          
   2702                    /* Read data from DR */
   2703                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000220   0x6A68             LDR      R0,[R5, #+36]
   \   00000222   0x1C41             ADDS     R1,R0,#+1
   \   00000224   0x6269             STR      R1,[R5, #+36]
   \   00000226   0x6829             LDR      R1,[R5, #+0]
   \   00000228   0x6909             LDR      R1,[R1, #+16]
   \   0000022A   0x7001             STRB     R1,[R0, #+0]
   2704                    hi2c->XferSize--;
   \   0000022C   0x8D28             LDRH     R0,[R5, #+40]
   \   0000022E   0x1E40             SUBS     R0,R0,#+1
   \   00000230   0x8528             STRH     R0,[R5, #+40]
   2705                    hi2c->XferCount--;
   \   00000232   0x8D68             LDRH     R0,[R5, #+42]
   \   00000234   0x1E40             SUBS     R0,R0,#+1
   \   00000236   0x8568             STRH     R0,[R5, #+42]
   2706          
   2707                    /* Read data from DR */
   2708                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000238   0x6A68             LDR      R0,[R5, #+36]
   \   0000023A   0x1C41             ADDS     R1,R0,#+1
   \   0000023C   0x6269             STR      R1,[R5, #+36]
   \   0000023E   0x6829             LDR      R1,[R5, #+0]
   \   00000240   0x6909             LDR      R1,[R1, #+16]
   \   00000242   0x7001             STRB     R1,[R0, #+0]
   2709                    hi2c->XferSize--;
   \   00000244   0x8D28             LDRH     R0,[R5, #+40]
   \   00000246   0x1E40             SUBS     R0,R0,#+1
   \   00000248   0x8528             STRH     R0,[R5, #+40]
   2710                    hi2c->XferCount--;
   \   0000024A   0x8D68             LDRH     R0,[R5, #+42]
   \   0000024C   0x1E40             SUBS     R0,R0,#+1
   \   0000024E   0x8568             STRH     R0,[R5, #+42]
   \   00000250   0xE778             B.N      ??HAL_I2C_Mem_Read_6
   2711                  }
   2712                }
   2713                else
   2714                {
   2715                  /* Wait until RXNE flag is set */
   2716                  if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_11: (+1)
   \   00000252   0x463A             MOV      R2,R7
   \   00000254   0x4631             MOV      R1,R6
   \   00000256   0x4628             MOV      R0,R5
   \   00000258   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   0000025C   0x2800             CMP      R0,#+0
   \   0000025E   0xD006             BEQ.N    ??HAL_I2C_Mem_Read_18
   2717                  {
   2718                    if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   \   00000260   0x6C28             LDR      R0,[R5, #+64]
   \   00000262   0x2820             CMP      R0,#+32
   \   00000264   0xD101             BNE.N    ??HAL_I2C_Mem_Read_19
   2719                    {
   2720                      return HAL_TIMEOUT;
   \   00000266   0x2003             MOVS     R0,#+3
   \   00000268   0xE029             B.N      ??HAL_I2C_Mem_Read_4
   2721                    }
   2722                    else
   2723                    {
   2724                      return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_19: (+1)
   \   0000026A   0x2001             MOVS     R0,#+1
   \   0000026C   0xE027             B.N      ??HAL_I2C_Mem_Read_4
   2725                    }
   2726                  }
   2727          
   2728                  /* Read data from DR */
   2729                  (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \                     ??HAL_I2C_Mem_Read_18: (+1)
   \   0000026E   0x6A68             LDR      R0,[R5, #+36]
   \   00000270   0x1C41             ADDS     R1,R0,#+1
   \   00000272   0x6269             STR      R1,[R5, #+36]
   \   00000274   0x6829             LDR      R1,[R5, #+0]
   \   00000276   0x6909             LDR      R1,[R1, #+16]
   \   00000278   0x7001             STRB     R1,[R0, #+0]
   2730                  hi2c->XferSize--;
   \   0000027A   0x8D28             LDRH     R0,[R5, #+40]
   \   0000027C   0x1E40             SUBS     R0,R0,#+1
   \   0000027E   0x8528             STRH     R0,[R5, #+40]
   2731                  hi2c->XferCount--;
   \   00000280   0x8D68             LDRH     R0,[R5, #+42]
   \   00000282   0x1E40             SUBS     R0,R0,#+1
   \   00000284   0x8568             STRH     R0,[R5, #+42]
   2732          
   2733                  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
   \   00000286   0x6828             LDR      R0,[R5, #+0]
   \   00000288   0x6940             LDR      R0,[R0, #+20]
   \   0000028A   0x0740             LSLS     R0,R0,#+29
   \   0000028C   0xF57F 0xAF5A      BPL.W    ??HAL_I2C_Mem_Read_6
   2734                  {
   2735                    /* Read data from DR */
   2736                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000290   0x6A68             LDR      R0,[R5, #+36]
   \   00000292   0x1C41             ADDS     R1,R0,#+1
   \   00000294   0x6269             STR      R1,[R5, #+36]
   \   00000296   0x6829             LDR      R1,[R5, #+0]
   \   00000298   0x6909             LDR      R1,[R1, #+16]
   \   0000029A   0x7001             STRB     R1,[R0, #+0]
   2737                    hi2c->XferSize--;
   \   0000029C   0x8D28             LDRH     R0,[R5, #+40]
   \   0000029E   0x1E40             SUBS     R0,R0,#+1
   \   000002A0   0x8528             STRH     R0,[R5, #+40]
   2738                    hi2c->XferCount--;
   \   000002A2   0x8D68             LDRH     R0,[R5, #+42]
   \   000002A4   0x1E40             SUBS     R0,R0,#+1
   \   000002A6   0x8568             STRH     R0,[R5, #+42]
   \   000002A8   0xE74C             B.N      ??HAL_I2C_Mem_Read_6
   2739                  }
   2740                }
   2741              }
   2742          
   2743              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Mem_Read_10: (+1)
   \   000002AA   0x2020             MOVS     R0,#+32
   \   000002AC   0xF885 0x003D      STRB     R0,[R5, #+61]
   2744              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   000002B0   0x2000             MOVS     R0,#+0
   \   000002B2   0xF885 0x003E      STRB     R0,[R5, #+62]
   2745              
   2746              /* Process Unlocked */
   2747              __HAL_UNLOCK(hi2c);
   \   000002B6   0xF885 0x003C      STRB     R0,[R5, #+60]
   2748          
   2749              return HAL_OK;
   \   000002BA   0xE000             B.N      ??HAL_I2C_Mem_Read_4
   2750            }
   2751            else
   2752            {
   2753              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_0: (+1)
   \   000002BC   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_4: (+1)
   \   000002BE   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   2754            }
   2755          }
   2756          
   2757          /**
   2758            * @brief  Write an amount of data in non-blocking mode with Interrupt to a specific memory address
   2759            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2760            *                the configuration information for the specified I2C.
   2761            * @param  DevAddress Target device address
   2762            * @param  MemAddress Internal memory address
   2763            * @param  MemAddSize Size of internal memory address
   2764            * @param  pData Pointer to data buffer
   2765            * @param  Size Amount of data to be sent
   2766            * @retval HAL status
   2767            */

   \                                 In section .text, align 2, keep-with-next
   2768          HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2769          {
   \                     HAL_I2C_Mem_Write_IT: (+1)
   \   00000000   0xB438             PUSH     {R3-R5}
   2770            __IO uint32_t count = 0U;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x9400             STR      R4,[SP, #+0]
   2771          
   2772            /* Check the parameters */
   2773            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2774          
   2775            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF890 0x403D      LDRB     R4,[R0, #+61]
   \   0000000A   0x2C20             CMP      R4,#+32
   \   0000000C   0xD157             BNE.N    ??HAL_I2C_Mem_Write_IT_0
   2776            {
   2777              /* Wait until BUSY flag is reset */
   2778              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable26_1
   \   00000012   0x6824             LDR      R4,[R4, #+0]
   \   00000014   0x2519             MOVS     R5,#+25
   \   00000016   0xFBB4 0xF4F5      UDIV     R4,R4,R5
   \   0000001A   0xF44F 0x757A      MOV      R5,#+1000
   \   0000001E   0xFBB4 0xF4F5      UDIV     R4,R4,R5
   \   00000022   0x2519             MOVS     R5,#+25
   \   00000024   0x436C             MULS     R4,R5,R4
   \   00000026   0x9400             STR      R4,[SP, #+0]
   2779              do
   2780              {
   2781                if(count-- == 0U)
   \                     ??HAL_I2C_Mem_Write_IT_1: (+1)
   \   00000028   0x9C00             LDR      R4,[SP, #+0]
   \   0000002A   0x1E65             SUBS     R5,R4,#+1
   \   0000002C   0x9500             STR      R5,[SP, #+0]
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD109             BNE.N    ??HAL_I2C_Mem_Write_IT_2
   2782                {
   2783                  hi2c->PreviousState = I2C_STATE_NONE;
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x6301             STR      R1,[R0, #+48]
   2784                  hi2c->State= HAL_I2C_STATE_READY;
   \   00000036   0x2120             MOVS     R1,#+32
   \   00000038   0xF880 0x103D      STRB     R1,[R0, #+61]
   2785          
   2786                  /* Process Unlocked */
   2787                  __HAL_UNLOCK(hi2c);
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0xF880 0x103C      STRB     R1,[R0, #+60]
   2788          
   2789                  return HAL_TIMEOUT; 
   \   00000042   0x2003             MOVS     R0,#+3
   \   00000044   0xE03C             B.N      ??HAL_I2C_Mem_Write_IT_3
   2790                }
   2791              }
   2792              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Mem_Write_IT_2: (+1)
   \   00000046   0x6804             LDR      R4,[R0, #+0]
   \   00000048   0x69A4             LDR      R4,[R4, #+24]
   \   0000004A   0x07A4             LSLS     R4,R4,#+30
   \   0000004C   0xD4EC             BMI.N    ??HAL_I2C_Mem_Write_IT_1
   2793          
   2794              /* Process Locked */
   2795              __HAL_LOCK(hi2c);
   \   0000004E   0xF990 0x403C      LDRSB    R4,[R0, #+60]
   \   00000052   0x2C01             CMP      R4,#+1
   \   00000054   0xD033             BEQ.N    ??HAL_I2C_Mem_Write_IT_0
   \   00000056   0x2401             MOVS     R4,#+1
   \   00000058   0xF880 0x403C      STRB     R4,[R0, #+60]
   2796          
   2797              /* Check if the I2C is already enabled */
   2798              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   0000005C   0x6804             LDR      R4,[R0, #+0]
   \   0000005E   0x6825             LDR      R5,[R4, #+0]
   \   00000060   0x07ED             LSLS     R5,R5,#+31
   \   00000062   0xD403             BMI.N    ??HAL_I2C_Mem_Write_IT_4
   2799              {
   2800                /* Enable I2C peripheral */
   2801                __HAL_I2C_ENABLE(hi2c);
   \   00000064   0x6825             LDR      R5,[R4, #+0]
   \   00000066   0xF045 0x0501      ORR      R5,R5,#0x1
   \   0000006A   0x6025             STR      R5,[R4, #+0]
   2802              }
   2803          
   2804              /* Disable Pos */
   2805              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Mem_Write_IT_4: (+1)
   \   0000006C   0x6804             LDR      R4,[R0, #+0]
   \   0000006E   0x6825             LDR      R5,[R4, #+0]
   \   00000070   0xF425 0x6500      BIC      R5,R5,#0x800
   \   00000074   0x6025             STR      R5,[R4, #+0]
   2806          
   2807              hi2c->State = HAL_I2C_STATE_BUSY_TX;
   \   00000076   0x2421             MOVS     R4,#+33
   \   00000078   0xF880 0x403D      STRB     R4,[R0, #+61]
   2808              hi2c->Mode = HAL_I2C_MODE_MEM;
   \   0000007C   0x2440             MOVS     R4,#+64
   \   0000007E   0xF880 0x403E      STRB     R4,[R0, #+62]
   2809              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000082   0x2400             MOVS     R4,#+0
   \   00000084   0x6404             STR      R4,[R0, #+64]
   2810          
   2811              /* Prepare transfer parameters */
   2812              hi2c->pBuffPtr = pData;
   \   00000086   0x9C03             LDR      R4,[SP, #+12]
   \   00000088   0x6244             STR      R4,[R0, #+36]
   \   0000008A   0x9C04             LDR      R4,[SP, #+16]
   2813              hi2c->XferSize = Size;
   \   0000008C   0x8504             STRH     R4,[R0, #+40]
   2814              hi2c->XferCount = Size;
   \   0000008E   0x8544             STRH     R4,[R0, #+42]
   2815              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   00000090   0x.... 0x....      LDR.W    R4,??DataTable21  ;; 0xffff0000
   \   00000094   0x62C4             STR      R4,[R0, #+44]
   2816              hi2c->Devaddress = DevAddress;
   \   00000096   0x6441             STR      R1,[R0, #+68]
   2817              hi2c->Memaddress = MemAddress;
   \   00000098   0x6482             STR      R2,[R0, #+72]
   2818              hi2c->MemaddSize = MemAddSize;
   \   0000009A   0x64C3             STR      R3,[R0, #+76]
   2819              hi2c->EventCount = 0U;
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0x6501             STR      R1,[R0, #+80]
   2820          
   2821              /* Generate Start */
   2822              hi2c->Instance->CR1 |= I2C_CR1_START;
   \   000000A0   0x6801             LDR      R1,[R0, #+0]
   \   000000A2   0x680A             LDR      R2,[R1, #+0]
   \   000000A4   0xF442 0x7280      ORR      R2,R2,#0x100
   \   000000A8   0x600A             STR      R2,[R1, #+0]
   2823          
   2824              /* Process Unlocked */
   2825              __HAL_UNLOCK(hi2c);
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0xF880 0x103C      STRB     R1,[R0, #+60]
   2826          
   2827              /* Note : The I2C interrupts must be enabled after unlocking current process
   2828              to avoid the risk of I2C interrupt handle execution before current
   2829              process unlock */
   2830          
   2831              /* Enable EVT, BUF and ERR interrupt */
   2832              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x6841             LDR      R1,[R0, #+4]
   \   000000B4   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   000000B8   0x6041             STR      R1,[R0, #+4]
   2833          
   2834              return HAL_OK;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xE000             B.N      ??HAL_I2C_Mem_Write_IT_3
   2835            }
   2836            else
   2837            {
   2838              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_IT_0: (+1)
   \   000000BE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_IT_3: (+1)
   \   000000C0   0xBC32             POP      {R1,R4,R5}
   \   000000C2   0x4770             BX       LR               ;; return
   2839            }
   2840          }
   2841          
   2842          /**
   2843            * @brief  Read an amount of data in non-blocking mode with Interrupt from a specific memory address
   2844            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2845            *                the configuration information for the specified I2C.
   2846            * @param  DevAddress Target device address
   2847            * @param  MemAddress Internal memory address
   2848            * @param  MemAddSize Size of internal memory address
   2849            * @param  pData Pointer to data buffer
   2850            * @param  Size Amount of data to be sent
   2851            * @retval HAL status
   2852            */

   \                                 In section .text, align 2, keep-with-next
   2853          HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2854          {
   \                     HAL_I2C_Mem_Read_IT: (+1)
   \   00000000   0xB438             PUSH     {R3-R5}
   2855            __IO uint32_t count = 0U;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x9400             STR      R4,[SP, #+0]
   2856          
   2857            /* Check the parameters */
   2858            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2859          
   2860            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF890 0x403D      LDRB     R4,[R0, #+61]
   \   0000000A   0x2C20             CMP      R4,#+32
   \   0000000C   0xD15F             BNE.N    ??HAL_I2C_Mem_Read_IT_0
   2861            {
   2862              /* Wait until BUSY flag is reset */
   2863              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable26_1
   \   00000012   0x6824             LDR      R4,[R4, #+0]
   \   00000014   0x2519             MOVS     R5,#+25
   \   00000016   0xFBB4 0xF4F5      UDIV     R4,R4,R5
   \   0000001A   0xF44F 0x757A      MOV      R5,#+1000
   \   0000001E   0xFBB4 0xF4F5      UDIV     R4,R4,R5
   \   00000022   0x2519             MOVS     R5,#+25
   \   00000024   0x436C             MULS     R4,R5,R4
   \   00000026   0x9400             STR      R4,[SP, #+0]
   2864              do
   2865              {
   2866                if(count-- == 0U)
   \                     ??HAL_I2C_Mem_Read_IT_1: (+1)
   \   00000028   0x9C00             LDR      R4,[SP, #+0]
   \   0000002A   0x1E65             SUBS     R5,R4,#+1
   \   0000002C   0x9500             STR      R5,[SP, #+0]
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD109             BNE.N    ??HAL_I2C_Mem_Read_IT_2
   2867                {
   2868                  hi2c->PreviousState = I2C_STATE_NONE;
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x6301             STR      R1,[R0, #+48]
   2869                  hi2c->State= HAL_I2C_STATE_READY;
   \   00000036   0x2120             MOVS     R1,#+32
   \   00000038   0xF880 0x103D      STRB     R1,[R0, #+61]
   2870          
   2871                  /* Process Unlocked */
   2872                  __HAL_UNLOCK(hi2c);
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0xF880 0x103C      STRB     R1,[R0, #+60]
   2873          
   2874                  return HAL_TIMEOUT; 
   \   00000042   0x2003             MOVS     R0,#+3
   \   00000044   0xE044             B.N      ??HAL_I2C_Mem_Read_IT_3
   2875                }
   2876              }
   2877              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Mem_Read_IT_2: (+1)
   \   00000046   0x6804             LDR      R4,[R0, #+0]
   \   00000048   0x69A4             LDR      R4,[R4, #+24]
   \   0000004A   0x07A4             LSLS     R4,R4,#+30
   \   0000004C   0xD4EC             BMI.N    ??HAL_I2C_Mem_Read_IT_1
   2878          
   2879              /* Process Locked */
   2880              __HAL_LOCK(hi2c);
   \   0000004E   0xF990 0x403C      LDRSB    R4,[R0, #+60]
   \   00000052   0x2C01             CMP      R4,#+1
   \   00000054   0xD03B             BEQ.N    ??HAL_I2C_Mem_Read_IT_0
   \   00000056   0x2401             MOVS     R4,#+1
   \   00000058   0xF880 0x403C      STRB     R4,[R0, #+60]
   2881          
   2882              /* Check if the I2C is already enabled */
   2883              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   0000005C   0x6804             LDR      R4,[R0, #+0]
   \   0000005E   0x6825             LDR      R5,[R4, #+0]
   \   00000060   0x07ED             LSLS     R5,R5,#+31
   \   00000062   0xD403             BMI.N    ??HAL_I2C_Mem_Read_IT_4
   2884              {
   2885                /* Enable I2C peripheral */
   2886                __HAL_I2C_ENABLE(hi2c);
   \   00000064   0x6825             LDR      R5,[R4, #+0]
   \   00000066   0xF045 0x0501      ORR      R5,R5,#0x1
   \   0000006A   0x6025             STR      R5,[R4, #+0]
   2887              }
   2888          
   2889              /* Disable Pos */
   2890              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Mem_Read_IT_4: (+1)
   \   0000006C   0x6804             LDR      R4,[R0, #+0]
   \   0000006E   0x6825             LDR      R5,[R4, #+0]
   \   00000070   0xF425 0x6500      BIC      R5,R5,#0x800
   \   00000074   0x6025             STR      R5,[R4, #+0]
   2891          
   2892              hi2c->State = HAL_I2C_STATE_BUSY_RX;
   \   00000076   0x2422             MOVS     R4,#+34
   \   00000078   0xF880 0x403D      STRB     R4,[R0, #+61]
   2893              hi2c->Mode = HAL_I2C_MODE_MEM;
   \   0000007C   0x2440             MOVS     R4,#+64
   \   0000007E   0xF880 0x403E      STRB     R4,[R0, #+62]
   2894              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000082   0x2400             MOVS     R4,#+0
   \   00000084   0x6404             STR      R4,[R0, #+64]
   2895          
   2896              /* Prepare transfer parameters */
   2897              hi2c->pBuffPtr = pData;
   \   00000086   0x9C03             LDR      R4,[SP, #+12]
   \   00000088   0x6244             STR      R4,[R0, #+36]
   \   0000008A   0x9C04             LDR      R4,[SP, #+16]
   2898              hi2c->XferSize = Size;
   \   0000008C   0x8504             STRH     R4,[R0, #+40]
   2899              hi2c->XferCount = Size;
   \   0000008E   0x8544             STRH     R4,[R0, #+42]
   2900              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   00000090   0x.... 0x....      LDR.W    R4,??DataTable21  ;; 0xffff0000
   \   00000094   0x62C4             STR      R4,[R0, #+44]
   2901              hi2c->Devaddress = DevAddress;
   \   00000096   0x6441             STR      R1,[R0, #+68]
   2902              hi2c->Memaddress = MemAddress;
   \   00000098   0x6482             STR      R2,[R0, #+72]
   2903              hi2c->MemaddSize = MemAddSize;
   \   0000009A   0x64C3             STR      R3,[R0, #+76]
   2904              hi2c->EventCount = 0U;
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0x6501             STR      R1,[R0, #+80]
   2905          
   2906              /* Enable Acknowledge */
   2907              hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \   000000A0   0x6801             LDR      R1,[R0, #+0]
   \   000000A2   0x680A             LDR      R2,[R1, #+0]
   \   000000A4   0xF442 0x6280      ORR      R2,R2,#0x400
   \   000000A8   0x600A             STR      R2,[R1, #+0]
   2908          
   2909              /* Generate Start */
   2910              hi2c->Instance->CR1 |= I2C_CR1_START;
   \   000000AA   0x6801             LDR      R1,[R0, #+0]
   \   000000AC   0x680A             LDR      R2,[R1, #+0]
   \   000000AE   0xF442 0x7280      ORR      R2,R2,#0x100
   \   000000B2   0x600A             STR      R2,[R1, #+0]
   2911          
   2912              /* Process Unlocked */
   2913              __HAL_UNLOCK(hi2c);
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0xF880 0x103C      STRB     R1,[R0, #+60]
   2914          
   2915              if(hi2c->XferSize > 0U)
   \   000000BA   0x8D01             LDRH     R1,[R0, #+40]
   \   000000BC   0x2900             CMP      R1,#+0
   \   000000BE   0xD004             BEQ.N    ??HAL_I2C_Mem_Read_IT_5
   2916              {
   2917                /* Note : The I2C interrupts must be enabled after unlocking current process
   2918                to avoid the risk of I2C interrupt handle execution before current
   2919                process unlock */
   2920                
   2921                /* Enable EVT, BUF and ERR interrupt */
   2922                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0x6841             LDR      R1,[R0, #+4]
   \   000000C4   0xF441 0x61E0      ORR      R1,R1,#0x700
   \   000000C8   0x6041             STR      R1,[R0, #+4]
   2923              }
   2924              return HAL_OK;
   \                     ??HAL_I2C_Mem_Read_IT_5: (+1)
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xE000             B.N      ??HAL_I2C_Mem_Read_IT_3
   2925            }
   2926            else
   2927            {
   2928              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_IT_0: (+1)
   \   000000CE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_IT_3: (+1)
   \   000000D0   0xBC32             POP      {R1,R4,R5}
   \   000000D2   0x4770             BX       LR               ;; return
   2929            }
   2930          }
   2931          
   2932          /**
   2933            * @brief  Write an amount of data in non-blocking mode with DMA to a specific memory address
   2934            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2935            *                the configuration information for the specified I2C.
   2936            * @param  DevAddress Target device address
   2937            * @param  MemAddress Internal memory address
   2938            * @param  MemAddSize Size of internal memory address
   2939            * @param  pData Pointer to data buffer
   2940            * @param  Size Amount of data to be sent
   2941            * @retval HAL status
   2942            */

   \                                 In section .text, align 2, keep-with-next
   2943          HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2944          {
   \                     HAL_I2C_Mem_Write_DMA: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
   2945            __IO uint32_t count = 0U;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   2946          
   2947            uint32_t tickstart = 0x00U;
   2948          
   2949            /* Init tickstart for timeout management*/
   2950            tickstart = HAL_GetTick();
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x4680             MOV      R8,R0
   2951            
   2952            /* Check the parameters */
   2953            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2954          
   2955            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000016   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000001A   0x2820             CMP      R0,#+32
   \   0000001C   0xF040 0x808E      BNE.W    ??HAL_I2C_Mem_Write_DMA_0
   2956            {
   2957              /* Wait until BUSY flag is reset */
   2958              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x2119             MOVS     R1,#+25
   \   00000028   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000002C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000030   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000034   0x2119             MOVS     R1,#+25
   \   00000036   0x4348             MULS     R0,R1,R0
   \   00000038   0x9000             STR      R0,[SP, #+0]
   2959              do
   2960              {
   2961                if(count-- == 0U)
   \                     ??HAL_I2C_Mem_Write_DMA_1: (+1)
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x1E41             SUBS     R1,R0,#+1
   \   0000003E   0x9100             STR      R1,[SP, #+0]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD109             BNE.N    ??HAL_I2C_Mem_Write_DMA_2
   2962                {
   2963                  hi2c->PreviousState = I2C_STATE_NONE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x6320             STR      R0,[R4, #+48]
   2964                  hi2c->State= HAL_I2C_STATE_READY;
   \   00000048   0x2020             MOVS     R0,#+32
   \   0000004A   0xF884 0x003D      STRB     R0,[R4, #+61]
   2965          
   2966                  /* Process Unlocked */
   2967                  __HAL_UNLOCK(hi2c);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF884 0x003C      STRB     R0,[R4, #+60]
   2968          
   2969                  return HAL_TIMEOUT; 
   \   00000054   0x2003             MOVS     R0,#+3
   \   00000056   0xE072             B.N      ??HAL_I2C_Mem_Write_DMA_3
   2970                }
   2971              }
   2972              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Mem_Write_DMA_2: (+1)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6980             LDR      R0,[R0, #+24]
   \   0000005C   0x0780             LSLS     R0,R0,#+30
   \   0000005E   0xD4EC             BMI.N    ??HAL_I2C_Mem_Write_DMA_1
   2973          
   2974              /* Process Locked */
   2975              __HAL_LOCK(hi2c);
   \   00000060   0xF994 0x003C      LDRSB    R0,[R4, #+60]
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD069             BEQ.N    ??HAL_I2C_Mem_Write_DMA_0
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xF884 0x003C      STRB     R0,[R4, #+60]
   2976          
   2977              /* Check if the I2C is already enabled */
   2978              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0x07C9             LSLS     R1,R1,#+31
   \   00000074   0xD403             BMI.N    ??HAL_I2C_Mem_Write_DMA_4
   2979              {
   2980                /* Enable I2C peripheral */
   2981                __HAL_I2C_ENABLE(hi2c);
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000007C   0x6001             STR      R1,[R0, #+0]
   2982              }
   2983          
   2984              /* Disable Pos */
   2985              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Mem_Write_DMA_4: (+1)
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6801             LDR      R1,[R0, #+0]
   \   00000082   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000086   0x6001             STR      R1,[R0, #+0]
   2986          
   2987              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \   00000088   0x2021             MOVS     R0,#+33
   \   0000008A   0xF884 0x003D      STRB     R0,[R4, #+61]
   2988              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \   0000008E   0x2040             MOVS     R0,#+64
   \   00000090   0xF884 0x003E      STRB     R0,[R4, #+62]
   2989              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x6420             STR      R0,[R4, #+64]
   2990          
   2991              /* Prepare transfer parameters */
   2992              hi2c->pBuffPtr = pData;
   \   00000098   0x9808             LDR      R0,[SP, #+32]
   \   0000009A   0x6260             STR      R0,[R4, #+36]
   \   0000009C   0x9809             LDR      R0,[SP, #+36]
   2993              hi2c->XferSize = Size;
   \   0000009E   0x8520             STRH     R0,[R4, #+40]
   2994              hi2c->XferCount = Size;
   \   000000A0   0x8560             STRH     R0,[R4, #+42]
   2995              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0xffff0000
   \   000000A6   0x62E0             STR      R0,[R4, #+44]
   2996          
   2997              if(hi2c->XferSize > 0U)
   \   000000A8   0x8D20             LDRH     R0,[R4, #+40]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD044             BEQ.N    ??HAL_I2C_Mem_Write_DMA_5
   2998              {    
   2999                /* Set the I2C DMA transfer complete callback */
   3000                hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
   \   000000AE   0x....             LDR.N    R0,??DataTable20
   \   000000B0   0x6B61             LDR      R1,[R4, #+52]
   \   000000B2   0x63C8             STR      R0,[R1, #+60]
   3001          
   3002                /* Set the DMA error callback */
   3003                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \   000000B4   0x....             LDR.N    R0,??DataTable20_1
   \   000000B6   0x6B61             LDR      R1,[R4, #+52]
   \   000000B8   0x64C8             STR      R0,[R1, #+76]
   3004          
   3005                /* Set the unused DMA callbacks to NULL */
   3006                hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x6B61             LDR      R1,[R4, #+52]
   \   000000BE   0x6408             STR      R0,[R1, #+64]
   3007                hi2c->hdmatx->XferM1CpltCallback = NULL;
   \   000000C0   0x6B61             LDR      R1,[R4, #+52]
   \   000000C2   0x6448             STR      R0,[R1, #+68]
   3008                hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
   \   000000C4   0x6B61             LDR      R1,[R4, #+52]
   \   000000C6   0x6488             STR      R0,[R1, #+72]
   3009                hi2c->hdmatx->XferAbortCallback = NULL;
   \   000000C8   0x6B61             LDR      R1,[R4, #+52]
   \   000000CA   0x6508             STR      R0,[R1, #+80]
   3010          
   3011                /* Enable the DMA Stream */
   3012                HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
   \   000000CC   0x8D23             LDRH     R3,[R4, #+40]
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0xF100 0x0210      ADD      R2,R0,#+16
   \   000000D4   0x6A61             LDR      R1,[R4, #+36]
   \   000000D6   0x6B60             LDR      R0,[R4, #+52]
   \   000000D8   0x.... 0x....      BL       HAL_DMA_Start_IT
   3013          
   3014                /* Send Slave Address and Memory Address */
   3015                if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \   000000DC   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   000000E0   0x2023             MOVS     R0,#+35
   \   000000E2   0x9000             STR      R0,[SP, #+0]
   \   000000E4   0x463B             MOV      R3,R7
   \   000000E6   0x4632             MOV      R2,R6
   \   000000E8   0x4629             MOV      R1,R5
   \   000000EA   0x4620             MOV      R0,R4
   \   000000EC   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD00C             BEQ.N    ??HAL_I2C_Mem_Write_DMA_6
   3016                {
   3017                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000F4   0x6C20             LDR      R0,[R4, #+64]
   \   000000F6   0x2804             CMP      R0,#+4
   \   000000F8   0xD104             BNE.N    ??HAL_I2C_Mem_Write_DMA_7
   3018                  {
   3019                    /* Process Unlocked */
   3020                    __HAL_UNLOCK(hi2c);
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xF884 0x003C      STRB     R0,[R4, #+60]
   3021                    return HAL_ERROR;
   \   00000100   0x2001             MOVS     R0,#+1
   \   00000102   0xE01C             B.N      ??HAL_I2C_Mem_Write_DMA_3
   3022                  }
   3023                  else
   3024                  {
   3025                    /* Process Unlocked */
   3026                    __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_DMA_7: (+1)
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xF884 0x003C      STRB     R0,[R4, #+60]
   3027                    return HAL_TIMEOUT;
   \   0000010A   0x2003             MOVS     R0,#+3
   \   0000010C   0xE017             B.N      ??HAL_I2C_Mem_Write_DMA_3
   3028                  }
   3029                }
   3030          
   3031                /* Clear ADDR flag */
   3032                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Mem_Write_DMA_6: (+1)
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0x9000             STR      R0,[SP, #+0]
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0x6941             LDR      R1,[R0, #+20]
   \   00000116   0x9100             STR      R1,[SP, #+0]
   \   00000118   0x6980             LDR      R0,[R0, #+24]
   \   0000011A   0x9000             STR      R0,[SP, #+0]
   \   0000011C   0x9800             LDR      R0,[SP, #+0]
   3033                
   3034                /* Process Unlocked */
   3035                __HAL_UNLOCK(hi2c);
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0xF884 0x003C      STRB     R0,[R4, #+60]
   3036                
   3037                /* Note : The I2C interrupts must be enabled after unlocking current process
   3038                to avoid the risk of I2C interrupt handle execution before current
   3039                process unlock */
   3040                /* Enable ERR interrupt */
   3041                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERR);
   \   00000124   0x6820             LDR      R0,[R4, #+0]
   \   00000126   0x6841             LDR      R1,[R0, #+4]
   \   00000128   0xF441 0x7180      ORR      R1,R1,#0x100
   \   0000012C   0x6041             STR      R1,[R0, #+4]
   3042          
   3043                /* Enable DMA Request */
   3044                hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
   \   0000012E   0x6820             LDR      R0,[R4, #+0]
   \   00000130   0x6841             LDR      R1,[R0, #+4]
   \   00000132   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000136   0x6041             STR      R1,[R0, #+4]
   3045              }
   3046              return HAL_OK;
   \                     ??HAL_I2C_Mem_Write_DMA_5: (+1)
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xE000             B.N      ??HAL_I2C_Mem_Write_DMA_3
   3047            }
   3048            else
   3049            {
   3050              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_DMA_0: (+1)
   \   0000013C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_DMA_3: (+1)
   \   0000013E   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   3051            }
   3052          }
   3053          
   3054          /**
   3055            * @brief  Reads an amount of data in non-blocking mode with DMA from a specific memory address.
   3056            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3057            *                the configuration information for the specified I2C.
   3058            * @param  DevAddress Target device address
   3059            * @param  MemAddress Internal memory address
   3060            * @param  MemAddSize Size of internal memory address
   3061            * @param  pData Pointer to data buffer
   3062            * @param  Size Amount of data to be read
   3063            * @retval HAL status
   3064            */

   \                                 In section .text, align 2, keep-with-next
   3065          HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   3066          {
   \                     HAL_I2C_Mem_Read_DMA: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4605             MOV      R5,R0
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0x4617             MOV      R7,R2
   \   0000000C   0x4698             MOV      R8,R3
   3067            uint32_t tickstart = 0x00U;
   3068          
   3069            /* Init tickstart for timeout management*/
   3070            tickstart = HAL_GetTick();
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x4681             MOV      R9,R0
   3071          
   3072            __IO uint32_t count = 0U;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x9000             STR      R0,[SP, #+0]
   3073          
   3074            /* Check the parameters */
   3075            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   3076          
   3077            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000018   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \   0000001C   0x2820             CMP      R0,#+32
   \   0000001E   0xF040 0x80BC      BNE.W    ??HAL_I2C_Mem_Read_DMA_0
   3078            {
   3079              /* Wait until BUSY flag is reset */
   3080              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock /25U /1000U);
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x2119             MOVS     R1,#+25
   \   0000002A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000002E   0xF44F 0x717A      MOV      R1,#+1000
   \   00000032   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000036   0x2119             MOVS     R1,#+25
   \   00000038   0x4348             MULS     R0,R1,R0
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   3081              do
   3082              {
   3083                if(count-- == 0U)
   \                     ??HAL_I2C_Mem_Read_DMA_1: (+1)
   \   0000003C   0x9800             LDR      R0,[SP, #+0]
   \   0000003E   0x1E41             SUBS     R1,R0,#+1
   \   00000040   0x9100             STR      R1,[SP, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD109             BNE.N    ??HAL_I2C_Mem_Read_DMA_2
   3084                {
   3085                  hi2c->PreviousState = I2C_STATE_NONE;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x6328             STR      R0,[R5, #+48]
   3086                  hi2c->State= HAL_I2C_STATE_READY;
   \   0000004A   0x2020             MOVS     R0,#+32
   \   0000004C   0xF885 0x003D      STRB     R0,[R5, #+61]
   3087          
   3088                  /* Process Unlocked */
   3089                  __HAL_UNLOCK(hi2c);
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF885 0x003C      STRB     R0,[R5, #+60]
   3090          
   3091                  return HAL_TIMEOUT; 
   \   00000056   0x2003             MOVS     R0,#+3
   \   00000058   0xE0A0             B.N      ??HAL_I2C_Mem_Read_DMA_3
   3092                }
   3093              }
   3094              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Mem_Read_DMA_2: (+1)
   \   0000005A   0x6828             LDR      R0,[R5, #+0]
   \   0000005C   0x6980             LDR      R0,[R0, #+24]
   \   0000005E   0x0780             LSLS     R0,R0,#+30
   \   00000060   0xD4EC             BMI.N    ??HAL_I2C_Mem_Read_DMA_1
   3095          
   3096              /* Process Locked */
   3097              __HAL_LOCK(hi2c);
   \   00000062   0xF995 0x003C      LDRSB    R0,[R5, #+60]
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xF000 0x8097      BEQ.W    ??HAL_I2C_Mem_Read_DMA_0
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xF885 0x003C      STRB     R0,[R5, #+60]
   3098          
   3099              /* Check if the I2C is already enabled */
   3100              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   00000072   0x6828             LDR      R0,[R5, #+0]
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0x07C9             LSLS     R1,R1,#+31
   \   00000078   0xD403             BMI.N    ??HAL_I2C_Mem_Read_DMA_4
   3101              {
   3102                /* Enable I2C peripheral */
   3103                __HAL_I2C_ENABLE(hi2c);
   \   0000007A   0x6801             LDR      R1,[R0, #+0]
   \   0000007C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000080   0x6001             STR      R1,[R0, #+0]
   3104              }
   3105          
   3106              /* Disable Pos */
   3107              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_Mem_Read_DMA_4: (+1)
   \   00000082   0x6828             LDR      R0,[R5, #+0]
   \   00000084   0x6801             LDR      R1,[R0, #+0]
   \   00000086   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000008A   0x6001             STR      R1,[R0, #+0]
   3108          
   3109              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \   0000008C   0x2022             MOVS     R0,#+34
   \   0000008E   0xF885 0x003D      STRB     R0,[R5, #+61]
   3110              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \   00000092   0x2040             MOVS     R0,#+64
   \   00000094   0xF885 0x003E      STRB     R0,[R5, #+62]
   3111              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x6428             STR      R0,[R5, #+64]
   3112          
   3113              /* Prepare transfer parameters */
   3114              hi2c->pBuffPtr = pData;
   \   0000009C   0x980A             LDR      R0,[SP, #+40]
   \   0000009E   0x6268             STR      R0,[R5, #+36]
   \   000000A0   0x9C0B             LDR      R4,[SP, #+44]
   3115              hi2c->XferCount = Size;
   \   000000A2   0x856C             STRH     R4,[R5, #+42]
   3116              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   000000A4   0x....             LDR.N    R0,??DataTable21  ;; 0xffff0000
   \   000000A6   0x62E8             STR      R0,[R5, #+44]
   3117              hi2c->XferSize    = hi2c->XferCount;
   \   000000A8   0x8D68             LDRH     R0,[R5, #+42]
   \   000000AA   0x8528             STRH     R0,[R5, #+40]
   3118          
   3119              if(hi2c->XferSize > 0U)
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD04C             BEQ.N    ??HAL_I2C_Mem_Read_DMA_5
   3120              {
   3121                /* Set the I2C DMA transfer complete callback */
   3122                hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
   \   000000B0   0x....             LDR.N    R0,??DataTable20
   \   000000B2   0x6BA9             LDR      R1,[R5, #+56]
   \   000000B4   0x63C8             STR      R0,[R1, #+60]
   3123          
   3124                /* Set the DMA error callback */
   3125                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \   000000B6   0x....             LDR.N    R0,??DataTable20_1
   \   000000B8   0x6BA9             LDR      R1,[R5, #+56]
   \   000000BA   0x64C8             STR      R0,[R1, #+76]
   3126          
   3127                /* Set the unused DMA callbacks to NULL */
   3128                hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x6BA9             LDR      R1,[R5, #+56]
   \   000000C0   0x6408             STR      R0,[R1, #+64]
   3129                hi2c->hdmarx->XferM1CpltCallback = NULL;
   \   000000C2   0x6BA9             LDR      R1,[R5, #+56]
   \   000000C4   0x6448             STR      R0,[R1, #+68]
   3130                hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
   \   000000C6   0x6BA9             LDR      R1,[R5, #+56]
   \   000000C8   0x6488             STR      R0,[R1, #+72]
   3131                hi2c->hdmarx->XferAbortCallback = NULL;
   \   000000CA   0x6BA9             LDR      R1,[R5, #+56]
   \   000000CC   0x6508             STR      R0,[R1, #+80]
   3132          
   3133                /* Enable the DMA Stream */
   3134                HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   \   000000CE   0x8D2B             LDRH     R3,[R5, #+40]
   \   000000D0   0x6A6A             LDR      R2,[R5, #+36]
   \   000000D2   0x6828             LDR      R0,[R5, #+0]
   \   000000D4   0xF100 0x0110      ADD      R1,R0,#+16
   \   000000D8   0x6BA8             LDR      R0,[R5, #+56]
   \   000000DA   0x.... 0x....      BL       HAL_DMA_Start_IT
   3135          
   3136                /* Send Slave Address and Memory Address */
   3137                if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \   000000DE   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   000000E2   0x2023             MOVS     R0,#+35
   \   000000E4   0x9000             STR      R0,[SP, #+0]
   \   000000E6   0x4643             MOV      R3,R8
   \   000000E8   0x463A             MOV      R2,R7
   \   000000EA   0x4631             MOV      R1,R6
   \   000000EC   0x4628             MOV      R0,R5
   \   000000EE   0x.... 0x....      BL       I2C_RequestMemoryRead
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD007             BEQ.N    ??HAL_I2C_Mem_Read_DMA_6
   3138                {
   3139                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000F6   0x6C28             LDR      R0,[R5, #+64]
   \   000000F8   0x2804             CMP      R0,#+4
   \   000000FA   0xD035             BEQ.N    ??HAL_I2C_Mem_Read_DMA_7
   3140                  {
   3141                    /* Process Unlocked */
   3142                    __HAL_UNLOCK(hi2c);
   3143                    return HAL_ERROR;
   3144                  }
   3145                  else
   3146                  {
   3147                    /* Process Unlocked */
   3148                    __HAL_UNLOCK(hi2c);
   3149                    return HAL_TIMEOUT;
   3150                  }
   3151                }
   3152          
   3153                if(Size == 1U)
   3154                {
   3155                  /* Disable Acknowledge */
   3156                  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   3157                }
   3158                else
   3159                {
   3160                  /* Enable Last DMA bit */
   3161                  hi2c->Instance->CR2 |= I2C_CR2_LAST;
   3162                }
   3163          
   3164                /* Clear ADDR flag */
   3165                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   3166          
   3167                /* Process Unlocked */
   3168                __HAL_UNLOCK(hi2c);
   3169          
   3170                /* Note : The I2C interrupts must be enabled after unlocking current process
   3171                          to avoid the risk of I2C interrupt handle execution before current
   3172                          process unlock */
   3173                /* Enable ERR interrupt */
   3174                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERR);
   3175                
   3176               /* Enable DMA Request */
   3177                hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
   3178              }
   3179              else
   3180              {
   3181                /* Send Slave Address and Memory Address */
   3182                if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   3183                {
   3184                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3185                  {
   3186                    /* Process Unlocked */
   3187                    __HAL_UNLOCK(hi2c);
   3188                    return HAL_ERROR;
   3189                  }
   3190                  else
   3191                  {
   3192                    /* Process Unlocked */
   3193                    __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_DMA_8: (+1)
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xF885 0x003C      STRB     R0,[R5, #+60]
   3194                    return HAL_TIMEOUT;
   \   00000102   0x2003             MOVS     R0,#+3
   \   00000104   0xE04A             B.N      ??HAL_I2C_Mem_Read_DMA_3
   3195                  }
   \                     ??HAL_I2C_Mem_Read_DMA_6: (+1)
   \   00000106   0x6828             LDR      R0,[R5, #+0]
   \   00000108   0x2C01             CMP      R4,#+1
   \   0000010A   0xD104             BNE.N    ??HAL_I2C_Mem_Read_DMA_9
   \   0000010C   0x6801             LDR      R1,[R0, #+0]
   \   0000010E   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000112   0x6001             STR      R1,[R0, #+0]
   \   00000114   0xE003             B.N      ??HAL_I2C_Mem_Read_DMA_10
   \                     ??HAL_I2C_Mem_Read_DMA_9: (+1)
   \   00000116   0x6841             LDR      R1,[R0, #+4]
   \   00000118   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   0000011C   0x6041             STR      R1,[R0, #+4]
   \                     ??HAL_I2C_Mem_Read_DMA_10: (+1)
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x9000             STR      R0,[SP, #+0]
   \   00000122   0x6828             LDR      R0,[R5, #+0]
   \   00000124   0x6941             LDR      R1,[R0, #+20]
   \   00000126   0x9100             STR      R1,[SP, #+0]
   \   00000128   0x6980             LDR      R0,[R0, #+24]
   \   0000012A   0x9000             STR      R0,[SP, #+0]
   \   0000012C   0x9800             LDR      R0,[SP, #+0]
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xF885 0x003C      STRB     R0,[R5, #+60]
   \   00000134   0x6828             LDR      R0,[R5, #+0]
   \   00000136   0x6841             LDR      R1,[R0, #+4]
   \   00000138   0xF441 0x7180      ORR      R1,R1,#0x100
   \   0000013C   0x6041             STR      R1,[R0, #+4]
   \   0000013E   0x6828             LDR      R0,[R5, #+0]
   \   00000140   0x6841             LDR      R1,[R0, #+4]
   \   00000142   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000146   0x6041             STR      R1,[R0, #+4]
   \   00000148   0xE025             B.N      ??HAL_I2C_Mem_Read_DMA_11
   \                     ??HAL_I2C_Mem_Read_DMA_5: (+1)
   \   0000014A   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   0000014E   0x2023             MOVS     R0,#+35
   \   00000150   0x9000             STR      R0,[SP, #+0]
   \   00000152   0x4643             MOV      R3,R8
   \   00000154   0x463A             MOV      R2,R7
   \   00000156   0x4631             MOV      R1,R6
   \   00000158   0x4628             MOV      R0,R5
   \   0000015A   0x.... 0x....      BL       I2C_RequestMemoryRead
   \   0000015E   0x2800             CMP      R0,#+0
   \   00000160   0xD007             BEQ.N    ??HAL_I2C_Mem_Read_DMA_12
   \   00000162   0x6C28             LDR      R0,[R5, #+64]
   \   00000164   0x2804             CMP      R0,#+4
   \   00000166   0xD1C9             BNE.N    ??HAL_I2C_Mem_Read_DMA_8
   \                     ??HAL_I2C_Mem_Read_DMA_7: (+1)
   \   00000168   0x2000             MOVS     R0,#+0
   \   0000016A   0xF885 0x003C      STRB     R0,[R5, #+60]
   \   0000016E   0x2001             MOVS     R0,#+1
   \   00000170   0xE014             B.N      ??HAL_I2C_Mem_Read_DMA_3
   3196                }
   3197          
   3198                /* Clear ADDR flag */
   3199                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Mem_Read_DMA_12: (+1)
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0x9000             STR      R0,[SP, #+0]
   \   00000176   0x6828             LDR      R0,[R5, #+0]
   \   00000178   0x6941             LDR      R1,[R0, #+20]
   \   0000017A   0x9100             STR      R1,[SP, #+0]
   \   0000017C   0x6981             LDR      R1,[R0, #+24]
   \   0000017E   0x9100             STR      R1,[SP, #+0]
   \   00000180   0x9900             LDR      R1,[SP, #+0]
   3200          
   3201                /* Generate Stop */
   3202                hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   00000182   0x6801             LDR      R1,[R0, #+0]
   \   00000184   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000188   0x6001             STR      R1,[R0, #+0]
   3203          
   3204                hi2c->State = HAL_I2C_STATE_READY;
   \   0000018A   0x2020             MOVS     R0,#+32
   \   0000018C   0xF885 0x003D      STRB     R0,[R5, #+61]
   3205          
   3206                /* Process Unlocked */
   3207                __HAL_UNLOCK(hi2c);
   \   00000190   0x2000             MOVS     R0,#+0
   \   00000192   0xF885 0x003C      STRB     R0,[R5, #+60]
   3208              }
   3209          
   3210              return HAL_OK;
   \                     ??HAL_I2C_Mem_Read_DMA_11: (+1)
   \   00000196   0x2000             MOVS     R0,#+0
   \   00000198   0xE000             B.N      ??HAL_I2C_Mem_Read_DMA_3
   3211            }
   3212            else
   3213            {
   3214              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_DMA_0: (+1)
   \   0000019A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_DMA_3: (+1)
   \   0000019C   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   3215            }
   3216          }
   3217          
   3218          /**
   3219            * @brief  Checks if target device is ready for communication.
   3220            * @note   This function is used with Memory devices
   3221            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3222            *                the configuration information for the specified I2C.
   3223            * @param  DevAddress Target device address
   3224            * @param  Trials Number of trials
   3225            * @param  Timeout Timeout duration
   3226            * @retval HAL status
   3227            */

   \                                 In section .text, align 2, keep-with-next
   3228          HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
   3229          {
   \                     HAL_I2C_IsDeviceReady: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460F             MOV      R7,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x4699             MOV      R9,R3
   3230            uint32_t tickstart = 0U, tmp1 = 0U, tmp2 = 0U, tmp3 = 0U, I2C_Trials = 1U;
   \   0000000E   0xF04F 0x0A01      MOV      R10,#+1
   3231          
   3232            /* Get tick */
   3233            tickstart = HAL_GetTick();
   \   00000012   0x.... 0x....      BL       HAL_GetTick
   \   00000016   0x4605             MOV      R5,R0
   3234          
   3235            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000018   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000001C   0x2820             CMP      R0,#+32
   \   0000001E   0xF040 0x80A7      BNE.W    ??HAL_I2C_IsDeviceReady_0
   3236            {
   3237              /* Wait until BUSY flag is reset */
   3238              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \   00000022   0x.... 0x....      LDR.W    R6,??DataTable23  ;; 0x100002
   \   00000026   0x9500             STR      R5,[SP, #+0]
   \   00000028   0x2319             MOVS     R3,#+25
   \   0000002A   0x4652             MOV      R2,R10
   \   0000002C   0x4631             MOV      R1,R6
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xF040 0x809B      BNE.W    ??HAL_I2C_IsDeviceReady_0
   3239              {
   3240                return HAL_BUSY;
   3241              }
   3242          
   3243              /* Process Locked */
   3244              __HAL_LOCK(hi2c);
   \   0000003A   0xF994 0x003C      LDRSB    R0,[R4, #+60]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xF000 0x8096      BEQ.W    ??HAL_I2C_IsDeviceReady_0
   \   00000044   0x4650             MOV      R0,R10
   \   00000046   0xF884 0x003C      STRB     R0,[R4, #+60]
   3245              
   3246              /* Check if the I2C is already enabled */
   3247              if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0x07C9             LSLS     R1,R1,#+31
   \   00000050   0xD403             BMI.N    ??HAL_I2C_IsDeviceReady_1
   3248              {
   3249                /* Enable I2C peripheral */
   3250                __HAL_I2C_ENABLE(hi2c);
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000058   0x6001             STR      R1,[R0, #+0]
   3251              }
   3252          
   3253              /* Disable Pos */
   3254              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??HAL_I2C_IsDeviceReady_1: (+1)
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000062   0x6001             STR      R1,[R0, #+0]
   3255          
   3256              hi2c->State = HAL_I2C_STATE_BUSY;
   \   00000064   0x2024             MOVS     R0,#+36
   \   00000066   0xF884 0x003D      STRB     R0,[R4, #+61]
   3257              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x6420             STR      R0,[R4, #+64]
   3258              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   0000006E   0x....             LDR.N    R0,??DataTable21  ;; 0xffff0000
   \   00000070   0x62E0             STR      R0,[R4, #+44]
   3259              
   3260              do
   3261              {
   3262                /* Generate Start */
   3263                hi2c->Instance->CR1 |= I2C_CR1_START;
   \                     ??HAL_I2C_IsDeviceReady_2: (+1)
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0xF441 0x7180      ORR      R1,R1,#0x100
   \   0000007A   0x6001             STR      R1,[R0, #+0]
   3264          
   3265                /* Wait until SB flag is set */
   3266                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, tickstart) != HAL_OK)
   \   0000007C   0x9500             STR      R5,[SP, #+0]
   \   0000007E   0x464B             MOV      R3,R9
   \   00000080   0x2200             MOVS     R2,#+0
   \   00000082   0xF04F 0x1101      MOV      R1,#+65537
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD001             BEQ.N    ??HAL_I2C_IsDeviceReady_3
   3267                {
   3268                  return HAL_TIMEOUT;
   \   00000090   0x2003             MOVS     R0,#+3
   \   00000092   0xE06E             B.N      ??HAL_I2C_IsDeviceReady_4
   3269                }
   3270          
   3271                /* Send slave address */
   3272                hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \                     ??HAL_I2C_IsDeviceReady_3: (+1)
   \   00000094   0xF007 0x00FE      AND      R0,R7,#0xFE
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x6108             STR      R0,[R1, #+16]
   3273          
   3274                /* Wait until ADDR or AF flag are set */
   3275                /* Get tick */
   3276                tickstart = HAL_GetTick();
   \   0000009C   0x.... 0x....      BL       HAL_GetTick
   \   000000A0   0x4605             MOV      R5,R0
   3277          
   3278                tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
   \   000000A2   0x6821             LDR      R1,[R4, #+0]
   \   000000A4   0x6948             LDR      R0,[R1, #+20]
   \   000000A6   0x0840             LSRS     R0,R0,#+1
   \   000000A8   0xF000 0x0001      AND      R0,R0,#0x1
   3279                tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
   \   000000AC   0x6949             LDR      R1,[R1, #+20]
   \   000000AE   0x0A89             LSRS     R1,R1,#+10
   \   000000B0   0xF001 0x0101      AND      R1,R1,#0x1
   3280                tmp3 = hi2c->State;
   \   000000B4   0xF894 0x203D      LDRB     R2,[R4, #+61]
   \   000000B8   0xE015             B.N      ??HAL_I2C_IsDeviceReady_5
   3281                while((tmp1 == RESET) && (tmp2 == RESET) && (tmp3 != HAL_I2C_STATE_TIMEOUT))
   3282                {
   3283                  if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
   \                     ??HAL_I2C_IsDeviceReady_6: (+1)
   \   000000BA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000BE   0xD004             BEQ.N    ??HAL_I2C_IsDeviceReady_7
   \   000000C0   0x.... 0x....      BL       HAL_GetTick
   \   000000C4   0x1B40             SUBS     R0,R0,R5
   \   000000C6   0x4581             CMP      R9,R0
   \   000000C8   0xD202             BCS.N    ??HAL_I2C_IsDeviceReady_8
   3284                  {
   3285                    hi2c->State = HAL_I2C_STATE_TIMEOUT;
   \                     ??HAL_I2C_IsDeviceReady_7: (+1)
   \   000000CA   0x20A0             MOVS     R0,#+160
   \   000000CC   0xF884 0x003D      STRB     R0,[R4, #+61]
   3286                  }
   3287                  tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
   \                     ??HAL_I2C_IsDeviceReady_8: (+1)
   \   000000D0   0x6821             LDR      R1,[R4, #+0]
   \   000000D2   0x6948             LDR      R0,[R1, #+20]
   \   000000D4   0x0840             LSRS     R0,R0,#+1
   \   000000D6   0xF000 0x0001      AND      R0,R0,#0x1
   3288                  tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
   \   000000DA   0x6949             LDR      R1,[R1, #+20]
   \   000000DC   0x0A89             LSRS     R1,R1,#+10
   \   000000DE   0xF001 0x0101      AND      R1,R1,#0x1
   3289                  tmp3 = hi2c->State;
   \   000000E2   0xF894 0x203D      LDRB     R2,[R4, #+61]
   3290                }
   \                     ??HAL_I2C_IsDeviceReady_5: (+1)
   \   000000E6   0x4308             ORRS     R0,R1,R0
   \   000000E8   0xD101             BNE.N    ??HAL_I2C_IsDeviceReady_9
   \   000000EA   0x2AA0             CMP      R2,#+160
   \   000000EC   0xD1E5             BNE.N    ??HAL_I2C_IsDeviceReady_6
   3291          
   3292                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_IsDeviceReady_9: (+1)
   \   000000EE   0x2020             MOVS     R0,#+32
   \   000000F0   0xF884 0x003D      STRB     R0,[R4, #+61]
   3293          
   3294                /* Check if the ADDR flag has been set */
   3295                if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0x6941             LDR      R1,[R0, #+20]
   \   000000F8   0x0789             LSLS     R1,R1,#+30
   \   000000FA   0x6801             LDR      R1,[R0, #+0]
   \   000000FC   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000100   0x6001             STR      R1,[R0, #+0]
   \   00000102   0xD519             BPL.N    ??HAL_I2C_IsDeviceReady_10
   3296                {
   3297                  /* Generate Stop */
   3298                  hi2c->Instance->CR1 |= I2C_CR1_STOP;
   3299          
   3300                  /* Clear ADDR Flag */
   3301                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0x9000             STR      R0,[SP, #+0]
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x6941             LDR      R1,[R0, #+20]
   \   0000010C   0x9100             STR      R1,[SP, #+0]
   \   0000010E   0x6980             LDR      R0,[R0, #+24]
   \   00000110   0x9000             STR      R0,[SP, #+0]
   \   00000112   0x9800             LDR      R0,[SP, #+0]
   3302          
   3303                  /* Wait until BUSY flag is reset */
   3304                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \   00000114   0x9500             STR      R5,[SP, #+0]
   \   00000116   0x2319             MOVS     R3,#+25
   \   00000118   0x2201             MOVS     R2,#+1
   \   0000011A   0x4631             MOV      R1,R6
   \   0000011C   0x4620             MOV      R0,R4
   \   0000011E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD001             BEQ.N    ??HAL_I2C_IsDeviceReady_11
   3305                  {
   3306                    return HAL_TIMEOUT;
   \   00000126   0x2003             MOVS     R0,#+3
   \   00000128   0xE023             B.N      ??HAL_I2C_IsDeviceReady_4
   3307                  }
   3308          
   3309                  hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_IsDeviceReady_11: (+1)
   \   0000012A   0x2020             MOVS     R0,#+32
   \   0000012C   0xF884 0x003D      STRB     R0,[R4, #+61]
   3310          
   3311                  /* Process Unlocked */
   3312                  __HAL_UNLOCK(hi2c);
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0xF884 0x003C      STRB     R0,[R4, #+60]
   3313          
   3314                  return HAL_OK;
   \   00000136   0xE01C             B.N      ??HAL_I2C_IsDeviceReady_4
   3315                }
   3316                else
   3317                {
   3318                  /* Generate Stop */
   3319                  hi2c->Instance->CR1 |= I2C_CR1_STOP;
   3320          
   3321                  /* Clear AF Flag */
   3322                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??HAL_I2C_IsDeviceReady_10: (+1)
   \   00000138   0xF46F 0x6080      MVN      R0,#+1024
   \   0000013C   0x6821             LDR      R1,[R4, #+0]
   \   0000013E   0x6148             STR      R0,[R1, #+20]
   3323          
   3324                  /* Wait until BUSY flag is reset */
   3325                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \   00000140   0x9500             STR      R5,[SP, #+0]
   \   00000142   0x2319             MOVS     R3,#+25
   \   00000144   0x2201             MOVS     R2,#+1
   \   00000146   0x4631             MOV      R1,R6
   \   00000148   0x4620             MOV      R0,R4
   \   0000014A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xD001             BEQ.N    ??HAL_I2C_IsDeviceReady_12
   3326                  {
   3327                    return HAL_TIMEOUT;
   \   00000152   0x2003             MOVS     R0,#+3
   \   00000154   0xE00D             B.N      ??HAL_I2C_IsDeviceReady_4
   3328                  }
   3329                }
   3330              }while(I2C_Trials++ < Trials);
   \                     ??HAL_I2C_IsDeviceReady_12: (+1)
   \   00000156   0x4650             MOV      R0,R10
   \   00000158   0xF100 0x0A01      ADD      R10,R0,#+1
   \   0000015C   0x4540             CMP      R0,R8
   \   0000015E   0xD388             BCC.N    ??HAL_I2C_IsDeviceReady_2
   3331          
   3332              hi2c->State = HAL_I2C_STATE_READY;
   \   00000160   0x2020             MOVS     R0,#+32
   \   00000162   0xF884 0x003D      STRB     R0,[R4, #+61]
   3333          
   3334              /* Process Unlocked */
   3335              __HAL_UNLOCK(hi2c);
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0xF884 0x003C      STRB     R0,[R4, #+60]
   3336          
   3337              return HAL_ERROR;
   \   0000016C   0x2001             MOVS     R0,#+1
   \   0000016E   0xE000             B.N      ??HAL_I2C_IsDeviceReady_4
   3338            }
   3339            else
   3340            {
   3341              return HAL_BUSY;
   \                     ??HAL_I2C_IsDeviceReady_0: (+1)
   \   00000170   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_IsDeviceReady_4: (+1)
   \   00000172   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   3342            }
   3343          }
   3344          
   3345          /**
   3346            * @brief  This function handles I2C event interrupt request.
   3347            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3348            *                the configuration information for the specified I2C.
   3349            * @retval None
   3350            */

   \                                 In section .text, align 2, keep-with-next
   3351          void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
   3352          {
   \                     HAL_I2C_EV_IRQHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   3353            uint32_t sr2itflags   = READ_REG(hi2c->Instance->SR2);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6985             LDR      R5,[R0, #+24]
   3354            uint32_t sr1itflags   = READ_REG(hi2c->Instance->SR1);
   \   00000008   0x6946             LDR      R6,[R0, #+20]
   3355            uint32_t itsources    = READ_REG(hi2c->Instance->CR2);
   \   0000000A   0x6847             LDR      R7,[R0, #+4]
   3356          
   3357            uint32_t CurrentMode  = hi2c->Mode;
   \   0000000C   0xF994 0x003E      LDRSB    R0,[R4, #+62]
   3358          
   3359            /* Master or Memory mode selected */
   3360            if((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
   \   00000010   0x2810             CMP      R0,#+16
   \   00000012   0xD001             BEQ.N    ??HAL_I2C_EV_IRQHandler_0
   \   00000014   0x2840             CMP      R0,#+64
   \   00000016   0xD14F             BNE.N    ??HAL_I2C_EV_IRQHandler_1
   3361            {
   3362              /* SB Set ----------------------------------------------------------------*/
   3363              if(((sr1itflags & I2C_FLAG_SB) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_0: (+1)
   \   00000018   0xF016 0x1F01      TST      R6,#0x10001
   \   0000001C   0xD005             BEQ.N    ??HAL_I2C_EV_IRQHandler_2
   \   0000001E   0x05B8             LSLS     R0,R7,#+22
   \   00000020   0xD503             BPL.N    ??HAL_I2C_EV_IRQHandler_2
   3364              {
   3365                I2C_Master_SB(hi2c);
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       I2C_Master_SB
   \   00000028   0xE012             B.N      ??HAL_I2C_EV_IRQHandler_3
   3366              }
   3367              /* ADD10 Set -------------------------------------------------------------*/
   3368              else if(((sr1itflags & I2C_FLAG_ADD10) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_2: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable31  ;; 0x10008
   \   0000002E   0x4206             TST      R6,R0
   \   00000030   0xD005             BEQ.N    ??HAL_I2C_EV_IRQHandler_4
   \   00000032   0x05B8             LSLS     R0,R7,#+22
   \   00000034   0xD503             BPL.N    ??HAL_I2C_EV_IRQHandler_4
   3369              {
   3370                I2C_Master_ADD10(hi2c);
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       I2C_Master_ADD10
   \   0000003C   0xE008             B.N      ??HAL_I2C_EV_IRQHandler_3
   3371              }
   3372              /* ADDR Set --------------------------------------------------------------*/
   3373              else if(((sr1itflags & I2C_FLAG_ADDR) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_4: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable32  ;; 0x10002
   \   00000042   0x4206             TST      R6,R0
   \   00000044   0xD004             BEQ.N    ??HAL_I2C_EV_IRQHandler_3
   \   00000046   0x05B8             LSLS     R0,R7,#+22
   \   00000048   0xD502             BPL.N    ??HAL_I2C_EV_IRQHandler_3
   3374              {
   3375                I2C_Master_ADDR(hi2c);
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       I2C_Master_ADDR
   3376              }
   3377          
   3378              /* I2C in mode Transmitter -----------------------------------------------*/
   3379              if((sr2itflags & I2C_FLAG_TRA) != RESET)
   \                     ??HAL_I2C_EV_IRQHandler_3: (+1)
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable32_1  ;; 0x100004
   \   00000054   0x4205             TST      R5,R0
   \   00000056   0xD017             BEQ.N    ??HAL_I2C_EV_IRQHandler_5
   3380              {
   3381                /* TXE set and BTF reset -----------------------------------------------*/
   3382                if(((sr1itflags & I2C_FLAG_TXE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x10080
   \   0000005C   0x4206             TST      R6,R0
   \   0000005E   0xD009             BEQ.N    ??HAL_I2C_EV_IRQHandler_6
   \   00000060   0x0578             LSLS     R0,R7,#+21
   \   00000062   0xD507             BPL.N    ??HAL_I2C_EV_IRQHandler_6
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x10004
   \   00000068   0x4206             TST      R6,R0
   \   0000006A   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_6
   3383                {
   3384                  I2C_MasterTransmit_TXE(hi2c);
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000072   0x....             B.N      I2C_MasterTransmit_TXE
   3385                }
   3386                /* BTF set -------------------------------------------------------------*/
   3387                else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_6: (+1)
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x10004
   \   00000078   0x4206             TST      R6,R0
   \   0000007A   0xD066             BEQ.N    ??HAL_I2C_EV_IRQHandler_7
   \   0000007C   0x05B8             LSLS     R0,R7,#+22
   \   0000007E   0xD564             BPL.N    ??HAL_I2C_EV_IRQHandler_7
   3388                {
   3389                  I2C_MasterTransmit_BTF(hi2c);
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000086   0x....             B.N      I2C_MasterTransmit_BTF
   3390                }
   3391              }
   3392              /* I2C in mode Receiver --------------------------------------------------*/
   3393              else
   3394              {
   3395                /* RXNE set and BTF reset -----------------------------------------------*/
   3396                if(((sr1itflags & I2C_FLAG_RXNE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
   \                     ??HAL_I2C_EV_IRQHandler_5: (+1)
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable32_3  ;; 0x10040
   \   0000008C   0x4206             TST      R6,R0
   \   0000008E   0xD009             BEQ.N    ??HAL_I2C_EV_IRQHandler_8
   \   00000090   0x0578             LSLS     R0,R7,#+21
   \   00000092   0xD507             BPL.N    ??HAL_I2C_EV_IRQHandler_8
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x10004
   \   00000098   0x4206             TST      R6,R0
   \   0000009A   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_8
   3397                {
   3398                  I2C_MasterReceive_RXNE(hi2c);
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   000000A2   0x....             B.N      I2C_MasterReceive_RXNE
   3399                }
   3400                /* BTF set -------------------------------------------------------------*/
   3401                else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_8: (+1)
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x10004
   \   000000A8   0x4206             TST      R6,R0
   \   000000AA   0xD04E             BEQ.N    ??HAL_I2C_EV_IRQHandler_7
   \   000000AC   0x05B8             LSLS     R0,R7,#+22
   \   000000AE   0xD54C             BPL.N    ??HAL_I2C_EV_IRQHandler_7
   3402                {
   3403                  I2C_MasterReceive_BTF(hi2c);
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   000000B6   0x....             B.N      I2C_MasterReceive_BTF
   3404                }
   3405              }
   3406            }
   3407            /* Slave mode selected */
   3408            else
   3409            {
   3410              /* ADDR set --------------------------------------------------------------*/
   3411              if(((sr1itflags & I2C_FLAG_ADDR) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_1: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable32  ;; 0x10002
   \   000000BC   0x4206             TST      R6,R0
   \   000000BE   0xD005             BEQ.N    ??HAL_I2C_EV_IRQHandler_9
   \   000000C0   0x05B8             LSLS     R0,R7,#+22
   \   000000C2   0xD503             BPL.N    ??HAL_I2C_EV_IRQHandler_9
   3412              {
   3413                I2C_Slave_ADDR(hi2c);
   \   000000C4   0x4620             MOV      R0,R4
   \   000000C6   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   000000CA   0x....             B.N      I2C_Slave_ADDR
   3414              }
   3415              /* STOPF set --------------------------------------------------------------*/
   3416              else if(((sr1itflags & I2C_FLAG_STOPF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_9: (+1)
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable32_4  ;; 0x10010
   \   000000D0   0x4206             TST      R6,R0
   \   000000D2   0xD006             BEQ.N    ??HAL_I2C_EV_IRQHandler_10
   \   000000D4   0x05B8             LSLS     R0,R7,#+22
   \   000000D6   0xD504             BPL.N    ??HAL_I2C_EV_IRQHandler_10
   3417              {
   3418                I2C_Slave_STOPF(hi2c);
   \   000000D8   0x4620             MOV      R0,R4
   \   000000DA   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   000000DE   0x.... 0x....      B.W      I2C_Slave_STOPF
   3419              }
   3420              /* I2C in mode Transmitter -----------------------------------------------*/
   3421              else if((sr2itflags & I2C_FLAG_TRA) != RESET)
   \                     ??HAL_I2C_EV_IRQHandler_10: (+1)
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable32_1  ;; 0x100004
   \   000000E6   0x4205             TST      R5,R0
   \   000000E8   0xD017             BEQ.N    ??HAL_I2C_EV_IRQHandler_11
   3422              {
   3423                /* TXE set and BTF reset -----------------------------------------------*/
   3424                if(((sr1itflags & I2C_FLAG_TXE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x10080
   \   000000EE   0x4206             TST      R6,R0
   \   000000F0   0xD009             BEQ.N    ??HAL_I2C_EV_IRQHandler_12
   \   000000F2   0x0578             LSLS     R0,R7,#+21
   \   000000F4   0xD507             BPL.N    ??HAL_I2C_EV_IRQHandler_12
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x10004
   \   000000FA   0x4206             TST      R6,R0
   \   000000FC   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_12
   3425                {
   3426                  I2C_SlaveTransmit_TXE(hi2c);
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000104   0x....             B.N      I2C_SlaveTransmit_TXE
   3427                }
   3428                /* BTF set -------------------------------------------------------------*/
   3429                else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_12: (+1)
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x10004
   \   0000010A   0x4206             TST      R6,R0
   \   0000010C   0xD01D             BEQ.N    ??HAL_I2C_EV_IRQHandler_7
   \   0000010E   0x05B8             LSLS     R0,R7,#+22
   \   00000110   0xD51B             BPL.N    ??HAL_I2C_EV_IRQHandler_7
   3430                {
   3431                  I2C_SlaveTransmit_BTF(hi2c);
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000118   0x....             B.N      I2C_SlaveTransmit_BTF
   3432                }
   3433              }
   3434              /* I2C in mode Receiver --------------------------------------------------*/
   3435              else
   3436              {
   3437                /* RXNE set and BTF reset ----------------------------------------------*/
   3438                if(((sr1itflags & I2C_FLAG_RXNE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
   \                     ??HAL_I2C_EV_IRQHandler_11: (+1)
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable32_3  ;; 0x10040
   \   0000011E   0x4206             TST      R6,R0
   \   00000120   0xD009             BEQ.N    ??HAL_I2C_EV_IRQHandler_13
   \   00000122   0x0578             LSLS     R0,R7,#+21
   \   00000124   0xD507             BPL.N    ??HAL_I2C_EV_IRQHandler_13
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x10004
   \   0000012A   0x4206             TST      R6,R0
   \   0000012C   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_13
   3439                {
   3440                  I2C_SlaveReceive_RXNE(hi2c);
   \   0000012E   0x4620             MOV      R0,R4
   \   00000130   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000134   0x....             B.N      I2C_SlaveReceive_RXNE
   3441                }
   3442                /* BTF set -------------------------------------------------------------*/
   3443                else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_13: (+1)
   \   00000136   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x10004
   \   0000013A   0x4206             TST      R6,R0
   \   0000013C   0xD005             BEQ.N    ??HAL_I2C_EV_IRQHandler_7
   \   0000013E   0x05B8             LSLS     R0,R7,#+22
   \   00000140   0xD503             BPL.N    ??HAL_I2C_EV_IRQHandler_7
   3444                {
   3445                  I2C_SlaveReceive_BTF(hi2c);
   \   00000142   0x4620             MOV      R0,R4
   \   00000144   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000148   0x....             B.N      I2C_SlaveReceive_BTF
   3446                }
   3447              }
   3448            }
   3449          }
   \                     ??HAL_I2C_EV_IRQHandler_7: (+1)
   \   0000014A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   3450          
   3451          /**
   3452            * @brief  This function handles I2C error interrupt request.
   3453            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3454            *                the configuration information for the specified I2C.
   3455            * @retval None
   3456            */

   \                                 In section .text, align 2, keep-with-next
   3457          void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
   3458          {
   \                     HAL_I2C_ER_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   3459            uint32_t tmp1 = 0U, tmp2 = 0U, tmp3 = 0U, tmp4 = 0U;
   3460            uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6945             LDR      R5,[R0, #+20]
   3461            uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
   \   00000008   0x6846             LDR      R6,[R0, #+4]
   3462          
   3463            /* I2C Bus error interrupt occurred ----------------------------------------*/
   3464            if(((sr1itflags & I2C_FLAG_BERR) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable33  ;; 0x10100
   \   0000000E   0x4205             TST      R5,R0
   \   00000010   0xD009             BEQ.N    ??HAL_I2C_ER_IRQHandler_0
   \   00000012   0x05F0             LSLS     R0,R6,#+23
   \   00000014   0xD507             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   3465            {
   3466              hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
   \   00000016   0x6C20             LDR      R0,[R4, #+64]
   \   00000018   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000001C   0x6420             STR      R0,[R4, #+64]
   3467          
   3468              /* Clear BERR flag */
   3469              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
   \   0000001E   0xF46F 0x7080      MVN      R0,#+256
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x6148             STR      R0,[R1, #+20]
   3470            }
   3471          
   3472            /* I2C Arbitration Loss error interrupt occurred ---------------------------*/
   3473            if(((sr1itflags & I2C_FLAG_ARLO) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
   \                     ??HAL_I2C_ER_IRQHandler_0: (+1)
   \   00000026   0xF415 0x3F81      TST      R5,#0x10200
   \   0000002A   0xD009             BEQ.N    ??HAL_I2C_ER_IRQHandler_1
   \   0000002C   0x05F0             LSLS     R0,R6,#+23
   \   0000002E   0xD507             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   3474            {
   3475              hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
   \   00000030   0x6C20             LDR      R0,[R4, #+64]
   \   00000032   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000036   0x6420             STR      R0,[R4, #+64]
   3476          
   3477              /* Clear ARLO flag */
   3478              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
   \   00000038   0xF46F 0x7000      MVN      R0,#+512
   \   0000003C   0x6821             LDR      R1,[R4, #+0]
   \   0000003E   0x6148             STR      R0,[R1, #+20]
   3479            }
   3480          
   3481            /* I2C Acknowledge failure error interrupt occurred ------------------------*/
   3482            if(((sr1itflags & I2C_FLAG_AF) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
   \                     ??HAL_I2C_ER_IRQHandler_1: (+1)
   \   00000040   0xF415 0x3F82      TST      R5,#0x10400
   \   00000044   0xD028             BEQ.N    ??HAL_I2C_ER_IRQHandler_2
   \   00000046   0x05F0             LSLS     R0,R6,#+23
   \   00000048   0xD526             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   3483            {
   3484              tmp1 = hi2c->Mode;
   \   0000004A   0xF994 0x003E      LDRSB    R0,[R4, #+62]
   3485              tmp2 = hi2c->XferCount;
   \   0000004E   0x8D61             LDRH     R1,[R4, #+42]
   3486              tmp3 = hi2c->State;
   \   00000050   0xF894 0x203D      LDRB     R2,[R4, #+61]
   3487              tmp4 = hi2c->PreviousState;
   \   00000054   0x6B23             LDR      R3,[R4, #+48]
   3488              if((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
   3489                ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
   3490                ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
   \   00000056   0x2820             CMP      R0,#+32
   \   00000058   0xD10D             BNE.N    ??HAL_I2C_ER_IRQHandler_3
   \   0000005A   0x2900             CMP      R1,#+0
   \   0000005C   0xD10B             BNE.N    ??HAL_I2C_ER_IRQHandler_3
   \   0000005E   0x2A21             CMP      R2,#+33
   \   00000060   0xD005             BEQ.N    ??HAL_I2C_ER_IRQHandler_4
   \   00000062   0x2A29             CMP      R2,#+41
   \   00000064   0xD003             BEQ.N    ??HAL_I2C_ER_IRQHandler_4
   \   00000066   0x2A28             CMP      R2,#+40
   \   00000068   0xD105             BNE.N    ??HAL_I2C_ER_IRQHandler_3
   \   0000006A   0x2B21             CMP      R3,#+33
   \   0000006C   0xD103             BNE.N    ??HAL_I2C_ER_IRQHandler_3
   3491              {
   3492                I2C_Slave_AF(hi2c);
   \                     ??HAL_I2C_ER_IRQHandler_4: (+1)
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       I2C_Slave_AF
   \   00000074   0xE010             B.N      ??HAL_I2C_ER_IRQHandler_2
   3493              }
   3494              else
   3495              {
   3496                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \                     ??HAL_I2C_ER_IRQHandler_3: (+1)
   \   00000076   0x6C20             LDR      R0,[R4, #+64]
   \   00000078   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000007C   0x6420             STR      R0,[R4, #+64]
   3497          
   3498                /* Do not generate a STOP in case of Slave receive non acknowledge during transfer (mean not at the end of transfer) */
   3499                if(hi2c->Mode == HAL_I2C_MODE_MASTER)
   \   0000007E   0xF994 0x003E      LDRSB    R0,[R4, #+62]
   \   00000082   0x2810             CMP      R0,#+16
   \   00000084   0xD104             BNE.N    ??HAL_I2C_ER_IRQHandler_5
   3500                {
   3501                  /* Generate Stop */
   3502                  SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000008E   0x6001             STR      R1,[R0, #+0]
   3503                }
   3504          
   3505                /* Clear AF flag */
   3506                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??HAL_I2C_ER_IRQHandler_5: (+1)
   \   00000090   0xF46F 0x6080      MVN      R0,#+1024
   \   00000094   0x6821             LDR      R1,[R4, #+0]
   \   00000096   0x6148             STR      R0,[R1, #+20]
   3507              }
   3508            }
   3509          
   3510            /* I2C Over-Run/Under-Run interrupt occurred -------------------------------*/
   3511            if(((sr1itflags & I2C_FLAG_OVR) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
   \                     ??HAL_I2C_ER_IRQHandler_2: (+1)
   \   00000098   0xF415 0x3F84      TST      R5,#0x10800
   \   0000009C   0xD009             BEQ.N    ??HAL_I2C_ER_IRQHandler_6
   \   0000009E   0x05F0             LSLS     R0,R6,#+23
   \   000000A0   0xD507             BPL.N    ??HAL_I2C_ER_IRQHandler_6
   3512            {
   3513              hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
   \   000000A2   0x6C20             LDR      R0,[R4, #+64]
   \   000000A4   0xF040 0x0008      ORR      R0,R0,#0x8
   \   000000A8   0x6420             STR      R0,[R4, #+64]
   3514              /* Clear OVR flag */
   3515              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
   \   000000AA   0xF46F 0x6000      MVN      R0,#+2048
   \   000000AE   0x6821             LDR      R1,[R4, #+0]
   \   000000B0   0x6148             STR      R0,[R1, #+20]
   3516            }
   3517          
   3518            /* Call the Error Callback in case of Error detected -----------------------*/
   3519            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??HAL_I2C_ER_IRQHandler_6: (+1)
   \   000000B2   0x6C20             LDR      R0,[R4, #+64]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD004             BEQ.N    ??HAL_I2C_ER_IRQHandler_7
   3520            {
   3521              I2C_ITError(hi2c);
   \   000000B8   0x4620             MOV      R0,R4
   \   000000BA   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   000000BE   0x.... 0x....      B.W      I2C_ITError
   3522            }
   3523          }
   \                     ??HAL_I2C_ER_IRQHandler_7: (+1)
   \   000000C2   0xBD70             POP      {R4-R6,PC}       ;; return
   3524          
   3525          /**
   3526            * @brief  Master Tx Transfer completed callback.
   3527            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3528            *                the configuration information for the specified I2C.
   3529            * @retval None
   3530            */

   \                                 In section .text, align 2, keep-with-next
   3531          __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
   3532          {
   3533            /* Prevent unused argument(s) compilation warning */
   3534            UNUSED(hi2c);
   3535          
   3536            /* NOTE : This function should not be modified, when the callback is needed,
   3537                      the HAL_I2C_MasterTxCpltCallback can be implemented in the user file
   3538             */
   3539          }
   \                     HAL_I2C_MasterTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   3540          
   3541          /**
   3542            * @brief  Master Rx Transfer completed callback.
   3543            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3544            *                the configuration information for the specified I2C.
   3545            * @retval None
   3546            */

   \                                 In section .text, align 2, keep-with-next
   3547          __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
   3548          {
   3549            /* Prevent unused argument(s) compilation warning */
   3550            UNUSED(hi2c);
   3551          
   3552            /* NOTE : This function should not be modified, when the callback is needed,
   3553                      the HAL_I2C_MasterRxCpltCallback can be implemented in the user file
   3554             */
   3555          }
   \                     HAL_I2C_MasterRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   3556          
   3557          /** @brief  Slave Tx Transfer completed callback.
   3558            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3559            *                the configuration information for the specified I2C.
   3560            * @retval None
   3561            */

   \                                 In section .text, align 2, keep-with-next
   3562          __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
   3563          {
   3564            /* Prevent unused argument(s) compilation warning */
   3565            UNUSED(hi2c);
   3566          
   3567            /* NOTE : This function should not be modified, when the callback is needed,
   3568                      the HAL_I2C_SlaveTxCpltCallback can be implemented in the user file
   3569             */
   3570          }
   \                     HAL_I2C_SlaveTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   3571          
   3572          /**
   3573            * @brief  Slave Rx Transfer completed callback.
   3574            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3575            *                the configuration information for the specified I2C.
   3576            * @retval None
   3577            */

   \                                 In section .text, align 2, keep-with-next
   3578          __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
   3579          {
   3580            /* Prevent unused argument(s) compilation warning */
   3581            UNUSED(hi2c);
   3582          
   3583            /* NOTE : This function should not be modified, when the callback is needed,
   3584                      the HAL_I2C_SlaveRxCpltCallback can be implemented in the user file
   3585             */
   3586          }
   \                     HAL_I2C_SlaveRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   3587          
   3588          /**
   3589            * @brief  Slave Address Match callback.
   3590            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3591            *                the configuration information for the specified I2C.
   3592            * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XferOptions_definition
   3593            * @param  AddrMatchCode Address Match Code
   3594            * @retval None
   3595            */

   \                                 In section .text, align 2, keep-with-next
   3596          __weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
   3597          {
   3598            /* Prevent unused argument(s) compilation warning */
   3599            UNUSED(hi2c);
   3600            UNUSED(TransferDirection);
   3601            UNUSED(AddrMatchCode);
   3602          
   3603            /* NOTE : This function should not be modified, when the callback is needed,
   3604                      the HAL_I2C_AddrCallback can be implemented in the user file
   3605             */
   3606          }
   \                     HAL_I2C_AddrCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   3607          
   3608          /**
   3609            * @brief  Listen Complete callback.
   3610            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3611            *                the configuration information for the specified I2C.
   3612            * @retval None
   3613            */

   \                                 In section .text, align 2, keep-with-next
   3614          __weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
   3615          {
   3616            /* Prevent unused argument(s) compilation warning */
   3617            UNUSED(hi2c);
   3618          
   3619              /* NOTE : This function should not be modified, when the callback is needed,
   3620                      the HAL_I2C_ListenCpltCallback can be implemented in the user file
   3621             */
   3622          }
   \                     HAL_I2C_ListenCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   3623          
   3624          /**
   3625            * @brief  Memory Tx Transfer completed callback.
   3626            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3627            *                the configuration information for the specified I2C.
   3628            * @retval None
   3629            */

   \                                 In section .text, align 2, keep-with-next
   3630          __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
   3631          {
   3632            /* Prevent unused argument(s) compilation warning */
   3633            UNUSED(hi2c);
   3634          
   3635            /* NOTE : This function should not be modified, when the callback is needed,
   3636                      the HAL_I2C_MemTxCpltCallback can be implemented in the user file
   3637             */
   3638          }
   \                     HAL_I2C_MemTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   3639          
   3640          /**
   3641            * @brief  Memory Rx Transfer completed callback.
   3642            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3643            *                the configuration information for the specified I2C.
   3644            * @retval None
   3645            */

   \                                 In section .text, align 2, keep-with-next
   3646          __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
   3647          {
   3648            /* Prevent unused argument(s) compilation warning */
   3649            UNUSED(hi2c);
   3650          
   3651            /* NOTE : This function should not be modified, when the callback is needed,
   3652                      the HAL_I2C_MemRxCpltCallback can be implemented in the user file
   3653             */
   3654          }
   \                     HAL_I2C_MemRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   3655          
   3656          /**
   3657            * @brief  I2C error callback.
   3658            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3659            *                the configuration information for the specified I2C.
   3660            * @retval None
   3661            */

   \                                 In section .text, align 2, keep-with-next
   3662          __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
   3663          {
   3664            /* Prevent unused argument(s) compilation warning */
   3665            UNUSED(hi2c);
   3666          
   3667            /* NOTE : This function should not be modified, when the callback is needed,
   3668                      the HAL_I2C_ErrorCallback can be implemented in the user file
   3669             */
   3670          }
   \                     HAL_I2C_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   3671          
   3672          /**
   3673            * @brief  I2C abort callback.
   3674            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3675            *                the configuration information for the specified I2C.
   3676            * @retval None
   3677            */

   \                                 In section .text, align 2, keep-with-next
   3678          __weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
   3679          {
   3680            /* Prevent unused argument(s) compilation warning */
   3681            UNUSED(hi2c);
   3682          
   3683            /* NOTE : This function should not be modified, when the callback is needed,
   3684                      the HAL_I2C_AbortCpltCallback could be implemented in the user file
   3685             */
   3686          }
   \                     HAL_I2C_AbortCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   3687          
   3688          /**
   3689            * @}
   3690            */
   3691          
   3692          /** @defgroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions
   3693            *  @brief   Peripheral State and Errors functions
   3694            *
   3695          @verbatim
   3696           ===============================================================================
   3697                      ##### Peripheral State, Mode and Error functions #####
   3698           ===============================================================================
   3699              [..]
   3700              This subsection permits to get in run-time the status of the peripheral
   3701              and the data flow.
   3702          
   3703          @endverbatim
   3704            * @{
   3705            */
   3706          
   3707          /**
   3708            * @brief  Return the I2C handle state.
   3709            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3710            *                the configuration information for the specified I2C.
   3711            * @retval HAL state
   3712            */

   \                                 In section .text, align 2, keep-with-next
   3713          HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
   3714          {
   3715            /* Return I2C handle state */
   3716            return hi2c->State;
   \                     HAL_I2C_GetState: (+1)
   \   00000000   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   00000004   0x4770             BX       LR               ;; return
   3717          }
   3718          
   3719          /**
   3720            * @brief  Return the I2C Master, Slave, Memory or no mode.
   3721            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3722            *         the configuration information for I2C module
   3723            * @retval HAL mode
   3724            */

   \                                 In section .text, align 2, keep-with-next
   3725          HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
   3726          {
   3727            return hi2c->Mode;
   \                     HAL_I2C_GetMode: (+1)
   \   00000000   0xF990 0x003E      LDRSB    R0,[R0, #+62]
   \   00000004   0x4770             BX       LR               ;; return
   3728          }
   3729          
   3730          /**
   3731            * @brief  Return the I2C error code
   3732            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3733            *              the configuration information for the specified I2C.
   3734            * @retval I2C Error Code
   3735            */

   \                                 In section .text, align 2, keep-with-next
   3736          uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
   3737          {
   3738            return hi2c->ErrorCode;
   \                     HAL_I2C_GetError: (+1)
   \   00000000   0x6C00             LDR      R0,[R0, #+64]
   \   00000002   0x4770             BX       LR               ;; return
   3739          }
   3740          
   3741          /**
   3742            * @}
   3743            */
   3744          
   3745          /**
   3746            * @brief  Handle TXE flag for Master
   3747            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3748            *         the configuration information for I2C module
   3749            * @retval HAL status
   3750            */

   \                                 In section .text, align 2, keep-with-next
   3751          static HAL_StatusTypeDef I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)
   3752          {
   \                     I2C_MasterTransmit_TXE: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   3753            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   3754            uint32_t CurrentState       = hi2c->State;
   \   00000002   0xF890 0x103D      LDRB     R1,[R0, #+61]
   3755            uint32_t CurrentMode        = hi2c->Mode;
   \   00000006   0xF990 0x203E      LDRSB    R2,[R0, #+62]
   3756            uint32_t CurrentXferOptions = hi2c->XferOptions;
   \   0000000A   0x6AC3             LDR      R3,[R0, #+44]
   3757          
   3758            if((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
   \   0000000C   0x8D04             LDRH     R4,[R0, #+40]
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD138             BNE.N    ??I2C_MasterTransmit_TXE_0
   \   00000012   0x2921             CMP      R1,#+33
   \   00000014   0xD136             BNE.N    ??I2C_MasterTransmit_TXE_0
   3759            {
   3760              /* Call TxCpltCallback() directly if no stop mode is set */
   3761              if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
   \   00000016   0x2B04             CMP      R3,#+4
   \   00000018   0xD015             BEQ.N    ??I2C_MasterTransmit_TXE_1
   \   0000001A   0x2B08             CMP      R3,#+8
   \   0000001C   0xD013             BEQ.N    ??I2C_MasterTransmit_TXE_1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable34  ;; 0xffff0000
   \   00000022   0x428B             CMP      R3,R1
   \   00000024   0xD00F             BEQ.N    ??I2C_MasterTransmit_TXE_1
   3762              {
   3763                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x684A             LDR      R2,[R1, #+4]
   \   0000002A   0xF422 0x62E0      BIC      R2,R2,#0x700
   \   0000002E   0x604A             STR      R2,[R1, #+4]
   3764          
   3765                hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
   \   00000030   0x2111             MOVS     R1,#+17
   \   00000032   0x6301             STR      R1,[R0, #+48]
   3766                hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0xF880 0x103E      STRB     R1,[R0, #+62]
   3767                hi2c->State = HAL_I2C_STATE_READY;
   \   0000003A   0x2120             MOVS     R1,#+32
   \   0000003C   0xF880 0x103D      STRB     R1,[R0, #+61]
   3768          
   3769                HAL_I2C_MasterTxCpltCallback(hi2c);
   \   00000040   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   \   00000044   0xE075             B.N      ??I2C_MasterTransmit_TXE_2
   3770              }
   3771              else /* Generate Stop condition then Call TxCpltCallback() */
   3772              {
   3773                /* Disable EVT, BUF and ERR interrupt */
   3774                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \                     ??I2C_MasterTransmit_TXE_1: (+1)
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x684A             LDR      R2,[R1, #+4]
   \   0000004A   0xF422 0x62E0      BIC      R2,R2,#0x700
   \   0000004E   0x604A             STR      R2,[R1, #+4]
   3775          
   3776                /* Generate Stop */
   3777                hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x680A             LDR      R2,[R1, #+0]
   \   00000054   0xF442 0x7200      ORR      R2,R2,#0x200
   \   00000058   0x600A             STR      R2,[R1, #+0]
   3778          
   3779                hi2c->PreviousState = I2C_STATE_NONE;
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x6301             STR      R1,[R0, #+48]
   3780                hi2c->State = HAL_I2C_STATE_READY;
   \   0000005E   0x2120             MOVS     R1,#+32
   \   00000060   0xF880 0x103D      STRB     R1,[R0, #+61]
   3781          
   3782                if(hi2c->Mode == HAL_I2C_MODE_MEM)
   \   00000064   0xF990 0x103E      LDRSB    R1,[R0, #+62]
   \   00000068   0x2940             CMP      R1,#+64
   \   0000006A   0xD105             BNE.N    ??I2C_MasterTransmit_TXE_3
   3783                {
   3784                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0xF880 0x103E      STRB     R1,[R0, #+62]
   3785                  HAL_I2C_MemTxCpltCallback(hi2c);
   \   00000072   0x.... 0x....      BL       HAL_I2C_MemTxCpltCallback
   \   00000076   0xE05C             B.N      ??I2C_MasterTransmit_TXE_2
   3786                }
   3787                else
   3788                {
   3789                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \                     ??I2C_MasterTransmit_TXE_3: (+1)
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0xF880 0x103E      STRB     R1,[R0, #+62]
   3790                  HAL_I2C_MasterTxCpltCallback(hi2c);
   \   0000007E   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   \   00000082   0xE056             B.N      ??I2C_MasterTransmit_TXE_2
   3791                }
   3792              }
   3793            }
   3794            else if((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
   3795              ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
   \                     ??I2C_MasterTransmit_TXE_0: (+1)
   \   00000084   0x2921             CMP      R1,#+33
   \   00000086   0xD003             BEQ.N    ??I2C_MasterTransmit_TXE_4
   \   00000088   0x2A40             CMP      R2,#+64
   \   0000008A   0xD152             BNE.N    ??I2C_MasterTransmit_TXE_2
   \   0000008C   0x2922             CMP      R1,#+34
   \   0000008E   0xD150             BNE.N    ??I2C_MasterTransmit_TXE_2
   3796            {
   3797              if(hi2c->XferCount == 0U)
   \                     ??I2C_MasterTransmit_TXE_4: (+1)
   \   00000090   0x8D41             LDRH     R1,[R0, #+42]
   \   00000092   0x2900             CMP      R1,#+0
   \   00000094   0xD105             BNE.N    ??I2C_MasterTransmit_TXE_5
   3798              {
   3799                /* Disable BUF interrupt */
   3800                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x6848             LDR      R0,[R1, #+4]
   \   0000009A   0xF420 0x6080      BIC      R0,R0,#0x400
   \   0000009E   0x6048             STR      R0,[R1, #+4]
   \   000000A0   0xE047             B.N      ??I2C_MasterTransmit_TXE_2
   3801              }
   3802              else
   3803              {
   3804                if(hi2c->Mode == HAL_I2C_MODE_MEM)
   \                     ??I2C_MasterTransmit_TXE_5: (+1)
   \   000000A2   0xF990 0x103E      LDRSB    R1,[R0, #+62]
   \   000000A6   0x2940             CMP      R1,#+64
   \   000000A8   0xD13A             BNE.N    ??I2C_MasterTransmit_TXE_6
   3805                {
   3806                  if(hi2c->EventCount == 0)
   \   000000AA   0x6D01             LDR      R1,[R0, #+80]
   \   000000AC   0x2900             CMP      R1,#+0
   \   000000AE   0xD111             BNE.N    ??I2C_MasterTransmit_TXE_7
   3807                  {
   3808                    /* If Memory address size is 8Bit */
   3809                    if(hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
   \   000000B0   0x6801             LDR      R1,[R0, #+0]
   \   000000B2   0x6CC2             LDR      R2,[R0, #+76]
   \   000000B4   0x2A01             CMP      R2,#+1
   \   000000B6   0x6C82             LDR      R2,[R0, #+72]
   \   000000B8   0xD105             BNE.N    ??I2C_MasterTransmit_TXE_8
   3810                    {
   3811                      /* Send Memory Address */
   3812                      hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
   \   000000BA   0xB2D2             UXTB     R2,R2
   \   000000BC   0x610A             STR      R2,[R1, #+16]
   3813                      
   3814                      hi2c->EventCount += 2;
   \   000000BE   0x6D01             LDR      R1,[R0, #+80]
   \   000000C0   0x1C89             ADDS     R1,R1,#+2
   \   000000C2   0x6501             STR      R1,[R0, #+80]
   \   000000C4   0xE035             B.N      ??I2C_MasterTransmit_TXE_2
   3815                    }
   3816                    /* If Memory address size is 16Bit */
   3817                    else
   3818                    {
   3819                      /* Send MSB of Memory Address */
   3820                      hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
   \                     ??I2C_MasterTransmit_TXE_8: (+1)
   \   000000C6   0xB292             UXTH     R2,R2
   \   000000C8   0x0A12             LSRS     R2,R2,#+8
   \   000000CA   0x610A             STR      R2,[R1, #+16]
   3821                      
   3822                      hi2c->EventCount++;
   \   000000CC   0x6D01             LDR      R1,[R0, #+80]
   \   000000CE   0x1C49             ADDS     R1,R1,#+1
   \   000000D0   0x6501             STR      R1,[R0, #+80]
   \   000000D2   0xE02E             B.N      ??I2C_MasterTransmit_TXE_2
   3823                    }
   3824                  }
   3825                  else if(hi2c->EventCount == 1)
   \                     ??I2C_MasterTransmit_TXE_7: (+1)
   \   000000D4   0x6D01             LDR      R1,[R0, #+80]
   \   000000D6   0x2901             CMP      R1,#+1
   \   000000D8   0xD107             BNE.N    ??I2C_MasterTransmit_TXE_9
   3826                  {
   3827                    /* Send LSB of Memory Address */
   3828                    hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
   \   000000DA   0x6C81             LDR      R1,[R0, #+72]
   \   000000DC   0xB2C9             UXTB     R1,R1
   \   000000DE   0x6802             LDR      R2,[R0, #+0]
   \   000000E0   0x6111             STR      R1,[R2, #+16]
   3829                    
   3830                    hi2c->EventCount++;
   \   000000E2   0x6D01             LDR      R1,[R0, #+80]
   \   000000E4   0x1C49             ADDS     R1,R1,#+1
   \   000000E6   0x6501             STR      R1,[R0, #+80]
   \   000000E8   0xE023             B.N      ??I2C_MasterTransmit_TXE_2
   3831                  }
   3832                  else if(hi2c->EventCount == 2)
   \                     ??I2C_MasterTransmit_TXE_9: (+1)
   \   000000EA   0x6D01             LDR      R1,[R0, #+80]
   \   000000EC   0x2902             CMP      R1,#+2
   \   000000EE   0xD120             BNE.N    ??I2C_MasterTransmit_TXE_2
   3833                  {
   3834                    if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
   \   000000F0   0xF890 0x103D      LDRB     R1,[R0, #+61]
   \   000000F4   0x2922             CMP      R1,#+34
   \   000000F6   0xD105             BNE.N    ??I2C_MasterTransmit_TXE_10
   3835                    {
   3836                      /* Generate Restart */
   3837                      hi2c->Instance->CR1 |= I2C_CR1_START;
   \   000000F8   0x6801             LDR      R1,[R0, #+0]
   \   000000FA   0x6808             LDR      R0,[R1, #+0]
   \   000000FC   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000100   0x6008             STR      R0,[R1, #+0]
   \   00000102   0xE016             B.N      ??I2C_MasterTransmit_TXE_2
   3838                    }
   3839                    else if(hi2c->State == HAL_I2C_STATE_BUSY_TX)
   \                     ??I2C_MasterTransmit_TXE_10: (+1)
   \   00000104   0xF890 0x103D      LDRB     R1,[R0, #+61]
   \   00000108   0x2921             CMP      R1,#+33
   \   0000010A   0xD112             BNE.N    ??I2C_MasterTransmit_TXE_2
   3840                    {
   3841                      /* Write data to DR */
   3842                      hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \   0000010C   0x6A41             LDR      R1,[R0, #+36]
   \   0000010E   0x1C4A             ADDS     R2,R1,#+1
   \   00000110   0x6242             STR      R2,[R0, #+36]
   \   00000112   0x7809             LDRB     R1,[R1, #+0]
   \   00000114   0x6802             LDR      R2,[R0, #+0]
   \   00000116   0x6111             STR      R1,[R2, #+16]
   3843                      hi2c->XferCount--;
   \   00000118   0x8D41             LDRH     R1,[R0, #+42]
   \   0000011A   0x1E49             SUBS     R1,R1,#+1
   \   0000011C   0x8541             STRH     R1,[R0, #+42]
   \   0000011E   0xE008             B.N      ??I2C_MasterTransmit_TXE_2
   3844                    }
   3845                  }
   3846                }
   3847                else
   3848                {
   3849                  /* Write data to DR */
   3850                  hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \                     ??I2C_MasterTransmit_TXE_6: (+1)
   \   00000120   0x6A41             LDR      R1,[R0, #+36]
   \   00000122   0x1C4A             ADDS     R2,R1,#+1
   \   00000124   0x6242             STR      R2,[R0, #+36]
   \   00000126   0x7809             LDRB     R1,[R1, #+0]
   \   00000128   0x6802             LDR      R2,[R0, #+0]
   \   0000012A   0x6111             STR      R1,[R2, #+16]
   3851                  hi2c->XferCount--;
   \   0000012C   0x8D41             LDRH     R1,[R0, #+42]
   \   0000012E   0x1E49             SUBS     R1,R1,#+1
   \   00000130   0x8541             STRH     R1,[R0, #+42]
   3852                }
   3853              }
   3854            }
   3855            return HAL_OK;
   \                     ??I2C_MasterTransmit_TXE_2: (+1)
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0xBD10             POP      {R4,PC}          ;; return
   3856          }
   3857          
   3858          /**
   3859            * @brief  Handle BTF flag for Master transmitter
   3860            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3861            *         the configuration information for I2C module
   3862            * @retval HAL status
   3863            */

   \                                 In section .text, align 2, keep-with-next
   3864          static HAL_StatusTypeDef I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)
   3865          {
   \                     I2C_MasterTransmit_BTF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3866            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   3867            uint32_t CurrentXferOptions = hi2c->XferOptions;
   \   00000002   0x6AC1             LDR      R1,[R0, #+44]
   3868          
   3869            if(hi2c->State == HAL_I2C_STATE_BUSY_TX)
   \   00000004   0xF890 0x203D      LDRB     R2,[R0, #+61]
   \   00000008   0x2A21             CMP      R2,#+33
   \   0000000A   0xD142             BNE.N    ??I2C_MasterTransmit_BTF_0
   3870            {    
   3871              if(hi2c->XferCount != 0U)
   \   0000000C   0x8D42             LDRH     R2,[R0, #+42]
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD009             BEQ.N    ??I2C_MasterTransmit_BTF_1
   3872              {
   3873                /* Write data to DR */
   3874                hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \   00000012   0x6A41             LDR      R1,[R0, #+36]
   \   00000014   0x1C4A             ADDS     R2,R1,#+1
   \   00000016   0x6242             STR      R2,[R0, #+36]
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x6802             LDR      R2,[R0, #+0]
   \   0000001C   0x6111             STR      R1,[R2, #+16]
   3875                hi2c->XferCount--;
   \   0000001E   0x8D41             LDRH     R1,[R0, #+42]
   \   00000020   0x1E49             SUBS     R1,R1,#+1
   \   00000022   0x8541             STRH     R1,[R0, #+42]
   \   00000024   0xE035             B.N      ??I2C_MasterTransmit_BTF_0
   3876              }
   3877              else
   3878              {
   3879                /* Call TxCpltCallback() directly if no stop mode is set */
   3880                if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
   \                     ??I2C_MasterTransmit_BTF_1: (+1)
   \   00000026   0x2904             CMP      R1,#+4
   \   00000028   0xD015             BEQ.N    ??I2C_MasterTransmit_BTF_2
   \   0000002A   0x2908             CMP      R1,#+8
   \   0000002C   0xD013             BEQ.N    ??I2C_MasterTransmit_BTF_2
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable34  ;; 0xffff0000
   \   00000032   0x4291             CMP      R1,R2
   \   00000034   0xD00F             BEQ.N    ??I2C_MasterTransmit_BTF_2
   3881                {
   3882                  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0x684A             LDR      R2,[R1, #+4]
   \   0000003A   0xF422 0x62E0      BIC      R2,R2,#0x700
   \   0000003E   0x604A             STR      R2,[R1, #+4]
   3883                  
   3884                  hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
   \   00000040   0x2111             MOVS     R1,#+17
   \   00000042   0x6301             STR      R1,[R0, #+48]
   3885                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0xF880 0x103E      STRB     R1,[R0, #+62]
   3886                  hi2c->State = HAL_I2C_STATE_READY;
   \   0000004A   0x2120             MOVS     R1,#+32
   \   0000004C   0xF880 0x103D      STRB     R1,[R0, #+61]
   3887                  
   3888                  HAL_I2C_MasterTxCpltCallback(hi2c);
   \   00000050   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   \   00000054   0xE01D             B.N      ??I2C_MasterTransmit_BTF_0
   3889                }
   3890                else /* Generate Stop condition then Call TxCpltCallback() */
   3891                {
   3892                  /* Disable EVT, BUF and ERR interrupt */
   3893                  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \                     ??I2C_MasterTransmit_BTF_2: (+1)
   \   00000056   0x6801             LDR      R1,[R0, #+0]
   \   00000058   0x684A             LDR      R2,[R1, #+4]
   \   0000005A   0xF422 0x62E0      BIC      R2,R2,#0x700
   \   0000005E   0x604A             STR      R2,[R1, #+4]
   3894                  
   3895                  /* Generate Stop */
   3896                  hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0x680A             LDR      R2,[R1, #+0]
   \   00000064   0xF442 0x7200      ORR      R2,R2,#0x200
   \   00000068   0x600A             STR      R2,[R1, #+0]
   3897                  
   3898                  hi2c->PreviousState = I2C_STATE_NONE;
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x6301             STR      R1,[R0, #+48]
   3899                  hi2c->State = HAL_I2C_STATE_READY;
   \   0000006E   0x2120             MOVS     R1,#+32
   \   00000070   0xF880 0x103D      STRB     R1,[R0, #+61]
   3900                  
   3901                  if(hi2c->Mode == HAL_I2C_MODE_MEM)
   \   00000074   0xF990 0x103E      LDRSB    R1,[R0, #+62]
   \   00000078   0x2940             CMP      R1,#+64
   \   0000007A   0xD105             BNE.N    ??I2C_MasterTransmit_BTF_3
   3902                  {
   3903                    hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0xF880 0x103E      STRB     R1,[R0, #+62]
   3904                    
   3905                    HAL_I2C_MemTxCpltCallback(hi2c);
   \   00000082   0x.... 0x....      BL       HAL_I2C_MemTxCpltCallback
   \   00000086   0xE004             B.N      ??I2C_MasterTransmit_BTF_0
   3906                  }
   3907                  else
   3908                  {
   3909                    hi2c->Mode = HAL_I2C_MODE_NONE;
   \                     ??I2C_MasterTransmit_BTF_3: (+1)
   \   00000088   0x2100             MOVS     R1,#+0
   \   0000008A   0xF880 0x103E      STRB     R1,[R0, #+62]
   3910                    
   3911                    HAL_I2C_MasterTxCpltCallback(hi2c);
   \   0000008E   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   3912                  }
   3913                }
   3914              }
   3915            }
   3916            return HAL_OK;
   \                     ??I2C_MasterTransmit_BTF_0: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xBD02             POP      {R1,PC}          ;; return
   3917          }
   3918          
   3919          /**
   3920            * @brief  Handle RXNE flag for Master
   3921            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3922            *         the configuration information for I2C module
   3923            * @retval HAL status
   3924            */

   \                                 In section .text, align 2, keep-with-next
   3925          static HAL_StatusTypeDef I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)
   3926          {
   \                     I2C_MasterReceive_RXNE: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3927            if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
   \   00000002   0xF890 0x103D      LDRB     R1,[R0, #+61]
   \   00000006   0x2922             CMP      R1,#+34
   \   00000008   0xD156             BNE.N    ??I2C_MasterReceive_RXNE_0
   3928            {
   3929              uint32_t tmp = 0U;
   3930              
   3931              tmp = hi2c->XferCount;
   \   0000000A   0x8D41             LDRH     R1,[R0, #+42]
   3932              if(tmp > 3U)
   \   0000000C   0x2904             CMP      R1,#+4
   \   0000000E   0xD309             BCC.N    ??I2C_MasterReceive_RXNE_1
   3933              {
   3934                /* Read data from DR */
   3935                (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000010   0x6A41             LDR      R1,[R0, #+36]
   \   00000012   0x1C4A             ADDS     R2,R1,#+1
   \   00000014   0x6242             STR      R2,[R0, #+36]
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x6912             LDR      R2,[R2, #+16]
   \   0000001A   0x700A             STRB     R2,[R1, #+0]
   3936                hi2c->XferCount--;
   \   0000001C   0x8D41             LDRH     R1,[R0, #+42]
   \   0000001E   0x1E49             SUBS     R1,R1,#+1
   \   00000020   0x8541             STRH     R1,[R0, #+42]
   \   00000022   0xE049             B.N      ??I2C_MasterReceive_RXNE_0
   3937              }
   3938              else if((tmp == 2U) || (tmp == 3U))
   \                     ??I2C_MasterReceive_RXNE_1: (+1)
   \   00000024   0x2902             CMP      R1,#+2
   \   00000026   0xD001             BEQ.N    ??I2C_MasterReceive_RXNE_2
   \   00000028   0x2903             CMP      R1,#+3
   \   0000002A   0xD116             BNE.N    ??I2C_MasterReceive_RXNE_3
   3939              {
   3940                if(hi2c->XferOptions != I2C_NEXT_FRAME)
   \                     ??I2C_MasterReceive_RXNE_2: (+1)
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x6AC2             LDR      R2,[R0, #+44]
   \   00000030   0x2A02             CMP      R2,#+2
   \   00000032   0x680A             LDR      R2,[R1, #+0]
   \   00000034   0xD008             BEQ.N    ??I2C_MasterReceive_RXNE_4
   3941                {
   3942                  /* Disable Acknowledge */
   3943                  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   00000036   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000003A   0x600A             STR      R2,[R1, #+0]
   3944                  
   3945                  /* Enable Pos */
   3946                  hi2c->Instance->CR1 |= I2C_CR1_POS;
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x680A             LDR      R2,[R1, #+0]
   \   00000040   0xF442 0x6200      ORR      R2,R2,#0x800
   \   00000044   0x600A             STR      R2,[R1, #+0]
   \   00000046   0xE002             B.N      ??I2C_MasterReceive_RXNE_5
   3947                }
   3948                else
   3949                {
   3950                  /* Enable Acknowledge */
   3951                  hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \                     ??I2C_MasterReceive_RXNE_4: (+1)
   \   00000048   0xF442 0x6280      ORR      R2,R2,#0x400
   \   0000004C   0x600A             STR      R2,[R1, #+0]
   3952                }
   3953                
   3954                /* Disable BUF interrupt */
   3955                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   \                     ??I2C_MasterReceive_RXNE_5: (+1)
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x6841             LDR      R1,[R0, #+4]
   \   00000052   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000056   0x6041             STR      R1,[R0, #+4]
   \   00000058   0xE02E             B.N      ??I2C_MasterReceive_RXNE_0
   3956              }
   3957              else
   3958              {
   3959                if(hi2c->XferOptions != I2C_NEXT_FRAME)
   \                     ??I2C_MasterReceive_RXNE_3: (+1)
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0x6AC2             LDR      R2,[R0, #+44]
   \   0000005E   0x2A02             CMP      R2,#+2
   \   00000060   0x680A             LDR      R2,[R1, #+0]
   \   00000062   0xD003             BEQ.N    ??I2C_MasterReceive_RXNE_6
   3960                {
   3961                  /* Disable Acknowledge */
   3962                  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   00000064   0xF422 0x6280      BIC      R2,R2,#0x400
   \   00000068   0x600A             STR      R2,[R1, #+0]
   \   0000006A   0xE002             B.N      ??I2C_MasterReceive_RXNE_7
   3963                }
   3964                else
   3965                {
   3966                  /* Enable Acknowledge */
   3967                  hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \                     ??I2C_MasterReceive_RXNE_6: (+1)
   \   0000006C   0xF442 0x6280      ORR      R2,R2,#0x400
   \   00000070   0x600A             STR      R2,[R1, #+0]
   3968                }
   3969          
   3970                /* Disable EVT, BUF and ERR interrupt */
   3971                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \                     ??I2C_MasterReceive_RXNE_7: (+1)
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0x684A             LDR      R2,[R1, #+4]
   \   00000076   0xF422 0x62E0      BIC      R2,R2,#0x700
   \   0000007A   0x604A             STR      R2,[R1, #+4]
   3972                
   3973                /* Read data from DR */
   3974                (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   0000007C   0x6A41             LDR      R1,[R0, #+36]
   \   0000007E   0x1C4A             ADDS     R2,R1,#+1
   \   00000080   0x6242             STR      R2,[R0, #+36]
   \   00000082   0x6802             LDR      R2,[R0, #+0]
   \   00000084   0x6912             LDR      R2,[R2, #+16]
   \   00000086   0x700A             STRB     R2,[R1, #+0]
   3975                hi2c->XferCount--;
   \   00000088   0x8D41             LDRH     R1,[R0, #+42]
   \   0000008A   0x1E49             SUBS     R1,R1,#+1
   \   0000008C   0x8541             STRH     R1,[R0, #+42]
   3976          
   3977                hi2c->State = HAL_I2C_STATE_READY;
   \   0000008E   0x2120             MOVS     R1,#+32
   \   00000090   0xF880 0x103D      STRB     R1,[R0, #+61]
   3978          
   3979                if(hi2c->Mode == HAL_I2C_MODE_MEM)
   \   00000094   0xF990 0x103E      LDRSB    R1,[R0, #+62]
   \   00000098   0x2940             CMP      R1,#+64
   \   0000009A   0xD106             BNE.N    ??I2C_MasterReceive_RXNE_8
   3980                {
   3981                  hi2c->PreviousState = I2C_STATE_NONE;
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0x6301             STR      R1,[R0, #+48]
   3982                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \   000000A0   0xF880 0x103E      STRB     R1,[R0, #+62]
   3983                  HAL_I2C_MemRxCpltCallback(hi2c);
   \   000000A4   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \   000000A8   0xE006             B.N      ??I2C_MasterReceive_RXNE_0
   3984                }
   3985                else
   3986                {
   3987                  hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
   \                     ??I2C_MasterReceive_RXNE_8: (+1)
   \   000000AA   0x2112             MOVS     R1,#+18
   \   000000AC   0x6301             STR      R1,[R0, #+48]
   3988                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0xF880 0x103E      STRB     R1,[R0, #+62]
   3989                  HAL_I2C_MasterRxCpltCallback(hi2c);
   \   000000B4   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   3990                }
   3991              }
   3992            }
   3993            return HAL_OK;
   \                     ??I2C_MasterReceive_RXNE_0: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xBD02             POP      {R1,PC}          ;; return
   3994          }
   3995          
   3996          /**
   3997            * @brief  Handle BTF flag for Master receiver
   3998            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3999            *         the configuration information for I2C module
   4000            * @retval HAL status
   4001            */

   \                                 In section .text, align 2, keep-with-next
   4002          static HAL_StatusTypeDef I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)
   4003          {
   \                     I2C_MasterReceive_BTF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   4004            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   4005            uint32_t CurrentXferOptions = hi2c->XferOptions;
   \   00000002   0x6AC1             LDR      R1,[R0, #+44]
   4006          
   4007            if(hi2c->XferCount == 3U)
   \   00000004   0x8D42             LDRH     R2,[R0, #+42]
   \   00000006   0x2A03             CMP      R2,#+3
   \   00000008   0xD116             BNE.N    ??I2C_MasterReceive_BTF_0
   4008            {
   4009              if((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME) || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
   \   0000000A   0x2904             CMP      R1,#+4
   \   0000000C   0xD005             BEQ.N    ??I2C_MasterReceive_BTF_1
   \   0000000E   0x2908             CMP      R1,#+8
   \   00000010   0xD003             BEQ.N    ??I2C_MasterReceive_BTF_1
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable34  ;; 0xffff0000
   \   00000016   0x4291             CMP      R1,R2
   \   00000018   0xD104             BNE.N    ??I2C_MasterReceive_BTF_2
   4010              {
   4011                /* Disable Acknowledge */
   4012                hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \                     ??I2C_MasterReceive_BTF_1: (+1)
   \   0000001A   0x6802             LDR      R2,[R0, #+0]
   \   0000001C   0x6811             LDR      R1,[R2, #+0]
   \   0000001E   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000022   0x6011             STR      R1,[R2, #+0]
   4013              }
   4014          
   4015              /* Read data from DR */
   4016              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \                     ??I2C_MasterReceive_BTF_2: (+1)
   \   00000024   0x6A41             LDR      R1,[R0, #+36]
   \   00000026   0x1C4A             ADDS     R2,R1,#+1
   \   00000028   0x6242             STR      R2,[R0, #+36]
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x6912             LDR      R2,[R2, #+16]
   \   0000002E   0x700A             STRB     R2,[R1, #+0]
   4017              hi2c->XferCount--;
   \   00000030   0x8D41             LDRH     R1,[R0, #+42]
   \   00000032   0x1E49             SUBS     R1,R1,#+1
   \   00000034   0x8541             STRH     R1,[R0, #+42]
   \   00000036   0xE051             B.N      ??I2C_MasterReceive_BTF_3
   4018            }
   4019            else if(hi2c->XferCount == 2U)
   \                     ??I2C_MasterReceive_BTF_0: (+1)
   \   00000038   0x8D42             LDRH     R2,[R0, #+42]
   \   0000003A   0x2A02             CMP      R2,#+2
   \   0000003C   0xD145             BNE.N    ??I2C_MasterReceive_BTF_4
   4020            {
   4021              /* Prepare next transfer or stop current transfer */
   4022              if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
   \   0000003E   0x2904             CMP      R1,#+4
   \   00000040   0xD011             BEQ.N    ??I2C_MasterReceive_BTF_5
   \   00000042   0x2908             CMP      R1,#+8
   \   00000044   0xD00F             BEQ.N    ??I2C_MasterReceive_BTF_5
   \   00000046   0x.... 0x....      LDR.W    R2,??DataTable34  ;; 0xffff0000
   \   0000004A   0x4291             CMP      R1,R2
   \   0000004C   0xD00B             BEQ.N    ??I2C_MasterReceive_BTF_5
   4023              {
   4024                if(CurrentXferOptions != I2C_NEXT_FRAME)
   \   0000004E   0x6802             LDR      R2,[R0, #+0]
   \   00000050   0x2902             CMP      R1,#+2
   \   00000052   0x6811             LDR      R1,[R2, #+0]
   \   00000054   0xD003             BEQ.N    ??I2C_MasterReceive_BTF_6
   4025                {
   4026                  /* Disable Acknowledge */
   4027                  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   00000056   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000005A   0x6011             STR      R1,[R2, #+0]
   \   0000005C   0xE008             B.N      ??I2C_MasterReceive_BTF_7
   4028                }
   4029                else
   4030                {
   4031                  /* Enable Acknowledge */
   4032                  hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \                     ??I2C_MasterReceive_BTF_6: (+1)
   \   0000005E   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000062   0x6011             STR      R1,[R2, #+0]
   \   00000064   0xE004             B.N      ??I2C_MasterReceive_BTF_7
   4033                }
   4034              }
   4035              else
   4036              {
   4037                /* Generate Stop */
   4038                hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \                     ??I2C_MasterReceive_BTF_5: (+1)
   \   00000066   0x6802             LDR      R2,[R0, #+0]
   \   00000068   0x6811             LDR      R1,[R2, #+0]
   \   0000006A   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000006E   0x6011             STR      R1,[R2, #+0]
   4039              }
   4040          
   4041              /* Read data from DR */
   4042              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \                     ??I2C_MasterReceive_BTF_7: (+1)
   \   00000070   0x6A41             LDR      R1,[R0, #+36]
   \   00000072   0x1C4A             ADDS     R2,R1,#+1
   \   00000074   0x6242             STR      R2,[R0, #+36]
   \   00000076   0x6802             LDR      R2,[R0, #+0]
   \   00000078   0x6912             LDR      R2,[R2, #+16]
   \   0000007A   0x700A             STRB     R2,[R1, #+0]
   4043              hi2c->XferCount--;
   \   0000007C   0x8D41             LDRH     R1,[R0, #+42]
   \   0000007E   0x1E49             SUBS     R1,R1,#+1
   \   00000080   0x8541             STRH     R1,[R0, #+42]
   4044          
   4045              /* Read data from DR */
   4046              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000082   0x6A41             LDR      R1,[R0, #+36]
   \   00000084   0x1C4A             ADDS     R2,R1,#+1
   \   00000086   0x6242             STR      R2,[R0, #+36]
   \   00000088   0x6802             LDR      R2,[R0, #+0]
   \   0000008A   0x6912             LDR      R2,[R2, #+16]
   \   0000008C   0x700A             STRB     R2,[R1, #+0]
   4047              hi2c->XferCount--;
   \   0000008E   0x8D41             LDRH     R1,[R0, #+42]
   \   00000090   0x1E49             SUBS     R1,R1,#+1
   \   00000092   0x8541             STRH     R1,[R0, #+42]
   4048          
   4049              /* Disable EVT and ERR interrupt */
   4050              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \   00000094   0x6801             LDR      R1,[R0, #+0]
   \   00000096   0x684A             LDR      R2,[R1, #+4]
   \   00000098   0xF422 0x7240      BIC      R2,R2,#0x300
   \   0000009C   0x604A             STR      R2,[R1, #+4]
   4051          
   4052              hi2c->State = HAL_I2C_STATE_READY;
   \   0000009E   0x2120             MOVS     R1,#+32
   \   000000A0   0xF880 0x103D      STRB     R1,[R0, #+61]
   4053              
   4054              if(hi2c->Mode == HAL_I2C_MODE_MEM)
   \   000000A4   0xF990 0x103E      LDRSB    R1,[R0, #+62]
   \   000000A8   0x2940             CMP      R1,#+64
   \   000000AA   0xD106             BNE.N    ??I2C_MasterReceive_BTF_8
   4055              {
   4056                hi2c->PreviousState = I2C_STATE_NONE;
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x6301             STR      R1,[R0, #+48]
   4057                hi2c->Mode = HAL_I2C_MODE_NONE;
   \   000000B0   0xF880 0x103E      STRB     R1,[R0, #+62]
   4058          
   4059                HAL_I2C_MemRxCpltCallback(hi2c);
   \   000000B4   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \   000000B8   0xE010             B.N      ??I2C_MasterReceive_BTF_3
   4060              }
   4061              else
   4062              {
   4063                hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
   \                     ??I2C_MasterReceive_BTF_8: (+1)
   \   000000BA   0x2112             MOVS     R1,#+18
   \   000000BC   0x6301             STR      R1,[R0, #+48]
   4064                hi2c->Mode = HAL_I2C_MODE_NONE;
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0xF880 0x103E      STRB     R1,[R0, #+62]
   4065          
   4066                HAL_I2C_MasterRxCpltCallback(hi2c);
   \   000000C4   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   \   000000C8   0xE008             B.N      ??I2C_MasterReceive_BTF_3
   4067              }
   4068            }
   4069            else
   4070            {
   4071              /* Read data from DR */
   4072              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \                     ??I2C_MasterReceive_BTF_4: (+1)
   \   000000CA   0x6A41             LDR      R1,[R0, #+36]
   \   000000CC   0x1C4A             ADDS     R2,R1,#+1
   \   000000CE   0x6242             STR      R2,[R0, #+36]
   \   000000D0   0x6802             LDR      R2,[R0, #+0]
   \   000000D2   0x6912             LDR      R2,[R2, #+16]
   \   000000D4   0x700A             STRB     R2,[R1, #+0]
   4073              hi2c->XferCount--;
   \   000000D6   0x8D41             LDRH     R1,[R0, #+42]
   \   000000D8   0x1E49             SUBS     R1,R1,#+1
   \   000000DA   0x8541             STRH     R1,[R0, #+42]
   4074            }
   4075            return HAL_OK;
   \                     ??I2C_MasterReceive_BTF_3: (+1)
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0xBD02             POP      {R1,PC}          ;; return
   4076          }
   4077          
   4078          /**
   4079            * @brief  Handle SB flag for Master
   4080            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4081            *         the configuration information for I2C module
   4082            * @retval HAL status
   4083            */

   \                                 In section .text, align 2, keep-with-next
   4084          static HAL_StatusTypeDef I2C_Master_SB(I2C_HandleTypeDef *hi2c)
   4085          {
   4086            if(hi2c->Mode == HAL_I2C_MODE_MEM)
   \                     I2C_Master_SB: (+1)
   \   00000000   0xF990 0x103E      LDRSB    R1,[R0, #+62]
   \   00000004   0x2940             CMP      R1,#+64
   \   00000006   0xD10D             BNE.N    ??I2C_Master_SB_0
   4087            {
   4088              if(hi2c->EventCount == 0U)
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x6D02             LDR      R2,[R0, #+80]
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0x6C40             LDR      R0,[R0, #+68]
   \   00000010   0xD103             BNE.N    ??I2C_Master_SB_1
   4089              {
   4090                /* Send slave address */
   4091                hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
   \   00000012   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   00000016   0x6108             STR      R0,[R1, #+16]
   \   00000018   0xE030             B.N      ??I2C_Master_SB_2
   4092              }
   4093              else
   4094              {
   4095                hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
   \                     ??I2C_Master_SB_1: (+1)
   \   0000001A   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x6108             STR      R0,[R1, #+16]
   \   00000022   0xE02B             B.N      ??I2C_Master_SB_2
   4096              }
   4097            }
   4098            else
   4099            {
   4100              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \                     ??I2C_Master_SB_0: (+1)
   \   00000024   0x6901             LDR      R1,[R0, #+16]
   \   00000026   0xF5B1 0x4F80      CMP      R1,#+16384
   \   0000002A   0xD10E             BNE.N    ??I2C_Master_SB_3
   4101              {
   4102                /* Send slave 7 Bits address */
   4103                if(hi2c->State == HAL_I2C_STATE_BUSY_TX) 
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0xF890 0x203D      LDRB     R2,[R0, #+61]
   \   00000032   0x2A21             CMP      R2,#+33
   \   00000034   0x6C40             LDR      R0,[R0, #+68]
   \   00000036   0xD103             BNE.N    ??I2C_Master_SB_4
   4104                {
   4105                  hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
   \   00000038   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   0000003C   0x6108             STR      R0,[R1, #+16]
   \   0000003E   0xE01D             B.N      ??I2C_Master_SB_2
   4106                }
   4107                else
   4108                {
   4109                  hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
   \                     ??I2C_Master_SB_4: (+1)
   \   00000040   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000044   0xB2C0             UXTB     R0,R0
   \   00000046   0x6108             STR      R0,[R1, #+16]
   \   00000048   0xE018             B.N      ??I2C_Master_SB_2
   4110                }
   4111              }
   4112              else
   4113              {
   4114                if(hi2c->EventCount == 0U)
   \                     ??I2C_Master_SB_3: (+1)
   \   0000004A   0x6D01             LDR      R1,[R0, #+80]
   \   0000004C   0x2900             CMP      R1,#+0
   \   0000004E   0xD109             BNE.N    ??I2C_Master_SB_5
   4115                {
   4116                  /* Send header of slave address */
   4117                  hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
   \   00000050   0x6C41             LDR      R1,[R0, #+68]
   \   00000052   0xB289             UXTH     R1,R1
   \   00000054   0x09C9             LSRS     R1,R1,#+7
   \   00000056   0xF001 0x0106      AND      R1,R1,#0x6
   \   0000005A   0xF041 0x01F0      ORR      R1,R1,#0xF0
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x6101             STR      R1,[R0, #+16]
   \   00000062   0xE00B             B.N      ??I2C_Master_SB_2
   4118                }
   4119                else if(hi2c->EventCount == 1U)
   \                     ??I2C_Master_SB_5: (+1)
   \   00000064   0x6D01             LDR      R1,[R0, #+80]
   \   00000066   0x2901             CMP      R1,#+1
   \   00000068   0xD108             BNE.N    ??I2C_Master_SB_2
   4120                {
   4121                  /* Send header of slave address */
   4122                  hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
   \   0000006A   0x6C41             LDR      R1,[R0, #+68]
   \   0000006C   0xB289             UXTH     R1,R1
   \   0000006E   0x09C9             LSRS     R1,R1,#+7
   \   00000070   0xF001 0x0106      AND      R1,R1,#0x6
   \   00000074   0xF041 0x01F1      ORR      R1,R1,#0xF1
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x6101             STR      R1,[R0, #+16]
   4123                }
   4124              }
   4125            }
   4126          
   4127            return HAL_OK;
   \                     ??I2C_Master_SB_2: (+1)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x4770             BX       LR               ;; return
   4128          }
   4129          
   4130          /**
   4131            * @brief  Handle ADD10 flag for Master
   4132            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4133            *         the configuration information for I2C module
   4134            * @retval HAL status
   4135            */

   \                                 In section .text, align 2, keep-with-next
   4136          static HAL_StatusTypeDef I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)
   4137          {
   4138            /* Send slave address */
   4139            hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
   \                     I2C_Master_ADD10: (+1)
   \   00000000   0x6C41             LDR      R1,[R0, #+68]
   \   00000002   0xB2C9             UXTB     R1,R1
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6101             STR      R1,[R0, #+16]
   4140          
   4141            return HAL_OK;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR               ;; return
   4142          }
   4143          
   4144          /**
   4145            * @brief  Handle ADDR flag for Master
   4146            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4147            *         the configuration information for I2C module
   4148            * @retval HAL status
   4149            */

   \                                 In section .text, align 2, keep-with-next
   4150          static HAL_StatusTypeDef I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)
   4151          {
   \                     I2C_Master_ADDR: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   4152            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   4153            uint32_t CurrentMode        = hi2c->Mode;
   \   00000002   0xF990 0x103E      LDRSB    R1,[R0, #+62]
   4154            uint32_t CurrentXferOptions = hi2c->XferOptions;
   \   00000006   0x6AC2             LDR      R2,[R0, #+44]
   4155            uint32_t Prev_State         = hi2c->PreviousState;
   \   00000008   0x6B03             LDR      R3,[R0, #+48]
   4156          
   4157            if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
   \   0000000A   0xF890 0x403D      LDRB     R4,[R0, #+61]
   \   0000000E   0x2C22             CMP      R4,#+34
   \   00000010   0xF040 0x80C7      BNE.W    ??I2C_Master_ADDR_0
   4158            {
   4159              if((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
   \   00000014   0x6D04             LDR      R4,[R0, #+80]
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD10A             BNE.N    ??I2C_Master_ADDR_1
   \   0000001A   0x2940             CMP      R1,#+64
   \   0000001C   0xD108             BNE.N    ??I2C_Master_ADDR_1
   4160              {
   4161                /* Clear ADDR flag */
   4162                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x9100             STR      R1,[SP, #+0]
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x6948             LDR      R0,[R1, #+20]
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0x6988             LDR      R0,[R1, #+24]
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0xE0C0             B.N      ??I2C_Master_ADDR_2
   4163              }
   4164              else if((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
   \                     ??I2C_Master_ADDR_1: (+1)
   \   00000030   0x6D01             LDR      R1,[R0, #+80]
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD113             BNE.N    ??I2C_Master_ADDR_3
   \   00000036   0x6901             LDR      R1,[R0, #+16]
   \   00000038   0xF5B1 0x4F40      CMP      R1,#+49152
   \   0000003C   0xD10F             BNE.N    ??I2C_Master_ADDR_3
   4165              {
   4166                /* Clear ADDR flag */
   4167                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x9100             STR      R1,[SP, #+0]
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0x694A             LDR      R2,[R1, #+20]
   \   00000046   0x9200             STR      R2,[SP, #+0]
   \   00000048   0x698A             LDR      R2,[R1, #+24]
   \   0000004A   0x9200             STR      R2,[SP, #+0]
   \   0000004C   0x9A00             LDR      R2,[SP, #+0]
   4168                
   4169                /* Generate Restart */
   4170                hi2c->Instance->CR1 |= I2C_CR1_START;
   \   0000004E   0x680A             LDR      R2,[R1, #+0]
   \   00000050   0xF442 0x7280      ORR      R2,R2,#0x100
   \   00000054   0x600A             STR      R2,[R1, #+0]
   4171                
   4172                hi2c->EventCount++;
   \   00000056   0x6D01             LDR      R1,[R0, #+80]
   \   00000058   0x1C49             ADDS     R1,R1,#+1
   \   0000005A   0x6501             STR      R1,[R0, #+80]
   \   0000005C   0xE0A9             B.N      ??I2C_Master_ADDR_2
   4173              }
   4174              else
   4175              {
   4176                if(hi2c->XferCount == 0U)
   \                     ??I2C_Master_ADDR_3: (+1)
   \   0000005E   0x8D41             LDRH     R1,[R0, #+42]
   \   00000060   0x2900             CMP      R1,#+0
   \   00000062   0xD10C             BNE.N    ??I2C_Master_ADDR_4
   4177                {
   4178                  /* Clear ADDR flag */
   4179                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x9100             STR      R1,[SP, #+0]
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0x694A             LDR      R2,[R1, #+20]
   \   0000006C   0x9200             STR      R2,[SP, #+0]
   \   0000006E   0x698A             LDR      R2,[R1, #+24]
   \   00000070   0x9200             STR      R2,[SP, #+0]
   \   00000072   0x9A00             LDR      R2,[SP, #+0]
   4180                  
   4181                  /* Generate Stop */
   4182                  hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   00000074   0x680A             LDR      R2,[R1, #+0]
   \   00000076   0xF442 0x7200      ORR      R2,R2,#0x200
   \   0000007A   0x600A             STR      R2,[R1, #+0]
   \   0000007C   0xE08E             B.N      ??I2C_Master_ADDR_5
   4183                }
   4184                else if(hi2c->XferCount == 1U)   
   \                     ??I2C_Master_ADDR_4: (+1)
   \   0000007E   0x8D41             LDRH     R1,[R0, #+42]
   \   00000080   0x2901             CMP      R1,#+1
   \   00000082   0xD152             BNE.N    ??I2C_Master_ADDR_6
   4185                {
   4186                  if(CurrentXferOptions == I2C_NO_OPTION_FRAME)
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable34  ;; 0xffff0000
   \   00000088   0x428A             CMP      R2,R1
   \   0000008A   0xD121             BNE.N    ??I2C_Master_ADDR_7
   4187                  {
   4188                    /* Disable Acknowledge */
   4189                      hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0x680A             LDR      R2,[R1, #+0]
   \   00000090   0xF422 0x6280      BIC      R2,R2,#0x400
   \   00000094   0x600A             STR      R2,[R1, #+0]
   4190          
   4191                    if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x684A             LDR      R2,[R1, #+4]
   \   0000009A   0x0512             LSLS     R2,R2,#+20
   \   0000009C   0xD50C             BPL.N    ??I2C_Master_ADDR_8
   4192                    {
   4193                      /* Disable Acknowledge */
   4194                      hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   0000009E   0x680A             LDR      R2,[R1, #+0]
   \   000000A0   0xF422 0x6280      BIC      R2,R2,#0x400
   \   000000A4   0x600A             STR      R2,[R1, #+0]
   4195          
   4196                      /* Clear ADDR flag */
   4197                      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0x9100             STR      R1,[SP, #+0]
   \   000000AA   0x6801             LDR      R1,[R0, #+0]
   \   000000AC   0x694A             LDR      R2,[R1, #+20]
   \   000000AE   0x9200             STR      R2,[SP, #+0]
   \   000000B0   0x6989             LDR      R1,[R1, #+24]
   \   000000B2   0x9100             STR      R1,[SP, #+0]
   \   000000B4   0x9900             LDR      R1,[SP, #+0]
   \   000000B6   0xE071             B.N      ??I2C_Master_ADDR_5
   4198                    }
   4199                    else
   4200                    {
   4201                      /* Clear ADDR flag */
   4202                      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_Master_ADDR_8: (+1)
   \   000000B8   0x2200             MOVS     R2,#+0
   \   000000BA   0x9200             STR      R2,[SP, #+0]
   \   000000BC   0x694A             LDR      R2,[R1, #+20]
   \   000000BE   0x9200             STR      R2,[SP, #+0]
   \   000000C0   0x698A             LDR      R2,[R1, #+24]
   \   000000C2   0x9200             STR      R2,[SP, #+0]
   \   000000C4   0x9A00             LDR      R2,[SP, #+0]
   4203          
   4204                      /* Generate Stop */
   4205                      hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   000000C6   0x680A             LDR      R2,[R1, #+0]
   \   000000C8   0xF442 0x7200      ORR      R2,R2,#0x200
   \   000000CC   0x600A             STR      R2,[R1, #+0]
   \   000000CE   0xE065             B.N      ??I2C_Master_ADDR_5
   4206                    }
   4207                  }
   4208                  /* Prepare next transfer or stop current transfer */
   4209                  else if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
   4210                    && (Prev_State != I2C_STATE_MASTER_BUSY_RX))
   \                     ??I2C_Master_ADDR_7: (+1)
   \   000000D0   0x2A04             CMP      R2,#+4
   \   000000D2   0xD018             BEQ.N    ??I2C_Master_ADDR_9
   \   000000D4   0x2A08             CMP      R2,#+8
   \   000000D6   0xD016             BEQ.N    ??I2C_Master_ADDR_9
   \   000000D8   0x2B12             CMP      R3,#+18
   \   000000DA   0xD014             BEQ.N    ??I2C_Master_ADDR_9
   4211                  {
   4212                    if(hi2c->XferOptions != I2C_NEXT_FRAME)
   \   000000DC   0x6801             LDR      R1,[R0, #+0]
   \   000000DE   0x6AC2             LDR      R2,[R0, #+44]
   \   000000E0   0x2A02             CMP      R2,#+2
   \   000000E2   0x680A             LDR      R2,[R1, #+0]
   \   000000E4   0xD003             BEQ.N    ??I2C_Master_ADDR_10
   4213                    {
   4214                      /* Disable Acknowledge */
   4215                      hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   000000E6   0xF422 0x6280      BIC      R2,R2,#0x400
   \   000000EA   0x600A             STR      R2,[R1, #+0]
   \   000000EC   0xE002             B.N      ??I2C_Master_ADDR_11
   4216                    }
   4217                    else
   4218                    {
   4219                      /* Enable Acknowledge */
   4220                      hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \                     ??I2C_Master_ADDR_10: (+1)
   \   000000EE   0xF442 0x6280      ORR      R2,R2,#0x400
   \   000000F2   0x600A             STR      R2,[R1, #+0]
   4221                    }
   4222                    
   4223                    /* Clear ADDR flag */
   4224                    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_Master_ADDR_11: (+1)
   \   000000F4   0x2100             MOVS     R1,#+0
   \   000000F6   0x9100             STR      R1,[SP, #+0]
   \   000000F8   0x6801             LDR      R1,[R0, #+0]
   \   000000FA   0x694A             LDR      R2,[R1, #+20]
   \   000000FC   0x9200             STR      R2,[SP, #+0]
   \   000000FE   0x6989             LDR      R1,[R1, #+24]
   \   00000100   0x9100             STR      R1,[SP, #+0]
   \   00000102   0x9900             LDR      R1,[SP, #+0]
   \   00000104   0xE04A             B.N      ??I2C_Master_ADDR_5
   4225                  }
   4226                  else
   4227                  {
   4228                    /* Disable Acknowledge */
   4229                    hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \                     ??I2C_Master_ADDR_9: (+1)
   \   00000106   0x6801             LDR      R1,[R0, #+0]
   \   00000108   0x680A             LDR      R2,[R1, #+0]
   \   0000010A   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000010E   0x600A             STR      R2,[R1, #+0]
   4230                    
   4231                    /* Clear ADDR flag */
   4232                    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \   00000110   0x2100             MOVS     R1,#+0
   \   00000112   0x9100             STR      R1,[SP, #+0]
   \   00000114   0x6801             LDR      R1,[R0, #+0]
   \   00000116   0x694A             LDR      R2,[R1, #+20]
   \   00000118   0x9200             STR      R2,[SP, #+0]
   \   0000011A   0x698A             LDR      R2,[R1, #+24]
   \   0000011C   0x9200             STR      R2,[SP, #+0]
   \   0000011E   0x9A00             LDR      R2,[SP, #+0]
   4233                    
   4234                    /* Generate Stop */
   4235                    hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   00000120   0x680A             LDR      R2,[R1, #+0]
   \   00000122   0xF442 0x7200      ORR      R2,R2,#0x200
   \   00000126   0x600A             STR      R2,[R1, #+0]
   \   00000128   0xE038             B.N      ??I2C_Master_ADDR_5
   4236                  }
   4237                }
   4238                else if(hi2c->XferCount == 2U)
   \                     ??I2C_Master_ADDR_6: (+1)
   \   0000012A   0x6801             LDR      R1,[R0, #+0]
   \   0000012C   0x8D42             LDRH     R2,[R0, #+42]
   \   0000012E   0x2A02             CMP      R2,#+2
   \   00000130   0xD120             BNE.N    ??I2C_Master_ADDR_12
   4239                {
   4240                  if(hi2c->XferOptions != I2C_NEXT_FRAME)
   \   00000132   0x6AC2             LDR      R2,[R0, #+44]
   \   00000134   0x2A02             CMP      R2,#+2
   \   00000136   0x680A             LDR      R2,[R1, #+0]
   \   00000138   0xD008             BEQ.N    ??I2C_Master_ADDR_13
   4241                  {
   4242                    /* Disable Acknowledge */
   4243                    hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   0000013A   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000013E   0x600A             STR      R2,[R1, #+0]
   4244                    
   4245                    /* Enable Pos */
   4246                    hi2c->Instance->CR1 |= I2C_CR1_POS;
   \   00000140   0x6801             LDR      R1,[R0, #+0]
   \   00000142   0x680A             LDR      R2,[R1, #+0]
   \   00000144   0xF442 0x6200      ORR      R2,R2,#0x800
   \   00000148   0x600A             STR      R2,[R1, #+0]
   \   0000014A   0xE002             B.N      ??I2C_Master_ADDR_14
   4247                  }
   4248                  else
   4249                  {
   4250                    /* Enable Acknowledge */
   4251                    hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \                     ??I2C_Master_ADDR_13: (+1)
   \   0000014C   0xF442 0x6280      ORR      R2,R2,#0x400
   \   00000150   0x600A             STR      R2,[R1, #+0]
   4252                  }
   4253          
   4254                  if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \                     ??I2C_Master_ADDR_14: (+1)
   \   00000152   0x6801             LDR      R1,[R0, #+0]
   \   00000154   0x684A             LDR      R2,[R1, #+4]
   \   00000156   0x0512             LSLS     R2,R2,#+20
   \   00000158   0xD503             BPL.N    ??I2C_Master_ADDR_15
   4255                  {
   4256                    /* Enable Last DMA bit */
   4257                    hi2c->Instance->CR2 |= I2C_CR2_LAST;
   \   0000015A   0x684A             LDR      R2,[R1, #+4]
   \   0000015C   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   00000160   0x604A             STR      R2,[R1, #+4]
   4258                  }
   4259          
   4260                  /* Clear ADDR flag */
   4261                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_Master_ADDR_15: (+1)
   \   00000162   0x2100             MOVS     R1,#+0
   \   00000164   0x9100             STR      R1,[SP, #+0]
   \   00000166   0x6801             LDR      R1,[R0, #+0]
   \   00000168   0x694A             LDR      R2,[R1, #+20]
   \   0000016A   0x9200             STR      R2,[SP, #+0]
   \   0000016C   0x6989             LDR      R1,[R1, #+24]
   \   0000016E   0x9100             STR      R1,[SP, #+0]
   \   00000170   0x9900             LDR      R1,[SP, #+0]
   \   00000172   0xE013             B.N      ??I2C_Master_ADDR_5
   4262                }
   4263                else
   4264                {
   4265                  /* Enable Acknowledge */
   4266                  hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \                     ??I2C_Master_ADDR_12: (+1)
   \   00000174   0x680A             LDR      R2,[R1, #+0]
   \   00000176   0xF442 0x6280      ORR      R2,R2,#0x400
   \   0000017A   0x600A             STR      R2,[R1, #+0]
   4267          
   4268                  if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \   0000017C   0x6801             LDR      R1,[R0, #+0]
   \   0000017E   0x684A             LDR      R2,[R1, #+4]
   \   00000180   0x0512             LSLS     R2,R2,#+20
   \   00000182   0xD503             BPL.N    ??I2C_Master_ADDR_16
   4269                  {
   4270                    /* Enable Last DMA bit */
   4271                    hi2c->Instance->CR2 |= I2C_CR2_LAST;
   \   00000184   0x684A             LDR      R2,[R1, #+4]
   \   00000186   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   0000018A   0x604A             STR      R2,[R1, #+4]
   4272                  }
   4273          
   4274                  /* Clear ADDR flag */
   4275                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_Master_ADDR_16: (+1)
   \   0000018C   0x2100             MOVS     R1,#+0
   \   0000018E   0x9100             STR      R1,[SP, #+0]
   \   00000190   0x6801             LDR      R1,[R0, #+0]
   \   00000192   0x694A             LDR      R2,[R1, #+20]
   \   00000194   0x9200             STR      R2,[SP, #+0]
   \   00000196   0x6989             LDR      R1,[R1, #+24]
   \   00000198   0x9100             STR      R1,[SP, #+0]
   \   0000019A   0x9900             LDR      R1,[SP, #+0]
   4276                }
   4277                
   4278                /* Reset Event counter  */
   4279                hi2c->EventCount = 0U;
   \                     ??I2C_Master_ADDR_5: (+1)
   \   0000019C   0x2100             MOVS     R1,#+0
   \   0000019E   0x6501             STR      R1,[R0, #+80]
   \   000001A0   0xE007             B.N      ??I2C_Master_ADDR_2
   4280              }
   4281            }
   4282            else
   4283            {
   4284              /* Clear ADDR flag */
   4285              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_Master_ADDR_0: (+1)
   \   000001A2   0x2100             MOVS     R1,#+0
   \   000001A4   0x9100             STR      R1,[SP, #+0]
   \   000001A6   0x6801             LDR      R1,[R0, #+0]
   \   000001A8   0x6948             LDR      R0,[R1, #+20]
   \   000001AA   0x9000             STR      R0,[SP, #+0]
   \   000001AC   0x6988             LDR      R0,[R1, #+24]
   \   000001AE   0x9000             STR      R0,[SP, #+0]
   \   000001B0   0x9800             LDR      R0,[SP, #+0]
   4286            }
   4287          
   4288            return HAL_OK;
   \                     ??I2C_Master_ADDR_2: (+1)
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0xBC12             POP      {R1,R4}
   \   000001B6   0x4770             BX       LR               ;; return
   4289          }
   4290          
   4291          /**
   4292            * @brief  Handle TXE flag for Slave
   4293            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4294            *         the configuration information for I2C module
   4295            * @retval HAL status
   4296            */

   \                                 In section .text, align 2, keep-with-next
   4297          static HAL_StatusTypeDef I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)
   4298          {
   \                     I2C_SlaveTransmit_TXE: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   4299            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   4300            uint32_t CurrentState = hi2c->State;
   \   00000002   0xF890 0x103D      LDRB     R1,[R0, #+61]
   4301          
   4302            if(hi2c->XferCount != 0U)
   \   00000006   0x8D42             LDRH     R2,[R0, #+42]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD019             BEQ.N    ??I2C_SlaveTransmit_TXE_0
   4303            {
   4304              /* Write data to DR */
   4305              hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \   0000000C   0x6A42             LDR      R2,[R0, #+36]
   \   0000000E   0x1C53             ADDS     R3,R2,#+1
   \   00000010   0x6243             STR      R3,[R0, #+36]
   \   00000012   0x7812             LDRB     R2,[R2, #+0]
   \   00000014   0x6803             LDR      R3,[R0, #+0]
   \   00000016   0x611A             STR      R2,[R3, #+16]
   4306              hi2c->XferCount--;
   \   00000018   0x8D42             LDRH     R2,[R0, #+42]
   \   0000001A   0x1E52             SUBS     R2,R2,#+1
   \   0000001C   0x8542             STRH     R2,[R0, #+42]
   4307          
   4308              if((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
   \   0000001E   0x8D42             LDRH     R2,[R0, #+42]
   \   00000020   0x2A00             CMP      R2,#+0
   \   00000022   0xD10D             BNE.N    ??I2C_SlaveTransmit_TXE_0
   \   00000024   0x2929             CMP      R1,#+41
   \   00000026   0xD10B             BNE.N    ??I2C_SlaveTransmit_TXE_0
   4309              {
   4310                /* Last Byte is received, disable Interrupt */
   4311                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0x684A             LDR      R2,[R1, #+4]
   \   0000002C   0xF422 0x6280      BIC      R2,R2,#0x400
   \   00000030   0x604A             STR      R2,[R1, #+4]
   4312                
   4313                /* Set state at HAL_I2C_STATE_LISTEN */
   4314                hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
   \   00000032   0x2121             MOVS     R1,#+33
   \   00000034   0x6301             STR      R1,[R0, #+48]
   4315                hi2c->State = HAL_I2C_STATE_LISTEN;
   \   00000036   0x2128             MOVS     R1,#+40
   \   00000038   0xF880 0x103D      STRB     R1,[R0, #+61]
   4316                
   4317                /* Call the Tx complete callback to inform upper layer of the end of receive process */
   4318                HAL_I2C_SlaveTxCpltCallback(hi2c);
   \   0000003C   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   4319              }
   4320            }
   4321            return HAL_OK;
   \                     ??I2C_SlaveTransmit_TXE_0: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD02             POP      {R1,PC}          ;; return
   4322          }
   4323          
   4324          /**
   4325            * @brief  Handle BTF flag for Slave transmitter
   4326            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4327            *         the configuration information for I2C module
   4328            * @retval HAL status
   4329            */

   \                                 In section .text, align 2, keep-with-next
   4330          static HAL_StatusTypeDef I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
   4331          {
   4332            if(hi2c->XferCount != 0U)
   \                     I2C_SlaveTransmit_BTF: (+1)
   \   00000000   0x8D41             LDRH     R1,[R0, #+42]
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD008             BEQ.N    ??I2C_SlaveTransmit_BTF_0
   4333            {
   4334              /* Write data to DR */
   4335              hi2c->Instance->DR = (*hi2c->pBuffPtr++);
   \   00000006   0x6A41             LDR      R1,[R0, #+36]
   \   00000008   0x1C4A             ADDS     R2,R1,#+1
   \   0000000A   0x6242             STR      R2,[R0, #+36]
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   \   00000010   0x6111             STR      R1,[R2, #+16]
   4336              hi2c->XferCount--;
   \   00000012   0x8D41             LDRH     R1,[R0, #+42]
   \   00000014   0x1E49             SUBS     R1,R1,#+1
   \   00000016   0x8541             STRH     R1,[R0, #+42]
   4337            }
   4338            return HAL_OK;
   \                     ??I2C_SlaveTransmit_BTF_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
   4339          }
   4340          
   4341          /**
   4342            * @brief  Handle RXNE flag for Slave
   4343            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4344            *         the configuration information for I2C module
   4345            * @retval HAL status
   4346            */

   \                                 In section .text, align 2, keep-with-next
   4347          static HAL_StatusTypeDef I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)
   4348          {
   \                     I2C_SlaveReceive_RXNE: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   4349            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   4350            uint32_t CurrentState = hi2c->State;
   \   00000002   0xF890 0x103D      LDRB     R1,[R0, #+61]
   4351          
   4352            if(hi2c->XferCount != 0U)
   \   00000006   0x8D42             LDRH     R2,[R0, #+42]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD019             BEQ.N    ??I2C_SlaveReceive_RXNE_0
   4353            {
   4354              /* Read data from DR */
   4355              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   0000000C   0x6A42             LDR      R2,[R0, #+36]
   \   0000000E   0x1C53             ADDS     R3,R2,#+1
   \   00000010   0x6243             STR      R3,[R0, #+36]
   \   00000012   0x6803             LDR      R3,[R0, #+0]
   \   00000014   0x691B             LDR      R3,[R3, #+16]
   \   00000016   0x7013             STRB     R3,[R2, #+0]
   4356              hi2c->XferCount--;
   \   00000018   0x8D42             LDRH     R2,[R0, #+42]
   \   0000001A   0x1E52             SUBS     R2,R2,#+1
   \   0000001C   0x8542             STRH     R2,[R0, #+42]
   4357          
   4358              if((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
   \   0000001E   0x8D42             LDRH     R2,[R0, #+42]
   \   00000020   0x2A00             CMP      R2,#+0
   \   00000022   0xD10D             BNE.N    ??I2C_SlaveReceive_RXNE_0
   \   00000024   0x292A             CMP      R1,#+42
   \   00000026   0xD10B             BNE.N    ??I2C_SlaveReceive_RXNE_0
   4359              {
   4360                /* Last Byte is received, disable Interrupt */
   4361                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0x684A             LDR      R2,[R1, #+4]
   \   0000002C   0xF422 0x6280      BIC      R2,R2,#0x400
   \   00000030   0x604A             STR      R2,[R1, #+4]
   4362          
   4363                /* Set state at HAL_I2C_STATE_LISTEN */
   4364                hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
   \   00000032   0x2122             MOVS     R1,#+34
   \   00000034   0x6301             STR      R1,[R0, #+48]
   4365                hi2c->State = HAL_I2C_STATE_LISTEN;
   \   00000036   0x2128             MOVS     R1,#+40
   \   00000038   0xF880 0x103D      STRB     R1,[R0, #+61]
   4366          
   4367                /* Call the Rx complete callback to inform upper layer of the end of receive process */
   4368                HAL_I2C_SlaveRxCpltCallback(hi2c);
   \   0000003C   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   4369              }
   4370            }
   4371            return HAL_OK;
   \                     ??I2C_SlaveReceive_RXNE_0: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD02             POP      {R1,PC}          ;; return
   4372          }
   4373          
   4374          /**
   4375            * @brief  Handle BTF flag for Slave receiver
   4376            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4377            *         the configuration information for I2C module
   4378            * @retval HAL status
   4379            */

   \                                 In section .text, align 2, keep-with-next
   4380          static HAL_StatusTypeDef I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
   4381          {
   4382            if(hi2c->XferCount != 0U)
   \                     I2C_SlaveReceive_BTF: (+1)
   \   00000000   0x8D41             LDRH     R1,[R0, #+42]
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD008             BEQ.N    ??I2C_SlaveReceive_BTF_0
   4383            {
   4384              /* Read data from DR */
   4385              (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000006   0x6A41             LDR      R1,[R0, #+36]
   \   00000008   0x1C4A             ADDS     R2,R1,#+1
   \   0000000A   0x6242             STR      R2,[R0, #+36]
   \   0000000C   0x6802             LDR      R2,[R0, #+0]
   \   0000000E   0x6912             LDR      R2,[R2, #+16]
   \   00000010   0x700A             STRB     R2,[R1, #+0]
   4386              hi2c->XferCount--;
   \   00000012   0x8D41             LDRH     R1,[R0, #+42]
   \   00000014   0x1E49             SUBS     R1,R1,#+1
   \   00000016   0x8541             STRH     R1,[R0, #+42]
   4387            }
   4388            return HAL_OK;
   \                     ??I2C_SlaveReceive_BTF_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
   4389          }
   4390          
   4391          /**
   4392            * @brief  Handle ADD flag for Slave
   4393            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4394            *         the configuration information for I2C module
   4395            * @retval HAL status
   4396            */

   \                                 In section .text, align 2, keep-with-next
   4397          static HAL_StatusTypeDef I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c)
   4398          {
   \                     I2C_Slave_ADDR: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   4399            uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
   \   00000002   0x2100             MOVS     R1,#+0
   4400            uint16_t SlaveAddrCode = 0U;
   4401          
   4402            /* Transfer Direction requested by Master */
   4403            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TRA) == RESET)
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x6993             LDR      R3,[R2, #+24]
   \   00000008   0x075B             LSLS     R3,R3,#+29
   \   0000000A   0xD400             BMI.N    ??I2C_Slave_ADDR_0
   4404            {
   4405              TransferDirection = I2C_DIRECTION_TRANSMIT;
   \   0000000C   0x2101             MOVS     R1,#+1
   4406            }
   4407            
   4408            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_DUALF) == RESET)
   \                     ??I2C_Slave_ADDR_0: (+1)
   \   0000000E   0x6992             LDR      R2,[R2, #+24]
   \   00000010   0x0612             LSLS     R2,R2,#+24
   \   00000012   0xD401             BMI.N    ??I2C_Slave_ADDR_1
   4409            {
   4410              SlaveAddrCode = hi2c->Init.OwnAddress1;
   \   00000014   0x68C2             LDR      R2,[R0, #+12]
   \   00000016   0xE000             B.N      ??I2C_Slave_ADDR_2
   4411            }
   4412            else
   4413            {
   4414              SlaveAddrCode = hi2c->Init.OwnAddress2;
   \                     ??I2C_Slave_ADDR_1: (+1)
   \   00000018   0x6982             LDR      R2,[R0, #+24]
   4415            }
   4416          
   4417            /* Call Slave Addr callback */
   4418            HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
   \                     ??I2C_Slave_ADDR_2: (+1)
   \   0000001A   0xB292             UXTH     R2,R2
   \   0000001C   0x.... 0x....      BL       HAL_I2C_AddrCallback
   4419          
   4420            return HAL_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD02             POP      {R1,PC}          ;; return
   4421          }
   4422          
   4423          /**
   4424            * @brief  Handle STOPF flag for Slave
   4425            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4426            *         the configuration information for I2C module
   4427            * @retval HAL status
   4428            */

   \                                 In section .text, align 2, keep-with-next
   4429          static HAL_StatusTypeDef I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)
   4430          {
   \                     I2C_Slave_STOPF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   4431            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   4432            uint32_t CurrentState = hi2c->State;
   \   00000002   0xF890 0x103D      LDRB     R1,[R0, #+61]
   4433            
   4434            /* Disable EVT, BUF and ERR interrupt */
   4435            __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x6853             LDR      R3,[R2, #+4]
   \   0000000A   0xF423 0x63E0      BIC      R3,R3,#0x700
   \   0000000E   0x6053             STR      R3,[R2, #+4]
   4436          
   4437            /* Clear STOPF flag */
   4438            __HAL_I2C_CLEAR_STOPFLAG(hi2c);
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x9200             STR      R2,[SP, #+0]
   \   00000014   0x6802             LDR      R2,[R0, #+0]
   \   00000016   0x6953             LDR      R3,[R2, #+20]
   \   00000018   0x9300             STR      R3,[SP, #+0]
   \   0000001A   0x6813             LDR      R3,[R2, #+0]
   \   0000001C   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000020   0x6013             STR      R3,[R2, #+0]
   \   00000022   0x9A00             LDR      R2,[SP, #+0]
   4439          
   4440            /* Disable Acknowledge */
   4441            hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   00000024   0x6802             LDR      R2,[R0, #+0]
   \   00000026   0x6813             LDR      R3,[R2, #+0]
   \   00000028   0xF423 0x6380      BIC      R3,R3,#0x400
   \   0000002C   0x6013             STR      R3,[R2, #+0]
   4442          
   4443            /* If a DMA is ongoing, Update handle size context */
   4444            if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \   0000002E   0x6802             LDR      R2,[R0, #+0]
   \   00000030   0x6852             LDR      R2,[R2, #+4]
   \   00000032   0x0512             LSLS     R2,R2,#+20
   \   00000034   0xD510             BPL.N    ??I2C_Slave_STOPF_0
   4445            {
   4446              if((hi2c->State == HAL_I2C_STATE_BUSY_RX) || (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN))
   \   00000036   0xF890 0x203D      LDRB     R2,[R0, #+61]
   \   0000003A   0x2A22             CMP      R2,#+34
   \   0000003C   0xD003             BEQ.N    ??I2C_Slave_STOPF_1
   \   0000003E   0xF890 0x203D      LDRB     R2,[R0, #+61]
   \   00000042   0x2A2A             CMP      R2,#+42
   \   00000044   0xD104             BNE.N    ??I2C_Slave_STOPF_2
   4447              {
   4448                hi2c->XferCount = __HAL_DMA_GET_COUNTER(hi2c->hdmarx);
   \                     ??I2C_Slave_STOPF_1: (+1)
   \   00000046   0x6B82             LDR      R2,[R0, #+56]
   \   00000048   0x6812             LDR      R2,[R2, #+0]
   \   0000004A   0x6852             LDR      R2,[R2, #+4]
   \   0000004C   0x8542             STRH     R2,[R0, #+42]
   \   0000004E   0xE003             B.N      ??I2C_Slave_STOPF_0
   4449              }
   4450              else
   4451              {
   4452                hi2c->XferCount = __HAL_DMA_GET_COUNTER(hi2c->hdmatx);
   \                     ??I2C_Slave_STOPF_2: (+1)
   \   00000050   0x6B42             LDR      R2,[R0, #+52]
   \   00000052   0x6812             LDR      R2,[R2, #+0]
   \   00000054   0x6852             LDR      R2,[R2, #+4]
   \   00000056   0x8542             STRH     R2,[R0, #+42]
   4453              }
   4454            }
   4455          
   4456            /* All data are not transferred, so set error code accordingly */
   4457            if(hi2c->XferCount != 0U)
   \                     ??I2C_Slave_STOPF_0: (+1)
   \   00000058   0x8D42             LDRH     R2,[R0, #+42]
   \   0000005A   0x2A00             CMP      R2,#+0
   \   0000005C   0xD01D             BEQ.N    ??I2C_Slave_STOPF_3
   4458            {
   4459              /* Store Last receive data if any */
   4460              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
   \   0000005E   0x6802             LDR      R2,[R0, #+0]
   \   00000060   0x6952             LDR      R2,[R2, #+20]
   \   00000062   0x0752             LSLS     R2,R2,#+29
   \   00000064   0xD508             BPL.N    ??I2C_Slave_STOPF_4
   4461              {
   4462                /* Read data from DR */
   4463                (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000066   0x6A42             LDR      R2,[R0, #+36]
   \   00000068   0x1C53             ADDS     R3,R2,#+1
   \   0000006A   0x6243             STR      R3,[R0, #+36]
   \   0000006C   0x6803             LDR      R3,[R0, #+0]
   \   0000006E   0x691B             LDR      R3,[R3, #+16]
   \   00000070   0x7013             STRB     R3,[R2, #+0]
   4464                hi2c->XferCount--;
   \   00000072   0x8D42             LDRH     R2,[R0, #+42]
   \   00000074   0x1E52             SUBS     R2,R2,#+1
   \   00000076   0x8542             STRH     R2,[R0, #+42]
   4465              }
   4466          
   4467              /* Store Last receive data if any */
   4468              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \                     ??I2C_Slave_STOPF_4: (+1)
   \   00000078   0x6802             LDR      R2,[R0, #+0]
   \   0000007A   0x6952             LDR      R2,[R2, #+20]
   \   0000007C   0x0652             LSLS     R2,R2,#+25
   \   0000007E   0xD508             BPL.N    ??I2C_Slave_STOPF_5
   4469              {
   4470                /* Read data from DR */
   4471                (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   00000080   0x6A42             LDR      R2,[R0, #+36]
   \   00000082   0x1C53             ADDS     R3,R2,#+1
   \   00000084   0x6243             STR      R3,[R0, #+36]
   \   00000086   0x6803             LDR      R3,[R0, #+0]
   \   00000088   0x691B             LDR      R3,[R3, #+16]
   \   0000008A   0x7013             STRB     R3,[R2, #+0]
   4472                hi2c->XferCount--;
   \   0000008C   0x8D42             LDRH     R2,[R0, #+42]
   \   0000008E   0x1E52             SUBS     R2,R2,#+1
   \   00000090   0x8542             STRH     R2,[R0, #+42]
   4473              }
   4474          
   4475              /* Set ErrorCode corresponding to a Non-Acknowledge */
   4476              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \                     ??I2C_Slave_STOPF_5: (+1)
   \   00000092   0x6C02             LDR      R2,[R0, #+64]
   \   00000094   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000098   0x6402             STR      R2,[R0, #+64]
   4477            }
   4478          
   4479            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??I2C_Slave_STOPF_3: (+1)
   \   0000009A   0x6C02             LDR      R2,[R0, #+64]
   \   0000009C   0x2A00             CMP      R2,#+0
   \   0000009E   0xD002             BEQ.N    ??I2C_Slave_STOPF_6
   4480            {
   4481              /* Call the corresponding callback to inform upper layer of End of Transfer */
   4482              I2C_ITError(hi2c);
   \   000000A0   0x.... 0x....      BL       I2C_ITError
   \   000000A4   0xE022             B.N      ??I2C_Slave_STOPF_7
   4483            }
   4484            else
   4485            {
   4486              if((CurrentState == HAL_I2C_STATE_LISTEN ) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN) || \
   4487                 (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
   \                     ??I2C_Slave_STOPF_6: (+1)
   \   000000A6   0x2928             CMP      R1,#+40
   \   000000A8   0xD003             BEQ.N    ??I2C_Slave_STOPF_8
   \   000000AA   0x292A             CMP      R1,#+42
   \   000000AC   0xD001             BEQ.N    ??I2C_Slave_STOPF_8
   \   000000AE   0x2929             CMP      R1,#+41
   \   000000B0   0xD10D             BNE.N    ??I2C_Slave_STOPF_9
   4488              {
   4489                hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \                     ??I2C_Slave_STOPF_8: (+1)
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable34  ;; 0xffff0000
   \   000000B6   0x62C1             STR      R1,[R0, #+44]
   4490                hi2c->PreviousState = I2C_STATE_NONE;
   \   000000B8   0x2100             MOVS     R1,#+0
   \   000000BA   0x6301             STR      R1,[R0, #+48]
   4491                hi2c->State = HAL_I2C_STATE_READY;
   \   000000BC   0x2120             MOVS     R1,#+32
   \   000000BE   0xF880 0x103D      STRB     R1,[R0, #+61]
   4492                hi2c->Mode = HAL_I2C_MODE_NONE;
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0xF880 0x103E      STRB     R1,[R0, #+62]
   4493          
   4494                /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   4495                HAL_I2C_ListenCpltCallback(hi2c);
   \   000000C8   0x.... 0x....      BL       HAL_I2C_ListenCpltCallback
   \   000000CC   0xE00E             B.N      ??I2C_Slave_STOPF_7
   4496              }
   4497              else
   4498              {
   4499                if((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
   \                     ??I2C_Slave_STOPF_9: (+1)
   \   000000CE   0x6B02             LDR      R2,[R0, #+48]
   \   000000D0   0x2A22             CMP      R2,#+34
   \   000000D2   0xD001             BEQ.N    ??I2C_Slave_STOPF_10
   \   000000D4   0x2922             CMP      R1,#+34
   \   000000D6   0xD109             BNE.N    ??I2C_Slave_STOPF_7
   4500                {
   4501                  hi2c->PreviousState = I2C_STATE_NONE;
   \                     ??I2C_Slave_STOPF_10: (+1)
   \   000000D8   0x2100             MOVS     R1,#+0
   \   000000DA   0x6301             STR      R1,[R0, #+48]
   4502                  hi2c->State = HAL_I2C_STATE_READY;
   \   000000DC   0x2120             MOVS     R1,#+32
   \   000000DE   0xF880 0x103D      STRB     R1,[R0, #+61]
   4503                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \   000000E2   0x2100             MOVS     R1,#+0
   \   000000E4   0xF880 0x103E      STRB     R1,[R0, #+62]
   4504          
   4505                  HAL_I2C_SlaveRxCpltCallback(hi2c);
   \   000000E8   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   4506                }
   4507              }
   4508            }
   4509            return HAL_OK;
   \                     ??I2C_Slave_STOPF_7: (+1)
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xBD02             POP      {R1,PC}          ;; return
   4510          }
   4511          
   4512          /**
   4513            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4514            *         the configuration information for I2C module
   4515            * @retval HAL status
   4516            */

   \                                 In section .text, align 2, keep-with-next
   4517          static HAL_StatusTypeDef I2C_Slave_AF(I2C_HandleTypeDef *hi2c)
   4518          {
   \                     I2C_Slave_AF: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   4519            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   4520            uint32_t CurrentState       = hi2c->State;
   \   00000002   0xF890 0x103D      LDRB     R1,[R0, #+61]
   4521            uint32_t CurrentXferOptions = hi2c->XferOptions;
   \   00000006   0x6AC2             LDR      R2,[R0, #+44]
   4522          
   4523            if(((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
   4524                    (CurrentState == HAL_I2C_STATE_LISTEN))
   \   00000008   0x2A04             CMP      R2,#+4
   \   0000000A   0xD001             BEQ.N    ??I2C_Slave_AF_0
   \   0000000C   0x2A08             CMP      R2,#+8
   \   0000000E   0xD11D             BNE.N    ??I2C_Slave_AF_1
   \                     ??I2C_Slave_AF_0: (+1)
   \   00000010   0x2928             CMP      R1,#+40
   \   00000012   0xD11B             BNE.N    ??I2C_Slave_AF_1
   4525            {
   4526              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable34  ;; 0xffff0000
   \   00000018   0x62C1             STR      R1,[R0, #+44]
   4527          
   4528              /* Disable EVT, BUF and ERR interrupt */
   4529              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0x684A             LDR      R2,[R1, #+4]
   \   0000001E   0xF422 0x62E0      BIC      R2,R2,#0x700
   \   00000022   0x604A             STR      R2,[R1, #+4]
   4530          
   4531              /* Clear AF flag */
   4532              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000024   0xF46F 0x6180      MVN      R1,#+1024
   \   00000028   0x6802             LDR      R2,[R0, #+0]
   \   0000002A   0x6151             STR      R1,[R2, #+20]
   4533          
   4534              /* Disable Acknowledge */
   4535              hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x680A             LDR      R2,[R1, #+0]
   \   00000030   0xF422 0x6280      BIC      R2,R2,#0x400
   \   00000034   0x600A             STR      R2,[R1, #+0]
   4536          
   4537              hi2c->PreviousState = I2C_STATE_NONE;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x6301             STR      R1,[R0, #+48]
   4538              hi2c->State = HAL_I2C_STATE_READY;
   \   0000003A   0x2120             MOVS     R1,#+32
   \   0000003C   0xF880 0x103D      STRB     R1,[R0, #+61]
   4539              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xF880 0x103E      STRB     R1,[R0, #+62]
   4540                
   4541              /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   4542              HAL_I2C_ListenCpltCallback(hi2c);
   \   00000046   0x.... 0x....      BL       HAL_I2C_ListenCpltCallback
   \   0000004A   0xE01F             B.N      ??I2C_Slave_AF_2
   4543            }
   4544            else if(CurrentState == HAL_I2C_STATE_BUSY_TX)
   \                     ??I2C_Slave_AF_1: (+1)
   \   0000004C   0xF46F 0x6280      MVN      R2,#+1024
   \   00000050   0x2921             CMP      R1,#+33
   \   00000052   0xD119             BNE.N    ??I2C_Slave_AF_3
   4545            {
   4546              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable34  ;; 0xffff0000
   \   00000058   0x62C1             STR      R1,[R0, #+44]
   4547              hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
   \   0000005A   0x2121             MOVS     R1,#+33
   \   0000005C   0x6301             STR      R1,[R0, #+48]
   4548              hi2c->State = HAL_I2C_STATE_READY;
   \   0000005E   0x2120             MOVS     R1,#+32
   \   00000060   0xF880 0x103D      STRB     R1,[R0, #+61]
   4549              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0xF880 0x103E      STRB     R1,[R0, #+62]
   4550              
   4551              /* Disable EVT, BUF and ERR interrupt */
   4552              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0x684B             LDR      R3,[R1, #+4]
   \   0000006E   0xF423 0x63E0      BIC      R3,R3,#0x700
   \   00000072   0x604B             STR      R3,[R1, #+4]
   4553          
   4554              /* Clear AF flag */
   4555              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0x614A             STR      R2,[R1, #+20]
   4556          
   4557              /* Disable Acknowledge */
   4558              hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   00000078   0x6801             LDR      R1,[R0, #+0]
   \   0000007A   0x680A             LDR      R2,[R1, #+0]
   \   0000007C   0xF422 0x6280      BIC      R2,R2,#0x400
   \   00000080   0x600A             STR      R2,[R1, #+0]
   4559          
   4560              HAL_I2C_SlaveTxCpltCallback(hi2c);
   \   00000082   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   \   00000086   0xE001             B.N      ??I2C_Slave_AF_2
   4561            }
   4562            else
   4563            {
   4564              /* Clear AF flag only */
   4565              /* State Listen, but XferOptions == FIRST or NEXT */
   4566              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_Slave_AF_3: (+1)
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x6142             STR      R2,[R0, #+20]
   4567            }
   4568            
   4569            return HAL_OK;
   \                     ??I2C_Slave_AF_2: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xBD02             POP      {R1,PC}          ;; return
   4570          }
   4571          
   4572          /**
   4573            * @brief  I2C interrupts error process
   4574            * @param  hi2c I2C handle.
   4575            * @retval None
   4576            */

   \                                 In section .text, align 2, keep-with-next
   4577          static void I2C_ITError(I2C_HandleTypeDef *hi2c)
   4578          {
   \                     I2C_ITError: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   4579            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   4580            uint32_t CurrentState = hi2c->State;
   \   00000004   0xF894 0x003D      LDRB     R0,[R4, #+61]
   4581          
   4582            if((CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
   \   00000008   0x2829             CMP      R0,#+41
   \   0000000A   0xD001             BEQ.N    ??I2C_ITError_0
   \   0000000C   0x282A             CMP      R0,#+42
   \   0000000E   0xD105             BNE.N    ??I2C_ITError_1
   4583            {
   4584              /* keep HAL_I2C_STATE_LISTEN */
   4585              hi2c->PreviousState = I2C_STATE_NONE;
   \                     ??I2C_ITError_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x6320             STR      R0,[R4, #+48]
   4586              hi2c->State = HAL_I2C_STATE_LISTEN;
   \   00000014   0x2028             MOVS     R0,#+40
   \   00000016   0xF884 0x003D      STRB     R0,[R4, #+61]
   \   0000001A   0xE00E             B.N      ??I2C_ITError_2
   4587            }
   4588            else
   4589            {
   4590              /* If state is an abort treatment on going, don't change state */
   4591              /* This change will be do later */
   4592              if((hi2c->State != HAL_I2C_STATE_ABORT) && ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) != I2C_CR2_DMAEN))
   \                     ??I2C_ITError_1: (+1)
   \   0000001C   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000020   0x2860             CMP      R0,#+96
   \   00000022   0xD006             BEQ.N    ??I2C_ITError_3
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6840             LDR      R0,[R0, #+4]
   \   00000028   0x0500             LSLS     R0,R0,#+20
   \   0000002A   0xD402             BMI.N    ??I2C_ITError_3
   4593              {
   4594                hi2c->State = HAL_I2C_STATE_READY;
   \   0000002C   0x2020             MOVS     R0,#+32
   \   0000002E   0xF884 0x003D      STRB     R0,[R4, #+61]
   4595              }
   4596              hi2c->PreviousState = I2C_STATE_NONE;
   \                     ??I2C_ITError_3: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6320             STR      R0,[R4, #+48]
   4597              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000036   0xF884 0x003E      STRB     R0,[R4, #+62]
   4598            }
   4599          
   4600            /* Disable Pos bit in I2C CR1 when error occurred in Master/Mem Receive IT Process */
   4601            hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \                     ??I2C_ITError_2: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000042   0x6001             STR      R1,[R0, #+0]
   4602          
   4603            /* Abort DMA transfer */
   4604            if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6841             LDR      R1,[R0, #+4]
   \   00000048   0x0509             LSLS     R1,R1,#+20
   \   0000004A   0xD539             BPL.N    ??I2C_ITError_4
   4605            {
   4606              hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
   \   0000004C   0x6841             LDR      R1,[R0, #+4]
   \   0000004E   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000052   0x6041             STR      R1,[R0, #+4]
   4607          
   4608              if(hi2c->hdmatx->State != HAL_DMA_STATE_READY)
   \   00000054   0x6B60             LDR      R0,[R4, #+52]
   \   00000056   0x.... 0x....      ADR.W    R1,I2C_DMAAbort
   \   0000005A   0xF990 0x2035      LDRSB    R2,[R0, #+53]
   \   0000005E   0x2A01             CMP      R2,#+1
   \   00000060   0xD011             BEQ.N    ??I2C_ITError_5
   4609              {
   4610                /* Set the DMA Abort callback : 
   4611                will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   4612                hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \   00000062   0x6501             STR      R1,[R0, #+80]
   4613          
   4614                if(HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \   00000064   0x6B60             LDR      R0,[R4, #+52]
   \   00000066   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD050             BEQ.N    ??I2C_ITError_6
   4615                {
   4616                  /* Disable I2C peripheral to prevent dummy data in buffer */
   4617                  __HAL_I2C_DISABLE(hi2c);
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0x0849             LSRS     R1,R1,#+1
   \   00000074   0x0049             LSLS     R1,R1,#+1
   \   00000076   0x6001             STR      R1,[R0, #+0]
   4618          
   4619                  hi2c->State = HAL_I2C_STATE_READY;
   \   00000078   0x2020             MOVS     R0,#+32
   \   0000007A   0xF884 0x003D      STRB     R0,[R4, #+61]
   4620          
   4621                  /* Call Directly XferAbortCallback function in case of error */
   4622                  hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \   0000007E   0x6B60             LDR      R0,[R4, #+52]
   \   00000080   0x6D01             LDR      R1,[R0, #+80]
   \   00000082   0x4788             BLX      R1
   \   00000084   0xE044             B.N      ??I2C_ITError_6
   4623                }
   4624              }
   4625              else
   4626              {
   4627                /* Set the DMA Abort callback : 
   4628                will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   4629                hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   \                     ??I2C_ITError_5: (+1)
   \   00000086   0x6BA0             LDR      R0,[R4, #+56]
   \   00000088   0x6501             STR      R1,[R0, #+80]
   4630          
   4631                if(HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \   0000008A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000008C   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD03D             BEQ.N    ??I2C_ITError_6
   4632                {
   4633                  /* Store Last receive data if any */
   4634                  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6940             LDR      R0,[R0, #+20]
   \   00000098   0x0640             LSLS     R0,R0,#+25
   \   0000009A   0xD505             BPL.N    ??I2C_ITError_7
   4635                  {
   4636                    /* Read data from DR */
   4637                    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   0000009C   0x6A60             LDR      R0,[R4, #+36]
   \   0000009E   0x1C41             ADDS     R1,R0,#+1
   \   000000A0   0x6261             STR      R1,[R4, #+36]
   \   000000A2   0x6821             LDR      R1,[R4, #+0]
   \   000000A4   0x6909             LDR      R1,[R1, #+16]
   \   000000A6   0x7001             STRB     R1,[R0, #+0]
   4638                  }
   4639          
   4640                  /* Disable I2C peripheral to prevent dummy data in buffer */
   4641                  __HAL_I2C_DISABLE(hi2c);
   \                     ??I2C_ITError_7: (+1)
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6801             LDR      R1,[R0, #+0]
   \   000000AC   0x0849             LSRS     R1,R1,#+1
   \   000000AE   0x0049             LSLS     R1,R1,#+1
   \   000000B0   0x6001             STR      R1,[R0, #+0]
   4642          
   4643                  hi2c->State = HAL_I2C_STATE_READY;
   \   000000B2   0x2020             MOVS     R0,#+32
   \   000000B4   0xF884 0x003D      STRB     R0,[R4, #+61]
   4644          
   4645                  /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
   4646                  hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \   000000B8   0x6BA0             LDR      R0,[R4, #+56]
   \   000000BA   0x6D01             LDR      R1,[R0, #+80]
   \   000000BC   0x4788             BLX      R1
   \   000000BE   0xE027             B.N      ??I2C_ITError_6
   4647                }
   4648              }
   4649            }
   4650            else if(hi2c->State == HAL_I2C_STATE_ABORT)
   \                     ??I2C_ITError_4: (+1)
   \   000000C0   0xF894 0x103D      LDRB     R1,[R4, #+61]
   \   000000C4   0x2960             CMP      R1,#+96
   \   000000C6   0xD117             BNE.N    ??I2C_ITError_8
   4651            {
   4652              hi2c->State = HAL_I2C_STATE_READY;
   \   000000C8   0x2020             MOVS     R0,#+32
   \   000000CA   0xF884 0x003D      STRB     R0,[R4, #+61]
   4653              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x6420             STR      R0,[R4, #+64]
   4654          
   4655              /* Store Last receive data if any */
   4656              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6940             LDR      R0,[R0, #+20]
   \   000000D6   0x0640             LSLS     R0,R0,#+25
   \   000000D8   0xD505             BPL.N    ??I2C_ITError_9
   4657              {
   4658                /* Read data from DR */
   4659                (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   000000DA   0x6A60             LDR      R0,[R4, #+36]
   \   000000DC   0x1C41             ADDS     R1,R0,#+1
   \   000000DE   0x6261             STR      R1,[R4, #+36]
   \   000000E0   0x6821             LDR      R1,[R4, #+0]
   \   000000E2   0x6909             LDR      R1,[R1, #+16]
   \   000000E4   0x7001             STRB     R1,[R0, #+0]
   4660              }
   4661          
   4662              /* Disable I2C peripheral to prevent dummy data in buffer */
   4663              __HAL_I2C_DISABLE(hi2c);
   \                     ??I2C_ITError_9: (+1)
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x6801             LDR      R1,[R0, #+0]
   \   000000EA   0x0849             LSRS     R1,R1,#+1
   \   000000EC   0x0049             LSLS     R1,R1,#+1
   \   000000EE   0x6001             STR      R1,[R0, #+0]
   4664          
   4665              /* Call the corresponding callback to inform upper layer of End of Transfer */
   4666              HAL_I2C_AbortCpltCallback(hi2c);
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0x.... 0x....      BL       HAL_I2C_AbortCpltCallback
   \   000000F6   0xE00B             B.N      ??I2C_ITError_6
   4667            }
   4668            else
   4669            {
   4670              /* Store Last receive data if any */
   4671              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \                     ??I2C_ITError_8: (+1)
   \   000000F8   0x6940             LDR      R0,[R0, #+20]
   \   000000FA   0x0640             LSLS     R0,R0,#+25
   \   000000FC   0xD505             BPL.N    ??I2C_ITError_10
   4672              {
   4673                /* Read data from DR */
   4674                (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
   \   000000FE   0x6A60             LDR      R0,[R4, #+36]
   \   00000100   0x1C41             ADDS     R1,R0,#+1
   \   00000102   0x6261             STR      R1,[R4, #+36]
   \   00000104   0x6821             LDR      R1,[R4, #+0]
   \   00000106   0x6909             LDR      R1,[R1, #+16]
   \   00000108   0x7001             STRB     R1,[R0, #+0]
   4675              }
   4676          
   4677              /* Call user error callback */
   4678              HAL_I2C_ErrorCallback(hi2c);
   \                     ??I2C_ITError_10: (+1)
   \   0000010A   0x4620             MOV      R0,R4
   \   0000010C   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   4679            }
   4680            /* STOP Flag is not set after a NACK reception */
   4681            /* So may inform upper layer that listen phase is stopped */
   4682            /* during NACK error treatment */
   4683            if((hi2c->State == HAL_I2C_STATE_LISTEN) && ((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF))
   \                     ??I2C_ITError_6: (+1)
   \   00000110   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000114   0x2828             CMP      R0,#+40
   \   00000116   0xD110             BNE.N    ??I2C_ITError_11
   \   00000118   0x6C20             LDR      R0,[R4, #+64]
   \   0000011A   0x0740             LSLS     R0,R0,#+29
   \   0000011C   0xD50D             BPL.N    ??I2C_ITError_11
   4684            {
   4685              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0xffff0000
   \   00000122   0x62E0             STR      R0,[R4, #+44]
   4686              hi2c->PreviousState = I2C_STATE_NONE;
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0x6320             STR      R0,[R4, #+48]
   4687              hi2c->State = HAL_I2C_STATE_READY;
   \   00000128   0x2020             MOVS     R0,#+32
   \   0000012A   0xF884 0x003D      STRB     R0,[R4, #+61]
   4688              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xF884 0x003E      STRB     R0,[R4, #+62]
   4689              
   4690              /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   4691              HAL_I2C_ListenCpltCallback(hi2c);
   \   00000134   0x4620             MOV      R0,R4
   \   00000136   0x.... 0x....      BL       HAL_I2C_ListenCpltCallback
   4692            }
   4693          }
   \                     ??I2C_ITError_11: (+1)
   \   0000013A   0xBD10             POP      {R4,PC}          ;; return
   4694          
   4695          /**
   4696            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4697            *         the configuration information for I2C module
   4698            * @param  DevAddress Target device address: The device 7 bits address value
   4699            *         in datasheet must be shift at right before call interface
   4700            * @param  Timeout Timeout duration
   4701            * @param  Tickstart Tick start value
   4702            * @retval HAL status
   4703            */

   \                                 In section .text, align 2, keep-with-next
   4704          static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
   4705          {
   \                     I2C_MasterRequestWrite: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
   4706            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   4707            uint32_t CurrentXferOptions = hi2c->XferOptions;
   \   0000000A   0x6AE0             LDR      R0,[R4, #+44]
   4708          
   4709            /* Generate Start condition if first transfer */
   4710            if((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD005             BEQ.N    ??I2C_MasterRequestWrite_0
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD003             BEQ.N    ??I2C_MasterRequestWrite_0
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable34  ;; 0xffff0000
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD105             BNE.N    ??I2C_MasterRequestWrite_1
   4711            {
   4712              /* Generate Start */
   4713              hi2c->Instance->CR1 |= I2C_CR1_START;
   \                     ??I2C_MasterRequestWrite_0: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0xE007             B.N      ??I2C_MasterRequestWrite_2
   4714            }
   4715            else if(hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX)
   \                     ??I2C_MasterRequestWrite_1: (+1)
   \   00000028   0x6B20             LDR      R0,[R4, #+48]
   \   0000002A   0x2812             CMP      R0,#+18
   \   0000002C   0xD104             BNE.N    ??I2C_MasterRequestWrite_2
   4716            {
   4717              /* Generate ReStart */
   4718              hi2c->Instance->CR1 |= I2C_CR1_START;
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000036   0x6001             STR      R1,[R0, #+0]
   4719            }
   4720          
   4721            /* Wait until SB flag is set */
   4722            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \                     ??I2C_MasterRequestWrite_2: (+1)
   \   00000038   0x9700             STR      R7,[SP, #+0]
   \   0000003A   0x4633             MOV      R3,R6
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0xF04F 0x1101      MOV      R1,#+65537
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD001             BEQ.N    ??I2C_MasterRequestWrite_3
   4723            {
   4724              return HAL_TIMEOUT;
   \   0000004C   0x2003             MOVS     R0,#+3
   \   0000004E   0xBDF2             POP      {R1,R4-R7,PC}
   4725            }
   4726          
   4727            if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \                     ??I2C_MasterRequestWrite_3: (+1)
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6921             LDR      R1,[R4, #+16]
   \   00000054   0xF5B1 0x4F80      CMP      R1,#+16384
   \   00000058   0xD103             BNE.N    ??I2C_MasterRequestWrite_4
   4728            {
   4729              /* Send slave address */
   4730              hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \   0000005A   0xF005 0x01FE      AND      R1,R5,#0xFE
   \   0000005E   0x6101             STR      R1,[R0, #+16]
   \   00000060   0xE017             B.N      ??I2C_MasterRequestWrite_5
   4731            }
   4732            else
   4733            {
   4734              /* Send header of slave address */
   4735              hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
   \                     ??I2C_MasterRequestWrite_4: (+1)
   \   00000062   0x09E9             LSRS     R1,R5,#+7
   \   00000064   0xF001 0x0106      AND      R1,R1,#0x6
   \   00000068   0xF041 0x01F0      ORR      R1,R1,#0xF0
   \   0000006C   0x6101             STR      R1,[R0, #+16]
   4736          
   4737              /* Wait until ADD10 flag is set */
   4738              if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
   \   0000006E   0x463B             MOV      R3,R7
   \   00000070   0x4632             MOV      R2,R6
   \   00000072   0x....             LDR.N    R1,??DataTable31  ;; 0x10008
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD006             BEQ.N    ??I2C_MasterRequestWrite_6
   4739              {
   4740                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000007E   0x6C20             LDR      R0,[R4, #+64]
   \   00000080   0x2804             CMP      R0,#+4
   \   00000082   0xD101             BNE.N    ??I2C_MasterRequestWrite_7
   4741                {
   4742                  return HAL_ERROR;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xBDF2             POP      {R1,R4-R7,PC}
   4743                }
   4744                else
   4745                {
   4746                  return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestWrite_7: (+1)
   \   00000088   0x2003             MOVS     R0,#+3
   \   0000008A   0xBDF2             POP      {R1,R4-R7,PC}
   4747                }
   4748              }
   4749          
   4750              /* Send slave address */
   4751              hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
   \                     ??I2C_MasterRequestWrite_6: (+1)
   \   0000008C   0xB2ED             UXTB     R5,R5
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x6105             STR      R5,[R0, #+16]
   4752            }
   4753          
   4754            /* Wait until ADDR flag is set */
   4755            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \                     ??I2C_MasterRequestWrite_5: (+1)
   \   00000092   0x463B             MOV      R3,R7
   \   00000094   0x4632             MOV      R2,R6
   \   00000096   0x....             LDR.N    R1,??DataTable32  ;; 0x10002
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD006             BEQ.N    ??I2C_MasterRequestWrite_8
   4756            {
   4757              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000A2   0x6C20             LDR      R0,[R4, #+64]
   \   000000A4   0x2804             CMP      R0,#+4
   \   000000A6   0xD101             BNE.N    ??I2C_MasterRequestWrite_9
   4758              {
   4759                return HAL_ERROR;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xBDF2             POP      {R1,R4-R7,PC}
   4760              }
   4761              else
   4762              {
   4763                return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestWrite_9: (+1)
   \   000000AC   0x2003             MOVS     R0,#+3
   \   000000AE   0xBDF2             POP      {R1,R4-R7,PC}
   4764              }
   4765            }
   4766          
   4767            return HAL_OK;
   \                     ??I2C_MasterRequestWrite_8: (+1)
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4768          }
   4769          
   4770          /**
   4771            * @brief  Master sends target device address for read request.
   4772            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4773            *         the configuration information for I2C module
   4774            * @param  DevAddress Target device address: The device 7 bits address value
   4775            *         in datasheet must be shift at right before call interface
   4776            * @param  Timeout Timeout duration
   4777            * @param  Tickstart Tick start value
   4778            * @retval HAL status
   4779            */

   \                                 In section .text, align 2, keep-with-next
   4780          static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
   4781          {
   \                     I2C_MasterRequestRead: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460F             MOV      R7,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
   4782            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   4783            uint32_t CurrentXferOptions = hi2c->XferOptions;
   \   0000000E   0x6AE0             LDR      R0,[R4, #+44]
   4784          
   4785            /* Enable Acknowledge */
   4786            hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \   00000010   0x6821             LDR      R1,[R4, #+0]
   \   00000012   0x680A             LDR      R2,[R1, #+0]
   \   00000014   0xF442 0x6280      ORR      R2,R2,#0x400
   \   00000018   0x600A             STR      R2,[R1, #+0]
   4787          
   4788            /* Generate Start condition if first transfer */
   4789            if((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME)  || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
   \   0000001A   0x2804             CMP      R0,#+4
   \   0000001C   0xD004             BEQ.N    ??I2C_MasterRequestRead_0
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD002             BEQ.N    ??I2C_MasterRequestRead_0
   \   00000022   0x....             LDR.N    R1,??DataTable34  ;; 0xffff0000
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD105             BNE.N    ??I2C_MasterRequestRead_1
   4790            {
   4791              /* Generate Start */
   4792              hi2c->Instance->CR1 |= I2C_CR1_START;
   \                     ??I2C_MasterRequestRead_0: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000030   0x6001             STR      R1,[R0, #+0]
   \   00000032   0xE007             B.N      ??I2C_MasterRequestRead_2
   4793            }
   4794            else if(hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX)
   \                     ??I2C_MasterRequestRead_1: (+1)
   \   00000034   0x6B20             LDR      R0,[R4, #+48]
   \   00000036   0x2811             CMP      R0,#+17
   \   00000038   0xD104             BNE.N    ??I2C_MasterRequestRead_2
   4795            {
   4796              /* Generate ReStart */
   4797              hi2c->Instance->CR1 |= I2C_CR1_START;
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000042   0x6001             STR      R1,[R0, #+0]
   4798            }
   4799          
   4800            /* Wait until SB flag is set */
   4801            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \                     ??I2C_MasterRequestRead_2: (+1)
   \   00000044   0x9600             STR      R6,[SP, #+0]
   \   00000046   0x462B             MOV      R3,R5
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0xF04F 0x1101      MOV      R1,#+65537
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD001             BEQ.N    ??I2C_MasterRequestRead_3
   4802            {
   4803              return HAL_TIMEOUT;
   \   00000058   0x2003             MOVS     R0,#+3
   \   0000005A   0xE05C             B.N      ??I2C_MasterRequestRead_4
   4804            }
   4805          
   4806            if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \                     ??I2C_MasterRequestRead_3: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6921             LDR      R1,[R4, #+16]
   \   00000060   0xF5B1 0x4F80      CMP      R1,#+16384
   \   00000064   0xD104             BNE.N    ??I2C_MasterRequestRead_5
   4807            {
   4808              /* Send slave address */
   4809              hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
   \   00000066   0xF047 0x0101      ORR      R1,R7,#0x1
   \   0000006A   0xB2C9             UXTB     R1,R1
   \   0000006C   0x6101             STR      R1,[R0, #+16]
   \   0000006E   0xE042             B.N      ??I2C_MasterRequestRead_6
   4810            }
   4811            else
   4812            {
   4813              /* Send header of slave address */
   4814              hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
   \                     ??I2C_MasterRequestRead_5: (+1)
   \   00000070   0x09F9             LSRS     R1,R7,#+7
   \   00000072   0xF001 0x0806      AND      R8,R1,#0x6
   \   00000076   0xF048 0x01F0      ORR      R1,R8,#0xF0
   \   0000007A   0x6101             STR      R1,[R0, #+16]
   4815          
   4816              /* Wait until ADD10 flag is set */
   4817              if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
   \   0000007C   0x4633             MOV      R3,R6
   \   0000007E   0x462A             MOV      R2,R5
   \   00000080   0x....             LDR.N    R1,??DataTable34_1  ;; 0x10008
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD006             BEQ.N    ??I2C_MasterRequestRead_7
   4818              {
   4819                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000008C   0x6C20             LDR      R0,[R4, #+64]
   \   0000008E   0x2804             CMP      R0,#+4
   \   00000090   0xD101             BNE.N    ??I2C_MasterRequestRead_8
   4820                {
   4821                  return HAL_ERROR;
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0xE03F             B.N      ??I2C_MasterRequestRead_4
   4822                }
   4823                else
   4824                {
   4825                  return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestRead_8: (+1)
   \   00000096   0x2003             MOVS     R0,#+3
   \   00000098   0xE03D             B.N      ??I2C_MasterRequestRead_4
   4826                }
   4827              }
   4828          
   4829              /* Send slave address */
   4830              hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
   \                     ??I2C_MasterRequestRead_7: (+1)
   \   0000009A   0xB2FF             UXTB     R7,R7
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x6107             STR      R7,[R0, #+16]
   4831          
   4832              /* Wait until ADDR flag is set */
   4833              if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \   000000A0   0x4633             MOV      R3,R6
   \   000000A2   0x462A             MOV      R2,R5
   \   000000A4   0x....             LDR.N    R1,??DataTable32  ;; 0x10002
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD006             BEQ.N    ??I2C_MasterRequestRead_9
   4834              {
   4835                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000B0   0x6C20             LDR      R0,[R4, #+64]
   \   000000B2   0x2804             CMP      R0,#+4
   \   000000B4   0xD101             BNE.N    ??I2C_MasterRequestRead_10
   4836                {
   4837                  return HAL_ERROR;
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0xE02D             B.N      ??I2C_MasterRequestRead_4
   4838                }
   4839                else
   4840                {
   4841                  return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestRead_10: (+1)
   \   000000BA   0x2003             MOVS     R0,#+3
   \   000000BC   0xE02B             B.N      ??I2C_MasterRequestRead_4
   4842                }
   4843              }
   4844          
   4845              /* Clear ADDR flag */
   4846              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_MasterRequestRead_9: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x9000             STR      R0,[SP, #+0]
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x6941             LDR      R1,[R0, #+20]
   \   000000C6   0x9100             STR      R1,[SP, #+0]
   \   000000C8   0x6981             LDR      R1,[R0, #+24]
   \   000000CA   0x9100             STR      R1,[SP, #+0]
   \   000000CC   0x9900             LDR      R1,[SP, #+0]
   4847          
   4848              /* Generate Restart */
   4849              hi2c->Instance->CR1 |= I2C_CR1_START;
   \   000000CE   0x6801             LDR      R1,[R0, #+0]
   \   000000D0   0xF441 0x7180      ORR      R1,R1,#0x100
   \   000000D4   0x6001             STR      R1,[R0, #+0]
   4850          
   4851              /* Wait until SB flag is set */
   4852              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \   000000D6   0x9600             STR      R6,[SP, #+0]
   \   000000D8   0x462B             MOV      R3,R5
   \   000000DA   0x2200             MOVS     R2,#+0
   \   000000DC   0xF04F 0x1101      MOV      R1,#+65537
   \   000000E0   0x4620             MOV      R0,R4
   \   000000E2   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD001             BEQ.N    ??I2C_MasterRequestRead_11
   4853              {
   4854                return HAL_TIMEOUT;
   \   000000EA   0x2003             MOVS     R0,#+3
   \   000000EC   0xE013             B.N      ??I2C_MasterRequestRead_4
   4855              }
   4856          
   4857              /* Send header of slave address */
   4858              hi2c->Instance->DR = I2C_10BIT_HEADER_READ(DevAddress);
   \                     ??I2C_MasterRequestRead_11: (+1)
   \   000000EE   0xF048 0x00F1      ORR      R0,R8,#0xF1
   \   000000F2   0x6821             LDR      R1,[R4, #+0]
   \   000000F4   0x6108             STR      R0,[R1, #+16]
   4859            }
   4860          
   4861            /* Wait until ADDR flag is set */
   4862            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \                     ??I2C_MasterRequestRead_6: (+1)
   \   000000F6   0x4633             MOV      R3,R6
   \   000000F8   0x462A             MOV      R2,R5
   \   000000FA   0x....             LDR.N    R1,??DataTable32  ;; 0x10002
   \   000000FC   0x4620             MOV      R0,R4
   \   000000FE   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD006             BEQ.N    ??I2C_MasterRequestRead_12
   4863            {
   4864              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000106   0x6C20             LDR      R0,[R4, #+64]
   \   00000108   0x2804             CMP      R0,#+4
   \   0000010A   0xD101             BNE.N    ??I2C_MasterRequestRead_13
   4865              {
   4866                return HAL_ERROR;
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0xE002             B.N      ??I2C_MasterRequestRead_4
   4867              }
   4868              else
   4869              {
   4870                return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestRead_13: (+1)
   \   00000110   0x2003             MOVS     R0,#+3
   \   00000112   0xE000             B.N      ??I2C_MasterRequestRead_4
   4871              }
   4872            }
   4873          
   4874            return HAL_OK;
   \                     ??I2C_MasterRequestRead_12: (+1)
   \   00000114   0x2000             MOVS     R0,#+0
   \                     ??I2C_MasterRequestRead_4: (+1)
   \   00000116   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   4875          }
   4876          
   4877          /**
   4878            * @brief  Master sends target device address followed by internal memory address for write request.
   4879            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4880            *         the configuration information for I2C module
   4881            * @param  DevAddress Target device address
   4882            * @param  MemAddress Internal memory address
   4883            * @param  MemAddSize Size of internal memory address
   4884            * @param  Timeout Timeout duration
   4885            * @param  Tickstart Tick start value
   4886            * @retval HAL status
   4887            */

   \                                 In section .text, align 2, keep-with-next
   4888          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
   4889          {
   \                     I2C_RequestMemoryWrite: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x461E             MOV      R6,R3
   4890            /* Generate Start */
   4891            hi2c->Instance->CR1 |= I2C_CR1_START;
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000014   0x6001             STR      R1,[R0, #+0]
   \   00000016   0x9F08             LDR      R7,[SP, #+32]
   \   00000018   0xF8DD 0x8024      LDR      R8,[SP, #+36]
   4892          
   4893            /* Wait until SB flag is set */
   4894            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \   0000001C   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000020   0x463B             MOV      R3,R7
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0xF04F 0x1101      MOV      R1,#+65537
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD001             BEQ.N    ??I2C_RequestMemoryWrite_0
   4895            {
   4896              return HAL_TIMEOUT;
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0xE049             B.N      ??I2C_RequestMemoryWrite_1
   4897            }
   4898          
   4899            /* Send slave address */
   4900            hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \                     ??I2C_RequestMemoryWrite_0: (+1)
   \   00000036   0xF009 0x00FE      AND      R0,R9,#0xFE
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x6108             STR      R0,[R1, #+16]
   4901          
   4902            /* Wait until ADDR flag is set */
   4903            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \   0000003E   0x4643             MOV      R3,R8
   \   00000040   0x463A             MOV      R2,R7
   \   00000042   0x....             LDR.N    R1,??DataTable34_2  ;; 0x10002
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD006             BEQ.N    ??I2C_RequestMemoryWrite_2
   4904            {
   4905              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000004E   0x6C20             LDR      R0,[R4, #+64]
   \   00000050   0x2804             CMP      R0,#+4
   \   00000052   0xD101             BNE.N    ??I2C_RequestMemoryWrite_3
   4906              {
   4907                return HAL_ERROR;
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xE038             B.N      ??I2C_RequestMemoryWrite_1
   4908              }
   4909              else
   4910              {
   4911                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryWrite_3: (+1)
   \   00000058   0x2003             MOVS     R0,#+3
   \   0000005A   0xE036             B.N      ??I2C_RequestMemoryWrite_1
   4912              }
   4913            }
   4914          
   4915            /* Clear ADDR flag */
   4916            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_RequestMemoryWrite_2: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6941             LDR      R1,[R0, #+20]
   \   00000064   0x9100             STR      R1,[SP, #+0]
   \   00000066   0x6980             LDR      R0,[R0, #+24]
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
   4917          
   4918            /* Wait until TXE flag is set */
   4919            if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \   0000006C   0x4642             MOV      R2,R8
   \   0000006E   0x4639             MOV      R1,R7
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD00B             BEQ.N    ??I2C_RequestMemoryWrite_4
   4920            {
   4921              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000007A   0x6C20             LDR      R0,[R4, #+64]
   \   0000007C   0x2804             CMP      R0,#+4
   \   0000007E   0xD106             BNE.N    ??I2C_RequestMemoryWrite_5
   4922              {
   4923                /* Generate Stop */
   4924                hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000088   0x6001             STR      R1,[R0, #+0]
   4925                return HAL_ERROR;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xE01D             B.N      ??I2C_RequestMemoryWrite_1
   4926              }
   4927              else
   4928              {
   4929                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryWrite_5: (+1)
   \   0000008E   0x2003             MOVS     R0,#+3
   \   00000090   0xE01B             B.N      ??I2C_RequestMemoryWrite_1
   4930              }
   4931            }
   4932          
   4933            /* If Memory address size is 8Bit */
   4934            if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \                     ??I2C_RequestMemoryWrite_4: (+1)
   \   00000092   0x2E01             CMP      R6,#+1
   \   00000094   0xD015             BEQ.N    ??I2C_RequestMemoryWrite_6
   4935            {
   4936              /* Send Memory Address */
   4937              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   4938            }
   4939            /* If Memory address size is 16Bit */
   4940            else
   4941            {
   4942              /* Send MSB of Memory Address */
   4943              hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
   \   00000096   0x0A28             LSRS     R0,R5,#+8
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x6108             STR      R0,[R1, #+16]
   4944          
   4945              /* Wait until TXE flag is set */
   4946              if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \   0000009C   0x4642             MOV      R2,R8
   \   0000009E   0x4639             MOV      R1,R7
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD00B             BEQ.N    ??I2C_RequestMemoryWrite_6
   4947              {
   4948                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000AA   0x6C20             LDR      R0,[R4, #+64]
   \   000000AC   0x2804             CMP      R0,#+4
   \   000000AE   0xD106             BNE.N    ??I2C_RequestMemoryWrite_7
   4949                {
   4950                  /* Generate Stop */
   4951                  hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6801             LDR      R1,[R0, #+0]
   \   000000B4   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000B8   0x6001             STR      R1,[R0, #+0]
   4952                  return HAL_ERROR;
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0xE005             B.N      ??I2C_RequestMemoryWrite_1
   4953                }
   4954                else
   4955                {
   4956                  return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryWrite_7: (+1)
   \   000000BE   0x2003             MOVS     R0,#+3
   \   000000C0   0xE003             B.N      ??I2C_RequestMemoryWrite_1
   4957                }
   4958              }
   4959          
   4960              /* Send LSB of Memory Address */
   4961              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   \                     ??I2C_RequestMemoryWrite_6: (+1)
   \   000000C2   0xB2ED             UXTB     R5,R5
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6105             STR      R5,[R0, #+16]
   4962            }
   4963          
   4964            return HAL_OK;
   \   000000C8   0x2000             MOVS     R0,#+0
   \                     ??I2C_RequestMemoryWrite_1: (+1)
   \   000000CA   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   4965          }
   4966          
   4967          /**
   4968            * @brief  Master sends target device address followed by internal memory address for read request.
   4969            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4970            *         the configuration information for I2C module
   4971            * @param  DevAddress Target device address
   4972            * @param  MemAddress Internal memory address
   4973            * @param  MemAddSize Size of internal memory address
   4974            * @param  Timeout Timeout duration
   4975            * @param  Tickstart Tick start value
   4976            * @retval HAL status
   4977            */

   \                                 In section .text, align 2, keep-with-next
   4978          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
   4979          {
   \                     I2C_RequestMemoryRead: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
   4980            /* Enable Acknowledge */
   4981            hi2c->Instance->CR1 |= I2C_CR1_ACK;
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000016   0x6001             STR      R1,[R0, #+0]
   4982          
   4983            /* Generate Start */
   4984            hi2c->Instance->CR1 |= I2C_CR1_START;
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000020   0x6001             STR      R1,[R0, #+0]
   \   00000022   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \   00000026   0xF8DD 0x902C      LDR      R9,[SP, #+44]
   4985          
   4986            /* Wait until SB flag is set */
   4987            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \   0000002A   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   0000002E   0x4643             MOV      R3,R8
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0xF04F 0x1101      MOV      R1,#+65537
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ.N    ??I2C_RequestMemoryRead_0
   4988            {
   4989              return HAL_TIMEOUT;
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0xE084             B.N      ??I2C_RequestMemoryRead_1
   4990            }
   4991          
   4992            /* Send slave address */
   4993            hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \                     ??I2C_RequestMemoryRead_0: (+1)
   \   00000044   0xF005 0x00FE      AND      R0,R5,#0xFE
   \   00000048   0x6821             LDR      R1,[R4, #+0]
   \   0000004A   0x6108             STR      R0,[R1, #+16]
   4994          
   4995            /* Wait until ADDR flag is set */
   4996            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \   0000004C   0x.... 0x....      LDR.W    R10,??DataTable34_2  ;; 0x10002
   \   00000050   0x464B             MOV      R3,R9
   \   00000052   0x4642             MOV      R2,R8
   \   00000054   0x4651             MOV      R1,R10
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD006             BEQ.N    ??I2C_RequestMemoryRead_2
   4997            {
   4998              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000060   0x6C20             LDR      R0,[R4, #+64]
   \   00000062   0x2804             CMP      R0,#+4
   \   00000064   0xD101             BNE.N    ??I2C_RequestMemoryRead_3
   4999              {
   5000                return HAL_ERROR;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xE071             B.N      ??I2C_RequestMemoryRead_1
   5001              }
   5002              else
   5003              {
   5004                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_3: (+1)
   \   0000006A   0x2003             MOVS     R0,#+3
   \   0000006C   0xE06F             B.N      ??I2C_RequestMemoryRead_1
   5005              }
   5006            }
   5007          
   5008            /* Clear ADDR flag */
   5009            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_RequestMemoryRead_2: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x9000             STR      R0,[SP, #+0]
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x6941             LDR      R1,[R0, #+20]
   \   00000076   0x9100             STR      R1,[SP, #+0]
   \   00000078   0x6980             LDR      R0,[R0, #+24]
   \   0000007A   0x9000             STR      R0,[SP, #+0]
   \   0000007C   0x9800             LDR      R0,[SP, #+0]
   5010          
   5011            /* Wait until TXE flag is set */
   5012            if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \   0000007E   0x464A             MOV      R2,R9
   \   00000080   0x4641             MOV      R1,R8
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD00B             BEQ.N    ??I2C_RequestMemoryRead_4
   5013            {
   5014              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000008C   0x6C20             LDR      R0,[R4, #+64]
   \   0000008E   0x2804             CMP      R0,#+4
   \   00000090   0xD106             BNE.N    ??I2C_RequestMemoryRead_5
   5015              {
   5016                /* Generate Stop */
   5017                hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6801             LDR      R1,[R0, #+0]
   \   00000096   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000009A   0x6001             STR      R1,[R0, #+0]
   5018                return HAL_ERROR;
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xE056             B.N      ??I2C_RequestMemoryRead_1
   5019              }
   5020              else
   5021              {
   5022                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_5: (+1)
   \   000000A0   0x2003             MOVS     R0,#+3
   \   000000A2   0xE054             B.N      ??I2C_RequestMemoryRead_1
   5023              }
   5024            }
   5025          
   5026            /* If Memory address size is 8Bit */
   5027            if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \                     ??I2C_RequestMemoryRead_4: (+1)
   \   000000A4   0x2F01             CMP      R7,#+1
   \   000000A6   0xD015             BEQ.N    ??I2C_RequestMemoryRead_6
   5028            {
   5029              /* Send Memory Address */
   5030              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   5031            }
   5032            /* If Memory address size is 16Bit */
   5033            else
   5034            {
   5035              /* Send MSB of Memory Address */
   5036              hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
   \   000000A8   0x0A30             LSRS     R0,R6,#+8
   \   000000AA   0x6821             LDR      R1,[R4, #+0]
   \   000000AC   0x6108             STR      R0,[R1, #+16]
   5037          
   5038              /* Wait until TXE flag is set */
   5039              if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \   000000AE   0x464A             MOV      R2,R9
   \   000000B0   0x4641             MOV      R1,R8
   \   000000B2   0x4620             MOV      R0,R4
   \   000000B4   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD00B             BEQ.N    ??I2C_RequestMemoryRead_6
   5040              {
   5041                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000BC   0x6C20             LDR      R0,[R4, #+64]
   \   000000BE   0x2804             CMP      R0,#+4
   \   000000C0   0xD106             BNE.N    ??I2C_RequestMemoryRead_7
   5042                {
   5043                  /* Generate Stop */
   5044                  hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x6801             LDR      R1,[R0, #+0]
   \   000000C6   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000CA   0x6001             STR      R1,[R0, #+0]
   5045                  return HAL_ERROR;
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0xE03E             B.N      ??I2C_RequestMemoryRead_1
   5046                }
   5047                else
   5048                {
   5049                  return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_7: (+1)
   \   000000D0   0x2003             MOVS     R0,#+3
   \   000000D2   0xE03C             B.N      ??I2C_RequestMemoryRead_1
   5050                }
   5051              }
   5052          
   5053              /* Send LSB of Memory Address */
   5054              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   \                     ??I2C_RequestMemoryRead_6: (+1)
   \   000000D4   0xB2F6             UXTB     R6,R6
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x6106             STR      R6,[R0, #+16]
   5055            }
   5056          
   5057            /* Wait until TXE flag is set */
   5058            if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \   000000DA   0x464A             MOV      R2,R9
   \   000000DC   0x4641             MOV      R1,R8
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD00B             BEQ.N    ??I2C_RequestMemoryRead_8
   5059            {
   5060              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000E8   0x6C20             LDR      R0,[R4, #+64]
   \   000000EA   0x2804             CMP      R0,#+4
   \   000000EC   0xD106             BNE.N    ??I2C_RequestMemoryRead_9
   5061              {
   5062                /* Generate Stop */
   5063                hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x6801             LDR      R1,[R0, #+0]
   \   000000F2   0xF441 0x7100      ORR      R1,R1,#0x200
   \   000000F6   0x6001             STR      R1,[R0, #+0]
   5064                return HAL_ERROR;
   \   000000F8   0x2001             MOVS     R0,#+1
   \   000000FA   0xE028             B.N      ??I2C_RequestMemoryRead_1
   5065              }
   5066              else
   5067              {
   5068                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_9: (+1)
   \   000000FC   0x2003             MOVS     R0,#+3
   \   000000FE   0xE026             B.N      ??I2C_RequestMemoryRead_1
   5069              }
   5070            }
   5071          
   5072            /* Generate Restart */
   5073            hi2c->Instance->CR1 |= I2C_CR1_START;
   \                     ??I2C_RequestMemoryRead_8: (+1)
   \   00000100   0x6820             LDR      R0,[R4, #+0]
   \   00000102   0x6801             LDR      R1,[R0, #+0]
   \   00000104   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000108   0x6001             STR      R1,[R0, #+0]
   5074          
   5075            /* Wait until SB flag is set */
   5076            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \   0000010A   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   0000010E   0x4643             MOV      R3,R8
   \   00000110   0x2200             MOVS     R2,#+0
   \   00000112   0xF04F 0x1101      MOV      R1,#+65537
   \   00000116   0x4620             MOV      R0,R4
   \   00000118   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD001             BEQ.N    ??I2C_RequestMemoryRead_10
   5077            {
   5078              return HAL_TIMEOUT;
   \   00000120   0x2003             MOVS     R0,#+3
   \   00000122   0xE014             B.N      ??I2C_RequestMemoryRead_1
   5079            }
   5080          
   5081            /* Send slave address */
   5082            hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
   \                     ??I2C_RequestMemoryRead_10: (+1)
   \   00000124   0xF045 0x0001      ORR      R0,R5,#0x1
   \   00000128   0xB2C0             UXTB     R0,R0
   \   0000012A   0x6821             LDR      R1,[R4, #+0]
   \   0000012C   0x6108             STR      R0,[R1, #+16]
   5083          
   5084            /* Wait until ADDR flag is set */
   5085            if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \   0000012E   0x464B             MOV      R3,R9
   \   00000130   0x4642             MOV      R2,R8
   \   00000132   0x4651             MOV      R1,R10
   \   00000134   0x4620             MOV      R0,R4
   \   00000136   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD006             BEQ.N    ??I2C_RequestMemoryRead_11
   5086            {
   5087              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000013E   0x6C20             LDR      R0,[R4, #+64]
   \   00000140   0x2804             CMP      R0,#+4
   \   00000142   0xD101             BNE.N    ??I2C_RequestMemoryRead_12
   5088              {
   5089                return HAL_ERROR;
   \   00000144   0x2001             MOVS     R0,#+1
   \   00000146   0xE002             B.N      ??I2C_RequestMemoryRead_1
   5090              }
   5091              else
   5092              {
   5093                return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_12: (+1)
   \   00000148   0x2003             MOVS     R0,#+3
   \   0000014A   0xE000             B.N      ??I2C_RequestMemoryRead_1
   5094              }
   5095            }
   5096          
   5097            return HAL_OK;
   \                     ??I2C_RequestMemoryRead_11: (+1)
   \   0000014C   0x2000             MOVS     R0,#+0
   \                     ??I2C_RequestMemoryRead_1: (+1)
   \   0000014E   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   5098          }
   5099          
   5100          /**
   5101            * @brief  DMA I2C process complete callback.
   5102            * @param  hdma DMA handle
   5103            * @retval None
   5104            */

   \                                 In section .text, align 2, keep-with-next
   5105          static void I2C_DMAXferCplt(DMA_HandleTypeDef *hdma)
   5106          {
   \                     I2C_DMAXferCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   5107            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   5108            
   5109            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   5110            uint32_t CurrentState = hi2c->State;
   \   00000004   0xF890 0x103D      LDRB     R1,[R0, #+61]
   5111            uint32_t CurrentMode  = hi2c->Mode;
   \   00000008   0xF990 0x203E      LDRSB    R2,[R0, #+62]
   5112          
   5113            if((CurrentState == HAL_I2C_STATE_BUSY_TX) || ((CurrentState == HAL_I2C_STATE_BUSY_RX) && (CurrentMode == HAL_I2C_MODE_SLAVE))) 
   \   0000000C   0x2921             CMP      R1,#+33
   \   0000000E   0xD003             BEQ.N    ??I2C_DMAXferCplt_0
   \   00000010   0x2922             CMP      R1,#+34
   \   00000012   0xD10E             BNE.N    ??I2C_DMAXferCplt_1
   \   00000014   0x2A20             CMP      R2,#+32
   \   00000016   0xD10C             BNE.N    ??I2C_DMAXferCplt_1
   5114            {
   5115              /* Disable DMA Request */
   5116              hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
   \                     ??I2C_DMAXferCplt_0: (+1)
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x684A             LDR      R2,[R1, #+4]
   \   0000001C   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000020   0x604A             STR      R2,[R1, #+4]
   5117              
   5118              hi2c->XferCount = 0U;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x8541             STRH     R1,[R0, #+42]
   5119              
   5120              /* Enable EVT and ERR interrupt */
   5121              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x6841             LDR      R1,[R0, #+4]
   \   0000002A   0xF441 0x7140      ORR      R1,R1,#0x300
   \   0000002E   0x6041             STR      R1,[R0, #+4]
   \   00000030   0xBD01             POP      {R0,PC}
   5122            }
   5123            else
   5124            {
   5125              /* Disable Acknowledge */
   5126              hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \                     ??I2C_DMAXferCplt_1: (+1)
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0x680A             LDR      R2,[R1, #+0]
   \   00000036   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000003A   0x600A             STR      R2,[R1, #+0]
   5127              
   5128              /* Generate Stop */
   5129              hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x680A             LDR      R2,[R1, #+0]
   \   00000040   0xF442 0x7200      ORR      R2,R2,#0x200
   \   00000044   0x600A             STR      R2,[R1, #+0]
   5130              
   5131              /* Disable Last DMA */
   5132              hi2c->Instance->CR2 &= ~I2C_CR2_LAST;
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x684A             LDR      R2,[R1, #+4]
   \   0000004A   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   0000004E   0x604A             STR      R2,[R1, #+4]
   5133              
   5134              /* Disable DMA Request */
   5135              hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x684A             LDR      R2,[R1, #+4]
   \   00000054   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000058   0x604A             STR      R2,[R1, #+4]
   5136              
   5137              hi2c->XferCount = 0U;
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x8541             STRH     R1,[R0, #+42]
   5138          
   5139              /* Check if Errors has been detected during transfer */
   5140              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000005E   0x6C01             LDR      R1,[R0, #+64]
   \   00000060   0x2900             CMP      R1,#+0
   \   00000062   0xD002             BEQ.N    ??I2C_DMAXferCplt_2
   5141              {
   5142                HAL_I2C_ErrorCallback(hi2c);
   \   00000064   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000068   0xBD01             POP      {R0,PC}
   5143              }
   5144              else
   5145              {
   5146                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_DMAXferCplt_2: (+1)
   \   0000006A   0x2120             MOVS     R1,#+32
   \   0000006C   0xF880 0x103D      STRB     R1,[R0, #+61]
   5147          
   5148                if(hi2c->Mode == HAL_I2C_MODE_MEM)
   \   00000070   0xF990 0x103E      LDRSB    R1,[R0, #+62]
   \   00000074   0x2940             CMP      R1,#+64
   \   00000076   0xD105             BNE.N    ??I2C_DMAXferCplt_3
   5149                {
   5150                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0xF880 0x103E      STRB     R1,[R0, #+62]
   5151          
   5152                  HAL_I2C_MemRxCpltCallback(hi2c);
   \   0000007E   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \   00000082   0xBD01             POP      {R0,PC}
   5153                }
   5154                else
   5155                {
   5156                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \                     ??I2C_DMAXferCplt_3: (+1)
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0xF880 0x103E      STRB     R1,[R0, #+62]
   5157          
   5158                  HAL_I2C_MasterRxCpltCallback(hi2c);
   \   0000008A   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   5159                }
   5160              }
   5161            }
   5162          }
   \   0000008E   0xBD01             POP      {R0,PC}          ;; return
   5163          
   5164          /**
   5165            * @brief  DMA I2C communication error callback.
   5166            * @param  hdma DMA handle
   5167            * @retval None
   5168            */

   \                                 In section .text, align 2, keep-with-next
   5169          static void I2C_DMAError(DMA_HandleTypeDef *hdma)
   5170          {
   \                     I2C_DMAError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   5171            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   5172          
   5173            /* Disable Acknowledge */
   5174            hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x680A             LDR      R2,[R1, #+0]
   \   00000008   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000000C   0x600A             STR      R2,[R1, #+0]
   5175          
   5176            hi2c->XferCount = 0U;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x8541             STRH     R1,[R0, #+42]
   5177          
   5178            hi2c->State = HAL_I2C_STATE_READY;
   \   00000012   0x2120             MOVS     R1,#+32
   \   00000014   0xF880 0x103D      STRB     R1,[R0, #+61]
   5179            hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0xF880 0x103E      STRB     R1,[R0, #+62]
   5180          
   5181            hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \   0000001E   0x6C01             LDR      R1,[R0, #+64]
   \   00000020   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000024   0x6401             STR      R1,[R0, #+64]
   5182          
   5183            HAL_I2C_ErrorCallback(hi2c);
   \   00000026   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   5184          }
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
   5185          
   5186          /**
   5187            * @brief DMA I2C communication abort callback
   5188            *        (To be called at end of DMA Abort procedure).
   5189            * @param hdma: DMA handle.
   5190            * @retval None
   5191            */

   \                                 In section .text, align 4, keep-with-next
   5192          static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
   5193          {
   \                     I2C_DMAAbort: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   5194            I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   5195            
   5196            /* Disable Acknowledge */
   5197            hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x680A             LDR      R2,[R1, #+0]
   \   00000008   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000000C   0x600A             STR      R2,[R1, #+0]
   5198          
   5199            hi2c->XferCount = 0U;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x8541             STRH     R1,[R0, #+42]
   5200          
   5201            /* Reset XferAbortCallback */
   5202            hi2c->hdmatx->XferAbortCallback = NULL;
   \   00000012   0x6B42             LDR      R2,[R0, #+52]
   \   00000014   0x6511             STR      R1,[R2, #+80]
   5203            hi2c->hdmarx->XferAbortCallback = NULL;
   \   00000016   0x6B82             LDR      R2,[R0, #+56]
   \   00000018   0x6511             STR      R1,[R2, #+80]
   5204          
   5205            /* Check if come from abort from user */
   5206            if(hi2c->State == HAL_I2C_STATE_ABORT)
   \   0000001A   0xF890 0x103D      LDRB     R1,[R0, #+61]
   \   0000001E   0x2960             CMP      R1,#+96
   \   00000020   0xD10E             BNE.N    ??I2C_DMAAbort_0
   5207            {
   5208              hi2c->State = HAL_I2C_STATE_READY;
   \   00000022   0x2120             MOVS     R1,#+32
   \   00000024   0xF880 0x103D      STRB     R1,[R0, #+61]
   5209              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xF880 0x103E      STRB     R1,[R0, #+62]
   5210              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000002E   0x6401             STR      R1,[R0, #+64]
   5211          
   5212              /* Disable I2C peripheral to prevent dummy data in buffer */
   5213              __HAL_I2C_DISABLE(hi2c);
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0x680A             LDR      R2,[R1, #+0]
   \   00000034   0x0852             LSRS     R2,R2,#+1
   \   00000036   0x0052             LSLS     R2,R2,#+1
   \   00000038   0x600A             STR      R2,[R1, #+0]
   5214          
   5215              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5216              HAL_I2C_AbortCpltCallback(hi2c);
   \   0000003A   0x.... 0x....      BL       HAL_I2C_AbortCpltCallback
   \   0000003E   0xBD01             POP      {R0,PC}
   5217            }
   5218            else
   5219            {
   5220              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_DMAAbort_0: (+1)
   \   00000040   0x2120             MOVS     R1,#+32
   \   00000042   0xF880 0x103D      STRB     R1,[R0, #+61]
   5221              hi2c->Mode = HAL_I2C_MODE_NONE;
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0xF880 0x103E      STRB     R1,[R0, #+62]
   5222          
   5223              /* Disable I2C peripheral to prevent dummy data in buffer */
   5224              __HAL_I2C_DISABLE(hi2c);
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0x680A             LDR      R2,[R1, #+0]
   \   00000050   0x0852             LSRS     R2,R2,#+1
   \   00000052   0x0052             LSLS     R2,R2,#+1
   \   00000054   0x600A             STR      R2,[R1, #+0]
   5225          
   5226              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5227              HAL_I2C_ErrorCallback(hi2c);
   \   00000056   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   5228            }
   5229          }
   \   0000005A   0xBD01             POP      {R0,PC}          ;; return
   5230          
   5231          /**
   5232            * @brief  This function handles I2C Communication Timeout.
   5233            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5234            *         the configuration information for I2C module
   5235            * @param  Flag specifies the I2C flag to check.
   5236            * @param  Status The new Flag status (SET or RESET).
   5237            * @param  Timeout Timeout duration
   5238            * @param  Tickstart Tick start value
   5239            * @retval HAL status
   5240            */

   \                                 In section .text, align 2, keep-with-next
   5241          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
   5242          {
   \                     I2C_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
   \   0000000C   0xF8DD 0x8018      LDR      R8,[SP, #+24]
   5243            /* Wait until flag is set */
   5244            while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
   \                     ??I2C_WaitOnFlagUntilTimeout_0: (+1)
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x0C29             LSRS     R1,R5,#+16
   \   00000014   0xB2C9             UXTB     R1,R1
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xD109             BNE.N    ??I2C_WaitOnFlagUntilTimeout_1
   \   0000001A   0x6940             LDR      R0,[R0, #+20]
   \   0000001C   0x4028             ANDS     R0,R5,R0
   \   0000001E   0xB280             UXTH     R0,R0
   \   00000020   0xB2A9             UXTH     R1,R5
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD101             BNE.N    ??I2C_WaitOnFlagUntilTimeout_2
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE00A             B.N      ??I2C_WaitOnFlagUntilTimeout_3
   \                     ??I2C_WaitOnFlagUntilTimeout_2: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE008             B.N      ??I2C_WaitOnFlagUntilTimeout_3
   \                     ??I2C_WaitOnFlagUntilTimeout_1: (+1)
   \   0000002E   0x6980             LDR      R0,[R0, #+24]
   \   00000030   0x4028             ANDS     R0,R5,R0
   \   00000032   0xB280             UXTH     R0,R0
   \   00000034   0xB2A9             UXTH     R1,R5
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD101             BNE.N    ??I2C_WaitOnFlagUntilTimeout_4
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xE000             B.N      ??I2C_WaitOnFlagUntilTimeout_3
   \                     ??I2C_WaitOnFlagUntilTimeout_4: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnFlagUntilTimeout_3: (+1)
   \   00000040   0x1E40             SUBS     R0,R0,#+1
   \   00000042   0x4180             SBCS     R0,R0,R0
   \   00000044   0x43C0             MVNS     R0,R0
   \   00000046   0x0FC0             LSRS     R0,R0,#+31
   \   00000048   0x42B0             CMP      R0,R6
   \   0000004A   0xD116             BNE.N    ??I2C_WaitOnFlagUntilTimeout_5
   5245            {
   5246              /* Check for the Timeout */
   5247              if(Timeout != HAL_MAX_DELAY)
   \   0000004C   0xF117 0x0F01      CMN      R7,#+1
   \   00000050   0xD0DE             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_0
   5248              {
   5249                if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
   \   00000052   0x2F00             CMP      R7,#+0
   \   00000054   0xD005             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_6
   \   00000056   0x.... 0x....      BL       HAL_GetTick
   \   0000005A   0xEBA0 0x0008      SUB      R0,R0,R8
   \   0000005E   0x4287             CMP      R7,R0
   \   00000060   0xD2D6             BCS.N    ??I2C_WaitOnFlagUntilTimeout_0
   5250                {
   5251                  hi2c->PreviousState = I2C_STATE_NONE;
   \                     ??I2C_WaitOnFlagUntilTimeout_6: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x6320             STR      R0,[R4, #+48]
   5252                  hi2c->State= HAL_I2C_STATE_READY;
   \   00000066   0x2020             MOVS     R0,#+32
   \   00000068   0xF884 0x003D      STRB     R0,[R4, #+61]
   5253                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF884 0x003E      STRB     R0,[R4, #+62]
   5254          
   5255                  /* Process Unlocked */
   5256                  __HAL_UNLOCK(hi2c);
   \   00000072   0xF884 0x003C      STRB     R0,[R4, #+60]
   5257                  
   5258                  return HAL_TIMEOUT;
   \   00000076   0x2003             MOVS     R0,#+3
   \   00000078   0xE000             B.N      ??I2C_WaitOnFlagUntilTimeout_7
   5259                }
   5260              }
   5261            }
   5262            
   5263            return HAL_OK;
   \                     ??I2C_WaitOnFlagUntilTimeout_5: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnFlagUntilTimeout_7: (+1)
   \   0000007C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   5264          }
   5265          
   5266          /**
   5267            * @brief  This function handles I2C Communication Timeout for Master addressing phase.
   5268            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5269            *         the configuration information for I2C module
   5270            * @param  Flag specifies the I2C flag to check.
   5271            * @param  Timeout Timeout duration
   5272            * @param  Tickstart Tick start value
   5273            * @retval HAL status
   5274            */

   \                                 In section .text, align 2, keep-with-next
   5275          static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout, uint32_t Tickstart)
   5276          {
   \                     I2C_WaitOnMasterAddressFlagUntilTimeout: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
   5277            while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_0: (+1)
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x0C29             LSRS     R1,R5,#+16
   \   0000000E   0xB2C9             UXTB     R1,R1
   \   00000010   0x2901             CMP      R1,#+1
   \   00000012   0xD109             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_1
   \   00000014   0x6941             LDR      R1,[R0, #+20]
   \   00000016   0x4029             ANDS     R1,R5,R1
   \   00000018   0xB289             UXTH     R1,R1
   \   0000001A   0xB2AA             UXTH     R2,R5
   \   0000001C   0x4291             CMP      R1,R2
   \   0000001E   0xD101             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_2
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0xE00A             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_3
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_2: (+1)
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xE008             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_3
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_1: (+1)
   \   00000028   0x6981             LDR      R1,[R0, #+24]
   \   0000002A   0x4029             ANDS     R1,R5,R1
   \   0000002C   0xB289             UXTH     R1,R1
   \   0000002E   0xB2AA             UXTH     R2,R5
   \   00000030   0x4291             CMP      R1,R2
   \   00000032   0xD101             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_4
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0xE000             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_3
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_4: (+1)
   \   00000038   0x2100             MOVS     R1,#+0
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_3: (+1)
   \   0000003A   0x2900             CMP      R1,#+0
   \   0000003C   0xD12A             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_5
   5278            {
   5279              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \   0000003E   0x6941             LDR      R1,[R0, #+20]
   \   00000040   0x0549             LSLS     R1,R1,#+21
   \   00000042   0xD513             BPL.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_6
   5280              {
   5281                /* Generate Stop */
   5282                hi2c->Instance->CR1 |= I2C_CR1_STOP;
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000004A   0x6001             STR      R1,[R0, #+0]
   5283          
   5284                /* Clear AF Flag */
   5285                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   0000004C   0xF46F 0x6080      MVN      R0,#+1024
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6148             STR      R0,[R1, #+20]
   5286          
   5287                hi2c->ErrorCode = HAL_I2C_ERROR_AF;
   \   00000054   0x2004             MOVS     R0,#+4
   \   00000056   0x6420             STR      R0,[R4, #+64]
   5288                hi2c->PreviousState = I2C_STATE_NONE;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x6320             STR      R0,[R4, #+48]
   5289                hi2c->State= HAL_I2C_STATE_READY;
   \   0000005C   0x2020             MOVS     R0,#+32
   \   0000005E   0xF884 0x003D      STRB     R0,[R4, #+61]
   5290          
   5291                /* Process Unlocked */
   5292                __HAL_UNLOCK(hi2c);
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xF884 0x003C      STRB     R0,[R4, #+60]
   5293          
   5294                return HAL_ERROR;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xBDF2             POP      {R1,R4-R7,PC}
   5295              }
   5296          
   5297              /* Check for the Timeout */
   5298              if(Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_6: (+1)
   \   0000006C   0xF116 0x0F01      CMN      R6,#+1
   \   00000070   0xD0CB             BEQ.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_0
   5299              {
   5300                if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
   \   00000072   0x2E00             CMP      R6,#+0
   \   00000074   0xD004             BEQ.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_7
   \   00000076   0x.... 0x....      BL       HAL_GetTick
   \   0000007A   0x1BC0             SUBS     R0,R0,R7
   \   0000007C   0x4286             CMP      R6,R0
   \   0000007E   0xD2C4             BCS.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_0
   5301                {
   5302                  hi2c->PreviousState = I2C_STATE_NONE;
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_7: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x6320             STR      R0,[R4, #+48]
   5303                  hi2c->State= HAL_I2C_STATE_READY;
   \   00000084   0x2020             MOVS     R0,#+32
   \   00000086   0xF884 0x003D      STRB     R0,[R4, #+61]
   5304          
   5305                  /* Process Unlocked */
   5306                  __HAL_UNLOCK(hi2c);
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xF884 0x003C      STRB     R0,[R4, #+60]
   5307          
   5308                  return HAL_TIMEOUT;
   \   00000090   0x2003             MOVS     R0,#+3
   \   00000092   0xBDF2             POP      {R1,R4-R7,PC}
   5309                }
   5310              }
   5311            }
   5312            return HAL_OK;
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_5: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   5313          }
   5314          
   5315          /**
   5316            * @brief  This function handles I2C Communication Timeout for specific usage of TXE flag.
   5317            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5318            *                the configuration information for the specified I2C.
   5319            * @param  Timeout Timeout duration
   5320            * @param  Tickstart Tick start value
   5321            * @retval HAL status
   5322            */

   \                                 In section .text, align 2, keep-with-next
   5323          static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   5324          {    
   \                     I2C_WaitOnTXEFlagUntilTimeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   5325            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_0: (+1)
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6940             LDR      R0,[R0, #+20]
   \   0000000C   0x0600             LSLS     R0,R0,#+24
   \   0000000E   0xD41E             BMI.N    ??I2C_WaitOnTXEFlagUntilTimeout_1
   5326            {
   5327              /* Check if a NACK is detected */
   5328              if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??I2C_WaitOnTXEFlagUntilTimeout_2
   5329              {
   5330                return HAL_ERROR;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBD70             POP      {R4-R6,PC}
   5331              }
   5332          		
   5333              /* Check for the Timeout */
   5334              if(Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_2: (+1)
   \   0000001E   0xF115 0x0F01      CMN      R5,#+1
   \   00000022   0xD0F1             BEQ.N    ??I2C_WaitOnTXEFlagUntilTimeout_0
   5335              {
   5336                if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD004             BEQ.N    ??I2C_WaitOnTXEFlagUntilTimeout_3
   \   00000028   0x.... 0x....      BL       HAL_GetTick
   \   0000002C   0x1B80             SUBS     R0,R0,R6
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xD2EA             BCS.N    ??I2C_WaitOnTXEFlagUntilTimeout_0
   5337                {
   5338                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_3: (+1)
   \   00000032   0x6C20             LDR      R0,[R4, #+64]
   \   00000034   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000038   0x6420             STR      R0,[R4, #+64]
   5339                  hi2c->PreviousState = I2C_STATE_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6320             STR      R0,[R4, #+48]
   5340                  hi2c->State= HAL_I2C_STATE_READY;
   \   0000003E   0x2020             MOVS     R0,#+32
   \   00000040   0xF884 0x003D      STRB     R0,[R4, #+61]
   5341          
   5342                  /* Process Unlocked */
   5343                  __HAL_UNLOCK(hi2c);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF884 0x003C      STRB     R0,[R4, #+60]
   5344          
   5345                  return HAL_TIMEOUT;
   \   0000004A   0x2003             MOVS     R0,#+3
   \   0000004C   0xBD70             POP      {R4-R6,PC}
   5346                }
   5347              }
   5348            }
   5349            return HAL_OK;      
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_1: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
   5350          }
   5351          
   5352          /**
   5353            * @brief  This function handles I2C Communication Timeout for specific usage of BTF flag.
   5354            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5355            *                the configuration information for the specified I2C.
   5356            * @param  Timeout Timeout duration
   5357            * @param  Tickstart Tick start value
   5358            * @retval HAL status
   5359            */

   \                                 In section .text, align 2, keep-with-next
   5360          static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   5361          {  
   \                     I2C_WaitOnBTFFlagUntilTimeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   5362            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_0: (+1)
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6940             LDR      R0,[R0, #+20]
   \   0000000C   0x0740             LSLS     R0,R0,#+29
   \   0000000E   0xD41E             BMI.N    ??I2C_WaitOnBTFFlagUntilTimeout_1
   5363            {
   5364              /* Check if a NACK is detected */
   5365              if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??I2C_WaitOnBTFFlagUntilTimeout_2
   5366              {
   5367                return HAL_ERROR;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBD70             POP      {R4-R6,PC}
   5368              }
   5369          
   5370              /* Check for the Timeout */
   5371              if(Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_2: (+1)
   \   0000001E   0xF115 0x0F01      CMN      R5,#+1
   \   00000022   0xD0F1             BEQ.N    ??I2C_WaitOnBTFFlagUntilTimeout_0
   5372              {
   5373                if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD004             BEQ.N    ??I2C_WaitOnBTFFlagUntilTimeout_3
   \   00000028   0x.... 0x....      BL       HAL_GetTick
   \   0000002C   0x1B80             SUBS     R0,R0,R6
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xD2EA             BCS.N    ??I2C_WaitOnBTFFlagUntilTimeout_0
   5374                {
   5375                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_3: (+1)
   \   00000032   0x6C20             LDR      R0,[R4, #+64]
   \   00000034   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000038   0x6420             STR      R0,[R4, #+64]
   5376                  hi2c->PreviousState = I2C_STATE_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6320             STR      R0,[R4, #+48]
   5377                  hi2c->State= HAL_I2C_STATE_READY;
   \   0000003E   0x2020             MOVS     R0,#+32
   \   00000040   0xF884 0x003D      STRB     R0,[R4, #+61]
   5378          
   5379                  /* Process Unlocked */
   5380                  __HAL_UNLOCK(hi2c);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF884 0x003C      STRB     R0,[R4, #+60]
   5381          
   5382                  return HAL_TIMEOUT;
   \   0000004A   0x2003             MOVS     R0,#+3
   \   0000004C   0xBD70             POP      {R4-R6,PC}
   5383                }
   5384              }
   5385            }
   5386            return HAL_OK;
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_1: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
   5387          }
   5388          
   5389          /**
   5390            * @brief  This function handles I2C Communication Timeout for specific usage of STOP flag.
   5391            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5392            *                the configuration information for the specified I2C.
   5393            * @param  Timeout Timeout duration
   5394            * @param  Tickstart Tick start value
   5395            * @retval HAL status
   5396            */

   \                                 In section .text, align 2, keep-with-next
   5397          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   5398          {  
   \                     I2C_WaitOnSTOPFlagUntilTimeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   5399            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_0: (+1)
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6940             LDR      R0,[R0, #+20]
   \   0000000C   0x06C0             LSLS     R0,R0,#+27
   \   0000000E   0xD41B             BMI.N    ??I2C_WaitOnSTOPFlagUntilTimeout_1
   5400            {
   5401              /* Check if a NACK is detected */
   5402              if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??I2C_WaitOnSTOPFlagUntilTimeout_2
   5403              {
   5404                return HAL_ERROR;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBD70             POP      {R4-R6,PC}
   5405              }
   5406          
   5407              /* Check for the Timeout */
   5408              if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_2: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD004             BEQ.N    ??I2C_WaitOnSTOPFlagUntilTimeout_3
   \   00000022   0x.... 0x....      BL       HAL_GetTick
   \   00000026   0x1B80             SUBS     R0,R0,R6
   \   00000028   0x4285             CMP      R5,R0
   \   0000002A   0xD2ED             BCS.N    ??I2C_WaitOnSTOPFlagUntilTimeout_0
   5409              {
   5410                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_3: (+1)
   \   0000002C   0x6C20             LDR      R0,[R4, #+64]
   \   0000002E   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000032   0x6420             STR      R0,[R4, #+64]
   5411                hi2c->PreviousState = I2C_STATE_NONE;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x6320             STR      R0,[R4, #+48]
   5412                hi2c->State= HAL_I2C_STATE_READY;
   \   00000038   0x2020             MOVS     R0,#+32
   \   0000003A   0xF884 0x003D      STRB     R0,[R4, #+61]
   5413          
   5414                /* Process Unlocked */
   5415                __HAL_UNLOCK(hi2c);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xF884 0x003C      STRB     R0,[R4, #+60]
   5416          
   5417                return HAL_TIMEOUT;
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0xBD70             POP      {R4-R6,PC}
   5418              }
   5419            }
   5420            return HAL_OK;
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_1: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
   5421          }
   5422          
   5423          /**
   5424            * @brief  This function handles I2C Communication Timeout for specific usage of RXNE flag.
   5425            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5426            *                the configuration information for the specified I2C.
   5427            * @param  Timeout Timeout duration
   5428            * @param  Tickstart Tick start value
   5429            * @retval HAL status
   5430            */

   \                                 In section .text, align 2, keep-with-next
   5431          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   5432          {  
   \                     I2C_WaitOnRXNEFlagUntilTimeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   5433          
   5434            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_0: (+1)
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6941             LDR      R1,[R0, #+20]
   \   0000000C   0x0649             LSLS     R1,R1,#+25
   \   0000000E   0xD423             BMI.N    ??I2C_WaitOnRXNEFlagUntilTimeout_1
   5435            {
   5436              /* Check if a STOPF is detected */
   5437              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \   00000010   0x6941             LDR      R1,[R0, #+20]
   \   00000012   0x06C9             LSLS     R1,R1,#+27
   \   00000014   0xD50D             BPL.N    ??I2C_WaitOnRXNEFlagUntilTimeout_2
   5438              {
   5439                /* Clear STOP Flag */
   5440                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \   00000016   0xF06F 0x0110      MVN      R1,#+16
   \   0000001A   0x6141             STR      R1,[R0, #+20]
   5441          
   5442                hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x6420             STR      R0,[R4, #+64]
   5443                hi2c->PreviousState = I2C_STATE_NONE;
   \   00000020   0x6320             STR      R0,[R4, #+48]
   5444                hi2c->State= HAL_I2C_STATE_READY;
   \   00000022   0x2020             MOVS     R0,#+32
   \   00000024   0xF884 0x003D      STRB     R0,[R4, #+61]
   5445          
   5446                /* Process Unlocked */
   5447                __HAL_UNLOCK(hi2c);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF884 0x003C      STRB     R0,[R4, #+60]
   5448          
   5449                return HAL_ERROR;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xBD70             POP      {R4-R6,PC}
   5450              }
   5451          
   5452              /* Check for the Timeout */
   5453              if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_2: (+1)
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD004             BEQ.N    ??I2C_WaitOnRXNEFlagUntilTimeout_3
   \   00000036   0x.... 0x....      BL       HAL_GetTick
   \   0000003A   0x1B80             SUBS     R0,R0,R6
   \   0000003C   0x4285             CMP      R5,R0
   \   0000003E   0xD2E3             BCS.N    ??I2C_WaitOnRXNEFlagUntilTimeout_0
   5454              {
   5455                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_3: (+1)
   \   00000040   0x6C20             LDR      R0,[R4, #+64]
   \   00000042   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000046   0x6420             STR      R0,[R4, #+64]
   5456                hi2c->State= HAL_I2C_STATE_READY;
   \   00000048   0x2020             MOVS     R0,#+32
   \   0000004A   0xF884 0x003D      STRB     R0,[R4, #+61]
   5457          
   5458                /* Process Unlocked */
   5459                __HAL_UNLOCK(hi2c);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF884 0x003C      STRB     R0,[R4, #+60]
   5460          
   5461                return HAL_TIMEOUT;
   \   00000054   0x2003             MOVS     R0,#+3
   \   00000056   0xBD70             POP      {R4-R6,PC}
   5462              }
   5463            }
   5464            return HAL_OK;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_1: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD70             POP      {R4-R6,PC}       ;; return
   5465          }
   5466          
   5467          /**
   5468            * @brief  This function handles Acknowledge failed detection during an I2C Communication.
   5469            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5470            *                the configuration information for the specified I2C.
   5471            * @retval HAL status
   5472            */

   \                                 In section .text, align 2, keep-with-next
   5473          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
   5474          {
   5475            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \                     I2C_IsAcknowledgeFailed: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x694A             LDR      R2,[R1, #+20]
   \   00000004   0x0552             LSLS     R2,R2,#+21
   \   00000006   0xD50E             BPL.N    ??I2C_IsAcknowledgeFailed_0
   5476            {
   5477              /* Clear NACKF Flag */
   5478              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000008   0xF46F 0x6280      MVN      R2,#+1024
   \   0000000C   0x614A             STR      R2,[R1, #+20]
   5479          
   5480              hi2c->ErrorCode = HAL_I2C_ERROR_AF;
   \   0000000E   0x2104             MOVS     R1,#+4
   \   00000010   0x6401             STR      R1,[R0, #+64]
   5481              hi2c->PreviousState = I2C_STATE_NONE;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x6301             STR      R1,[R0, #+48]
   5482              hi2c->State= HAL_I2C_STATE_READY;
   \   00000016   0x2120             MOVS     R1,#+32
   \   00000018   0xF880 0x103D      STRB     R1,[R0, #+61]
   5483          
   5484              /* Process Unlocked */
   5485              __HAL_UNLOCK(hi2c);
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xF880 0x103C      STRB     R1,[R0, #+60]
   5486          
   5487              return HAL_ERROR;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x4770             BX       LR
   5488            }
   5489            return HAL_OK;
   \                     ??I2C_IsAcknowledgeFailed_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x4770             BX       LR               ;; return
   5490          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x000186A1         DC32     0x186a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x00100002         DC32     0x100002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0xFFFF0000         DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0xFFFF0000         DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x00010004         DC32     0x10004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x00010002         DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     I2C_DMAXferCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0xFFFF0000         DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x00100002         DC32     0x100002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x00010004         DC32     0x10004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0x00010008         DC32     0x10008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x00010002         DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \   00000000   0x00100004         DC32     0x100004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \   00000000   0x00010080         DC32     0x10080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \   00000000   0x00010040         DC32     0x10040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_4:
   \   00000000   0x00010010         DC32     0x10010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   0x00010100         DC32     0x10100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0xFFFF0000         DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   0x00010008         DC32     0x10008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_2:
   \   00000000   0x00010002         DC32     0x10002
   5491          /**
   5492            * @}
   5493            */
   5494          
   5495          #endif /* HAL_I2C_MODULE_ENABLED */
   5496          
   5497          /**
   5498            * @}
   5499            */
   5500          
   5501          /**
   5502            * @}
   5503            */
   5504          
   5505          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_I2C_AbortCpltCallback
       0   HAL_I2C_AddrCallback
       8   HAL_I2C_DeInit
         8   -> HAL_I2C_MspDeInit
       0   HAL_I2C_DisableListen_IT
      16   HAL_I2C_ER_IRQHandler
         0   -> I2C_ITError
        16   -> I2C_Slave_AF
      24   HAL_I2C_EV_IRQHandler
         0   -> I2C_MasterReceive_BTF
         0   -> I2C_MasterReceive_RXNE
         0   -> I2C_MasterTransmit_BTF
         0   -> I2C_MasterTransmit_TXE
        24   -> I2C_Master_ADD10
        24   -> I2C_Master_ADDR
        24   -> I2C_Master_SB
         0   -> I2C_SlaveReceive_BTF
         0   -> I2C_SlaveReceive_RXNE
         0   -> I2C_SlaveTransmit_BTF
         0   -> I2C_SlaveTransmit_TXE
         0   -> I2C_Slave_ADDR
         0   -> I2C_Slave_STOPF
       0   HAL_I2C_EnableListen_IT
       0   HAL_I2C_ErrorCallback
       0   HAL_I2C_GetError
       0   HAL_I2C_GetMode
       0   HAL_I2C_GetState
       8   HAL_I2C_Init
         8   -> HAL_I2C_MspInit
         8   -> HAL_RCC_GetPCLK1Freq
      40   HAL_I2C_IsDeviceReady
        40   -> HAL_GetTick
        40   -> I2C_WaitOnFlagUntilTimeout
       0   HAL_I2C_ListenCpltCallback
       0   HAL_I2C_MasterRxCpltCallback
       0   HAL_I2C_MasterTxCpltCallback
       8   HAL_I2C_Master_Abort_IT
         8   -> I2C_ITError
      32   HAL_I2C_Master_Receive
        32   -> HAL_GetTick
        32   -> I2C_MasterRequestRead
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnRXNEFlagUntilTimeout
      16   HAL_I2C_Master_Receive_DMA
        16   -> HAL_DMA_Start_IT
      12   HAL_I2C_Master_Receive_IT
      16   HAL_I2C_Master_Sequential_Receive_IT
      20   HAL_I2C_Master_Sequential_Transmit_IT
      32   HAL_I2C_Master_Transmit
        32   -> HAL_GetTick
        32   -> I2C_MasterRequestWrite
        32   -> I2C_WaitOnBTFFlagUntilTimeout
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
      16   HAL_I2C_Master_Transmit_DMA
        16   -> HAL_DMA_Start_IT
      12   HAL_I2C_Master_Transmit_IT
       0   HAL_I2C_MemRxCpltCallback
       0   HAL_I2C_MemTxCpltCallback
      40   HAL_I2C_Mem_Read
        40   -> HAL_GetTick
        40   -> I2C_RequestMemoryRead
        40   -> I2C_WaitOnFlagUntilTimeout
        40   -> I2C_WaitOnRXNEFlagUntilTimeout
      40   HAL_I2C_Mem_Read_DMA
        40   -> HAL_DMA_Start_IT
        40   -> HAL_GetTick
        40   -> I2C_RequestMemoryRead
      12   HAL_I2C_Mem_Read_IT
      40   HAL_I2C_Mem_Write
        40   -> HAL_GetTick
        40   -> I2C_RequestMemoryWrite
        40   -> I2C_WaitOnBTFFlagUntilTimeout
        40   -> I2C_WaitOnFlagUntilTimeout
        40   -> I2C_WaitOnTXEFlagUntilTimeout
      32   HAL_I2C_Mem_Write_DMA
        32   -> HAL_DMA_Start_IT
        32   -> HAL_GetTick
        32   -> I2C_RequestMemoryWrite
      12   HAL_I2C_Mem_Write_IT
       0   HAL_I2C_MspDeInit
       0   HAL_I2C_MspInit
       0   HAL_I2C_SlaveRxCpltCallback
       0   HAL_I2C_SlaveTxCpltCallback
      32   HAL_I2C_Slave_Receive
        32   -> HAL_GetTick
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnRXNEFlagUntilTimeout
        32   -> I2C_WaitOnSTOPFlagUntilTimeout
      16   HAL_I2C_Slave_Receive_DMA
        16   -> HAL_DMA_Start_IT
       8   HAL_I2C_Slave_Receive_IT
      12   HAL_I2C_Slave_Sequential_Receive_IT
      12   HAL_I2C_Slave_Sequential_Transmit_IT
      32   HAL_I2C_Slave_Transmit
        32   -> HAL_GetTick
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
      16   HAL_I2C_Slave_Transmit_DMA
        16   -> HAL_DMA_Start_IT
       8   HAL_I2C_Slave_Transmit_IT
       8   I2C_DMAAbort
         8   -> HAL_I2C_AbortCpltCallback
         8   -> HAL_I2C_ErrorCallback
       8   I2C_DMAError
         8   -> HAL_I2C_ErrorCallback
       8   I2C_DMAXferCplt
         8   -> HAL_I2C_ErrorCallback
         8   -> HAL_I2C_MasterRxCpltCallback
         8   -> HAL_I2C_MemRxCpltCallback
       8   I2C_ITError
         8   -- Indirect call
         8   -> HAL_DMA_Abort_IT
         8   -> HAL_I2C_AbortCpltCallback
         8   -> HAL_I2C_ErrorCallback
         8   -> HAL_I2C_ListenCpltCallback
       0   I2C_IsAcknowledgeFailed
       8   I2C_MasterReceive_BTF
         8   -> HAL_I2C_MasterRxCpltCallback
         8   -> HAL_I2C_MemRxCpltCallback
       8   I2C_MasterReceive_RXNE
         8   -> HAL_I2C_MasterRxCpltCallback
         8   -> HAL_I2C_MemRxCpltCallback
      32   I2C_MasterRequestRead
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnMasterAddressFlagUntilTimeout
      24   I2C_MasterRequestWrite
        24   -> I2C_WaitOnFlagUntilTimeout
        24   -> I2C_WaitOnMasterAddressFlagUntilTimeout
       8   I2C_MasterTransmit_BTF
         8   -> HAL_I2C_MasterTxCpltCallback
         8   -> HAL_I2C_MemTxCpltCallback
       8   I2C_MasterTransmit_TXE
         8   -> HAL_I2C_MasterTxCpltCallback
         8   -> HAL_I2C_MemTxCpltCallback
       0   I2C_Master_ADD10
       8   I2C_Master_ADDR
       0   I2C_Master_SB
      40   I2C_RequestMemoryRead
        40   -> I2C_WaitOnFlagUntilTimeout
        40   -> I2C_WaitOnMasterAddressFlagUntilTimeout
        40   -> I2C_WaitOnTXEFlagUntilTimeout
      32   I2C_RequestMemoryWrite
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnMasterAddressFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
       0   I2C_SlaveReceive_BTF
       8   I2C_SlaveReceive_RXNE
         8   -> HAL_I2C_SlaveRxCpltCallback
       0   I2C_SlaveTransmit_BTF
       8   I2C_SlaveTransmit_TXE
         8   -> HAL_I2C_SlaveTxCpltCallback
       8   I2C_Slave_ADDR
         8   -> HAL_I2C_AddrCallback
       8   I2C_Slave_AF
         8   -> HAL_I2C_ListenCpltCallback
         8   -> HAL_I2C_SlaveTxCpltCallback
       8   I2C_Slave_STOPF
         8   -> HAL_I2C_ListenCpltCallback
         8   -> HAL_I2C_SlaveRxCpltCallback
         8   -> I2C_ITError
      16   I2C_WaitOnBTFFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
      24   I2C_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick
      24   I2C_WaitOnMasterAddressFlagUntilTimeout
        24   -> HAL_GetTick
      16   I2C_WaitOnRXNEFlagUntilTimeout
        16   -> HAL_GetTick
      16   I2C_WaitOnSTOPFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_WaitOnTXEFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable21
       4  ??DataTable23
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable31
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable32_4
       4  ??DataTable33
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       2  HAL_I2C_AbortCpltCallback
       2  HAL_I2C_AddrCallback
      52  HAL_I2C_DeInit
      64  HAL_I2C_DisableListen_IT
     196  HAL_I2C_ER_IRQHandler
     332  HAL_I2C_EV_IRQHandler
      58  HAL_I2C_EnableListen_IT
       2  HAL_I2C_ErrorCallback
       4  HAL_I2C_GetError
       6  HAL_I2C_GetMode
       6  HAL_I2C_GetState
     250  HAL_I2C_Init
     374  HAL_I2C_IsDeviceReady
       2  HAL_I2C_ListenCpltCallback
       2  HAL_I2C_MasterRxCpltCallback
       2  HAL_I2C_MasterTxCpltCallback
      90  HAL_I2C_Master_Abort_IT
     710  HAL_I2C_Master_Receive
     302  HAL_I2C_Master_Receive_DMA
     196  HAL_I2C_Master_Receive_IT
     258  HAL_I2C_Master_Sequential_Receive_IT
     236  HAL_I2C_Master_Sequential_Transmit_IT
     360  HAL_I2C_Master_Transmit
     300  HAL_I2C_Master_Transmit_DMA
     186  HAL_I2C_Master_Transmit_IT
       2  HAL_I2C_MemRxCpltCallback
       2  HAL_I2C_MemTxCpltCallback
     706  HAL_I2C_Mem_Read
     416  HAL_I2C_Mem_Read_DMA
     212  HAL_I2C_Mem_Read_IT
     356  HAL_I2C_Mem_Write
     322  HAL_I2C_Mem_Write_DMA
     196  HAL_I2C_Mem_Write_IT
       2  HAL_I2C_MspDeInit
       2  HAL_I2C_MspInit
       2  HAL_I2C_SlaveRxCpltCallback
       2  HAL_I2C_SlaveTxCpltCallback
     364  HAL_I2C_Slave_Receive
     256  HAL_I2C_Slave_Receive_DMA
     192  HAL_I2C_Slave_Receive_IT
     130  HAL_I2C_Slave_Sequential_Receive_IT
     130  HAL_I2C_Slave_Sequential_Transmit_IT
     388  HAL_I2C_Slave_Transmit
     256  HAL_I2C_Slave_Transmit_DMA
     196  HAL_I2C_Slave_Transmit_IT
      92  I2C_DMAAbort
      44  I2C_DMAError
     144  I2C_DMAXferCplt
     316  I2C_ITError
      42  I2C_IsAcknowledgeFailed
     224  I2C_MasterReceive_BTF
     188  I2C_MasterReceive_RXNE
     282  I2C_MasterRequestRead
     180  I2C_MasterRequestWrite
     150  I2C_MasterTransmit_BTF
     310  I2C_MasterTransmit_TXE
      12  I2C_Master_ADD10
     440  I2C_Master_ADDR
     128  I2C_Master_SB
     338  I2C_RequestMemoryRead
     206  I2C_RequestMemoryWrite
      28  I2C_SlaveReceive_BTF
      68  I2C_SlaveReceive_RXNE
      28  I2C_SlaveTransmit_BTF
      68  I2C_SlaveTransmit_TXE
      36  I2C_Slave_ADDR
     144  I2C_Slave_AF
     240  I2C_Slave_STOPF
      82  I2C_WaitOnBTFFlagUntilTimeout
     128  I2C_WaitOnFlagUntilTimeout
     152  I2C_WaitOnMasterAddressFlagUntilTimeout
      92  I2C_WaitOnRXNEFlagUntilTimeout
      76  I2C_WaitOnSTOPFlagUntilTimeout
      82  I2C_WaitOnTXEFlagUntilTimeout

 
 12 540 bytes in section .text
 
 12 540 bytes of CODE memory

Errors: none
Warnings: none
