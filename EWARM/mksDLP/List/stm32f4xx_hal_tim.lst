###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:21
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\stm32f4xx_hal_tim.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\stm32f4xx_hal_tim.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.5.2
      6            * @date    22-September-2016
      7            * @brief   TIM HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Timer (TIM) peripheral:
     10            *           + Time Base Initialization
     11            *           + Time Base Start
     12            *           + Time Base Start Interruption
     13            *           + Time Base Start DMA
     14            *           + Time Output Compare/PWM Initialization
     15            *           + Time Output Compare/PWM Channel Configuration
     16            *           + Time Output Compare/PWM  Start
     17            *           + Time Output Compare/PWM  Start Interruption
     18            *           + Time Output Compare/PWM Start DMA
     19            *           + Time Input Capture Initialization
     20            *           + Time Input Capture Channel Configuration
     21            *           + Time Input Capture Start
     22            *           + Time Input Capture Start Interruption 
     23            *           + Time Input Capture Start DMA
     24            *           + Time One Pulse Initialization
     25            *           + Time One Pulse Channel Configuration
     26            *           + Time One Pulse Start 
     27            *           + Time Encoder Interface Initialization
     28            *           + Time Encoder Interface Start
     29            *           + Time Encoder Interface Start Interruption
     30            *           + Time Encoder Interface Start DMA
     31            *           + Commutation Event configuration with Interruption and DMA
     32            *           + Time OCRef clear configuration
     33            *           + Time External Clock configuration
     34            @verbatim 
     35            ==============================================================================
     36                                ##### TIMER Generic features #####
     37            ==============================================================================
     38            [..] The Timer features include: 
     39                 (#) 16-bit up, down, up/down auto-reload counter.
     40                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the 
     41                     counter clock frequency either by any factor between 1 and 65536.
     42                 (#) Up to 4 independent channels for:
     43                     (++) Input Capture
     44                     (++) Output Compare
     45                     (++) PWM generation (Edge and Center-aligned Mode)
     46                     (++) One-pulse mode output               
     47             
     48                                  ##### How to use this driver #####
     49            ==============================================================================
     50              [..]
     51               (#) Initialize the TIM low level resources by implementing the following functions 
     52                   depending from feature used :
     53                     (++) Time Base : HAL_TIM_Base_MspInit() 
     54                     (++) Input Capture : HAL_TIM_IC_MspInit()
     55                     (++) Output Compare : HAL_TIM_OC_MspInit()
     56                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     57                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     58                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     59                     
     60               (#) Initialize the TIM low level resources :
     61                  (##) Enable the TIM interface clock using __TIMx_CLK_ENABLE(); 
     62                  (##) TIM pins configuration
     63                      (+++) Enable the clock for the TIM GPIOs using the following function:
     64                           __GPIOx_CLK_ENABLE();   
     65                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();  
     66          
     67               (#) The external Clock can be configured, if needed (the default clock is the 
     68                   internal clock from the APBx), using the following function:
     69                   HAL_TIM_ConfigClockSource, the clock configuration should be done before 
     70                   any start function.
     71            
     72               (#) Configure the TIM in the desired functioning mode using one of the 
     73                   initialization function of this driver:
     74                   (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     75                   (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an 
     76                        Output Compare signal.
     77                   (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a 
     78                        PWM signal.
     79                   (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an 
     80                        external signal.
     81                   (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer 
     82                        in One Pulse Mode.
     83                   (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     84                   
     85               (#) Activate the TIM peripheral using one of the start functions depending from the feature used: 
     86                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     87                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     88                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     89                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     90                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     91                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     92          
     93               (#) The DMA Burst is managed with the two following functions:
     94                   HAL_TIM_DMABurst_WriteStart()
     95                   HAL_TIM_DMABurst_ReadStart()
     96            
     97            @endverbatim
     98            ******************************************************************************
     99            * @attention
    100            *
    101            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    102            *
    103            * Redistribution and use in source and binary forms, with or without modification,
    104            * are permitted provided that the following conditions are met:
    105            *   1. Redistributions of source code must retain the above copyright notice,
    106            *      this list of conditions and the following disclaimer.
    107            *   2. Redistributions in binary form must reproduce the above copyright notice,
    108            *      this list of conditions and the following disclaimer in the documentation
    109            *      and/or other materials provided with the distribution.
    110            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    111            *      may be used to endorse or promote products derived from this software
    112            *      without specific prior written permission.
    113            *
    114            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    115            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    116            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    117            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    118            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    119            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    120            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    121            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    122            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    123            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    124            *
    125            ******************************************************************************
    126            */ 
    127          
    128          /* Includes ------------------------------------------------------------------*/
    129          #include "stm32f4xx_hal.h"
    130          
    131          /** @addtogroup STM32F4xx_HAL_Driver
    132            * @{
    133            */
    134          
    135          /** @defgroup TIM TIM
    136            * @brief TIM HAL module driver
    137            * @{
    138            */
    139          
    140          #ifdef HAL_TIM_MODULE_ENABLED
    141          
    142          /* Private typedef -----------------------------------------------------------*/
    143          /* Private define ------------------------------------------------------------*/
    144          /* Private macro -------------------------------------------------------------*/
    145          /* Private variables ---------------------------------------------------------*/
    146          /** @addtogroup TIM_Private_Functions
    147            * @{
    148            */
    149          /* Private function prototypes -----------------------------------------------*/
    150          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    151          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    152          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    153          
    154          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    155          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    156                                 uint32_t TIM_ICFilter);
    157          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    158          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    159                                 uint32_t TIM_ICFilter);
    160          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    161                                 uint32_t TIM_ICFilter);
    162          
    163          static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
    164                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter);
    165          
    166          static void TIM_ITRx_SetConfig(TIM_TypeDef* TIMx, uint16_t TIM_ITRx);
    167          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    168          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    169          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    170                                               TIM_SlaveConfigTypeDef * sSlaveConfig);
    171          /**
    172            * @}
    173            */
    174            
    175          /* Exported functions --------------------------------------------------------*/
    176          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    177            * @{
    178            */
    179          
    180          /** @defgroup TIM_Exported_Functions_Group1 Time Base functions 
    181           *  @brief    Time Base functions 
    182           *
    183          @verbatim    
    184            ==============================================================================
    185                        ##### Time Base functions #####
    186            ==============================================================================
    187            [..]  
    188              This section provides functions allowing to:
    189              (+) Initialize and configure the TIM base. 
    190              (+) De-initialize the TIM base.
    191              (+) Start the Time Base.
    192              (+) Stop the Time Base.
    193              (+) Start the Time Base and enable interrupt.
    194              (+) Stop the Time Base and disable interrupt.
    195              (+) Start the Time Base and enable DMA transfer.
    196              (+) Stop the Time Base and disable DMA transfer.
    197           
    198          @endverbatim
    199            * @{
    200            */
    201          /**
    202            * @brief  Initializes the TIM Time base Unit according to the specified
    203            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    204            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    205            *                the configuration information for TIM module.
    206            * @retval HAL status
    207            */

   \                                 In section .text, align 2, keep-with-next
    208          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    209          { 
   \                     HAL_TIM_Base_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    210            /* Check the TIM handle allocation */
    211            if(htim == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_TIM_Base_Init_0
    212            {
    213              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    214            }
    215            
    216            /* Check the parameters */
    217            assert_param(IS_TIM_INSTANCE(htim->Instance)); 
    218            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    219            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    220            
    221            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Base_Init_0: (+1)
   \   0000000A   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE.N    ??HAL_TIM_Base_Init_1
    222            {  
    223              /* Allocate lock resource and initialize it */
    224              htim->Lock = HAL_UNLOCKED;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF884 0x0038      STRB     R0,[R4, #+56]
    225              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    226              HAL_TIM_Base_MspInit(htim);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_TIM_Base_MspInit
    227            }
    228            
    229            /* Set the TIM state */
    230            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Init_1: (+1)
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xF884 0x0039      STRB     R0,[R4, #+57]
    231            
    232            /* Set the Time Base configuration */
    233            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   \   00000024   0x1D21             ADDS     R1,R4,#+4
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       TIM_Base_SetConfig
    234            
    235            /* Initialize the TIM state*/
    236            htim->State= HAL_TIM_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0039      STRB     R0,[R4, #+57]
    237            
    238            return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    239          }
    240          
    241          /**
    242            * @brief  DeInitializes the TIM Base peripheral 
    243            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    244            *                the configuration information for TIM module.
    245            * @retval HAL status
    246            */

   \                                 In section .text, align 2, keep-with-next
    247          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    248          {  
   \                     HAL_TIM_Base_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    249            /* Check the parameters */
    250            assert_param(IS_TIM_INSTANCE(htim->Instance));
    251          
    252            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
    253             
    254            /* Disable the TIM Peripheral Clock */
    255            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIM_Base_DeInit_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_Base_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
    256              
    257            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    258            HAL_TIM_Base_MspDeInit(htim);
   \                     ??HAL_TIM_Base_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_Base_MspDeInit
    259            
    260            /* Change TIM state */  
    261            htim->State = HAL_TIM_STATE_RESET; 
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
    262            
    263            /* Release Lock */
    264            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
    265          
    266            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    267          }
    268          
    269          /**
    270            * @brief  Initializes the TIM Base MSP.
    271            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    272            *                the configuration information for TIM module.
    273            * @retval None
    274            */

   \                                 In section .text, align 2, keep-with-next
    275          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    276          {
    277            /* Prevent unused argument(s) compilation warning */
    278            UNUSED(htim);
    279            /* NOTE : This function Should not be modified, when the callback is needed,
    280                      the HAL_TIM_Base_MspInit could be implemented in the user file
    281             */
    282          }
   \                     HAL_TIM_Base_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    283          
    284          /**
    285            * @brief  DeInitializes TIM Base MSP.
    286            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    287            *                the configuration information for TIM module.
    288            * @retval None
    289            */

   \                                 In section .text, align 2, keep-with-next
    290          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    291          {
    292            /* Prevent unused argument(s) compilation warning */
    293            UNUSED(htim);
    294            /* NOTE : This function Should not be modified, when the callback is needed,
    295                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    296             */
    297          }
   \                     HAL_TIM_Base_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    298          
    299          /**
    300            * @brief  Starts the TIM Base generation.
    301            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    302            *                the configuration information for TIM module.
    303            * @retval HAL status
    304            */

   \                                 In section .text, align 2, keep-with-next
    305          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    306          {
    307            /* Check the parameters */
    308            assert_param(IS_TIM_INSTANCE(htim->Instance));
    309            
    310            /* Set the TIM state */
    311            htim->State= HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Start: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x1039      STRB     R1,[R0, #+57]
    312            
    313            /* Enable the Peripheral */
    314            __HAL_TIM_ENABLE(htim);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x680A             LDR      R2,[R1, #+0]
   \   0000000A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000000E   0x600A             STR      R2,[R1, #+0]
    315            
    316            /* Change the TIM state*/
    317            htim->State= HAL_TIM_STATE_READY;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0xF880 0x1039      STRB     R1,[R0, #+57]
    318            
    319            /* Return function status */
    320            return HAL_OK;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
    321          }
    322          
    323          /**
    324            * @brief  Stops the TIM Base generation.
    325            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    326            *                the configuration information for TIM module.
    327            * @retval HAL status
    328            */

   \                                 In section .text, align 2, keep-with-next
    329          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    330          {
    331            /* Check the parameters */
    332            assert_param(IS_TIM_INSTANCE(htim->Instance));
    333            
    334            /* Set the TIM state */
    335            htim->State= HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Stop: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x1039      STRB     R1,[R0, #+57]
    336            
    337            /* Disable the Peripheral */
    338            __HAL_TIM_DISABLE(htim);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000A   0xF241 0x1311      MOVW     R3,#+4369
   \   0000000E   0x421A             TST      R2,R3
   \   00000010   0xD108             BNE.N    ??HAL_TIM_Base_Stop_0
   \   00000012   0x6A0A             LDR      R2,[R1, #+32]
   \   00000014   0xF240 0x4344      MOVW     R3,#+1092
   \   00000018   0x421A             TST      R2,R3
   \   0000001A   0xD103             BNE.N    ??HAL_TIM_Base_Stop_0
   \   0000001C   0x680A             LDR      R2,[R1, #+0]
   \   0000001E   0x0852             LSRS     R2,R2,#+1
   \   00000020   0x0052             LSLS     R2,R2,#+1
   \   00000022   0x600A             STR      R2,[R1, #+0]
    339            
    340            /* Change the TIM state*/
    341            htim->State= HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_0: (+1)
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xF880 0x1039      STRB     R1,[R0, #+57]
    342            
    343            /* Return function status */
    344            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4770             BX       LR               ;; return
    345          }
    346          
    347          /**
    348            * @brief  Starts the TIM Base generation in interrupt mode.
    349            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    350            *                the configuration information for TIM module.
    351            * @retval HAL status
    352            */

   \                                 In section .text, align 2, keep-with-next
    353          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    354          {
    355            /* Check the parameters */
    356            assert_param(IS_TIM_INSTANCE(htim->Instance));
    357            
    358            /* Enable the TIM Update interrupt */
    359            __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Start_IT: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68CA             LDR      R2,[R1, #+12]
   \   00000004   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000008   0x60CA             STR      R2,[R1, #+12]
    360                
    361            /* Enable the Peripheral */
    362            __HAL_TIM_ENABLE(htim);
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000012   0x6001             STR      R1,[R0, #+0]
    363                
    364            /* Return function status */
    365            return HAL_OK;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
    366          }
    367          
    368          /**
    369            * @brief  Stops the TIM Base generation in interrupt mode.
    370            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    371            *                the configuration information for TIM module.
    372            * @retval HAL status
    373            */

   \                                 In section .text, align 2, keep-with-next
    374          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    375          {
    376            /* Check the parameters */
    377            assert_param(IS_TIM_INSTANCE(htim->Instance));
    378            /* Disable the TIM Update interrupt */
    379            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Stop_IT: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68CA             LDR      R2,[R1, #+12]
   \   00000004   0x0852             LSRS     R2,R2,#+1
   \   00000006   0x0052             LSLS     R2,R2,#+1
   \   00000008   0x60CA             STR      R2,[R1, #+12]
    380                
    381            /* Disable the Peripheral */
    382            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
    383              
    384            /* Return function status */
    385            return HAL_OK;
   \                     ??HAL_TIM_Base_Stop_IT_0: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x4770             BX       LR               ;; return
    386          }
    387          
    388          /**
    389            * @brief  Starts the TIM Base generation in DMA mode.
    390            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    391            *                the configuration information for TIM module.
    392            * @param  pData: The source Buffer address.
    393            * @param  Length: The length of data to be transferred from memory to peripheral.
    394            * @retval HAL status
    395            */

   \                                 In section .text, align 2, keep-with-next
    396          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    397          {
   \                     HAL_TIM_Base_Start_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    398            /* Check the parameters */
    399            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
    400            
    401            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000004   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_Base_Start_DMA_0
    402            {
    403               return HAL_BUSY;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
    404            }
    405            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_Base_Start_DMA_0: (+1)
   \   00000010   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD108             BNE.N    ??HAL_TIM_Base_Start_DMA_1
    406            {
    407              if((pData == 0U) && (Length > 0U)) 
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD103             BNE.N    ??HAL_TIM_Base_Start_DMA_2
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD001             BEQ.N    ??HAL_TIM_Base_Start_DMA_2
    408              {
    409                return HAL_ERROR;                                    
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xBD10             POP      {R4,PC}
    410              }
    411              else
    412              {
    413                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Start_DMA_2: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF884 0x0039      STRB     R0,[R4, #+57]
    414              }
    415            }  
    416            /* Set the DMA Period elapsed callback */
    417            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_Base_Start_DMA_1: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000002E   0x69E3             LDR      R3,[R4, #+28]
   \   00000030   0x63D8             STR      R0,[R3, #+60]
    418               
    419            /* Set the DMA error callback */
    420            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000036   0x69E3             LDR      R3,[R4, #+28]
   \   00000038   0x64D8             STR      R0,[R3, #+76]
    421            
    422            /* Enable the DMA Stream */
    423            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
   \   0000003A   0x4613             MOV      R3,R2
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0xF100 0x022C      ADD      R2,R0,#+44
   \   00000042   0x69E0             LDR      R0,[R4, #+28]
   \   00000044   0x.... 0x....      BL       HAL_DMA_Start_IT
    424            
    425            /* Enable the TIM Update DMA request */
    426            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x68C1             LDR      R1,[R0, #+12]
   \   0000004C   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000050   0x60C1             STR      R1,[R0, #+12]
    427          
    428            /* Enable the Peripheral */
    429            __HAL_TIM_ENABLE(htim);  
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000005A   0x6001             STR      R1,[R0, #+0]
    430            
    431            /* Return function status */
    432            return HAL_OK;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xBD10             POP      {R4,PC}          ;; return
    433          }
    434          
    435          /**
    436            * @brief  Stops the TIM Base generation in DMA mode.
    437            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    438            *                the configuration information for TIM module.
    439            * @retval HAL status
    440            */

   \                                 In section .text, align 2, keep-with-next
    441          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    442          {
    443            /* Check the parameters */
    444            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    445            
    446            /* Disable the TIM Update DMA request */
    447            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
   \                     HAL_TIM_Base_Stop_DMA: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68CA             LDR      R2,[R1, #+12]
   \   00000004   0xF422 0x7280      BIC      R2,R2,#0x100
   \   00000008   0x60CA             STR      R2,[R1, #+12]
    448                
    449            /* Disable the Peripheral */
    450            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000E   0xF241 0x1311      MOVW     R3,#+4369
   \   00000012   0x421A             TST      R2,R3
   \   00000014   0xD108             BNE.N    ??HAL_TIM_Base_Stop_DMA_0
   \   00000016   0x6A0A             LDR      R2,[R1, #+32]
   \   00000018   0xF240 0x4344      MOVW     R3,#+1092
   \   0000001C   0x421A             TST      R2,R3
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_Base_Stop_DMA_0
   \   00000020   0x680A             LDR      R2,[R1, #+0]
   \   00000022   0x0852             LSRS     R2,R2,#+1
   \   00000024   0x0052             LSLS     R2,R2,#+1
   \   00000026   0x600A             STR      R2,[R1, #+0]
    451              
    452            /* Change the htim state */
    453            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_DMA_0: (+1)
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0xF880 0x1039      STRB     R1,[R0, #+57]
    454                
    455            /* Return function status */
    456            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4770             BX       LR               ;; return
    457          }
    458          /**
    459            * @}
    460            */
    461            
    462          /** @defgroup TIM_Exported_Functions_Group2 Time Output Compare functions 
    463           *  @brief    Time Output Compare functions 
    464           *
    465          @verbatim    
    466            ==============================================================================
    467                            ##### Time Output Compare functions #####
    468            ==============================================================================
    469            [..]
    470              This section provides functions allowing to:
    471              (+) Initialize and configure the TIM Output Compare. 
    472              (+) De-initialize the TIM Output Compare.
    473              (+) Start the Time Output Compare.
    474              (+) Stop the Time Output Compare.
    475              (+) Start the Time Output Compare and enable interrupt.
    476              (+) Stop the Time Output Compare and disable interrupt.
    477              (+) Start the Time Output Compare and enable DMA transfer.
    478              (+) Stop the Time Output Compare and disable DMA transfer.
    479           
    480          @endverbatim
    481            * @{
    482            */
    483          /**
    484            * @brief  Initializes the TIM Output Compare according to the specified
    485            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    486            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    487            *                the configuration information for TIM module.
    488            * @retval HAL status
    489            */

   \                                 In section .text, align 2, keep-with-next
    490          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
    491          {
   \                     HAL_TIM_OC_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    492            /* Check the TIM handle allocation */
    493            if(htim == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_TIM_OC_Init_0
    494            {
    495              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    496            }
    497          
    498            /* Check the parameters */
    499            assert_param(IS_TIM_INSTANCE(htim->Instance));
    500            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    501            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    502           
    503            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OC_Init_0: (+1)
   \   0000000A   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE.N    ??HAL_TIM_OC_Init_1
    504            { 
    505              /* Allocate lock resource and initialize it */
    506              htim->Lock = HAL_UNLOCKED;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF884 0x0038      STRB     R0,[R4, #+56]
    507              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    508              HAL_TIM_OC_MspInit(htim);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_TIM_OC_MspInit
    509            }
    510            
    511            /* Set the TIM state */
    512            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Init_1: (+1)
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xF884 0x0039      STRB     R0,[R4, #+57]
    513            
    514            /* Init the base time for the Output Compare */  
    515            TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
   \   00000024   0x1D21             ADDS     R1,R4,#+4
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       TIM_Base_SetConfig
    516            
    517            /* Initialize the TIM state*/
    518            htim->State= HAL_TIM_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0039      STRB     R0,[R4, #+57]
    519            
    520            return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    521          }
    522          
    523          /**
    524            * @brief  DeInitializes the TIM peripheral 
    525            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    526            *                the configuration information for TIM module.
    527            * @retval HAL status
    528            */

   \                                 In section .text, align 2, keep-with-next
    529          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    530          {
   \                     HAL_TIM_OC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    531            /* Check the parameters */
    532            assert_param(IS_TIM_INSTANCE(htim->Instance));
    533            
    534             htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
    535             
    536            /* Disable the TIM Peripheral Clock */
    537            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIM_OC_DeInit_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_OC_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
    538            
    539            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    540            HAL_TIM_OC_MspDeInit(htim);
   \                     ??HAL_TIM_OC_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_OC_MspDeInit
    541              
    542            /* Change TIM state */  
    543            htim->State = HAL_TIM_STATE_RESET; 
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
    544          
    545            /* Release Lock */
    546            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
    547          
    548            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    549          }
    550          
    551          /**
    552            * @brief  Initializes the TIM Output Compare MSP.
    553            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    554            *                the configuration information for TIM module.
    555            * @retval None
    556            */

   \                                 In section .text, align 2, keep-with-next
    557          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    558          {
    559            /* Prevent unused argument(s) compilation warning */
    560            UNUSED(htim);
    561            /* NOTE : This function Should not be modified, when the callback is needed,
    562                      the HAL_TIM_OC_MspInit could be implemented in the user file
    563             */
    564          }
   \                     HAL_TIM_OC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    565          
    566          /**
    567            * @brief  DeInitializes TIM Output Compare MSP.
    568            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    569            *                the configuration information for TIM module.
    570            * @retval None
    571            */

   \                                 In section .text, align 2, keep-with-next
    572          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    573          {
    574            /* Prevent unused argument(s) compilation warning */
    575            UNUSED(htim);
    576            /* NOTE : This function Should not be modified, when the callback is needed,
    577                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    578             */
    579          }
   \                     HAL_TIM_OC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    580          
    581          /**
    582            * @brief  Starts the TIM Output Compare signal generation.
    583            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    584            *                the configuration information for TIM module.  
    585            * @param  Channel: TIM Channel to be enabled.
    586            *          This parameter can be one of the following values:
    587            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    588            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    589            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    590            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected   
    591            * @retval HAL status
    592            */

   \                                 In section .text, align 2, keep-with-next
    593          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    594          {
   \                     HAL_TIM_OC_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    595            /* Check the parameters */
    596            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    597            
    598            /* Enable the Output compare channel */
    599            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
    600            
    601            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40010000
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD003             BEQ.N    ??HAL_TIM_OC_Start_0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40010400
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??HAL_TIM_OC_Start_1
   \                     ??HAL_TIM_OC_Start_0: (+1)
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xE000             B.N      ??HAL_TIM_OC_Start_2
   \                     ??HAL_TIM_OC_Start_1: (+1)
   \   00000022   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OC_Start_2: (+1)
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD003             BEQ.N    ??HAL_TIM_OC_Start_3
    602            {
    603              /* Enable the main output */
    604              __HAL_TIM_MOE_ENABLE(htim);
   \   00000028   0x6C41             LDR      R1,[R0, #+68]
   \   0000002A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000002E   0x6441             STR      R1,[R0, #+68]
    605            }
    606            
    607            /* Enable the Peripheral */
    608            __HAL_TIM_ENABLE(htim); 
   \                     ??HAL_TIM_OC_Start_3: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000038   0x6001             STR      R1,[R0, #+0]
    609            
    610            /* Return function status */
    611            return HAL_OK;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    612          }
    613          
    614          /**
    615            * @brief  Stops the TIM Output Compare signal generation.
    616            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    617            *                the configuration information for TIM module.
    618            * @param  Channel: TIM Channel to be disabled.
    619            *          This parameter can be one of the following values:
    620            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    621            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    622            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    623            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    624            * @retval HAL status
    625            */

   \                                 In section .text, align 2, keep-with-next
    626          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    627          {
   \                     HAL_TIM_OC_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    628            /* Check the parameters */
    629            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    630            
    631            /* Disable the Output compare channel */
    632            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
    633            
    634            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40010000
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD003             BEQ.N    ??HAL_TIM_OC_Stop_0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40010400
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??HAL_TIM_OC_Stop_1
   \                     ??HAL_TIM_OC_Stop_0: (+1)
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xE000             B.N      ??HAL_TIM_OC_Stop_2
   \                     ??HAL_TIM_OC_Stop_1: (+1)
   \   00000022   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OC_Stop_2: (+1)
   \   00000024   0xF241 0x1211      MOVW     R2,#+4369
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD00B             BEQ.N    ??HAL_TIM_OC_Stop_3
    635            {
    636              /* Disable the Main Output */
    637              __HAL_TIM_MOE_DISABLE(htim);
   \   0000002C   0x6A01             LDR      R1,[R0, #+32]
   \   0000002E   0x4211             TST      R1,R2
   \   00000030   0xD108             BNE.N    ??HAL_TIM_OC_Stop_3
   \   00000032   0x6A01             LDR      R1,[R0, #+32]
   \   00000034   0xF240 0x4344      MOVW     R3,#+1092
   \   00000038   0x4219             TST      R1,R3
   \   0000003A   0xD103             BNE.N    ??HAL_TIM_OC_Stop_3
   \   0000003C   0x6C41             LDR      R1,[R0, #+68]
   \   0000003E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000042   0x6441             STR      R1,[R0, #+68]
    638            }  
    639            
    640            /* Disable the Peripheral */
    641            __HAL_TIM_DISABLE(htim);  
   \                     ??HAL_TIM_OC_Stop_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6A01             LDR      R1,[R0, #+32]
   \   00000048   0x4211             TST      R1,R2
   \   0000004A   0xD108             BNE.N    ??HAL_TIM_OC_Stop_4
   \   0000004C   0x6A01             LDR      R1,[R0, #+32]
   \   0000004E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000052   0x4211             TST      R1,R2
   \   00000054   0xD103             BNE.N    ??HAL_TIM_OC_Stop_4
   \   00000056   0x6801             LDR      R1,[R0, #+0]
   \   00000058   0x0849             LSRS     R1,R1,#+1
   \   0000005A   0x0049             LSLS     R1,R1,#+1
   \   0000005C   0x6001             STR      R1,[R0, #+0]
    642            
    643            /* Return function status */
    644            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_4: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBD10             POP      {R4,PC}          ;; return
    645          }  
    646          
    647          /**
    648            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    649            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    650            *                the configuration information for TIM module.
    651            * @param  Channel: TIM Channel to be enabled.
    652            *          This parameter can be one of the following values:
    653            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    654            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    655            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    656            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    657            * @retval HAL status
    658            */

   \                                 In section .text, align 2, keep-with-next
    659          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    660          {
   \                     HAL_TIM_OC_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    661            /* Check the parameters */
    662            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    663            
    664            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_OC_Start_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_OC_Start_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_OC_Start_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_OC_Start_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIM_OC_Start_IT_4
    665            {
    666              case TIM_CHANNEL_1:
    667              {       
    668                /* Enable the TIM Capture/Compare 1 interrupt */
    669                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Start_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
    670              }
    671              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_OC_Start_IT_4
    672              
    673              case TIM_CHANNEL_2:
    674              {
    675                /* Enable the TIM Capture/Compare 2 interrupt */
    676                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Start_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
    677              }
    678              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_OC_Start_IT_4
    679              
    680              case TIM_CHANNEL_3:
    681              {
    682                /* Enable the TIM Capture/Compare 3 interrupt */
    683                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Start_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
    684              }
    685              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_OC_Start_IT_4
    686              
    687              case TIM_CHANNEL_4:
    688              {
    689                /* Enable the TIM Capture/Compare 4 interrupt */
    690                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Start_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
    691              }
    692              break;
    693              
    694              default:
    695              break;
    696            } 
    697          
    698            /* Enable the Output compare channel */
    699            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_IT_4: (+1)
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
    700            
    701            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40010000
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD003             BEQ.N    ??HAL_TIM_OC_Start_IT_5
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40010400
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??HAL_TIM_OC_Start_IT_6
   \                     ??HAL_TIM_OC_Start_IT_5: (+1)
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE000             B.N      ??HAL_TIM_OC_Start_IT_7
   \                     ??HAL_TIM_OC_Start_IT_6: (+1)
   \   00000062   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OC_Start_IT_7: (+1)
   \   00000064   0x2900             CMP      R1,#+0
   \   00000066   0xD003             BEQ.N    ??HAL_TIM_OC_Start_IT_8
    702            {
    703              /* Enable the main output */
    704              __HAL_TIM_MOE_ENABLE(htim);
   \   00000068   0x6C41             LDR      R1,[R0, #+68]
   \   0000006A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000006E   0x6441             STR      R1,[R0, #+68]
    705            }
    706          
    707            /* Enable the Peripheral */
    708            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_OC_Start_IT_8: (+1)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000078   0x6001             STR      R1,[R0, #+0]
    709            
    710            /* Return function status */
    711            return HAL_OK;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xBD10             POP      {R4,PC}          ;; return
    712          }
    713          
    714          /**
    715            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    716            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    717            *                the configuration information for TIM module.
    718            * @param  Channel: TIM Channel to be disabled.
    719            *          This parameter can be one of the following values:
    720            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    721            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    722            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    723            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    724            * @retval HAL status
    725            */

   \                                 In section .text, align 2, keep-with-next
    726          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    727          {
   \                     HAL_TIM_OC_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    728            /* Check the parameters */
    729            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    730            
    731            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_OC_Stop_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_OC_Stop_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_OC_Stop_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIM_OC_Stop_IT_4
    732            {
    733              case TIM_CHANNEL_1:
    734              {       
    735                /* Disable the TIM Capture/Compare 1 interrupt */
    736                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Stop_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
    737              }
    738              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_OC_Stop_IT_4
    739              
    740              case TIM_CHANNEL_2:
    741              {
    742                /* Disable the TIM Capture/Compare 2 interrupt */
    743                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Stop_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF022 0x0204      BIC      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
    744              }
    745              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_OC_Stop_IT_4
    746              
    747              case TIM_CHANNEL_3:
    748              {
    749                /* Disable the TIM Capture/Compare 3 interrupt */
    750                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Stop_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF022 0x0208      BIC      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
    751              }
    752              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_OC_Stop_IT_4
    753              
    754              case TIM_CHANNEL_4:
    755              {
    756                /* Disable the TIM Capture/Compare 4 interrupt */
    757                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Stop_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
    758              }
    759              break;
    760              
    761              default:
    762              break; 
    763            } 
    764            
    765            /* Disable the Output compare channel */
    766            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_OC_Stop_IT_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
    767            
    768            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40010000
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD003             BEQ.N    ??HAL_TIM_OC_Stop_IT_5
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40010400
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??HAL_TIM_OC_Stop_IT_6
   \                     ??HAL_TIM_OC_Stop_IT_5: (+1)
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE000             B.N      ??HAL_TIM_OC_Stop_IT_7
   \                     ??HAL_TIM_OC_Stop_IT_6: (+1)
   \   00000062   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OC_Stop_IT_7: (+1)
   \   00000064   0xF241 0x1211      MOVW     R2,#+4369
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0xD00B             BEQ.N    ??HAL_TIM_OC_Stop_IT_8
    769            {
    770              /* Disable the Main Output */
    771              __HAL_TIM_MOE_DISABLE(htim);
   \   0000006C   0x6A01             LDR      R1,[R0, #+32]
   \   0000006E   0x4211             TST      R1,R2
   \   00000070   0xD108             BNE.N    ??HAL_TIM_OC_Stop_IT_8
   \   00000072   0x6A01             LDR      R1,[R0, #+32]
   \   00000074   0xF240 0x4344      MOVW     R3,#+1092
   \   00000078   0x4219             TST      R1,R3
   \   0000007A   0xD103             BNE.N    ??HAL_TIM_OC_Stop_IT_8
   \   0000007C   0x6C41             LDR      R1,[R0, #+68]
   \   0000007E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000082   0x6441             STR      R1,[R0, #+68]
    772            }
    773            
    774            /* Disable the Peripheral */
    775            __HAL_TIM_DISABLE(htim);  
   \                     ??HAL_TIM_OC_Stop_IT_8: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6A01             LDR      R1,[R0, #+32]
   \   00000088   0x4211             TST      R1,R2
   \   0000008A   0xD108             BNE.N    ??HAL_TIM_OC_Stop_IT_9
   \   0000008C   0x6A01             LDR      R1,[R0, #+32]
   \   0000008E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000092   0x4211             TST      R1,R2
   \   00000094   0xD103             BNE.N    ??HAL_TIM_OC_Stop_IT_9
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x0849             LSRS     R1,R1,#+1
   \   0000009A   0x0049             LSLS     R1,R1,#+1
   \   0000009C   0x6001             STR      R1,[R0, #+0]
    776            
    777            /* Return function status */
    778            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_IT_9: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xBD10             POP      {R4,PC}          ;; return
    779          }
    780          
    781          /**
    782            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    783            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    784            *                the configuration information for TIM module.
    785            * @param  Channel: TIM Channel to be enabled.
    786            *          This parameter can be one of the following values:
    787            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    788            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    789            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    790            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    791            * @param  pData: The source Buffer address.
    792            * @param  Length: The length of data to be transferred from memory to TIM peripheral
    793            * @retval HAL status
    794            */

   \                                 In section .text, align 2, keep-with-next
    795          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    796          {
   \                     HAL_TIM_OC_Start_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4611             MOV      R1,R2
    797            /* Check the parameters */
    798            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    799            
    800            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_OC_Start_DMA_0
    801            {
    802               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}
    803            }
    804            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_OC_Start_DMA_0: (+1)
   \   00000014   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD108             BNE.N    ??HAL_TIM_OC_Start_DMA_1
    805            {
    806              if(((uint32_t)pData == 0U) && (Length > 0U)) 
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_OC_Start_DMA_2
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD001             BEQ.N    ??HAL_TIM_OC_Start_DMA_2
    807              {
    808                return HAL_ERROR;                                    
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
    809              }
    810              else
    811              {
    812                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Start_DMA_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
    813              }
    814            }    
    815            switch (Channel)
   \                     ??HAL_TIM_OC_Start_DMA_1: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0xD006             BEQ.N    ??HAL_TIM_OC_Start_DMA_3
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD018             BEQ.N    ??HAL_TIM_OC_Start_DMA_4
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xD02A             BEQ.N    ??HAL_TIM_OC_Start_DMA_5
   \   0000003A   0x280C             CMP      R0,#+12
   \   0000003C   0xD03C             BEQ.N    ??HAL_TIM_OC_Start_DMA_6
   \   0000003E   0xE04E             B.N      ??HAL_TIM_OC_Start_DMA_7
    816            {
    817              case TIM_CHANNEL_1:
    818              {      
    819                /* Set the DMA Period elapsed callback */
    820                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_3: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000044   0x6A22             LDR      R2,[R4, #+32]
   \   00000046   0x63D0             STR      R0,[R2, #+60]
    821               
    822                /* Set the DMA error callback */
    823                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000004C   0x6A22             LDR      R2,[R4, #+32]
   \   0000004E   0x64D0             STR      R0,[R2, #+76]
    824                
    825                /* Enable the DMA Stream */
    826                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0xF100 0x0234      ADD      R2,R0,#+52
   \   00000056   0x6A20             LDR      R0,[R4, #+32]
   \   00000058   0x.... 0x....      BL       HAL_DMA_Start_IT
    827                
    828                /* Enable the TIM Capture/Compare 1 DMA request */
    829                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x68C1             LDR      R1,[R0, #+12]
   \   00000060   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000064   0x60C1             STR      R1,[R0, #+12]
    830              }
    831              break;
   \   00000066   0xE03A             B.N      ??HAL_TIM_OC_Start_DMA_7
    832              
    833              case TIM_CHANNEL_2:
    834              {
    835                /* Set the DMA Period elapsed callback */
    836                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_4: (+1)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000006C   0x6A62             LDR      R2,[R4, #+36]
   \   0000006E   0x63D0             STR      R0,[R2, #+60]
    837               
    838                /* Set the DMA error callback */
    839                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000074   0x6A62             LDR      R2,[R4, #+36]
   \   00000076   0x64D0             STR      R0,[R2, #+76]
    840                
    841                /* Enable the DMA Stream */
    842                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0xF100 0x0238      ADD      R2,R0,#+56
   \   0000007E   0x6A60             LDR      R0,[R4, #+36]
   \   00000080   0x.... 0x....      BL       HAL_DMA_Start_IT
    843                
    844                /* Enable the TIM Capture/Compare 2 DMA request */
    845                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x68C1             LDR      R1,[R0, #+12]
   \   00000088   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000008C   0x60C1             STR      R1,[R0, #+12]
    846              }
    847              break;
   \   0000008E   0xE026             B.N      ??HAL_TIM_OC_Start_DMA_7
    848              
    849              case TIM_CHANNEL_3:
    850              {
    851                /* Set the DMA Period elapsed callback */
    852                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_5: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000094   0x6AA2             LDR      R2,[R4, #+40]
   \   00000096   0x63D0             STR      R0,[R2, #+60]
    853               
    854                /* Set the DMA error callback */
    855                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000009C   0x6AA2             LDR      R2,[R4, #+40]
   \   0000009E   0x64D0             STR      R0,[R2, #+76]
    856                
    857                /* Enable the DMA Stream */
    858                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0xF100 0x023C      ADD      R2,R0,#+60
   \   000000A6   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A8   0x.... 0x....      BL       HAL_DMA_Start_IT
    859                
    860                /* Enable the TIM Capture/Compare 3 DMA request */
    861                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x68C1             LDR      R1,[R0, #+12]
   \   000000B0   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000B4   0x60C1             STR      R1,[R0, #+12]
    862              }
    863              break;
   \   000000B6   0xE012             B.N      ??HAL_TIM_OC_Start_DMA_7
    864              
    865              case TIM_CHANNEL_4:
    866              {
    867               /* Set the DMA Period elapsed callback */
    868                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_6: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   000000BC   0x6AE2             LDR      R2,[R4, #+44]
   \   000000BE   0x63D0             STR      R0,[R2, #+60]
    869               
    870                /* Set the DMA error callback */
    871                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000C4   0x6AE2             LDR      R2,[R4, #+44]
   \   000000C6   0x64D0             STR      R0,[R2, #+76]
    872                
    873                /* Enable the DMA Stream */
    874                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0xF100 0x0240      ADD      R2,R0,#+64
   \   000000CE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000D0   0x.... 0x....      BL       HAL_DMA_Start_IT
    875                
    876                /* Enable the TIM Capture/Compare 4 DMA request */
    877                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x68C1             LDR      R1,[R0, #+12]
   \   000000D8   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000DC   0x60C1             STR      R1,[R0, #+12]
    878              }
    879              break;
    880              
    881              default:
    882              break;
    883            }
    884          
    885            /* Enable the Output compare channel */
    886            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_DMA_7: (+1)
   \   000000DE   0x2201             MOVS     R2,#+1
   \   000000E0   0x4629             MOV      R1,R5
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x.... 0x....      BL       TIM_CCxChannelCmd
    887            
    888            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40010000
   \   000000EE   0x4288             CMP      R0,R1
   \   000000F0   0xD003             BEQ.N    ??HAL_TIM_OC_Start_DMA_8
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40010400
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xD101             BNE.N    ??HAL_TIM_OC_Start_DMA_9
   \                     ??HAL_TIM_OC_Start_DMA_8: (+1)
   \   000000FA   0x2101             MOVS     R1,#+1
   \   000000FC   0xE000             B.N      ??HAL_TIM_OC_Start_DMA_10
   \                     ??HAL_TIM_OC_Start_DMA_9: (+1)
   \   000000FE   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OC_Start_DMA_10: (+1)
   \   00000100   0x2900             CMP      R1,#+0
   \   00000102   0xD003             BEQ.N    ??HAL_TIM_OC_Start_DMA_11
    889            {
    890              /* Enable the main output */
    891              __HAL_TIM_MOE_ENABLE(htim);
   \   00000104   0x6C41             LDR      R1,[R0, #+68]
   \   00000106   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000010A   0x6441             STR      R1,[R0, #+68]
    892            }  
    893            
    894            /* Enable the Peripheral */
    895            __HAL_TIM_ENABLE(htim); 
   \                     ??HAL_TIM_OC_Start_DMA_11: (+1)
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x6801             LDR      R1,[R0, #+0]
   \   00000110   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000114   0x6001             STR      R1,[R0, #+0]
    896            
    897            /* Return function status */
    898            return HAL_OK;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    899          }
    900          
    901          /**
    902            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
    903            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    904            *                the configuration information for TIM module.
    905            * @param  Channel: TIM Channel to be disabled.
    906            *          This parameter can be one of the following values:
    907            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    908            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    909            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    910            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    911            * @retval HAL status
    912            */

   \                                 In section .text, align 2, keep-with-next
    913          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    914          {
   \                     HAL_TIM_OC_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    915            /* Check the parameters */
    916            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    917            
    918            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_DMA_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_OC_Stop_DMA_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_OC_Stop_DMA_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_OC_Stop_DMA_3
   \   00000014   0xE016             B.N      ??HAL_TIM_OC_Stop_DMA_4
    919            {
    920              case TIM_CHANNEL_1:
    921              {       
    922                /* Disable the TIM Capture/Compare 1 DMA request */
    923                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_OC_Stop_DMA_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF422 0x7200      BIC      R2,R2,#0x200
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
    924              }
    925              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_OC_Stop_DMA_4
    926              
    927              case TIM_CHANNEL_2:
    928              {
    929                /* Disable the TIM Capture/Compare 2 DMA request */
    930                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_OC_Stop_DMA_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
    931              }
    932              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_OC_Stop_DMA_4
    933              
    934              case TIM_CHANNEL_3:
    935              {
    936                /* Disable the TIM Capture/Compare 3 DMA request */
    937                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_OC_Stop_DMA_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000036   0x60C2             STR      R2,[R0, #+12]
    938              }
    939              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_OC_Stop_DMA_4
    940              
    941              case TIM_CHANNEL_4:
    942              {
    943                /* Disable the TIM Capture/Compare 4 interrupt */
    944                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Stop_DMA_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000042   0x60C2             STR      R2,[R0, #+12]
    945              }
    946              break;
    947              
    948              default:
    949              break;
    950            } 
    951            
    952            /* Disable the Output compare channel */
    953            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_DMA_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
    954            
    955            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40010000
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD003             BEQ.N    ??HAL_TIM_OC_Stop_DMA_5
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40010400
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??HAL_TIM_OC_Stop_DMA_6
   \                     ??HAL_TIM_OC_Stop_DMA_5: (+1)
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE000             B.N      ??HAL_TIM_OC_Stop_DMA_7
   \                     ??HAL_TIM_OC_Stop_DMA_6: (+1)
   \   00000062   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OC_Stop_DMA_7: (+1)
   \   00000064   0xF241 0x1211      MOVW     R2,#+4369
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0xD00B             BEQ.N    ??HAL_TIM_OC_Stop_DMA_8
    956            {
    957              /* Disable the Main Output */
    958              __HAL_TIM_MOE_DISABLE(htim);
   \   0000006C   0x6A01             LDR      R1,[R0, #+32]
   \   0000006E   0x4211             TST      R1,R2
   \   00000070   0xD108             BNE.N    ??HAL_TIM_OC_Stop_DMA_8
   \   00000072   0x6A01             LDR      R1,[R0, #+32]
   \   00000074   0xF240 0x4344      MOVW     R3,#+1092
   \   00000078   0x4219             TST      R1,R3
   \   0000007A   0xD103             BNE.N    ??HAL_TIM_OC_Stop_DMA_8
   \   0000007C   0x6C41             LDR      R1,[R0, #+68]
   \   0000007E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000082   0x6441             STR      R1,[R0, #+68]
    959            }
    960            
    961            /* Disable the Peripheral */
    962            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_DMA_8: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6A01             LDR      R1,[R0, #+32]
   \   00000088   0x4211             TST      R1,R2
   \   0000008A   0xD108             BNE.N    ??HAL_TIM_OC_Stop_DMA_9
   \   0000008C   0x6A01             LDR      R1,[R0, #+32]
   \   0000008E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000092   0x4211             TST      R1,R2
   \   00000094   0xD103             BNE.N    ??HAL_TIM_OC_Stop_DMA_9
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x0849             LSRS     R1,R1,#+1
   \   0000009A   0x0049             LSLS     R1,R1,#+1
   \   0000009C   0x6001             STR      R1,[R0, #+0]
    963            
    964            /* Change the htim state */
    965            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_Stop_DMA_9: (+1)
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xF884 0x0039      STRB     R0,[R4, #+57]
    966            
    967            /* Return function status */
    968            return HAL_OK;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xBD10             POP      {R4,PC}          ;; return
    969          }
    970          /**
    971            * @}
    972            */
    973          
    974          /** @defgroup TIM_Exported_Functions_Group3 Time PWM functions 
    975           *  @brief    Time PWM functions 
    976           *
    977          @verbatim    
    978            ==============================================================================
    979                                    ##### Time PWM functions #####
    980            ==============================================================================
    981            [..]  
    982              This section provides functions allowing to:
    983              (+) Initialize and configure the TIM OPWM. 
    984              (+) De-initialize the TIM PWM.
    985              (+) Start the Time PWM.
    986              (+) Stop the Time PWM.
    987              (+) Start the Time PWM and enable interrupt.
    988              (+) Stop the Time PWM and disable interrupt.
    989              (+) Start the Time PWM and enable DMA transfer.
    990              (+) Stop the Time PWM and disable DMA transfer.
    991           
    992          @endverbatim
    993            * @{
    994            */
    995          /**
    996            * @brief  Initializes the TIM PWM Time Base according to the specified
    997            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    998            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    999            *                the configuration information for TIM module.
   1000            * @retval HAL status
   1001            */

   \                                 In section .text, align 2, keep-with-next
   1002          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
   1003          {
   \                     HAL_TIM_PWM_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1004            /* Check the TIM handle allocation */
   1005            if(htim == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_TIM_PWM_Init_0
   1006            {
   1007              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
   1008            }
   1009          
   1010            /* Check the parameters */
   1011            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1012            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1013            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1014          
   1015            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_PWM_Init_0: (+1)
   \   0000000A   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE.N    ??HAL_TIM_PWM_Init_1
   1016            {
   1017              /* Allocate lock resource and initialize it */
   1018              htim->Lock = HAL_UNLOCKED;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF884 0x0038      STRB     R0,[R4, #+56]
   1019              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1020              HAL_TIM_PWM_MspInit(htim);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_TIM_PWM_MspInit
   1021            }
   1022          
   1023            /* Set the TIM state */
   1024            htim->State= HAL_TIM_STATE_BUSY;  
   \                     ??HAL_TIM_PWM_Init_1: (+1)
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xF884 0x0039      STRB     R0,[R4, #+57]
   1025            
   1026            /* Init the base time for the PWM */  
   1027            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   \   00000024   0x1D21             ADDS     R1,R4,#+4
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       TIM_Base_SetConfig
   1028             
   1029            /* Initialize the TIM state*/
   1030            htim->State= HAL_TIM_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0039      STRB     R0,[R4, #+57]
   1031            
   1032            return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
   1033          }  
   1034          
   1035          /**
   1036            * @brief  DeInitializes the TIM peripheral 
   1037            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1038            *                the configuration information for TIM module.
   1039            * @retval HAL status
   1040            */

   \                                 In section .text, align 2, keep-with-next
   1041          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1042          {
   \                     HAL_TIM_PWM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1043            /* Check the parameters */
   1044            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1045            
   1046            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   1047            
   1048            /* Disable the TIM Peripheral Clock */
   1049            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIM_PWM_DeInit_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_PWM_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   1050              
   1051            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1052            HAL_TIM_PWM_MspDeInit(htim);
   \                     ??HAL_TIM_PWM_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_PWM_MspDeInit
   1053              
   1054            /* Change TIM state */  
   1055            htim->State = HAL_TIM_STATE_RESET; 
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   1056          
   1057            /* Release Lock */
   1058            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
   1059          
   1060            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   1061          }
   1062          
   1063          /**
   1064            * @brief  Initializes the TIM PWM MSP.
   1065            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1066            *                the configuration information for TIM module.
   1067            * @retval None
   1068            */

   \                                 In section .text, align 2, keep-with-next
   1069          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1070          {
   1071            /* Prevent unused argument(s) compilation warning */
   1072            UNUSED(htim);
   1073            /* NOTE : This function Should not be modified, when the callback is needed,
   1074                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1075             */
   1076          }
   \                     HAL_TIM_PWM_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1077          
   1078          /**
   1079            * @brief  DeInitializes TIM PWM MSP.
   1080            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1081            *                the configuration information for TIM module.
   1082            * @retval None
   1083            */

   \                                 In section .text, align 2, keep-with-next
   1084          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1085          {
   1086            /* Prevent unused argument(s) compilation warning */
   1087            UNUSED(htim);
   1088            /* NOTE : This function Should not be modified, when the callback is needed,
   1089                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1090             */
   1091          }
   \                     HAL_TIM_PWM_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1092          
   1093          /**
   1094            * @brief  Starts the PWM signal generation.
   1095            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1096            *                the configuration information for TIM module.
   1097            * @param  Channel: TIM Channels to be enabled.
   1098            *          This parameter can be one of the following values:
   1099            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1100            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1101            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1102            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1103            * @retval HAL status
   1104            */

   \                                 In section .text, align 2, keep-with-next
   1105          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1106          {
   \                     HAL_TIM_PWM_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1107            /* Check the parameters */
   1108            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1109          
   1110            /* Enable the Capture compare channel */
   1111            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
   1112            
   1113            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40010000
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD003             BEQ.N    ??HAL_TIM_PWM_Start_0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40010400
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??HAL_TIM_PWM_Start_1
   \                     ??HAL_TIM_PWM_Start_0: (+1)
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xE000             B.N      ??HAL_TIM_PWM_Start_2
   \                     ??HAL_TIM_PWM_Start_1: (+1)
   \   00000022   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_PWM_Start_2: (+1)
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD003             BEQ.N    ??HAL_TIM_PWM_Start_3
   1114            {
   1115              /* Enable the main output */
   1116              __HAL_TIM_MOE_ENABLE(htim);
   \   00000028   0x6C41             LDR      R1,[R0, #+68]
   \   0000002A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000002E   0x6441             STR      R1,[R0, #+68]
   1117            }
   1118              
   1119            /* Enable the Peripheral */
   1120            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_PWM_Start_3: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000038   0x6001             STR      R1,[R0, #+0]
   1121            
   1122            /* Return function status */
   1123            return HAL_OK;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   1124          } 
   1125          
   1126          /**
   1127            * @brief  Stops the PWM signal generation.
   1128            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1129            *                the configuration information for TIM module.
   1130            * @param  Channel: TIM Channels to be disabled.
   1131            *          This parameter can be one of the following values:
   1132            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1133            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1134            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1135            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1136            * @retval HAL status
   1137            */

   \                                 In section .text, align 2, keep-with-next
   1138          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1139          { 
   \                     HAL_TIM_PWM_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1140            /* Check the parameters */
   1141            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1142              
   1143            /* Disable the Capture compare channel */
   1144            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
   1145            
   1146            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40010000
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD003             BEQ.N    ??HAL_TIM_PWM_Stop_0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40010400
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??HAL_TIM_PWM_Stop_1
   \                     ??HAL_TIM_PWM_Stop_0: (+1)
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xE000             B.N      ??HAL_TIM_PWM_Stop_2
   \                     ??HAL_TIM_PWM_Stop_1: (+1)
   \   00000022   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_PWM_Stop_2: (+1)
   \   00000024   0xF241 0x1211      MOVW     R2,#+4369
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD00B             BEQ.N    ??HAL_TIM_PWM_Stop_3
   1147            {
   1148              /* Disable the Main Output */
   1149              __HAL_TIM_MOE_DISABLE(htim);
   \   0000002C   0x6A01             LDR      R1,[R0, #+32]
   \   0000002E   0x4211             TST      R1,R2
   \   00000030   0xD108             BNE.N    ??HAL_TIM_PWM_Stop_3
   \   00000032   0x6A01             LDR      R1,[R0, #+32]
   \   00000034   0xF240 0x4344      MOVW     R3,#+1092
   \   00000038   0x4219             TST      R1,R3
   \   0000003A   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_3
   \   0000003C   0x6C41             LDR      R1,[R0, #+68]
   \   0000003E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000042   0x6441             STR      R1,[R0, #+68]
   1150            }
   1151            
   1152            /* Disable the Peripheral */
   1153            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6A01             LDR      R1,[R0, #+32]
   \   00000048   0x4211             TST      R1,R2
   \   0000004A   0xD108             BNE.N    ??HAL_TIM_PWM_Stop_4
   \   0000004C   0x6A01             LDR      R1,[R0, #+32]
   \   0000004E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000052   0x4211             TST      R1,R2
   \   00000054   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_4
   \   00000056   0x6801             LDR      R1,[R0, #+0]
   \   00000058   0x0849             LSRS     R1,R1,#+1
   \   0000005A   0x0049             LSLS     R1,R1,#+1
   \   0000005C   0x6001             STR      R1,[R0, #+0]
   1154            
   1155            /* Change the htim state */
   1156            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_4: (+1)
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xF884 0x0039      STRB     R0,[R4, #+57]
   1157            
   1158            /* Return function status */
   1159            return HAL_OK;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xBD10             POP      {R4,PC}          ;; return
   1160          } 
   1161          
   1162          /**
   1163            * @brief  Starts the PWM signal generation in interrupt mode.
   1164            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1165            *                the configuration information for TIM module.
   1166            * @param  Channel: TIM Channel to be disabled.
   1167            *          This parameter can be one of the following values:
   1168            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1169            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1170            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1171            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1172            * @retval HAL status
   1173            */

   \                                 In section .text, align 2, keep-with-next
   1174          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1175          {
   \                     HAL_TIM_PWM_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1176            /* Check the parameters */
   1177            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1178            
   1179            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_PWM_Start_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_PWM_Start_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_PWM_Start_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_PWM_Start_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIM_PWM_Start_IT_4
   1180            {
   1181              case TIM_CHANNEL_1:
   1182              {       
   1183                /* Enable the TIM Capture/Compare 1 interrupt */
   1184                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Start_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1185              }
   1186              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_PWM_Start_IT_4
   1187              
   1188              case TIM_CHANNEL_2:
   1189              {
   1190                /* Enable the TIM Capture/Compare 2 interrupt */
   1191                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Start_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1192              }
   1193              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_PWM_Start_IT_4
   1194              
   1195              case TIM_CHANNEL_3:
   1196              {
   1197                /* Enable the TIM Capture/Compare 3 interrupt */
   1198                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Start_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1199              }
   1200              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_PWM_Start_IT_4
   1201              
   1202              case TIM_CHANNEL_4:
   1203              {
   1204                /* Enable the TIM Capture/Compare 4 interrupt */
   1205                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Start_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1206              }
   1207              break;
   1208              
   1209              default:
   1210              break;
   1211            } 
   1212            
   1213            /* Enable the Capture compare channel */
   1214            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_IT_4: (+1)
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
   1215            
   1216            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40010000
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD003             BEQ.N    ??HAL_TIM_PWM_Start_IT_5
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40010400
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??HAL_TIM_PWM_Start_IT_6
   \                     ??HAL_TIM_PWM_Start_IT_5: (+1)
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE000             B.N      ??HAL_TIM_PWM_Start_IT_7
   \                     ??HAL_TIM_PWM_Start_IT_6: (+1)
   \   00000062   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_PWM_Start_IT_7: (+1)
   \   00000064   0x2900             CMP      R1,#+0
   \   00000066   0xD003             BEQ.N    ??HAL_TIM_PWM_Start_IT_8
   1217            {
   1218              /* Enable the main output */
   1219              __HAL_TIM_MOE_ENABLE(htim);
   \   00000068   0x6C41             LDR      R1,[R0, #+68]
   \   0000006A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000006E   0x6441             STR      R1,[R0, #+68]
   1220            }
   1221          
   1222            /* Enable the Peripheral */
   1223            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_PWM_Start_IT_8: (+1)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000078   0x6001             STR      R1,[R0, #+0]
   1224            
   1225            /* Return function status */
   1226            return HAL_OK;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xBD10             POP      {R4,PC}          ;; return
   1227          } 
   1228          
   1229          /**
   1230            * @brief  Stops the PWM signal generation in interrupt mode.
   1231            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1232            *                the configuration information for TIM module.
   1233            * @param  Channel: TIM Channels to be disabled.
   1234            *          This parameter can be one of the following values:
   1235            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1236            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1237            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1238            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1239            * @retval HAL status
   1240            */

   \                                 In section .text, align 2, keep-with-next
   1241          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1242          {
   \                     HAL_TIM_PWM_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1243            /* Check the parameters */
   1244            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1245            
   1246            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_PWM_Stop_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_PWM_Stop_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_PWM_Stop_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIM_PWM_Stop_IT_4
   1247            {
   1248              case TIM_CHANNEL_1:
   1249              {       
   1250                /* Disable the TIM Capture/Compare 1 interrupt */
   1251                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Stop_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1252              }
   1253              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_PWM_Stop_IT_4
   1254              
   1255              case TIM_CHANNEL_2:
   1256              {
   1257                /* Disable the TIM Capture/Compare 2 interrupt */
   1258                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Stop_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF022 0x0204      BIC      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1259              }
   1260              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_PWM_Stop_IT_4
   1261              
   1262              case TIM_CHANNEL_3:
   1263              {
   1264                /* Disable the TIM Capture/Compare 3 interrupt */
   1265                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Stop_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF022 0x0208      BIC      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1266              }
   1267              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_PWM_Stop_IT_4
   1268              
   1269              case TIM_CHANNEL_4:
   1270              {
   1271                /* Disable the TIM Capture/Compare 4 interrupt */
   1272                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Stop_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1273              }
   1274              break;
   1275              
   1276              default:
   1277              break; 
   1278            }
   1279            
   1280            /* Disable the Capture compare channel */
   1281            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_IT_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
   1282            
   1283            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40010000
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD003             BEQ.N    ??HAL_TIM_PWM_Stop_IT_5
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40010400
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??HAL_TIM_PWM_Stop_IT_6
   \                     ??HAL_TIM_PWM_Stop_IT_5: (+1)
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE000             B.N      ??HAL_TIM_PWM_Stop_IT_7
   \                     ??HAL_TIM_PWM_Stop_IT_6: (+1)
   \   00000062   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_PWM_Stop_IT_7: (+1)
   \   00000064   0xF241 0x1211      MOVW     R2,#+4369
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0xD00B             BEQ.N    ??HAL_TIM_PWM_Stop_IT_8
   1284            {
   1285              /* Disable the Main Output */
   1286              __HAL_TIM_MOE_DISABLE(htim);
   \   0000006C   0x6A01             LDR      R1,[R0, #+32]
   \   0000006E   0x4211             TST      R1,R2
   \   00000070   0xD108             BNE.N    ??HAL_TIM_PWM_Stop_IT_8
   \   00000072   0x6A01             LDR      R1,[R0, #+32]
   \   00000074   0xF240 0x4344      MOVW     R3,#+1092
   \   00000078   0x4219             TST      R1,R3
   \   0000007A   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_IT_8
   \   0000007C   0x6C41             LDR      R1,[R0, #+68]
   \   0000007E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000082   0x6441             STR      R1,[R0, #+68]
   1287            }
   1288            
   1289            /* Disable the Peripheral */
   1290            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_IT_8: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6A01             LDR      R1,[R0, #+32]
   \   00000088   0x4211             TST      R1,R2
   \   0000008A   0xD108             BNE.N    ??HAL_TIM_PWM_Stop_IT_9
   \   0000008C   0x6A01             LDR      R1,[R0, #+32]
   \   0000008E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000092   0x4211             TST      R1,R2
   \   00000094   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_IT_9
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x0849             LSRS     R1,R1,#+1
   \   0000009A   0x0049             LSLS     R1,R1,#+1
   \   0000009C   0x6001             STR      R1,[R0, #+0]
   1291            
   1292            /* Return function status */
   1293            return HAL_OK;
   \                     ??HAL_TIM_PWM_Stop_IT_9: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xBD10             POP      {R4,PC}          ;; return
   1294          } 
   1295          
   1296          /**
   1297            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1298            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1299            *                the configuration information for TIM module.
   1300            * @param  Channel: TIM Channels to be enabled.
   1301            *          This parameter can be one of the following values:
   1302            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1303            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1304            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1305            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1306            * @param  pData: The source Buffer address.
   1307            * @param  Length: The length of data to be transferred from memory to TIM peripheral
   1308            * @retval HAL status
   1309            */

   \                                 In section .text, align 2, keep-with-next
   1310          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1311          {
   \                     HAL_TIM_PWM_Start_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4611             MOV      R1,R2
   1312            /* Check the parameters */
   1313            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1314            
   1315            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_PWM_Start_DMA_0
   1316            {
   1317               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}
   1318            }
   1319            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_PWM_Start_DMA_0: (+1)
   \   00000014   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD108             BNE.N    ??HAL_TIM_PWM_Start_DMA_1
   1320            {
   1321              if(((uint32_t)pData == 0U) && (Length > 0U)) 
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_PWM_Start_DMA_2
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD001             BEQ.N    ??HAL_TIM_PWM_Start_DMA_2
   1322              {
   1323                return HAL_ERROR;                                    
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
   1324              }
   1325              else
   1326              {
   1327                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Start_DMA_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
   1328              }
   1329            }    
   1330            switch (Channel)
   \                     ??HAL_TIM_PWM_Start_DMA_1: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0xD006             BEQ.N    ??HAL_TIM_PWM_Start_DMA_3
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD018             BEQ.N    ??HAL_TIM_PWM_Start_DMA_4
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xD02A             BEQ.N    ??HAL_TIM_PWM_Start_DMA_5
   \   0000003A   0x280C             CMP      R0,#+12
   \   0000003C   0xD03C             BEQ.N    ??HAL_TIM_PWM_Start_DMA_6
   \   0000003E   0xE04E             B.N      ??HAL_TIM_PWM_Start_DMA_7
   1331            {
   1332              case TIM_CHANNEL_1:
   1333              {      
   1334                /* Set the DMA Period elapsed callback */
   1335                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_3: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000044   0x6A22             LDR      R2,[R4, #+32]
   \   00000046   0x63D0             STR      R0,[R2, #+60]
   1336               
   1337                /* Set the DMA error callback */
   1338                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000004C   0x6A22             LDR      R2,[R4, #+32]
   \   0000004E   0x64D0             STR      R0,[R2, #+76]
   1339                
   1340                /* Enable the DMA Stream */
   1341                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0xF100 0x0234      ADD      R2,R0,#+52
   \   00000056   0x6A20             LDR      R0,[R4, #+32]
   \   00000058   0x.... 0x....      BL       HAL_DMA_Start_IT
   1342                
   1343                /* Enable the TIM Capture/Compare 1 DMA request */
   1344                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x68C1             LDR      R1,[R0, #+12]
   \   00000060   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000064   0x60C1             STR      R1,[R0, #+12]
   1345              }
   1346              break;
   \   00000066   0xE03A             B.N      ??HAL_TIM_PWM_Start_DMA_7
   1347              
   1348              case TIM_CHANNEL_2:
   1349              {
   1350                /* Set the DMA Period elapsed callback */
   1351                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_4: (+1)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000006C   0x6A62             LDR      R2,[R4, #+36]
   \   0000006E   0x63D0             STR      R0,[R2, #+60]
   1352               
   1353                /* Set the DMA error callback */
   1354                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000074   0x6A62             LDR      R2,[R4, #+36]
   \   00000076   0x64D0             STR      R0,[R2, #+76]
   1355                
   1356                /* Enable the DMA Stream */
   1357                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0xF100 0x0238      ADD      R2,R0,#+56
   \   0000007E   0x6A60             LDR      R0,[R4, #+36]
   \   00000080   0x.... 0x....      BL       HAL_DMA_Start_IT
   1358                
   1359                /* Enable the TIM Capture/Compare 2 DMA request */
   1360                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x68C1             LDR      R1,[R0, #+12]
   \   00000088   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000008C   0x60C1             STR      R1,[R0, #+12]
   1361              }
   1362              break;
   \   0000008E   0xE026             B.N      ??HAL_TIM_PWM_Start_DMA_7
   1363              
   1364              case TIM_CHANNEL_3:
   1365              {
   1366                /* Set the DMA Period elapsed callback */
   1367                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_5: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000094   0x6AA2             LDR      R2,[R4, #+40]
   \   00000096   0x63D0             STR      R0,[R2, #+60]
   1368               
   1369                /* Set the DMA error callback */
   1370                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000009C   0x6AA2             LDR      R2,[R4, #+40]
   \   0000009E   0x64D0             STR      R0,[R2, #+76]
   1371                
   1372                /* Enable the DMA Stream */
   1373                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0xF100 0x023C      ADD      R2,R0,#+60
   \   000000A6   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A8   0x.... 0x....      BL       HAL_DMA_Start_IT
   1374                
   1375                /* Enable the TIM Output Capture/Compare 3 request */
   1376                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x68C1             LDR      R1,[R0, #+12]
   \   000000B0   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000B4   0x60C1             STR      R1,[R0, #+12]
   1377              }
   1378              break;
   \   000000B6   0xE012             B.N      ??HAL_TIM_PWM_Start_DMA_7
   1379              
   1380              case TIM_CHANNEL_4:
   1381              {
   1382               /* Set the DMA Period elapsed callback */
   1383                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_6: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   000000BC   0x6AE2             LDR      R2,[R4, #+44]
   \   000000BE   0x63D0             STR      R0,[R2, #+60]
   1384               
   1385                /* Set the DMA error callback */
   1386                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable16
   \   000000C4   0x6AE2             LDR      R2,[R4, #+44]
   \   000000C6   0x64D0             STR      R0,[R2, #+76]
   1387                
   1388                /* Enable the DMA Stream */
   1389                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0xF100 0x0240      ADD      R2,R0,#+64
   \   000000CE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000D0   0x.... 0x....      BL       HAL_DMA_Start_IT
   1390                
   1391                /* Enable the TIM Capture/Compare 4 DMA request */
   1392                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x68C1             LDR      R1,[R0, #+12]
   \   000000D8   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000DC   0x60C1             STR      R1,[R0, #+12]
   1393              }
   1394              break;
   1395              
   1396              default:
   1397              break;
   1398            }
   1399          
   1400            /* Enable the Capture compare channel */
   1401            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_DMA_7: (+1)
   \   000000DE   0x2201             MOVS     R2,#+1
   \   000000E0   0x4629             MOV      R1,R5
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x.... 0x....      BL       TIM_CCxChannelCmd
   1402              
   1403            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40010000
   \   000000EE   0x4288             CMP      R0,R1
   \   000000F0   0xD003             BEQ.N    ??HAL_TIM_PWM_Start_DMA_8
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40010400
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xD101             BNE.N    ??HAL_TIM_PWM_Start_DMA_9
   \                     ??HAL_TIM_PWM_Start_DMA_8: (+1)
   \   000000FA   0x2101             MOVS     R1,#+1
   \   000000FC   0xE000             B.N      ??HAL_TIM_PWM_Start_DMA_10
   \                     ??HAL_TIM_PWM_Start_DMA_9: (+1)
   \   000000FE   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_PWM_Start_DMA_10: (+1)
   \   00000100   0x2900             CMP      R1,#+0
   \   00000102   0xD003             BEQ.N    ??HAL_TIM_PWM_Start_DMA_11
   1404            {
   1405              /* Enable the main output */
   1406              __HAL_TIM_MOE_ENABLE(htim);
   \   00000104   0x6C41             LDR      R1,[R0, #+68]
   \   00000106   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000010A   0x6441             STR      R1,[R0, #+68]
   1407            }
   1408            
   1409            /* Enable the Peripheral */
   1410            __HAL_TIM_ENABLE(htim); 
   \                     ??HAL_TIM_PWM_Start_DMA_11: (+1)
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x6801             LDR      R1,[R0, #+0]
   \   00000110   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000114   0x6001             STR      R1,[R0, #+0]
   1411            
   1412            /* Return function status */
   1413            return HAL_OK;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1414          }
   1415          
   1416          /**
   1417            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1418            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1419            *                the configuration information for TIM module.
   1420            * @param  Channel: TIM Channels to be disabled.
   1421            *          This parameter can be one of the following values:
   1422            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1423            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1424            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1425            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1426            * @retval HAL status
   1427            */

   \                                 In section .text, align 2, keep-with-next
   1428          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1429          {
   \                     HAL_TIM_PWM_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1430            /* Check the parameters */
   1431            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1432            
   1433            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_3
   \   00000014   0xE016             B.N      ??HAL_TIM_PWM_Stop_DMA_4
   1434            {
   1435              case TIM_CHANNEL_1:
   1436              {       
   1437                /* Disable the TIM Capture/Compare 1 DMA request */
   1438                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_PWM_Stop_DMA_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF422 0x7200      BIC      R2,R2,#0x200
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1439              }
   1440              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_PWM_Stop_DMA_4
   1441              
   1442              case TIM_CHANNEL_2:
   1443              {
   1444                /* Disable the TIM Capture/Compare 2 DMA request */
   1445                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_PWM_Stop_DMA_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1446              }
   1447              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_PWM_Stop_DMA_4
   1448              
   1449              case TIM_CHANNEL_3:
   1450              {
   1451                /* Disable the TIM Capture/Compare 3 DMA request */
   1452                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_PWM_Stop_DMA_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1453              }
   1454              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_PWM_Stop_DMA_4
   1455              
   1456              case TIM_CHANNEL_4:
   1457              {
   1458                /* Disable the TIM Capture/Compare 4 interrupt */
   1459                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Stop_DMA_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1460              }
   1461              break;
   1462              
   1463              default:
   1464              break;
   1465            } 
   1466            
   1467            /* Disable the Capture compare channel */
   1468            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_DMA_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
   1469            
   1470            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40010000
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD003             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_5
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40010400
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??HAL_TIM_PWM_Stop_DMA_6
   \                     ??HAL_TIM_PWM_Stop_DMA_5: (+1)
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE000             B.N      ??HAL_TIM_PWM_Stop_DMA_7
   \                     ??HAL_TIM_PWM_Stop_DMA_6: (+1)
   \   00000062   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_PWM_Stop_DMA_7: (+1)
   \   00000064   0xF241 0x1211      MOVW     R2,#+4369
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0xD00B             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_8
   1471            {
   1472              /* Disable the Main Output */
   1473              __HAL_TIM_MOE_DISABLE(htim);
   \   0000006C   0x6A01             LDR      R1,[R0, #+32]
   \   0000006E   0x4211             TST      R1,R2
   \   00000070   0xD108             BNE.N    ??HAL_TIM_PWM_Stop_DMA_8
   \   00000072   0x6A01             LDR      R1,[R0, #+32]
   \   00000074   0xF240 0x4344      MOVW     R3,#+1092
   \   00000078   0x4219             TST      R1,R3
   \   0000007A   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_DMA_8
   \   0000007C   0x6C41             LDR      R1,[R0, #+68]
   \   0000007E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000082   0x6441             STR      R1,[R0, #+68]
   1474            }
   1475            
   1476            /* Disable the Peripheral */
   1477            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_DMA_8: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6A01             LDR      R1,[R0, #+32]
   \   00000088   0x4211             TST      R1,R2
   \   0000008A   0xD108             BNE.N    ??HAL_TIM_PWM_Stop_DMA_9
   \   0000008C   0x6A01             LDR      R1,[R0, #+32]
   \   0000008E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000092   0x4211             TST      R1,R2
   \   00000094   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_DMA_9
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x0849             LSRS     R1,R1,#+1
   \   0000009A   0x0049             LSLS     R1,R1,#+1
   \   0000009C   0x6001             STR      R1,[R0, #+0]
   1478            
   1479            /* Change the htim state */
   1480            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_DMA_9: (+1)
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xF884 0x0039      STRB     R0,[R4, #+57]
   1481            
   1482            /* Return function status */
   1483            return HAL_OK;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xBD10             POP      {R4,PC}          ;; return
   1484          }
   1485          /**
   1486            * @}
   1487            */
   1488          
   1489          /** @defgroup TIM_Exported_Functions_Group4 Time Input Capture functions 
   1490           *  @brief    Time Input Capture functions 
   1491           *
   1492          @verbatim    
   1493            ==============================================================================
   1494                        ##### Time Input Capture functions #####
   1495            ==============================================================================
   1496           [..]  
   1497             This section provides functions allowing to:
   1498             (+) Initialize and configure the TIM Input Capture. 
   1499             (+) De-initialize the TIM Input Capture.
   1500             (+) Start the Time Input Capture.
   1501             (+) Stop the Time Input Capture.
   1502             (+) Start the Time Input Capture and enable interrupt.
   1503             (+) Stop the Time Input Capture and disable interrupt.
   1504             (+) Start the Time Input Capture and enable DMA transfer.
   1505             (+) Stop the Time Input Capture and disable DMA transfer.
   1506           
   1507          @endverbatim
   1508            * @{
   1509            */
   1510          /**
   1511            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1512            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1513            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1514            *                the configuration information for TIM module.
   1515            * @retval HAL status
   1516            */

   \                                 In section .text, align 2, keep-with-next
   1517          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1518          {
   \                     HAL_TIM_IC_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1519            /* Check the TIM handle allocation */
   1520            if(htim == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_TIM_IC_Init_0
   1521            {
   1522              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
   1523            }
   1524          
   1525            /* Check the parameters */
   1526            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1527            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1528            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
   1529          
   1530            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_IC_Init_0: (+1)
   \   0000000A   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE.N    ??HAL_TIM_IC_Init_1
   1531            { 
   1532              /* Allocate lock resource and initialize it */
   1533              htim->Lock = HAL_UNLOCKED;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF884 0x0038      STRB     R0,[R4, #+56]
   1534              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1535              HAL_TIM_IC_MspInit(htim);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_TIM_IC_MspInit
   1536            }
   1537            
   1538            /* Set the TIM state */
   1539            htim->State= HAL_TIM_STATE_BUSY;   
   \                     ??HAL_TIM_IC_Init_1: (+1)
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xF884 0x0039      STRB     R0,[R4, #+57]
   1540            
   1541            /* Init the base time for the input capture */  
   1542            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   \   00000024   0x1D21             ADDS     R1,R4,#+4
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       TIM_Base_SetConfig
   1543             
   1544            /* Initialize the TIM state*/
   1545            htim->State= HAL_TIM_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0039      STRB     R0,[R4, #+57]
   1546            
   1547            return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
   1548          }
   1549          
   1550          /**
   1551            * @brief  DeInitializes the TIM peripheral 
   1552            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1553            *                the configuration information for TIM module.
   1554            * @retval HAL status
   1555            */

   \                                 In section .text, align 2, keep-with-next
   1556          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1557          {
   \                     HAL_TIM_IC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1558            /* Check the parameters */
   1559            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1560          
   1561            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   1562            
   1563            /* Disable the TIM Peripheral Clock */
   1564            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIM_IC_DeInit_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_IC_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   1565              
   1566            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1567            HAL_TIM_IC_MspDeInit(htim);
   \                     ??HAL_TIM_IC_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_IC_MspDeInit
   1568              
   1569            /* Change TIM state */  
   1570            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   1571          
   1572            /* Release Lock */
   1573            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
   1574          
   1575            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   1576          }
   1577          
   1578          /**
   1579            * @brief  Initializes the TIM INput Capture MSP.
   1580            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1581            *                the configuration information for TIM module.
   1582            * @retval None
   1583            */

   \                                 In section .text, align 2, keep-with-next
   1584          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1585          {
   1586            /* Prevent unused argument(s) compilation warning */
   1587            UNUSED(htim);
   1588            /* NOTE : This function Should not be modified, when the callback is needed,
   1589                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1590             */
   1591          }
   \                     HAL_TIM_IC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1592          
   1593          /**
   1594            * @brief  DeInitializes TIM Input Capture MSP.
   1595            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1596            *                the configuration information for TIM module.
   1597            * @retval None
   1598            */

   \                                 In section .text, align 2, keep-with-next
   1599          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1600          {
   1601            /* Prevent unused argument(s) compilation warning */
   1602            UNUSED(htim);
   1603            /* NOTE : This function Should not be modified, when the callback is needed,
   1604                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1605             */
   1606          }
   \                     HAL_TIM_IC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1607          
   1608          /**
   1609            * @brief  Starts the TIM Input Capture measurement.
   1610            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1611            *                the configuration information for TIM module.
   1612            * @param  Channel: TIM Channels to be enabled.
   1613            *          This parameter can be one of the following values:
   1614            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1615            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1616            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1617            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1618            * @retval HAL status
   1619            */

   \                                 In section .text, align 2, keep-with-next
   1620          HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
   1621          {
   \                     HAL_TIM_IC_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1622            /* Check the parameters */
   1623            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1624            
   1625            /* Enable the Input Capture channel */
   1626            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
   1627              
   1628            /* Enable the Peripheral */
   1629            __HAL_TIM_ENABLE(htim);  
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000014   0x6001             STR      R1,[R0, #+0]
   1630          
   1631            /* Return function status */
   1632            return HAL_OK;  
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1633          } 
   1634          
   1635          /**
   1636            * @brief  Stops the TIM Input Capture measurement.
   1637            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1638            *                the configuration information for TIM module.
   1639            * @param  Channel: TIM Channels to be disabled.
   1640            *          This parameter can be one of the following values:
   1641            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1642            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1643            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1644            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1645            * @retval HAL status
   1646            */

   \                                 In section .text, align 2, keep-with-next
   1647          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1648          { 
   \                     HAL_TIM_IC_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1649            /* Check the parameters */
   1650            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1651            
   1652            /* Disable the Input Capture channel */
   1653            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
   1654            
   1655            /* Disable the Peripheral */
   1656            __HAL_TIM_DISABLE(htim); 
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6A01             LDR      R1,[R0, #+32]
   \   00000010   0xF241 0x1211      MOVW     R2,#+4369
   \   00000014   0x4211             TST      R1,R2
   \   00000016   0xD108             BNE.N    ??HAL_TIM_IC_Stop_0
   \   00000018   0x6A01             LDR      R1,[R0, #+32]
   \   0000001A   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD103             BNE.N    ??HAL_TIM_IC_Stop_0
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x0849             LSRS     R1,R1,#+1
   \   00000026   0x0049             LSLS     R1,R1,#+1
   \   00000028   0x6001             STR      R1,[R0, #+0]
   1657            
   1658            /* Return function status */
   1659            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_0: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
   1660          }
   1661          
   1662          /**
   1663            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1664            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1665            *                the configuration information for TIM module.
   1666            * @param  Channel: TIM Channels to be enabled.
   1667            *          This parameter can be one of the following values:
   1668            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1669            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1670            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1671            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1672            * @retval HAL status
   1673            */

   \                                 In section .text, align 2, keep-with-next
   1674          HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1675          {
   \                     HAL_TIM_IC_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1676            /* Check the parameters */
   1677            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1678            
   1679            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_IC_Start_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_IC_Start_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_IC_Start_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_IC_Start_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIM_IC_Start_IT_4
   1680            {
   1681              case TIM_CHANNEL_1:
   1682              {       
   1683                /* Enable the TIM Capture/Compare 1 interrupt */
   1684                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Start_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1685              }
   1686              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_IC_Start_IT_4
   1687              
   1688              case TIM_CHANNEL_2:
   1689              {
   1690                /* Enable the TIM Capture/Compare 2 interrupt */
   1691                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Start_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1692              }
   1693              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_IC_Start_IT_4
   1694              
   1695              case TIM_CHANNEL_3:
   1696              {
   1697                /* Enable the TIM Capture/Compare 3 interrupt */
   1698                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Start_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1699              }
   1700              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_IC_Start_IT_4
   1701              
   1702              case TIM_CHANNEL_4:
   1703              {
   1704                /* Enable the TIM Capture/Compare 4 interrupt */
   1705                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Start_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1706              }
   1707              break;
   1708              
   1709              default:
   1710              break;
   1711            }  
   1712            /* Enable the Input Capture channel */
   1713            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_IT_4: (+1)
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
   1714              
   1715            /* Enable the Peripheral */
   1716            __HAL_TIM_ENABLE(htim);  
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000054   0x6001             STR      R1,[R0, #+0]
   1717          
   1718            /* Return function status */
   1719            return HAL_OK;  
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
   1720          } 
   1721          
   1722          /**
   1723            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1724            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1725            *                the configuration information for TIM module.
   1726            * @param  Channel: TIM Channels to be disabled.
   1727            *          This parameter can be one of the following values:
   1728            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1729            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1730            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1731            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1732            * @retval HAL status
   1733            */

   \                                 In section .text, align 2, keep-with-next
   1734          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1735          {
   \                     HAL_TIM_IC_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1736            /* Check the parameters */
   1737            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1738            
   1739            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_IC_Stop_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_IC_Stop_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_IC_Stop_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIM_IC_Stop_IT_4
   1740            {
   1741              case TIM_CHANNEL_1:
   1742              {       
   1743                /* Disable the TIM Capture/Compare 1 interrupt */
   1744                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Stop_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1745              }
   1746              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_IC_Stop_IT_4
   1747              
   1748              case TIM_CHANNEL_2:
   1749              {
   1750                /* Disable the TIM Capture/Compare 2 interrupt */
   1751                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Stop_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF022 0x0204      BIC      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1752              }
   1753              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_IC_Stop_IT_4
   1754              
   1755              case TIM_CHANNEL_3:
   1756              {
   1757                /* Disable the TIM Capture/Compare 3 interrupt */
   1758                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Stop_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF022 0x0208      BIC      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1759              }
   1760              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_IC_Stop_IT_4
   1761              
   1762              case TIM_CHANNEL_4:
   1763              {
   1764                /* Disable the TIM Capture/Compare 4 interrupt */
   1765                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Stop_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1766              }
   1767              break;
   1768              
   1769              default:
   1770              break; 
   1771            } 
   1772            
   1773            /* Disable the Input Capture channel */
   1774            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_IC_Stop_IT_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
   1775            
   1776            /* Disable the Peripheral */
   1777            __HAL_TIM_DISABLE(htim); 
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6A01             LDR      R1,[R0, #+32]
   \   00000050   0xF241 0x1211      MOVW     R2,#+4369
   \   00000054   0x4211             TST      R1,R2
   \   00000056   0xD108             BNE.N    ??HAL_TIM_IC_Stop_IT_5
   \   00000058   0x6A01             LDR      R1,[R0, #+32]
   \   0000005A   0xF240 0x4244      MOVW     R2,#+1092
   \   0000005E   0x4211             TST      R1,R2
   \   00000060   0xD103             BNE.N    ??HAL_TIM_IC_Stop_IT_5
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0x0849             LSRS     R1,R1,#+1
   \   00000066   0x0049             LSLS     R1,R1,#+1
   \   00000068   0x6001             STR      R1,[R0, #+0]
   1778            
   1779            /* Return function status */
   1780            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_IT_5: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
   1781          }
   1782          
   1783          /**
   1784            * @brief  Starts the TIM Input Capture measurement on in DMA mode.
   1785            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1786            *                the configuration information for TIM module.
   1787            * @param  Channel: TIM Channels to be enabled.
   1788            *          This parameter can be one of the following values:
   1789            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1790            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1791            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1792            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1793            * @param  pData: The destination Buffer address.
   1794            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
   1795            * @retval HAL status
   1796            */

   \                                 In section .text, align 2, keep-with-next
   1797          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1798          {
   \                     HAL_TIM_IC_Start_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1799            /* Check the parameters */
   1800            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1801            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1802            
   1803            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000006   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD101             BNE.N    ??HAL_TIM_IC_Start_DMA_0
   1804            {
   1805               return HAL_BUSY;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   1806            }
   1807            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_IC_Start_DMA_0: (+1)
   \   00000012   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD108             BNE.N    ??HAL_TIM_IC_Start_DMA_1
   1808            {
   1809              if((pData == 0U) && (Length > 0U)) 
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD103             BNE.N    ??HAL_TIM_IC_Start_DMA_2
   \   0000001E   0x2B00             CMP      R3,#+0
   \   00000020   0xD001             BEQ.N    ??HAL_TIM_IC_Start_DMA_2
   1810              {
   1811                return HAL_ERROR;                                    
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}
   1812              }
   1813              else
   1814              {
   1815                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Start_DMA_2: (+1)
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF884 0x0039      STRB     R0,[R4, #+57]
   1816              }
   1817            }  
   1818             
   1819            switch (Channel)
   \                     ??HAL_TIM_IC_Start_DMA_1: (+1)
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0xD006             BEQ.N    ??HAL_TIM_IC_Start_DMA_3
   \   00000030   0x2804             CMP      R0,#+4
   \   00000032   0xD018             BEQ.N    ??HAL_TIM_IC_Start_DMA_4
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0xD02A             BEQ.N    ??HAL_TIM_IC_Start_DMA_5
   \   00000038   0x280C             CMP      R0,#+12
   \   0000003A   0xD03B             BEQ.N    ??HAL_TIM_IC_Start_DMA_6
   \   0000003C   0xE04C             B.N      ??HAL_TIM_IC_Start_DMA_7
   1820            {
   1821              case TIM_CHANNEL_1:
   1822              {
   1823                /* Set the DMA Period elapsed callback */
   1824                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_3: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000042   0x6A21             LDR      R1,[R4, #+32]
   \   00000044   0x63C8             STR      R0,[R1, #+60]
   1825               
   1826                /* Set the DMA error callback */
   1827                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000004A   0x6A21             LDR      R1,[R4, #+32]
   \   0000004C   0x64C8             STR      R0,[R1, #+76]
   1828                
   1829                /* Enable the DMA Stream */
   1830                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000054   0x6A20             LDR      R0,[R4, #+32]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Start_IT
   1831                
   1832                /* Enable the TIM Capture/Compare 1 DMA request */      
   1833                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x68C1             LDR      R1,[R0, #+12]
   \   0000005E   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000062   0x60C1             STR      R1,[R0, #+12]
   1834              }
   1835              break;
   \   00000064   0xE038             B.N      ??HAL_TIM_IC_Start_DMA_7
   1836              
   1837              case TIM_CHANNEL_2:
   1838              {
   1839                /* Set the DMA Period elapsed callback */
   1840                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_4: (+1)
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000006A   0x6A61             LDR      R1,[R4, #+36]
   \   0000006C   0x63C8             STR      R0,[R1, #+60]
   1841               
   1842                /* Set the DMA error callback */
   1843                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000072   0x6A61             LDR      R1,[R4, #+36]
   \   00000074   0x64C8             STR      R0,[R1, #+76]
   1844                
   1845                /* Enable the DMA Stream */
   1846                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0xF100 0x0138      ADD      R1,R0,#+56
   \   0000007C   0x6A60             LDR      R0,[R4, #+36]
   \   0000007E   0x.... 0x....      BL       HAL_DMA_Start_IT
   1847                
   1848                /* Enable the TIM Capture/Compare 2  DMA request */
   1849                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x68C1             LDR      R1,[R0, #+12]
   \   00000086   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000008A   0x60C1             STR      R1,[R0, #+12]
   1850              }
   1851              break;
   \   0000008C   0xE024             B.N      ??HAL_TIM_IC_Start_DMA_7
   1852              
   1853              case TIM_CHANNEL_3:
   1854              {
   1855                /* Set the DMA Period elapsed callback */
   1856                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_5: (+1)
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000092   0x6AA1             LDR      R1,[R4, #+40]
   \   00000094   0x63C8             STR      R0,[R1, #+60]
   1857               
   1858                /* Set the DMA error callback */
   1859                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   00000096   0x....             LDR.N    R0,??DataTable18_2
   \   00000098   0x6AA1             LDR      R1,[R4, #+40]
   \   0000009A   0x64C8             STR      R0,[R1, #+76]
   1860                
   1861                /* Enable the DMA Stream */
   1862                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0xF100 0x013C      ADD      R1,R0,#+60
   \   000000A2   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A4   0x.... 0x....      BL       HAL_DMA_Start_IT
   1863                
   1864                /* Enable the TIM Capture/Compare 3  DMA request */
   1865                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x68C1             LDR      R1,[R0, #+12]
   \   000000AC   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000B0   0x60C1             STR      R1,[R0, #+12]
   1866              }
   1867              break;
   \   000000B2   0xE011             B.N      ??HAL_TIM_IC_Start_DMA_7
   1868              
   1869              case TIM_CHANNEL_4:
   1870              {
   1871                /* Set the DMA Period elapsed callback */
   1872                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_6: (+1)
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000B8   0x6AE1             LDR      R1,[R4, #+44]
   \   000000BA   0x63C8             STR      R0,[R1, #+60]
   1873               
   1874                /* Set the DMA error callback */
   1875                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000BC   0x....             LDR.N    R0,??DataTable18_2
   \   000000BE   0x6AE1             LDR      R1,[R4, #+44]
   \   000000C0   0x64C8             STR      R0,[R1, #+76]
   1876                
   1877                /* Enable the DMA Stream */
   1878                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0xF100 0x0140      ADD      R1,R0,#+64
   \   000000C8   0x6AE0             LDR      R0,[R4, #+44]
   \   000000CA   0x.... 0x....      BL       HAL_DMA_Start_IT
   1879                
   1880                /* Enable the TIM Capture/Compare 4  DMA request */
   1881                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x68C1             LDR      R1,[R0, #+12]
   \   000000D2   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000D6   0x60C1             STR      R1,[R0, #+12]
   1882              }
   1883              break;
   1884              
   1885              default:
   1886              break;
   1887            }
   1888          
   1889            /* Enable the Input Capture channel */
   1890            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_DMA_7: (+1)
   \   000000D8   0x2201             MOVS     R2,#+1
   \   000000DA   0x4629             MOV      R1,R5
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x.... 0x....      BL       TIM_CCxChannelCmd
   1891             
   1892            /* Enable the Peripheral */
   1893            __HAL_TIM_ENABLE(htim); 
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x6801             LDR      R1,[R0, #+0]
   \   000000E6   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000EA   0x6001             STR      R1,[R0, #+0]
   1894            
   1895            /* Return function status */
   1896            return HAL_OK;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1897          }
   1898          
   1899          /**
   1900            * @brief  Stops the TIM Input Capture measurement on in DMA mode.
   1901            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1902            *                the configuration information for TIM module.
   1903            * @param  Channel: TIM Channels to be disabled.
   1904            *          This parameter can be one of the following values:
   1905            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1906            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1907            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1908            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1909            * @retval HAL status
   1910            */

   \                                 In section .text, align 2, keep-with-next
   1911          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1912          {
   \                     HAL_TIM_IC_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1913            /* Check the parameters */
   1914            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1915            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1916            
   1917            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_DMA_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_IC_Stop_DMA_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_IC_Stop_DMA_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_IC_Stop_DMA_3
   \   00000014   0xE016             B.N      ??HAL_TIM_IC_Stop_DMA_4
   1918            {
   1919              case TIM_CHANNEL_1:
   1920              {       
   1921                /* Disable the TIM Capture/Compare 1 DMA request */
   1922                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_IC_Stop_DMA_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF422 0x7200      BIC      R2,R2,#0x200
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1923              }
   1924              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_IC_Stop_DMA_4
   1925              
   1926              case TIM_CHANNEL_2:
   1927              {
   1928                /* Disable the TIM Capture/Compare 2 DMA request */
   1929                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_IC_Stop_DMA_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1930              }
   1931              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_IC_Stop_DMA_4
   1932              
   1933              case TIM_CHANNEL_3:
   1934              {
   1935                /* Disable the TIM Capture/Compare 3  DMA request */
   1936                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_IC_Stop_DMA_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1937              }
   1938              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_IC_Stop_DMA_4
   1939              
   1940              case TIM_CHANNEL_4:
   1941              {
   1942                /* Disable the TIM Capture/Compare 4  DMA request */
   1943                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Stop_DMA_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1944              }
   1945              break;
   1946              
   1947              default:
   1948              break;
   1949            }
   1950          
   1951            /* Disable the Input Capture channel */
   1952            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_DMA_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
   1953            
   1954            /* Disable the Peripheral */
   1955            __HAL_TIM_DISABLE(htim); 
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6A01             LDR      R1,[R0, #+32]
   \   00000050   0xF241 0x1211      MOVW     R2,#+4369
   \   00000054   0x4211             TST      R1,R2
   \   00000056   0xD108             BNE.N    ??HAL_TIM_IC_Stop_DMA_5
   \   00000058   0x6A01             LDR      R1,[R0, #+32]
   \   0000005A   0xF240 0x4244      MOVW     R2,#+1092
   \   0000005E   0x4211             TST      R1,R2
   \   00000060   0xD103             BNE.N    ??HAL_TIM_IC_Stop_DMA_5
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0x0849             LSRS     R1,R1,#+1
   \   00000066   0x0049             LSLS     R1,R1,#+1
   \   00000068   0x6001             STR      R1,[R0, #+0]
   1956            
   1957            /* Change the htim state */
   1958            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_Stop_DMA_5: (+1)
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xF884 0x0039      STRB     R0,[R4, #+57]
   1959            
   1960            /* Return function status */
   1961            return HAL_OK;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xBD10             POP      {R4,PC}          ;; return
   1962          }  
   1963          /**
   1964            * @}
   1965            */
   1966            
   1967          /** @defgroup TIM_Exported_Functions_Group5 Time One Pulse functions 
   1968           *  @brief    Time One Pulse functions 
   1969           *
   1970          @verbatim    
   1971            ==============================================================================
   1972                                  ##### Time One Pulse functions #####
   1973            ==============================================================================
   1974            [..]  
   1975              This section provides functions allowing to:
   1976              (+) Initialize and configure the TIM One Pulse. 
   1977              (+) De-initialize the TIM One Pulse.
   1978              (+) Start the Time One Pulse.
   1979              (+) Stop the Time One Pulse.
   1980              (+) Start the Time One Pulse and enable interrupt.
   1981              (+) Stop the Time One Pulse and disable interrupt.
   1982              (+) Start the Time One Pulse and enable DMA transfer.
   1983              (+) Stop the Time One Pulse and disable DMA transfer.
   1984           
   1985          @endverbatim
   1986            * @{
   1987            */
   1988          /**
   1989            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   1990            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1991            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1992            *                the configuration information for TIM module.
   1993            * @param  OnePulseMode: Select the One pulse mode.
   1994            *         This parameter can be one of the following values:
   1995            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   1996            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
   1997            * @retval HAL status
   1998            */

   \                                 In section .text, align 2, keep-with-next
   1999          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   2000          {
   \                     HAL_TIM_OnePulse_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2001            /* Check the TIM handle allocation */
   2002            if(htim == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_TIM_OnePulse_Init_0
   2003            {
   2004              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
   2005            }
   2006          
   2007            /* Check the parameters */
   2008            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2009            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2010            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2011            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   2012            
   2013            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OnePulse_Init_0: (+1)
   \   0000000E   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD105             BNE.N    ??HAL_TIM_OnePulse_Init_1
   2014            { 
   2015              /* Allocate lock resource and initialize it */
   2016              htim->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x0038      STRB     R0,[R4, #+56]
   2017              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2018              HAL_TIM_OnePulse_MspInit(htim);
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_TIM_OnePulse_MspInit
   2019            }
   2020            
   2021            /* Set the TIM state */
   2022            htim->State= HAL_TIM_STATE_BUSY;  
   \                     ??HAL_TIM_OnePulse_Init_1: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
   2023            
   2024            /* Configure the Time base in the One Pulse Mode */
   2025            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000028   0x1D21             ADDS     R1,R4,#+4
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_Base_SetConfig
   2026            
   2027            /* Reset the OPM Bit */
   2028            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0xF021 0x0108      BIC      R1,R1,#0x8
   \   00000038   0x6001             STR      R1,[R0, #+0]
   2029          
   2030            /* Configure the OPM Mode */
   2031            htim->Instance->CR1 |= OnePulseMode;
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x4329             ORRS     R1,R5,R1
   \   00000040   0x6001             STR      R1,[R0, #+0]
   2032             
   2033            /* Initialize the TIM state*/
   2034            htim->State= HAL_TIM_STATE_READY;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF884 0x0039      STRB     R0,[R4, #+57]
   2035            
   2036            return HAL_OK;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2037          }
   2038          
   2039          /**
   2040            * @brief  DeInitializes the TIM One Pulse  
   2041            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2042            *                the configuration information for TIM module.
   2043            * @retval HAL status
   2044            */

   \                                 In section .text, align 2, keep-with-next
   2045          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2046          {
   \                     HAL_TIM_OnePulse_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2047            /* Check the parameters */
   2048            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2049            
   2050            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   2051            
   2052            /* Disable the TIM Peripheral Clock */
   2053            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIM_OnePulse_DeInit_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_OnePulse_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   2054            
   2055            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2056            HAL_TIM_OnePulse_MspDeInit(htim);
   \                     ??HAL_TIM_OnePulse_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_OnePulse_MspDeInit
   2057              
   2058            /* Change TIM state */  
   2059            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   2060          
   2061            /* Release Lock */
   2062            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
   2063          
   2064            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   2065          }
   2066          
   2067          /**
   2068            * @brief  Initializes the TIM One Pulse MSP.
   2069            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2070            *                the configuration information for TIM module.
   2071            * @retval None
   2072            */

   \                                 In section .text, align 2, keep-with-next
   2073          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2074          {
   2075            /* Prevent unused argument(s) compilation warning */
   2076            UNUSED(htim);
   2077            /* NOTE : This function Should not be modified, when the callback is needed,
   2078                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2079             */
   2080          }
   \                     HAL_TIM_OnePulse_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2081          
   2082          /**
   2083            * @brief  DeInitializes TIM One Pulse MSP.
   2084            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2085            *                the configuration information for TIM module.
   2086            * @retval None
   2087            */

   \                                 In section .text, align 2, keep-with-next
   2088          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2089          {
   2090            /* Prevent unused argument(s) compilation warning */
   2091            UNUSED(htim);
   2092            /* NOTE : This function Should not be modified, when the callback is needed,
   2093                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2094             */
   2095          }
   \                     HAL_TIM_OnePulse_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2096          
   2097          /**
   2098            * @brief  Starts the TIM One Pulse signal generation.
   2099            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2100            *                the configuration information for TIM module.
   2101            * @param  OutputChannel : TIM Channels to be enabled.
   2102            *          This parameter can be one of the following values:
   2103            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2104            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2105            * @retval HAL status
   2106            */

   \                                 In section .text, align 2, keep-with-next
   2107          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2108          {
   \                     HAL_TIM_OnePulse_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2109            /* Enable the Capture compare and the Input Capture channels 
   2110              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2111              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2112              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2113              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2114              
   2115              No need to enable the counter, it's enabled automatically by hardware 
   2116              (the counter starts in response to a stimulus and generate a pulse */
   2117            
   2118            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2119            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2120            
   2121            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable16_1  ;; 0x40010000
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD002             BEQ.N    ??HAL_TIM_OnePulse_Start_0
   \   00000020   0x....             LDR.N    R1,??DataTable18  ;; 0x40010400
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD101             BNE.N    ??HAL_TIM_OnePulse_Start_1
   \                     ??HAL_TIM_OnePulse_Start_0: (+1)
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xE000             B.N      ??HAL_TIM_OnePulse_Start_2
   \                     ??HAL_TIM_OnePulse_Start_1: (+1)
   \   0000002A   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OnePulse_Start_2: (+1)
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD003             BEQ.N    ??HAL_TIM_OnePulse_Start_3
   2122            {
   2123              /* Enable the main output */
   2124              __HAL_TIM_MOE_ENABLE(htim);
   \   00000030   0x6C41             LDR      R1,[R0, #+68]
   \   00000032   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000036   0x6441             STR      R1,[R0, #+68]
   2125            }
   2126            
   2127            /* Return function status */
   2128            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_3: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
   2129          }
   2130          
   2131          /**
   2132            * @brief  Stops the TIM One Pulse signal generation.
   2133            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2134            *                the configuration information for TIM module.
   2135            * @param  OutputChannel : TIM Channels to be disable.
   2136            *          This parameter can be one of the following values:
   2137            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2138            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2139            * @retval HAL status
   2140            */

   \                                 In section .text, align 2, keep-with-next
   2141          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2142          {
   \                     HAL_TIM_OnePulse_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2143            /* Disable the Capture compare and the Input Capture channels 
   2144            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2145            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2146            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2147            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2148            
   2149            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2150            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2151              
   2152            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable16_1  ;; 0x40010000
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD002             BEQ.N    ??HAL_TIM_OnePulse_Stop_0
   \   00000020   0x....             LDR.N    R1,??DataTable18  ;; 0x40010400
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD101             BNE.N    ??HAL_TIM_OnePulse_Stop_1
   \                     ??HAL_TIM_OnePulse_Stop_0: (+1)
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xE000             B.N      ??HAL_TIM_OnePulse_Stop_2
   \                     ??HAL_TIM_OnePulse_Stop_1: (+1)
   \   0000002A   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OnePulse_Stop_2: (+1)
   \   0000002C   0xF241 0x1211      MOVW     R2,#+4369
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD00B             BEQ.N    ??HAL_TIM_OnePulse_Stop_3
   2153            {
   2154              /* Disable the Main Output */
   2155              __HAL_TIM_MOE_DISABLE(htim);
   \   00000034   0x6A01             LDR      R1,[R0, #+32]
   \   00000036   0x4211             TST      R1,R2
   \   00000038   0xD108             BNE.N    ??HAL_TIM_OnePulse_Stop_3
   \   0000003A   0x6A01             LDR      R1,[R0, #+32]
   \   0000003C   0xF240 0x4344      MOVW     R3,#+1092
   \   00000040   0x4219             TST      R1,R3
   \   00000042   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_3
   \   00000044   0x6C41             LDR      R1,[R0, #+68]
   \   00000046   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000004A   0x6441             STR      R1,[R0, #+68]
   2156            }
   2157              
   2158            /* Disable the Peripheral */
   2159            __HAL_TIM_DISABLE(htim); 
   \                     ??HAL_TIM_OnePulse_Stop_3: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6A01             LDR      R1,[R0, #+32]
   \   00000050   0x4211             TST      R1,R2
   \   00000052   0xD108             BNE.N    ??HAL_TIM_OnePulse_Stop_4
   \   00000054   0x6A01             LDR      R1,[R0, #+32]
   \   00000056   0xF240 0x4244      MOVW     R2,#+1092
   \   0000005A   0x4211             TST      R1,R2
   \   0000005C   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_4
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0x0849             LSRS     R1,R1,#+1
   \   00000062   0x0049             LSLS     R1,R1,#+1
   \   00000064   0x6001             STR      R1,[R0, #+0]
   2160            
   2161            /* Return function status */
   2162            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_4: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xBD10             POP      {R4,PC}          ;; return
   2163          }
   2164          
   2165          /**
   2166            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2167            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2168            *                the configuration information for TIM module.
   2169            * @param  OutputChannel : TIM Channels to be enabled.
   2170            *          This parameter can be one of the following values:
   2171            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2172            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2173            * @retval HAL status
   2174            */

   \                                 In section .text, align 2, keep-with-next
   2175          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2176          {
   \                     HAL_TIM_OnePulse_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2177            /* Enable the Capture compare and the Input Capture channels 
   2178              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2179              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2180              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2181              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2182              
   2183              No need to enable the counter, it's enabled automatically by hardware 
   2184              (the counter starts in response to a stimulus and generate a pulse */
   2185           
   2186            /* Enable the TIM Capture/Compare 1 interrupt */
   2187            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   2188            
   2189            /* Enable the TIM Capture/Compare 2 interrupt */
   2190            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x68C1             LDR      R1,[R0, #+12]
   \   00000012   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000016   0x60C1             STR      R1,[R0, #+12]
   2191            
   2192            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2193            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       TIM_CCxChannelCmd
   2194            
   2195            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x....             LDR.N    R1,??DataTable16_1  ;; 0x40010000
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD002             BEQ.N    ??HAL_TIM_OnePulse_Start_IT_0
   \   00000034   0x....             LDR.N    R1,??DataTable18  ;; 0x40010400
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD101             BNE.N    ??HAL_TIM_OnePulse_Start_IT_1
   \                     ??HAL_TIM_OnePulse_Start_IT_0: (+1)
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0xE000             B.N      ??HAL_TIM_OnePulse_Start_IT_2
   \                     ??HAL_TIM_OnePulse_Start_IT_1: (+1)
   \   0000003E   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OnePulse_Start_IT_2: (+1)
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD003             BEQ.N    ??HAL_TIM_OnePulse_Start_IT_3
   2196            {
   2197              /* Enable the main output */
   2198              __HAL_TIM_MOE_ENABLE(htim);
   \   00000044   0x6C41             LDR      R1,[R0, #+68]
   \   00000046   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000004A   0x6441             STR      R1,[R0, #+68]
   2199            }
   2200            
   2201            /* Return function status */
   2202            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_IT_3: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
   2203          }
   2204          
   2205          /**
   2206            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2207            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2208            *                the configuration information for TIM module.
   2209            * @param  OutputChannel : TIM Channels to be enabled.
   2210            *          This parameter can be one of the following values:
   2211            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2212            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2213            * @retval HAL status
   2214            */

   \                                 In section .text, align 2, keep-with-next
   2215          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2216          {
   \                     HAL_TIM_OnePulse_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2217            /* Disable the TIM Capture/Compare 1 interrupt */
   2218            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   2219            
   2220            /* Disable the TIM Capture/Compare 2 interrupt */
   2221            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x68C1             LDR      R1,[R0, #+12]
   \   00000012   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000016   0x60C1             STR      R1,[R0, #+12]
   2222            
   2223            /* Disable the Capture compare and the Input Capture channels 
   2224            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2225            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2226            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2227            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
   2228            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x4611             MOV      R1,R2
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2229            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       TIM_CCxChannelCmd
   2230              
   2231            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x40010000
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD002             BEQ.N    ??HAL_TIM_OnePulse_Stop_IT_0
   \   00000036   0x....             LDR.N    R1,??DataTable18  ;; 0x40010400
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD101             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_1
   \                     ??HAL_TIM_OnePulse_Stop_IT_0: (+1)
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0xE000             B.N      ??HAL_TIM_OnePulse_Stop_IT_2
   \                     ??HAL_TIM_OnePulse_Stop_IT_1: (+1)
   \   00000040   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OnePulse_Stop_IT_2: (+1)
   \   00000042   0xF241 0x1211      MOVW     R2,#+4369
   \   00000046   0x2900             CMP      R1,#+0
   \   00000048   0xD00B             BEQ.N    ??HAL_TIM_OnePulse_Stop_IT_3
   2232            {
   2233              /* Disable the Main Output */
   2234              __HAL_TIM_MOE_DISABLE(htim);
   \   0000004A   0x6A01             LDR      R1,[R0, #+32]
   \   0000004C   0x4211             TST      R1,R2
   \   0000004E   0xD108             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_3
   \   00000050   0x6A01             LDR      R1,[R0, #+32]
   \   00000052   0xF240 0x4344      MOVW     R3,#+1092
   \   00000056   0x4219             TST      R1,R3
   \   00000058   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_3
   \   0000005A   0x6C41             LDR      R1,[R0, #+68]
   \   0000005C   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000060   0x6441             STR      R1,[R0, #+68]
   2235            }
   2236              
   2237            /* Disable the Peripheral */
   2238             __HAL_TIM_DISABLE(htim);  
   \                     ??HAL_TIM_OnePulse_Stop_IT_3: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6A01             LDR      R1,[R0, #+32]
   \   00000066   0x4211             TST      R1,R2
   \   00000068   0xD108             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_4
   \   0000006A   0x6A01             LDR      R1,[R0, #+32]
   \   0000006C   0xF240 0x4244      MOVW     R2,#+1092
   \   00000070   0x4211             TST      R1,R2
   \   00000072   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_4
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0x0849             LSRS     R1,R1,#+1
   \   00000078   0x0049             LSLS     R1,R1,#+1
   \   0000007A   0x6001             STR      R1,[R0, #+0]
   2239            
   2240            /* Return function status */
   2241            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_IT_4: (+1)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xBD10             POP      {R4,PC}          ;; return
   2242          }
   2243          /**
   2244            * @}
   2245            */
   2246          
   2247          /** @defgroup TIM_Exported_Functions_Group6 Time Encoder functions 
   2248           *  @brief    Time Encoder functions 
   2249           *
   2250          @verbatim    
   2251            ==============================================================================
   2252                                    ##### Time Encoder functions #####
   2253            ==============================================================================
   2254            [..]
   2255              This section provides functions allowing to:
   2256              (+) Initialize and configure the TIM Encoder. 
   2257              (+) De-initialize the TIM Encoder.
   2258              (+) Start the Time Encoder.
   2259              (+) Stop the Time Encoder.
   2260              (+) Start the Time Encoder and enable interrupt.
   2261              (+) Stop the Time Encoder and disable interrupt.
   2262              (+) Start the Time Encoder and enable DMA transfer.
   2263              (+) Stop the Time Encoder and disable DMA transfer.
   2264           
   2265          @endverbatim
   2266            * @{
   2267            */
   2268          /**
   2269            * @brief  Initializes the TIM Encoder Interface and create the associated handle.
   2270            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2271            *                the configuration information for TIM module.
   2272            * @param  sConfig: TIM Encoder Interface configuration structure
   2273            * @retval HAL status
   2274            */

   \                                 In section .text, align 2, keep-with-next
   2275          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
   2276          {
   \                     HAL_TIM_Encoder_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2277            uint32_t tmpsmcr = 0U;
   2278            uint32_t tmpccmr1 = 0U;
   2279            uint32_t tmpccer = 0U;
   2280            
   2281            /* Check the TIM handle allocation */
   2282            if(htim == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_TIM_Encoder_Init_0
   2283            {
   2284              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD70             POP      {R4-R6,PC}
   2285            }
   2286             
   2287            /* Check the parameters */
   2288            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2289            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2290            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2291            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2292            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
   2293            assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
   2294            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2295            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2296            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2297            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2298          
   2299            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Encoder_Init_0: (+1)
   \   0000000E   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD105             BNE.N    ??HAL_TIM_Encoder_Init_1
   2300            { 
   2301              /* Allocate lock resource and initialize it */
   2302              htim->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x0038      STRB     R0,[R4, #+56]
   2303              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2304              HAL_TIM_Encoder_MspInit(htim);
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_TIM_Encoder_MspInit
   2305            }
   2306            
   2307            /* Set the TIM state */
   2308            htim->State= HAL_TIM_STATE_BUSY;   
   \                     ??HAL_TIM_Encoder_Init_1: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
   2309              
   2310            /* Reset the SMS bits */
   2311            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6881             LDR      R1,[R0, #+8]
   \   0000002C   0x08C9             LSRS     R1,R1,#+3
   \   0000002E   0x00C9             LSLS     R1,R1,#+3
   \   00000030   0x6081             STR      R1,[R0, #+8]
   2312            
   2313            /* Configure the Time base in the Encoder Mode */
   2314            TIM_Base_SetConfig(htim->Instance, &htim->Init);  
   \   00000032   0x1D21             ADDS     R1,R4,#+4
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       TIM_Base_SetConfig
   2315            
   2316            /* Get the TIMx SMCR register value */
   2317            tmpsmcr = htim->Instance->SMCR;
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6881             LDR      R1,[R0, #+8]
   2318          
   2319            /* Get the TIMx CCMR1 register value */
   2320            tmpccmr1 = htim->Instance->CCMR1;
   \   0000003E   0x6983             LDR      R3,[R0, #+24]
   2321          
   2322            /* Get the TIMx CCER register value */
   2323            tmpccer = htim->Instance->CCER;
   \   00000040   0x6A02             LDR      R2,[R0, #+32]
   2324          
   2325            /* Set the encoder Mode */
   2326            tmpsmcr |= sConfig->EncoderMode;
   2327          
   2328            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2329            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   2330            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
   2331            
   2332            /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2333            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   2334            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   2335            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
   2336            tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
   \   00000042   0x.... 0x....      LDR.W    R6,??DataTable21_1  ;; 0xfffffcfc
   \   00000046   0x4033             ANDS     R3,R6,R3
   \   00000048   0x68AE             LDR      R6,[R5, #+8]
   \   0000004A   0x4333             ORRS     R3,R6,R3
   \   0000004C   0x69AE             LDR      R6,[R5, #+24]
   \   0000004E   0xEA43 0x2306      ORR      R3,R3,R6, LSL #+8
   \   00000052   0x.... 0x....      LDR.W    R6,??DataTable22  ;; 0xffff0303
   \   00000056   0x4033             ANDS     R3,R6,R3
   \   00000058   0x68EE             LDR      R6,[R5, #+12]
   \   0000005A   0x4333             ORRS     R3,R6,R3
   \   0000005C   0x69EE             LDR      R6,[R5, #+28]
   \   0000005E   0xEA43 0x2306      ORR      R3,R3,R6, LSL #+8
   \   00000062   0x692E             LDR      R6,[R5, #+16]
   \   00000064   0xEA43 0x1306      ORR      R3,R3,R6, LSL #+4
   \   00000068   0x6A2E             LDR      R6,[R5, #+32]
   \   0000006A   0xEA43 0x3306      ORR      R3,R3,R6, LSL #+12
   2337          
   2338            /* Set the TI1 and the TI2 Polarities */
   2339            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   2340            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   2341            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
   \   0000006E   0xF022 0x02AA      BIC      R2,R2,#0xAA
   \   00000072   0x686E             LDR      R6,[R5, #+4]
   \   00000074   0x4332             ORRS     R2,R6,R2
   \   00000076   0x696E             LDR      R6,[R5, #+20]
   \   00000078   0xEA42 0x1206      ORR      R2,R2,R6, LSL #+4
   2342            
   2343            /* Write to TIMx SMCR */
   2344            htim->Instance->SMCR = tmpsmcr;
   \   0000007C   0x682D             LDR      R5,[R5, #+0]
   \   0000007E   0x4329             ORRS     R1,R5,R1
   \   00000080   0x6081             STR      R1,[R0, #+8]
   2345          
   2346            /* Write to TIMx CCMR1 */
   2347            htim->Instance->CCMR1 = tmpccmr1;
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6183             STR      R3,[R0, #+24]
   2348          
   2349            /* Write to TIMx CCER */
   2350            htim->Instance->CCER = tmpccer;
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6202             STR      R2,[R0, #+32]
   2351            
   2352            /* Initialize the TIM state*/
   2353            htim->State= HAL_TIM_STATE_READY;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xF884 0x0039      STRB     R0,[R4, #+57]
   2354            
   2355            return HAL_OK;
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xBD70             POP      {R4-R6,PC}       ;; return
   2356          }
   2357          
   2358          /**
   2359            * @brief  DeInitializes the TIM Encoder interface  
   2360            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2361            *                the configuration information for TIM module.
   2362            * @retval HAL status
   2363            */

   \                                 In section .text, align 2, keep-with-next
   2364          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2365          {
   \                     HAL_TIM_Encoder_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2366            /* Check the parameters */
   2367            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2368            
   2369            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   2370            
   2371            /* Disable the TIM Peripheral Clock */
   2372            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIM_Encoder_DeInit_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_Encoder_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   2373            
   2374            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2375            HAL_TIM_Encoder_MspDeInit(htim);
   \                     ??HAL_TIM_Encoder_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_Encoder_MspDeInit
   2376              
   2377            /* Change TIM state */  
   2378            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   2379           
   2380            /* Release Lock */
   2381            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
   2382          
   2383            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   2384          }
   2385          
   2386          /**
   2387            * @brief  Initializes the TIM Encoder Interface MSP.
   2388            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2389            *                the configuration information for TIM module.
   2390            * @retval None
   2391            */

   \                                 In section .text, align 2, keep-with-next
   2392          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2393          {
   2394            /* Prevent unused argument(s) compilation warning */
   2395            UNUSED(htim);
   2396            /* NOTE : This function Should not be modified, when the callback is needed,
   2397                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2398             */
   2399          }
   \                     HAL_TIM_Encoder_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2400          
   2401          /**
   2402            * @brief  DeInitializes TIM Encoder Interface MSP.
   2403            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2404            *                the configuration information for TIM module.
   2405            * @retval None
   2406            */

   \                                 In section .text, align 2, keep-with-next
   2407          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2408          {
   2409            /* Prevent unused argument(s) compilation warning */
   2410            UNUSED(htim);
   2411            /* NOTE : This function Should not be modified, when the callback is needed,
   2412                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2413             */
   2414          }
   \                     HAL_TIM_Encoder_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2415          
   2416          /**
   2417            * @brief  Starts the TIM Encoder Interface.
   2418            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2419            *                the configuration information for TIM module.
   2420            * @param  Channel: TIM Channels to be enabled.
   2421            *          This parameter can be one of the following values:
   2422            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2423            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2424            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2425            * @retval HAL status
   2426            */

   \                                 In section .text, align 2, keep-with-next
   2427          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2428          {
   \                     HAL_TIM_Encoder_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2429            /* Check the parameters */
   2430            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2431            
   2432            /* Enable the encoder interface channels */
   2433            switch (Channel)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD002             BEQ.N    ??HAL_TIM_Encoder_Start_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_Encoder_Start_1
   \   0000000C   0xE00B             B.N      ??HAL_TIM_Encoder_Start_2
   2434            {
   2435              case TIM_CHANNEL_1:
   2436              {
   2437                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_0: (+1)
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2438                break; 
   \   00000018   0xE00F             B.N      ??HAL_TIM_Encoder_Start_3
   2439              }
   2440              case TIM_CHANNEL_2:
   2441              { 
   2442                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \                     ??HAL_TIM_Encoder_Start_1: (+1)
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       TIM_CCxChannelCmd
   2443                break;
   \   00000024   0xE009             B.N      ??HAL_TIM_Encoder_Start_3
   2444              }  
   2445              default :
   2446              {
   2447               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_2: (+1)
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2448               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x2104             MOVS     R1,#+4
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       TIM_CCxChannelCmd
   2449               break; 
   2450              }
   2451            }  
   2452            /* Enable the Peripheral */
   2453            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000042   0x6001             STR      R1,[R0, #+0]
   2454            
   2455            /* Return function status */
   2456            return HAL_OK;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
   2457          }
   2458          
   2459          /**
   2460            * @brief  Stops the TIM Encoder Interface.
   2461            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2462            *                the configuration information for TIM module.
   2463            * @param  Channel: TIM Channels to be disabled.
   2464            *          This parameter can be one of the following values:
   2465            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2466            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2467            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2468            * @retval HAL status
   2469            */

   \                                 In section .text, align 2, keep-with-next
   2470          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2471          {
   \                     HAL_TIM_Encoder_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2472            /* Check the parameters */
   2473              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2474              
   2475             /* Disable the Input Capture channels 1 and 2
   2476              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2477            switch (Channel)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD002             BEQ.N    ??HAL_TIM_Encoder_Stop_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_Encoder_Stop_1
   \   0000000C   0xE00B             B.N      ??HAL_TIM_Encoder_Stop_2
   2478            {
   2479              case TIM_CHANNEL_1:
   2480              {
   2481                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_0: (+1)
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x4611             MOV      R1,R2
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2482                break; 
   \   00000018   0xE00F             B.N      ??HAL_TIM_Encoder_Stop_3
   2483              }
   2484              case TIM_CHANNEL_2:
   2485              { 
   2486                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_1: (+1)
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       TIM_CCxChannelCmd
   2487                break;
   \   00000024   0xE009             B.N      ??HAL_TIM_Encoder_Stop_3
   2488              }  
   2489              default :
   2490              {
   2491               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_2: (+1)
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x4611             MOV      R1,R2
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2492               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x2104             MOVS     R1,#+4
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       TIM_CCxChannelCmd
   2493               break; 
   2494              }
   2495            }  
   2496            /* Disable the Peripheral */
   2497            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6A01             LDR      R1,[R0, #+32]
   \   0000003E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000042   0x4211             TST      R1,R2
   \   00000044   0xD108             BNE.N    ??HAL_TIM_Encoder_Stop_4
   \   00000046   0x6A01             LDR      R1,[R0, #+32]
   \   00000048   0xF240 0x4244      MOVW     R2,#+1092
   \   0000004C   0x4211             TST      R1,R2
   \   0000004E   0xD103             BNE.N    ??HAL_TIM_Encoder_Stop_4
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x0849             LSRS     R1,R1,#+1
   \   00000054   0x0049             LSLS     R1,R1,#+1
   \   00000056   0x6001             STR      R1,[R0, #+0]
   2498            
   2499            /* Return function status */
   2500            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Stop_4: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
   2501          }
   2502          
   2503          /**
   2504            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2505            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2506            *                the configuration information for TIM module.
   2507            * @param  Channel: TIM Channels to be enabled.
   2508            *          This parameter can be one of the following values:
   2509            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2510            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2511            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2512            * @retval HAL status
   2513            */

   \                                 In section .text, align 2, keep-with-next
   2514          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2515          {
   \                     HAL_TIM_Encoder_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2516            /* Check the parameters */
   2517            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2518            
   2519            /* Enable the encoder interface channels */
   2520            /* Enable the capture compare Interrupts 1 and/or 2 */
   2521            switch (Channel)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD002             BEQ.N    ??HAL_TIM_Encoder_Start_IT_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD00B             BEQ.N    ??HAL_TIM_Encoder_Start_IT_1
   \   0000000C   0xE015             B.N      ??HAL_TIM_Encoder_Start_IT_2
   2522            {
   2523              case TIM_CHANNEL_1:
   2524              {
   2525                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_0: (+1)
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2526                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C1             LDR      R1,[R0, #+12]
   \   0000001C   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000020   0x60C1             STR      R1,[R0, #+12]
   2527                break; 
   \   00000022   0xE01E             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2528              }
   2529              case TIM_CHANNEL_2:
   2530              { 
   2531                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_1: (+1)
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0x2104             MOVS     R1,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2532                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C1             LDR      R1,[R0, #+12]
   \   00000032   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000036   0x60C1             STR      R1,[R0, #+12]
   2533                break;
   \   00000038   0xE013             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2534              }  
   2535              default :
   2536              {
   2537               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_2: (+1)
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      BL       TIM_CCxChannelCmd
   2538               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x2104             MOVS     R1,#+4
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2539               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x68C1             LDR      R1,[R0, #+12]
   \   00000052   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000056   0x60C1             STR      R1,[R0, #+12]
   2540               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x68C1             LDR      R1,[R0, #+12]
   \   0000005C   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000060   0x60C1             STR      R1,[R0, #+12]
   2541               break; 
   2542              }
   2543            }
   2544            
   2545            /* Enable the Peripheral */
   2546            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_IT_3: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6801             LDR      R1,[R0, #+0]
   \   00000066   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000006A   0x6001             STR      R1,[R0, #+0]
   2547            
   2548            /* Return function status */
   2549            return HAL_OK;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
   2550          }
   2551          
   2552          /**
   2553            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2554            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2555            *                the configuration information for TIM module.
   2556            * @param  Channel: TIM Channels to be disabled.
   2557            *          This parameter can be one of the following values:
   2558            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2559            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2560            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2561            * @retval HAL status
   2562            */

   \                                 In section .text, align 2, keep-with-next
   2563          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2564          {
   \                     HAL_TIM_Encoder_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2565            /* Check the parameters */
   2566            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2567              
   2568            /* Disable the Input Capture channels 1 and 2
   2569              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2570            if(Channel == TIM_CHANNEL_1)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD109             BNE.N    ??HAL_TIM_Encoder_Stop_IT_0
   2571            {
   2572              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x4611             MOV      R1,R2
   \   0000000E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2573              
   2574              /* Disable the capture compare Interrupts 1 */
   2575            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C1             LDR      R1,[R0, #+12]
   \   00000016   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000001A   0x60C1             STR      R1,[R0, #+12]
   \   0000001C   0xE01E             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2576            }  
   2577            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_IT_0: (+1)
   \   0000001E   0x2904             CMP      R1,#+4
   \   00000020   0xD109             BNE.N    ??HAL_TIM_Encoder_Stop_IT_2
   2578            {  
   2579              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0x.... 0x....      BL       TIM_CCxChannelCmd
   2580              
   2581              /* Disable the capture compare Interrupts 2 */
   2582            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x68C1             LDR      R1,[R0, #+12]
   \   0000002E   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000032   0x60C1             STR      R1,[R0, #+12]
   \   00000034   0xE012             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2583            }  
   2584            else
   2585            {
   2586              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_IT_2: (+1)
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x4611             MOV      R1,R2
   \   0000003A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2587              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x2104             MOVS     R1,#+4
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_CCxChannelCmd
   2588              
   2589              /* Disable the capture compare Interrupts 1 and 2 */
   2590              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x68C1             LDR      R1,[R0, #+12]
   \   0000004C   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000050   0x60C1             STR      R1,[R0, #+12]
   2591              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C1             LDR      R1,[R0, #+12]
   \   00000056   0xF021 0x0104      BIC      R1,R1,#0x4
   \   0000005A   0x60C1             STR      R1,[R0, #+12]
   2592            }
   2593              
   2594            /* Disable the Peripheral */
   2595            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_IT_1: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6A01             LDR      R1,[R0, #+32]
   \   00000060   0xF241 0x1211      MOVW     R2,#+4369
   \   00000064   0x4211             TST      R1,R2
   \   00000066   0xD108             BNE.N    ??HAL_TIM_Encoder_Stop_IT_3
   \   00000068   0x6A01             LDR      R1,[R0, #+32]
   \   0000006A   0xF240 0x4244      MOVW     R2,#+1092
   \   0000006E   0x4211             TST      R1,R2
   \   00000070   0xD103             BNE.N    ??HAL_TIM_Encoder_Stop_IT_3
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0x0849             LSRS     R1,R1,#+1
   \   00000076   0x0049             LSLS     R1,R1,#+1
   \   00000078   0x6001             STR      R1,[R0, #+0]
   2596            
   2597            /* Change the htim state */
   2598            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_IT_3: (+1)
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0039      STRB     R0,[R4, #+57]
   2599            
   2600            /* Return function status */
   2601            return HAL_OK;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
   2602          }
   2603          
   2604          /**
   2605            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2606            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2607            *                the configuration information for TIM module.
   2608            * @param  Channel: TIM Channels to be enabled.
   2609            *          This parameter can be one of the following values:
   2610            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2611            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2612            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2613            * @param  pData1: The destination Buffer address for IC1.
   2614            * @param  pData2: The destination Buffer address for IC2.
   2615            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
   2616            * @retval HAL status
   2617            */

   \                                 In section .text, align 2, keep-with-next
   2618          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
   2619          {
   \                     HAL_TIM_Encoder_Start_DMA: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x461E             MOV      R6,R3
   2620            /* Check the parameters */
   2621            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2622            
   2623            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF995 0x0039      LDRSB    R0,[R5, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_Encoder_Start_DMA_0
   2624            {
   2625               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE08C             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   2626            }
   \                     ??HAL_TIM_Encoder_Start_DMA_0: (+1)
   \   00000014   0x9C06             LDR      R4,[SP, #+24]
   2627            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000016   0xF995 0x0039      LDRSB    R0,[R5, #+57]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD10A             BNE.N    ??HAL_TIM_Encoder_Start_DMA_2
   2628            {
   2629              if((((pData1 == 0U) || (pData2 == 0U) )) && (Length > 0U)) 
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_3
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD103             BNE.N    ??HAL_TIM_Encoder_Start_DMA_4
   \                     ??HAL_TIM_Encoder_Start_DMA_3: (+1)
   \   00000026   0x2C00             CMP      R4,#+0
   \   00000028   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_4
   2630              {
   2631                return HAL_ERROR;                                    
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE07F             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   2632              }
   2633              else
   2634              {
   2635                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Start_DMA_4: (+1)
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xF885 0x0039      STRB     R0,[R5, #+57]
   2636              }
   2637            }  
   2638             
   2639            switch (Channel)
   \                     ??HAL_TIM_Encoder_Start_DMA_2: (+1)
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD004             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_5
   \   00000038   0x2904             CMP      R1,#+4
   \   0000003A   0xD021             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_6
   \   0000003C   0x2918             CMP      R1,#+24
   \   0000003E   0xD03F             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_7
   \   00000040   0xE074             B.N      ??HAL_TIM_Encoder_Start_DMA_8
   2640            {
   2641              case TIM_CHANNEL_1:
   2642              {
   2643                /* Set the DMA Period elapsed callback */
   2644                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_5: (+1)
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000046   0x6A29             LDR      R1,[R5, #+32]
   \   00000048   0x63C8             STR      R0,[R1, #+60]
   2645               
   2646                /* Set the DMA error callback */
   2647                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable23
   \   0000004E   0x6A29             LDR      R1,[R5, #+32]
   \   00000050   0x64C8             STR      R0,[R1, #+76]
   2648                
   2649                /* Enable the DMA Stream */
   2650                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
   \   00000052   0x4623             MOV      R3,R4
   \   00000054   0x6828             LDR      R0,[R5, #+0]
   \   00000056   0xF100 0x0134      ADD      R1,R0,#+52
   \   0000005A   0x6A28             LDR      R0,[R5, #+32]
   \   0000005C   0x.... 0x....      BL       HAL_DMA_Start_IT
   2651                
   2652                /* Enable the TIM Input Capture DMA request */      
   2653                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000060   0x6828             LDR      R0,[R5, #+0]
   \   00000062   0x68C1             LDR      R1,[R0, #+12]
   \   00000064   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000068   0x60C1             STR      R1,[R0, #+12]
   2654                      
   2655                /* Enable the Peripheral */
   2656                __HAL_TIM_ENABLE(htim);
   \   0000006A   0x6828             LDR      R0,[R5, #+0]
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000072   0x6001             STR      R1,[R0, #+0]
   2657                
   2658                /* Enable the Capture compare channel */
   2659                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000074   0x2201             MOVS     R2,#+1
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0x6828             LDR      R0,[R5, #+0]
   \   0000007A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2660              }
   2661              break;
   \   0000007E   0xE055             B.N      ??HAL_TIM_Encoder_Start_DMA_8
   2662              
   2663              case TIM_CHANNEL_2:
   2664              {
   2665                /* Set the DMA Period elapsed callback */
   2666                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_6: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000084   0x6A69             LDR      R1,[R5, #+36]
   \   00000086   0x63C8             STR      R0,[R1, #+60]
   2667               
   2668                /* Set the DMA error callback */
   2669                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable23
   \   0000008C   0x6A69             LDR      R1,[R5, #+36]
   \   0000008E   0x64C8             STR      R0,[R1, #+76]
   2670                /* Enable the DMA Stream */
   2671                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   \   00000090   0x4623             MOV      R3,R4
   \   00000092   0x4632             MOV      R2,R6
   \   00000094   0x6828             LDR      R0,[R5, #+0]
   \   00000096   0xF100 0x0138      ADD      R1,R0,#+56
   \   0000009A   0x6A68             LDR      R0,[R5, #+36]
   \   0000009C   0x.... 0x....      BL       HAL_DMA_Start_IT
   2672                
   2673                /* Enable the TIM Input Capture  DMA request */
   2674                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   000000A0   0x6828             LDR      R0,[R5, #+0]
   \   000000A2   0x68C1             LDR      R1,[R0, #+12]
   \   000000A4   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000A8   0x60C1             STR      R1,[R0, #+12]
   2675               
   2676                /* Enable the Peripheral */
   2677                __HAL_TIM_ENABLE(htim);
   \   000000AA   0x6828             LDR      R0,[R5, #+0]
   \   000000AC   0x6801             LDR      R1,[R0, #+0]
   \   000000AE   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000B2   0x6001             STR      R1,[R0, #+0]
   2678                
   2679                /* Enable the Capture compare channel */
   2680                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   000000B4   0x2201             MOVS     R2,#+1
   \   000000B6   0x2104             MOVS     R1,#+4
   \   000000B8   0x6828             LDR      R0,[R5, #+0]
   \   000000BA   0x.... 0x....      BL       TIM_CCxChannelCmd
   2681              }
   2682              break;
   \   000000BE   0xE035             B.N      ??HAL_TIM_Encoder_Start_DMA_8
   2683              
   2684              case TIM_CHANNEL_ALL:
   2685              {
   2686                /* Set the DMA Period elapsed callback */
   2687                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_7: (+1)
   \   000000C0   0x.... 0x....      LDR.W    R7,??DataTable20
   \   000000C4   0x6A28             LDR      R0,[R5, #+32]
   \   000000C6   0x63C7             STR      R7,[R0, #+60]
   2688               
   2689                /* Set the DMA error callback */
   2690                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   000000C8   0x.... 0x....      LDR.W    R8,??DataTable23
   \   000000CC   0x6A28             LDR      R0,[R5, #+32]
   \   000000CE   0xF8C0 0x804C      STR      R8,[R0, #+76]
   2691                
   2692                /* Enable the DMA Stream */
   2693                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
   \   000000D2   0x4623             MOV      R3,R4
   \   000000D4   0x6828             LDR      R0,[R5, #+0]
   \   000000D6   0xF100 0x0134      ADD      R1,R0,#+52
   \   000000DA   0x6A28             LDR      R0,[R5, #+32]
   \   000000DC   0x.... 0x....      BL       HAL_DMA_Start_IT
   2694                
   2695                /* Set the DMA Period elapsed callback */
   2696                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \   000000E0   0x6A68             LDR      R0,[R5, #+36]
   \   000000E2   0x63C7             STR      R7,[R0, #+60]
   2697               
   2698                /* Set the DMA error callback */
   2699                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   000000E4   0x6A68             LDR      R0,[R5, #+36]
   \   000000E6   0xF8C0 0x804C      STR      R8,[R0, #+76]
   2700                
   2701                /* Enable the DMA Stream */
   2702                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   \   000000EA   0x4623             MOV      R3,R4
   \   000000EC   0x4632             MOV      R2,R6
   \   000000EE   0x6828             LDR      R0,[R5, #+0]
   \   000000F0   0xF100 0x0138      ADD      R1,R0,#+56
   \   000000F4   0x6A68             LDR      R0,[R5, #+36]
   \   000000F6   0x.... 0x....      BL       HAL_DMA_Start_IT
   2703                    
   2704               /* Enable the Peripheral */
   2705                __HAL_TIM_ENABLE(htim);
   \   000000FA   0x6828             LDR      R0,[R5, #+0]
   \   000000FC   0x6801             LDR      R1,[R0, #+0]
   \   000000FE   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000102   0x6001             STR      R1,[R0, #+0]
   2706                
   2707                /* Enable the Capture compare channel */
   2708                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000104   0x2201             MOVS     R2,#+1
   \   00000106   0x2100             MOVS     R1,#+0
   \   00000108   0x6828             LDR      R0,[R5, #+0]
   \   0000010A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2709                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   0000010E   0x2201             MOVS     R2,#+1
   \   00000110   0x2104             MOVS     R1,#+4
   \   00000112   0x6828             LDR      R0,[R5, #+0]
   \   00000114   0x.... 0x....      BL       TIM_CCxChannelCmd
   2710                
   2711                /* Enable the TIM Input Capture  DMA request */
   2712                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000118   0x6828             LDR      R0,[R5, #+0]
   \   0000011A   0x68C1             LDR      R1,[R0, #+12]
   \   0000011C   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000120   0x60C1             STR      R1,[R0, #+12]
   2713                /* Enable the TIM Input Capture  DMA request */
   2714                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000122   0x6828             LDR      R0,[R5, #+0]
   \   00000124   0x68C1             LDR      R1,[R0, #+12]
   \   00000126   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000012A   0x60C1             STR      R1,[R0, #+12]
   2715              }
   2716              break;
   2717              
   2718              default:
   2719              break;
   2720            }  
   2721            /* Return function status */
   2722            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Start_DMA_8: (+1)
   \   0000012C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Start_DMA_1: (+1)
   \   0000012E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2723          }
   2724          
   2725          /**
   2726            * @brief  Stops the TIM Encoder Interface in DMA mode.
   2727            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2728            *                the configuration information for TIM module.
   2729            * @param  Channel: TIM Channels to be enabled.
   2730            *          This parameter can be one of the following values:
   2731            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2732            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2733            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2734            * @retval HAL status
   2735            */

   \                                 In section .text, align 2, keep-with-next
   2736          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2737          {
   \                     HAL_TIM_Encoder_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2738            /* Check the parameters */
   2739            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2740            
   2741            /* Disable the Input Capture channels 1 and 2
   2742              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2743            if(Channel == TIM_CHANNEL_1)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD109             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_0
   2744            {
   2745              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x4611             MOV      R1,R2
   \   0000000E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2746              
   2747              /* Disable the capture compare DMA Request 1 */
   2748              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C1             LDR      R1,[R0, #+12]
   \   00000016   0xF421 0x7100      BIC      R1,R1,#0x200
   \   0000001A   0x60C1             STR      R1,[R0, #+12]
   \   0000001C   0xE01E             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   2749            }  
   2750            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_DMA_0: (+1)
   \   0000001E   0x2904             CMP      R1,#+4
   \   00000020   0xD109             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_2
   2751            {  
   2752              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0x.... 0x....      BL       TIM_CCxChannelCmd
   2753              
   2754              /* Disable the capture compare DMA Request 2 */
   2755              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x68C1             LDR      R1,[R0, #+12]
   \   0000002E   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000032   0x60C1             STR      R1,[R0, #+12]
   \   00000034   0xE012             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   2756            }  
   2757            else
   2758            {
   2759              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_DMA_2: (+1)
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x4611             MOV      R1,R2
   \   0000003A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2760              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x2104             MOVS     R1,#+4
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_CCxChannelCmd
   2761              
   2762              /* Disable the capture compare DMA Request 1 and 2 */
   2763              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x68C1             LDR      R1,[R0, #+12]
   \   0000004C   0xF421 0x7100      BIC      R1,R1,#0x200
   \   00000050   0x60C1             STR      R1,[R0, #+12]
   2764              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C1             LDR      R1,[R0, #+12]
   \   00000056   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000005A   0x60C1             STR      R1,[R0, #+12]
   2765            }
   2766            
   2767            /* Disable the Peripheral */
   2768            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_DMA_1: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6A01             LDR      R1,[R0, #+32]
   \   00000060   0xF241 0x1211      MOVW     R2,#+4369
   \   00000064   0x4211             TST      R1,R2
   \   00000066   0xD108             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_3
   \   00000068   0x6A01             LDR      R1,[R0, #+32]
   \   0000006A   0xF240 0x4244      MOVW     R2,#+1092
   \   0000006E   0x4211             TST      R1,R2
   \   00000070   0xD103             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_3
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0x0849             LSRS     R1,R1,#+1
   \   00000076   0x0049             LSLS     R1,R1,#+1
   \   00000078   0x6001             STR      R1,[R0, #+0]
   2769            
   2770            /* Change the htim state */
   2771            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_DMA_3: (+1)
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0039      STRB     R0,[R4, #+57]
   2772            
   2773            /* Return function status */
   2774            return HAL_OK;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
   2775          }
   2776          /**
   2777            * @}
   2778            */
   2779            
   2780          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management 
   2781           *  @brief    IRQ handler management 
   2782           *
   2783          @verbatim   
   2784            ==============================================================================
   2785                                  ##### IRQ handler management #####
   2786            ==============================================================================  
   2787            [..]  
   2788              This section provides Timer IRQ handler function.
   2789                         
   2790          @endverbatim
   2791            * @{
   2792            */
   2793          /**
   2794            * @brief  This function handles TIM interrupts requests.
   2795            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2796            *                the configuration information for TIM module.
   2797            * @retval None
   2798            */

   \                                 In section .text, align 2, keep-with-next
   2799          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   2800          {
   \                     HAL_TIM_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2801            /* Capture compare 1 event */
   2802            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6901             LDR      R1,[R0, #+16]
   \   00000008   0x0789             LSLS     R1,R1,#+30
   \   0000000A   0xD517             BPL.N    ??HAL_TIM_IRQHandler_0
   2803            {
   2804              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
   \   0000000C   0x68C1             LDR      R1,[R0, #+12]
   \   0000000E   0x0789             LSLS     R1,R1,#+30
   \   00000010   0xD514             BPL.N    ??HAL_TIM_IRQHandler_0
   2805              {
   2806                {
   2807                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   \   00000012   0xF06F 0x0102      MVN      R1,#+2
   \   00000016   0x6101             STR      R1,[R0, #+16]
   2808                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x7620             STRB     R0,[R4, #+24]
   2809                  
   2810                  /* Input capture event */
   2811                  if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0xF010 0x0F03      TST      R0,#0x3
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_1
   2812                  {
   2813                    HAL_TIM_IC_CaptureCallback(htim);
   \   00000028   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   0000002C   0xE004             B.N      ??HAL_TIM_IRQHandler_2
   2814                  }
   2815                  /* Output compare event */
   2816                  else
   2817                  {
   2818                    HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_1: (+1)
   \   0000002E   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2819                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2820                  }
   2821                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_2: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7620             STRB     R0,[R4, #+24]
   2822                }
   2823              }
   2824            }
   2825            /* Capture compare 2 event */
   2826            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   \                     ??HAL_TIM_IRQHandler_0: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6901             LDR      R1,[R0, #+16]
   \   00000040   0x0749             LSLS     R1,R1,#+29
   \   00000042   0xD517             BPL.N    ??HAL_TIM_IRQHandler_3
   2827            {
   2828              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
   \   00000044   0x68C1             LDR      R1,[R0, #+12]
   \   00000046   0x0749             LSLS     R1,R1,#+29
   \   00000048   0xD514             BPL.N    ??HAL_TIM_IRQHandler_3
   2829              {
   2830                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   \   0000004A   0xF06F 0x0104      MVN      R1,#+4
   \   0000004E   0x6101             STR      R1,[R0, #+16]
   2831                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0x7620             STRB     R0,[R4, #+24]
   2832                /* Input capture event */
   2833                if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6980             LDR      R0,[R0, #+24]
   \   00000058   0xF410 0x7F40      TST      R0,#0x300
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_4
   2834                {          
   2835                  HAL_TIM_IC_CaptureCallback(htim);
   \   00000060   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   00000064   0xE004             B.N      ??HAL_TIM_IRQHandler_5
   2836                }
   2837                /* Output compare event */
   2838                else
   2839                {
   2840                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_4: (+1)
   \   00000066   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2841                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2842                }
   2843                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_5: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x7620             STRB     R0,[R4, #+24]
   2844              }
   2845            }
   2846            /* Capture compare 3 event */
   2847            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   \                     ??HAL_TIM_IRQHandler_3: (+1)
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6901             LDR      R1,[R0, #+16]
   \   00000078   0x0709             LSLS     R1,R1,#+28
   \   0000007A   0xD517             BPL.N    ??HAL_TIM_IRQHandler_6
   2848            {
   2849              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
   \   0000007C   0x68C1             LDR      R1,[R0, #+12]
   \   0000007E   0x0709             LSLS     R1,R1,#+28
   \   00000080   0xD514             BPL.N    ??HAL_TIM_IRQHandler_6
   2850              {
   2851                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   \   00000082   0xF06F 0x0108      MVN      R1,#+8
   \   00000086   0x6101             STR      R1,[R0, #+16]
   2852                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000088   0x2004             MOVS     R0,#+4
   \   0000008A   0x7620             STRB     R0,[R4, #+24]
   2853                /* Input capture event */
   2854                if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x69C0             LDR      R0,[R0, #+28]
   \   00000090   0xF010 0x0F03      TST      R0,#0x3
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_7
   2855                {          
   2856                  HAL_TIM_IC_CaptureCallback(htim);
   \   00000098   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   0000009C   0xE004             B.N      ??HAL_TIM_IRQHandler_8
   2857                }
   2858                /* Output compare event */
   2859                else
   2860                {
   2861                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_7: (+1)
   \   0000009E   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2862                  HAL_TIM_PWM_PulseFinishedCallback(htim); 
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2863                }
   2864                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_8: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x7620             STRB     R0,[R4, #+24]
   2865              }
   2866            }
   2867            /* Capture compare 4 event */
   2868            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   \                     ??HAL_TIM_IRQHandler_6: (+1)
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6901             LDR      R1,[R0, #+16]
   \   000000B0   0x06C9             LSLS     R1,R1,#+27
   \   000000B2   0xD517             BPL.N    ??HAL_TIM_IRQHandler_9
   2869            {
   2870              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
   \   000000B4   0x68C1             LDR      R1,[R0, #+12]
   \   000000B6   0x06C9             LSLS     R1,R1,#+27
   \   000000B8   0xD514             BPL.N    ??HAL_TIM_IRQHandler_9
   2871              {
   2872                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   \   000000BA   0xF06F 0x0110      MVN      R1,#+16
   \   000000BE   0x6101             STR      R1,[R0, #+16]
   2873                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   000000C0   0x2008             MOVS     R0,#+8
   \   000000C2   0x7620             STRB     R0,[R4, #+24]
   2874                /* Input capture event */
   2875                if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x69C0             LDR      R0,[R0, #+28]
   \   000000C8   0xF410 0x7F40      TST      R0,#0x300
   \   000000CC   0x4620             MOV      R0,R4
   \   000000CE   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_10
   2876                {          
   2877                  HAL_TIM_IC_CaptureCallback(htim);
   \   000000D0   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   000000D4   0xE004             B.N      ??HAL_TIM_IRQHandler_11
   2878                }
   2879                /* Output compare event */
   2880                else
   2881                {
   2882                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_10: (+1)
   \   000000D6   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2883                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   000000DA   0x4620             MOV      R0,R4
   \   000000DC   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2884                }
   2885                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_11: (+1)
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x7620             STRB     R0,[R4, #+24]
   2886              }
   2887            }
   2888            /* TIM Update event */
   2889            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   \                     ??HAL_TIM_IRQHandler_9: (+1)
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6901             LDR      R1,[R0, #+16]
   \   000000E8   0x07C9             LSLS     R1,R1,#+31
   \   000000EA   0xD508             BPL.N    ??HAL_TIM_IRQHandler_12
   2890            {
   2891              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
   \   000000EC   0x68C1             LDR      R1,[R0, #+12]
   \   000000EE   0x07C9             LSLS     R1,R1,#+31
   \   000000F0   0xD505             BPL.N    ??HAL_TIM_IRQHandler_12
   2892              {
   2893                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   \   000000F2   0xF06F 0x0101      MVN      R1,#+1
   \   000000F6   0x6101             STR      R1,[R0, #+16]
   2894                HAL_TIM_PeriodElapsedCallback(htim);
   \   000000F8   0x4620             MOV      R0,R4
   \   000000FA   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   2895              }
   2896            }
   2897            /* TIM Break input event */
   2898            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
   \                     ??HAL_TIM_IRQHandler_12: (+1)
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x6901             LDR      R1,[R0, #+16]
   \   00000102   0x0609             LSLS     R1,R1,#+24
   \   00000104   0xD508             BPL.N    ??HAL_TIM_IRQHandler_13
   2899            {
   2900              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
   \   00000106   0x68C1             LDR      R1,[R0, #+12]
   \   00000108   0x0609             LSLS     R1,R1,#+24
   \   0000010A   0xD505             BPL.N    ??HAL_TIM_IRQHandler_13
   2901              {
   2902                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   \   0000010C   0xF06F 0x0180      MVN      R1,#+128
   \   00000110   0x6101             STR      R1,[R0, #+16]
   2903                HAL_TIMEx_BreakCallback(htim);
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0x.... 0x....      BL       HAL_TIMEx_BreakCallback
   2904              }
   2905            }
   2906            /* TIM Trigger detection event */
   2907            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   \                     ??HAL_TIM_IRQHandler_13: (+1)
   \   00000118   0x6820             LDR      R0,[R4, #+0]
   \   0000011A   0x6901             LDR      R1,[R0, #+16]
   \   0000011C   0x0649             LSLS     R1,R1,#+25
   \   0000011E   0xD508             BPL.N    ??HAL_TIM_IRQHandler_14
   2908            {
   2909              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
   \   00000120   0x68C1             LDR      R1,[R0, #+12]
   \   00000122   0x0649             LSLS     R1,R1,#+25
   \   00000124   0xD505             BPL.N    ??HAL_TIM_IRQHandler_14
   2910              {
   2911                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   \   00000126   0xF06F 0x0140      MVN      R1,#+64
   \   0000012A   0x6101             STR      R1,[R0, #+16]
   2912                HAL_TIM_TriggerCallback(htim);
   \   0000012C   0x4620             MOV      R0,R4
   \   0000012E   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   2913              }
   2914            }
   2915            /* TIM commutation event */
   2916            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
   \                     ??HAL_TIM_IRQHandler_14: (+1)
   \   00000132   0x6820             LDR      R0,[R4, #+0]
   \   00000134   0x6901             LDR      R1,[R0, #+16]
   \   00000136   0x0689             LSLS     R1,R1,#+26
   \   00000138   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_15
   2917            {
   2918              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
   \   0000013A   0x68C1             LDR      R1,[R0, #+12]
   \   0000013C   0x0689             LSLS     R1,R1,#+26
   \   0000013E   0xD507             BPL.N    ??HAL_TIM_IRQHandler_15
   2919              {
   2920                __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
   \   00000140   0xF06F 0x0120      MVN      R1,#+32
   \   00000144   0x6101             STR      R1,[R0, #+16]
   2921                HAL_TIMEx_CommutationCallback(htim);
   \   00000146   0x4620             MOV      R0,R4
   \   00000148   0xE8BD 0x4010      POP      {R4,LR}
   \   0000014C   0x.... 0x....      B.W      HAL_TIMEx_CommutationCallback
   2922              }
   2923            }
   2924          }
   \                     ??HAL_TIM_IRQHandler_15: (+1)
   \   00000150   0xBD10             POP      {R4,PC}          ;; return
   2925          /**
   2926            * @}
   2927            */
   2928            
   2929          /** @defgroup TIM_Exported_Functions_Group8 Peripheral Control functions
   2930           *  @brief   	Peripheral Control functions 
   2931           *
   2932          @verbatim   
   2933            ==============================================================================
   2934                             ##### Peripheral Control functions #####
   2935            ==============================================================================  
   2936           [..] 
   2937             This section provides functions allowing to:
   2938             (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode. 
   2939             (+) Configure External Clock source.
   2940             (+) Configure Complementary channels, break features and dead time.
   2941             (+) Configure Master and the Slave synchronization.
   2942             (+) Configure the DMA Burst Mode.
   2943                
   2944          @endverbatim
   2945            * @{
   2946            */
   2947            
   2948          /**
   2949            * @brief  Initializes the TIM Output Compare Channels according to the specified
   2950            *         parameters in the TIM_OC_InitTypeDef.
   2951            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2952            *                the configuration information for TIM module.
   2953            * @param  sConfig: TIM Output Compare configuration structure
   2954            * @param  Channel: TIM Channels to be enabled.
   2955            *          This parameter can be one of the following values:
   2956            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2957            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2958            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2959            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   2960            * @retval HAL status
   2961            */

   \                                 In section .text, align 2, keep-with-next
   2962          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   2963          {
   \                     HAL_TIM_OC_ConfigChannel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2964            /* Check the parameters */ 
   2965            assert_param(IS_TIM_CHANNELS(Channel)); 
   2966            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   2967            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   2968            
   2969            /* Check input state */
   2970            __HAL_LOCK(htim); 
   \   00000004   0xF994 0x0038      LDRSB    R0,[R4, #+56]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_OC_ConfigChannel_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_TIM_OC_ConfigChannel_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   2971            
   2972            htim->State = HAL_TIM_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF884 0x0039      STRB     R0,[R4, #+57]
   2973            
   2974            switch (Channel)
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD006             BEQ.N    ??HAL_TIM_OC_ConfigChannel_1
   \   00000020   0x2A04             CMP      R2,#+4
   \   00000022   0xD008             BEQ.N    ??HAL_TIM_OC_ConfigChannel_2
   \   00000024   0x2A08             CMP      R2,#+8
   \   00000026   0xD00A             BEQ.N    ??HAL_TIM_OC_ConfigChannel_3
   \   00000028   0x2A0C             CMP      R2,#+12
   \   0000002A   0xD00C             BEQ.N    ??HAL_TIM_OC_ConfigChannel_4
   \   0000002C   0xE00E             B.N      ??HAL_TIM_OC_ConfigChannel_5
   2975            {
   2976              case TIM_CHANNEL_1:
   2977              {
   2978                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2979                /* Configure the TIM Channel 1 in Output Compare */
   2980                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_1: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      BL       TIM_OC1_SetConfig
   2981              }
   2982              break;
   \   00000034   0xE00A             B.N      ??HAL_TIM_OC_ConfigChannel_5
   2983              
   2984              case TIM_CHANNEL_2:
   2985              {
   2986                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2987                /* Configure the TIM Channel 2 in Output Compare */
   2988                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_2: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x.... 0x....      BL       TIM_OC2_SetConfig
   2989              }
   2990              break;
   \   0000003C   0xE006             B.N      ??HAL_TIM_OC_ConfigChannel_5
   2991              
   2992              case TIM_CHANNEL_3:
   2993              {
   2994                 assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   2995                /* Configure the TIM Channel 3 in Output Compare */
   2996                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_3: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      BL       TIM_OC3_SetConfig
   2997              }
   2998              break;
   \   00000044   0xE002             B.N      ??HAL_TIM_OC_ConfigChannel_5
   2999              
   3000              case TIM_CHANNEL_4:
   3001              {
   3002                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3003                /* Configure the TIM Channel 4 in Output Compare */
   3004                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_4: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_OC4_SetConfig
   3005              }
   3006              break;
   3007              
   3008              default:
   3009              break;    
   3010            }
   3011            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_ConfigChannel_5: (+1)
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xF884 0x0039      STRB     R0,[R4, #+57]
   3012            
   3013            __HAL_UNLOCK(htim); 
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF884 0x0038      STRB     R0,[R4, #+56]
   3014            
   3015            return HAL_OK;
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
   3016          }
   3017          
   3018          /**
   3019            * @brief  Initializes the TIM Input Capture Channels according to the specified
   3020            *         parameters in the TIM_IC_InitTypeDef.
   3021            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3022            *                the configuration information for TIM module.
   3023            * @param  sConfig: TIM Input Capture configuration structure
   3024            * @param  Channel: TIM Channels to be enabled.
   3025            *          This parameter can be one of the following values:
   3026            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3027            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3028            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3029            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   3030            * @retval HAL status
   3031            */

   \                                 In section .text, align 2, keep-with-next
   3032          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
   3033          {
   \                     HAL_TIM_IC_ConfigChannel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   3034            /* Check the parameters */
   3035            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3036            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   3037            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   3038            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   3039            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   3040            
   3041            __HAL_LOCK(htim);
   \   00000006   0xF995 0x0038      LDRSB    R0,[R5, #+56]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_TIM_IC_ConfigChannel_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_TIM_IC_ConfigChannel_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF885 0x0038      STRB     R0,[R5, #+56]
   3042            
   3043            htim->State = HAL_TIM_STATE_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF885 0x0039      STRB     R0,[R5, #+57]
   3044            
   3045            if (Channel == TIM_CHANNEL_1)
   \   0000001E   0x6874             LDR      R4,[R6, #+4]
   \   00000020   0x68F3             LDR      R3,[R6, #+12]
   \   00000022   0x6828             LDR      R0,[R5, #+0]
   \   00000024   0x6831             LDR      R1,[R6, #+0]
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xD10D             BNE.N    ??HAL_TIM_IC_ConfigChannel_1
   3046            {
   3047              /* TI1 Configuration */
   3048              TIM_TI1_SetConfig(htim->Instance,
   3049                         sConfig->ICPolarity,
   3050                         sConfig->ICSelection,
   3051                         sConfig->ICFilter);
   \   0000002A   0x4622             MOV      R2,R4
   \   0000002C   0x.... 0x....      BL       TIM_TI1_SetConfig
   3052                         
   3053              /* Reset the IC1PSC Bits */
   3054              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0x6981             LDR      R1,[R0, #+24]
   \   00000034   0xF021 0x010C      BIC      R1,R1,#0xC
   \   00000038   0x6181             STR      R1,[R0, #+24]
   3055          
   3056              /* Set the IC1PSC value */
   3057              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   \   0000003A   0x6828             LDR      R0,[R5, #+0]
   \   0000003C   0x6981             LDR      R1,[R0, #+24]
   \   0000003E   0x68B2             LDR      R2,[R6, #+8]
   \   00000040   0x4311             ORRS     R1,R2,R1
   \   00000042   0x6181             STR      R1,[R0, #+24]
   \   00000044   0xE02D             B.N      ??HAL_TIM_IC_ConfigChannel_2
   3058            }
   3059            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_IC_ConfigChannel_1: (+1)
   \   00000046   0x2A04             CMP      R2,#+4
   \   00000048   0xD10E             BNE.N    ??HAL_TIM_IC_ConfigChannel_3
   3060            {
   3061              /* TI2 Configuration */
   3062              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3063              
   3064              TIM_TI2_SetConfig(htim->Instance, 
   3065                                sConfig->ICPolarity,
   3066                                sConfig->ICSelection,
   3067                                sConfig->ICFilter);
   \   0000004A   0x4622             MOV      R2,R4
   \   0000004C   0x.... 0x....      BL       TIM_TI2_SetConfig
   3068                         
   3069              /* Reset the IC2PSC Bits */
   3070              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   00000050   0x6828             LDR      R0,[R5, #+0]
   \   00000052   0x6981             LDR      R1,[R0, #+24]
   \   00000054   0xF421 0x6140      BIC      R1,R1,#0xC00
   \   00000058   0x6181             STR      R1,[R0, #+24]
   3071          
   3072              /* Set the IC2PSC value */
   3073              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
   \   0000005A   0x6828             LDR      R0,[R5, #+0]
   \   0000005C   0x6981             LDR      R1,[R0, #+24]
   \   0000005E   0x68B2             LDR      R2,[R6, #+8]
   \   00000060   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000064   0x6181             STR      R1,[R0, #+24]
   \   00000066   0xE01C             B.N      ??HAL_TIM_IC_ConfigChannel_2
   3074            }
   3075            else if (Channel == TIM_CHANNEL_3)
   \                     ??HAL_TIM_IC_ConfigChannel_3: (+1)
   \   00000068   0x2A08             CMP      R2,#+8
   \   0000006A   0x4622             MOV      R2,R4
   \   0000006C   0xD10C             BNE.N    ??HAL_TIM_IC_ConfigChannel_4
   3076            {
   3077              /* TI3 Configuration */
   3078              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3079              
   3080              TIM_TI3_SetConfig(htim->Instance,  
   3081                         sConfig->ICPolarity,
   3082                         sConfig->ICSelection,
   3083                         sConfig->ICFilter);
   \   0000006E   0x.... 0x....      BL       TIM_TI3_SetConfig
   3084                         
   3085              /* Reset the IC3PSC Bits */
   3086              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   \   00000072   0x6828             LDR      R0,[R5, #+0]
   \   00000074   0x69C1             LDR      R1,[R0, #+28]
   \   00000076   0xF021 0x010C      BIC      R1,R1,#0xC
   \   0000007A   0x61C1             STR      R1,[R0, #+28]
   3087          
   3088              /* Set the IC3PSC value */
   3089              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   \   0000007C   0x6828             LDR      R0,[R5, #+0]
   \   0000007E   0x69C1             LDR      R1,[R0, #+28]
   \   00000080   0x68B2             LDR      R2,[R6, #+8]
   \   00000082   0x4311             ORRS     R1,R2,R1
   \   00000084   0x61C1             STR      R1,[R0, #+28]
   \   00000086   0xE00C             B.N      ??HAL_TIM_IC_ConfigChannel_2
   3090            }
   3091            else
   3092            {
   3093              /* TI4 Configuration */
   3094              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3095              
   3096              TIM_TI4_SetConfig(htim->Instance, 
   3097                         sConfig->ICPolarity,
   3098                         sConfig->ICSelection,
   3099                         sConfig->ICFilter);
   \                     ??HAL_TIM_IC_ConfigChannel_4: (+1)
   \   00000088   0x.... 0x....      BL       TIM_TI4_SetConfig
   3100                         
   3101              /* Reset the IC4PSC Bits */
   3102              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   \   0000008C   0x6828             LDR      R0,[R5, #+0]
   \   0000008E   0x69C1             LDR      R1,[R0, #+28]
   \   00000090   0xF421 0x6140      BIC      R1,R1,#0xC00
   \   00000094   0x61C1             STR      R1,[R0, #+28]
   3103          
   3104              /* Set the IC4PSC value */
   3105              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
   \   00000096   0x6828             LDR      R0,[R5, #+0]
   \   00000098   0x69C1             LDR      R1,[R0, #+28]
   \   0000009A   0x68B2             LDR      R2,[R6, #+8]
   \   0000009C   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000000A0   0x61C1             STR      R1,[R0, #+28]
   3106            }
   3107            
   3108            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_ConfigChannel_2: (+1)
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0xF885 0x0039      STRB     R0,[R5, #+57]
   3109              
   3110            __HAL_UNLOCK(htim);
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xF885 0x0038      STRB     R0,[R5, #+56]
   3111            
   3112            return HAL_OK; 
   \   000000AE   0xBD70             POP      {R4-R6,PC}       ;; return
   3113          }
   3114          
   3115          /**
   3116            * @brief  Initializes the TIM PWM  channels according to the specified
   3117            *         parameters in the TIM_OC_InitTypeDef.
   3118            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3119            *                the configuration information for TIM module.
   3120            * @param  sConfig: TIM PWM configuration structure
   3121            * @param  Channel: TIM Channels to be enabled.
   3122            *          This parameter can be one of the following values:
   3123            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3124            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3125            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3126            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3127            * @retval HAL status
   3128            */

   \                                 In section .text, align 2, keep-with-next
   3129          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   3130          {
   \                     HAL_TIM_PWM_ConfigChannel: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   3131            __HAL_LOCK(htim);
   \   00000006   0xF994 0x0038      LDRSB    R0,[R4, #+56]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_TIM_PWM_ConfigChannel_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_TIM_PWM_ConfigChannel_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0038      STRB     R0,[R4, #+56]
   3132            
   3133            /* Check the parameters */ 
   3134            assert_param(IS_TIM_CHANNELS(Channel)); 
   3135            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3136            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3137            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   3138          
   3139            htim->State = HAL_TIM_STATE_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x0039      STRB     R0,[R4, #+57]
   3140              
   3141            switch (Channel)
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD006             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_1
   \   00000022   0x2A04             CMP      R2,#+4
   \   00000024   0xD017             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_2
   \   00000026   0x2A08             CMP      R2,#+8
   \   00000028   0xD029             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_3
   \   0000002A   0x2A0C             CMP      R2,#+12
   \   0000002C   0xD03A             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_4
   \   0000002E   0xE04C             B.N      ??HAL_TIM_PWM_ConfigChannel_5
   3142            {
   3143              case TIM_CHANNEL_1:
   3144              {
   3145                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3146                /* Configure the Channel 1 in PWM mode */
   3147                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_1: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x.... 0x....      BL       TIM_OC1_SetConfig
   3148                
   3149                /* Set the Preload enable bit for channel1 */
   3150                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x6981             LDR      R1,[R0, #+24]
   \   0000003A   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000003E   0x6181             STR      R1,[R0, #+24]
   3151                
   3152                /* Configure the Output Fast mode */
   3153                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x6981             LDR      R1,[R0, #+24]
   \   00000044   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000048   0x6181             STR      R1,[R0, #+24]
   3154                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6981             LDR      R1,[R0, #+24]
   \   0000004E   0x692A             LDR      R2,[R5, #+16]
   \   00000050   0x4311             ORRS     R1,R2,R1
   \   00000052   0x6181             STR      R1,[R0, #+24]
   3155              }
   3156              break;
   \   00000054   0xE039             B.N      ??HAL_TIM_PWM_ConfigChannel_5
   3157              
   3158              case TIM_CHANNEL_2:
   3159              {
   3160                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3161                /* Configure the Channel 2 in PWM mode */
   3162                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_2: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      BL       TIM_OC2_SetConfig
   3163                
   3164                /* Set the Preload enable bit for channel2 */
   3165                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6981             LDR      R1,[R0, #+24]
   \   00000060   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000064   0x6181             STR      R1,[R0, #+24]
   3166                
   3167                /* Configure the Output Fast mode */
   3168                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6981             LDR      R1,[R0, #+24]
   \   0000006A   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000006E   0x6181             STR      R1,[R0, #+24]
   3169                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6981             LDR      R1,[R0, #+24]
   \   00000074   0x692A             LDR      R2,[R5, #+16]
   \   00000076   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   0000007A   0x6181             STR      R1,[R0, #+24]
   3170              }
   3171              break;
   \   0000007C   0xE025             B.N      ??HAL_TIM_PWM_ConfigChannel_5
   3172              
   3173              case TIM_CHANNEL_3:
   3174              {
   3175                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3176                /* Configure the Channel 3 in PWM mode */
   3177                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_3: (+1)
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x.... 0x....      BL       TIM_OC3_SetConfig
   3178                
   3179                /* Set the Preload enable bit for channel3 */
   3180                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x69C1             LDR      R1,[R0, #+28]
   \   00000088   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000008C   0x61C1             STR      R1,[R0, #+28]
   3181                
   3182               /* Configure the Output Fast mode */
   3183                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x69C1             LDR      R1,[R0, #+28]
   \   00000092   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000096   0x61C1             STR      R1,[R0, #+28]
   3184                htim->Instance->CCMR2 |= sConfig->OCFastMode;  
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x69C1             LDR      R1,[R0, #+28]
   \   0000009C   0x692A             LDR      R2,[R5, #+16]
   \   0000009E   0x4311             ORRS     R1,R2,R1
   \   000000A0   0x61C1             STR      R1,[R0, #+28]
   3185              }
   3186              break;
   \   000000A2   0xE012             B.N      ??HAL_TIM_PWM_ConfigChannel_5
   3187              
   3188              case TIM_CHANNEL_4:
   3189              {
   3190                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3191                /* Configure the Channel 4 in PWM mode */
   3192                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_4: (+1)
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x.... 0x....      BL       TIM_OC4_SetConfig
   3193                
   3194                /* Set the Preload enable bit for channel4 */
   3195                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x69C1             LDR      R1,[R0, #+28]
   \   000000AE   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000B2   0x61C1             STR      R1,[R0, #+28]
   3196                
   3197               /* Configure the Output Fast mode */
   3198                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x69C1             LDR      R1,[R0, #+28]
   \   000000B8   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000BC   0x61C1             STR      R1,[R0, #+28]
   3199                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;  
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x69C1             LDR      R1,[R0, #+28]
   \   000000C2   0x692A             LDR      R2,[R5, #+16]
   \   000000C4   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000000C8   0x61C1             STR      R1,[R0, #+28]
   3200              }
   3201              break;
   3202              
   3203              default:
   3204              break;    
   3205            }
   3206            
   3207            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_ConfigChannel_5: (+1)
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0xF884 0x0039      STRB     R0,[R4, #+57]
   3208              
   3209            __HAL_UNLOCK(htim);
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xF884 0x0038      STRB     R0,[R4, #+56]
   3210            
   3211            return HAL_OK;
   \   000000D6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3212          }
   3213          
   3214          /**
   3215            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3216            *         parameters in the TIM_OnePulse_InitTypeDef.
   3217            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3218            *                the configuration information for TIM module.
   3219            * @param  sConfig: TIM One Pulse configuration structure
   3220            * @param  OutputChannel: TIM Channels to be enabled.
   3221            *          This parameter can be one of the following values:
   3222            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3223            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3224            * @param  InputChannel: TIM Channels to be enabled.
   3225            *          This parameter can be one of the following values:
   3226            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3227            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3228            * @retval HAL status
   3229            */

   \                                 In section .text, align 2, keep-with-next
   3230          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
   3231          {
   \                     HAL_TIM_OnePulse_ConfigChannel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x461E             MOV      R6,R3
   3232            TIM_OC_InitTypeDef temp1;
   3233            
   3234            /* Check the parameters */
   3235            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3236            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3237          
   3238            if(OutputChannel != InputChannel)  
   \   0000000A   0x42B2             CMP      R2,R6
   \   0000000C   0xD070             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_0
   3239            {
   3240              __HAL_LOCK(htim);
   \   0000000E   0xF994 0x0038      LDRSB    R0,[R4, #+56]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD101             BNE.N    ??HAL_TIM_OnePulse_ConfigChannel_1
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE06B             B.N      ??HAL_TIM_OnePulse_ConfigChannel_2
   \                     ??HAL_TIM_OnePulse_ConfigChannel_1: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF884 0x0038      STRB     R0,[R4, #+56]
   3241            
   3242              htim->State = HAL_TIM_STATE_BUSY;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   3243          
   3244              /* Extract the Output compare configuration from sConfig structure */  
   3245              temp1.OCMode = sConfig->OCMode;
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x9000             STR      R0,[SP, #+0]
   3246              temp1.Pulse = sConfig->Pulse;
   \   0000002A   0x6868             LDR      R0,[R5, #+4]
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   3247              temp1.OCPolarity = sConfig->OCPolarity;
   \   0000002E   0x68A8             LDR      R0,[R5, #+8]
   \   00000030   0x9002             STR      R0,[SP, #+8]
   3248              temp1.OCNPolarity = sConfig->OCNPolarity;
   \   00000032   0x68E8             LDR      R0,[R5, #+12]
   \   00000034   0x9003             STR      R0,[SP, #+12]
   3249              temp1.OCIdleState = sConfig->OCIdleState;
   \   00000036   0x6928             LDR      R0,[R5, #+16]
   \   00000038   0x9005             STR      R0,[SP, #+20]
   3250              temp1.OCNIdleState = sConfig->OCNIdleState; 
   \   0000003A   0x6968             LDR      R0,[R5, #+20]
   \   0000003C   0x9006             STR      R0,[SP, #+24]
   3251              
   3252              switch (OutputChannel)
   \   0000003E   0x2A00             CMP      R2,#+0
   \   00000040   0xD002             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_3
   \   00000042   0x2A04             CMP      R2,#+4
   \   00000044   0xD005             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_4
   \   00000046   0xE008             B.N      ??HAL_TIM_OnePulse_ConfigChannel_5
   3253              {
   3254                case TIM_CHANNEL_1:
   3255                {
   3256                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3257                
   3258                  TIM_OC1_SetConfig(htim->Instance, &temp1); 
   \                     ??HAL_TIM_OnePulse_ConfigChannel_3: (+1)
   \   00000048   0xA900             ADD      R1,SP,#+0
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      BL       TIM_OC1_SetConfig
   3259                }
   3260                break;
   \   00000050   0xE003             B.N      ??HAL_TIM_OnePulse_ConfigChannel_5
   3261                case TIM_CHANNEL_2:
   3262                {
   3263                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3264                
   3265                  TIM_OC2_SetConfig(htim->Instance, &temp1);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_4: (+1)
   \   00000052   0xA900             ADD      R1,SP,#+0
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       TIM_OC2_SetConfig
   3266                }
   3267                break;
   3268                default:
   3269                break;  
   3270              } 
   3271              switch (InputChannel)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_5: (+1)
   \   0000005A   0x2E00             CMP      R6,#+0
   \   0000005C   0xD002             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_6
   \   0000005E   0x2E04             CMP      R6,#+4
   \   00000060   0xD020             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_7
   \   00000062   0xE03E             B.N      ??HAL_TIM_OnePulse_ConfigChannel_8
   3272              {
   3273                case TIM_CHANNEL_1:
   3274                {
   3275                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3276                
   3277                  TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3278                                  sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_6: (+1)
   \   00000064   0x6A2B             LDR      R3,[R5, #+32]
   \   00000066   0x69EA             LDR      R2,[R5, #+28]
   \   00000068   0x69A9             LDR      R1,[R5, #+24]
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x.... 0x....      BL       TIM_TI1_SetConfig
   3279                         
   3280                  /* Reset the IC1PSC Bits */
   3281                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6981             LDR      R1,[R0, #+24]
   \   00000074   0xF021 0x010C      BIC      R1,R1,#0xC
   \   00000078   0x6181             STR      R1,[R0, #+24]
   3282          
   3283                  /* Select the Trigger source */
   3284                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6881             LDR      R1,[R0, #+8]
   \   0000007E   0xF021 0x0170      BIC      R1,R1,#0x70
   \   00000082   0x6081             STR      R1,[R0, #+8]
   3285                  htim->Instance->SMCR |= TIM_TS_TI1FP1;
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6881             LDR      R1,[R0, #+8]
   \   00000088   0xF041 0x0150      ORR      R1,R1,#0x50
   \   0000008C   0x6081             STR      R1,[R0, #+8]
   3286                
   3287                  /* Select the Slave Mode */      
   3288                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x6881             LDR      R1,[R0, #+8]
   \   00000092   0x08C9             LSRS     R1,R1,#+3
   \   00000094   0x00C9             LSLS     R1,R1,#+3
   \   00000096   0x6081             STR      R1,[R0, #+8]
   3289                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x6881             LDR      R1,[R0, #+8]
   \   0000009C   0xF041 0x0106      ORR      R1,R1,#0x6
   \   000000A0   0x6081             STR      R1,[R0, #+8]
   3290                }
   3291                break;
   \   000000A2   0xE01E             B.N      ??HAL_TIM_OnePulse_ConfigChannel_8
   3292                case TIM_CHANNEL_2:
   3293                {
   3294                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3295                
   3296                  TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3297                           sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_7: (+1)
   \   000000A4   0x6A2B             LDR      R3,[R5, #+32]
   \   000000A6   0x69EA             LDR      R2,[R5, #+28]
   \   000000A8   0x69A9             LDR      R1,[R5, #+24]
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x.... 0x....      BL       TIM_TI2_SetConfig
   3298                         
   3299                  /* Reset the IC2PSC Bits */
   3300                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6981             LDR      R1,[R0, #+24]
   \   000000B4   0xF421 0x6140      BIC      R1,R1,#0xC00
   \   000000B8   0x6181             STR      R1,[R0, #+24]
   3301          
   3302                  /* Select the Trigger source */
   3303                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x6881             LDR      R1,[R0, #+8]
   \   000000BE   0xF021 0x0170      BIC      R1,R1,#0x70
   \   000000C2   0x6081             STR      R1,[R0, #+8]
   3304                  htim->Instance->SMCR |= TIM_TS_TI2FP2;
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6881             LDR      R1,[R0, #+8]
   \   000000C8   0xF041 0x0160      ORR      R1,R1,#0x60
   \   000000CC   0x6081             STR      R1,[R0, #+8]
   3305                
   3306                  /* Select the Slave Mode */      
   3307                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x6881             LDR      R1,[R0, #+8]
   \   000000D2   0x08C9             LSRS     R1,R1,#+3
   \   000000D4   0x00C9             LSLS     R1,R1,#+3
   \   000000D6   0x6081             STR      R1,[R0, #+8]
   3308                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0x6881             LDR      R1,[R0, #+8]
   \   000000DC   0xF041 0x0106      ORR      R1,R1,#0x6
   \   000000E0   0x6081             STR      R1,[R0, #+8]
   3309                }
   3310                break;
   3311              
   3312                default:
   3313                break;  
   3314              }
   3315            
   3316              htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_8: (+1)
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0xF884 0x0039      STRB     R0,[R4, #+57]
   3317              
   3318              __HAL_UNLOCK(htim);
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xF884 0x0038      STRB     R0,[R4, #+56]
   3319            
   3320              return HAL_OK;
   \   000000EE   0xE000             B.N      ??HAL_TIM_OnePulse_ConfigChannel_2
   3321            }
   3322            else
   3323            {
   3324              return HAL_ERROR;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_0: (+1)
   \   000000F0   0x2001             MOVS     R0,#+1
   \                     ??HAL_TIM_OnePulse_ConfigChannel_2: (+1)
   \   000000F2   0xB008             ADD      SP,SP,#+32
   \   000000F4   0xBD70             POP      {R4-R6,PC}       ;; return
   3325            }
   3326          } 
   3327          
   3328          /**
   3329            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral  
   3330            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3331            *                the configuration information for TIM module.
   3332            * @param  BurstBaseAddress: TIM Base address from when the DMA will starts the Data write.
   3333            *         This parameters can be on of the following values:
   3334            *            @arg TIM_DMABASE_CR1  
   3335            *            @arg TIM_DMABASE_CR2
   3336            *            @arg TIM_DMABASE_SMCR
   3337            *            @arg TIM_DMABASE_DIER
   3338            *            @arg TIM_DMABASE_SR
   3339            *            @arg TIM_DMABASE_EGR
   3340            *            @arg TIM_DMABASE_CCMR1
   3341            *            @arg TIM_DMABASE_CCMR2
   3342            *            @arg TIM_DMABASE_CCER
   3343            *            @arg TIM_DMABASE_CNT   
   3344            *            @arg TIM_DMABASE_PSC   
   3345            *            @arg TIM_DMABASE_ARR
   3346            *            @arg TIM_DMABASE_RCR
   3347            *            @arg TIM_DMABASE_CCR1
   3348            *            @arg TIM_DMABASE_CCR2
   3349            *            @arg TIM_DMABASE_CCR3  
   3350            *            @arg TIM_DMABASE_CCR4
   3351            *            @arg TIM_DMABASE_BDTR
   3352            *            @arg TIM_DMABASE_DCR
   3353            * @param  BurstRequestSrc: TIM DMA Request sources.
   3354            *         This parameters can be on of the following values:
   3355            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3356            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3357            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3358            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3359            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3360            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3361            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3362            * @param  BurstBuffer: The Buffer address.
   3363            * @param  BurstLength: DMA Burst length. This parameter can be one value
   3364            *         between TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3365            * @retval HAL status
   3366            */

   \                                 In section .text, align 2, keep-with-next
   3367          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3368                                                        uint32_t* BurstBuffer, uint32_t  BurstLength)
   3369          {
   \                     HAL_TIM_DMABurst_WriteStart: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x4619             MOV      R1,R3
   3370            /* Check the parameters */
   3371            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3372            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3373            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3374            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3375            
   3376            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD101             BNE.N    ??HAL_TIM_DMABurst_WriteStart_0
   3377            {
   3378               return HAL_BUSY;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
   3379            }
   \                     ??HAL_TIM_DMABurst_WriteStart_0: (+1)
   \   00000016   0x9F06             LDR      R7,[SP, #+24]
   3380            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000018   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD108             BNE.N    ??HAL_TIM_DMABurst_WriteStart_1
   3381            {
   3382              if((BurstBuffer == 0U) && (BurstLength > 0U)) 
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD103             BNE.N    ??HAL_TIM_DMABurst_WriteStart_2
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_2
   3383              {
   3384                return HAL_ERROR;                                    
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}
   3385              }
   3386              else
   3387              {
   3388                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_WriteStart_2: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF884 0x0039      STRB     R0,[R4, #+57]
   3389              }
   3390            }
   3391            switch(BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_WriteStart_1: (+1)
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000038   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_3
   \   0000003A   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000003E   0xD020             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_4
   \   00000040   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000044   0xD02E             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_5
   \   00000046   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000004A   0xD03C             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_6
   \   0000004C   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000050   0xD04A             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_7
   \   00000052   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000056   0xD058             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_8
   \   00000058   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000005C   0xD066             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_9
   \   0000005E   0xE075             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3392            {
   3393              case TIM_DMA_UPDATE:
   3394              {  
   3395                /* Set the DMA Period elapsed callback */
   3396                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_3: (+1)
   \   00000060   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedCplt
   \   00000064   0x69E2             LDR      R2,[R4, #+28]
   \   00000066   0x63D0             STR      R0,[R2, #+60]
   3397               
   3398                /* Set the DMA error callback */
   3399                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \   00000068   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000006C   0x69E2             LDR      R2,[R4, #+28]
   \   0000006E   0x64D0             STR      R0,[R2, #+76]
   3400            
   3401                /* Enable the DMA Stream */
   3402                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U); 
   \   00000070   0x0A38             LSRS     R0,R7,#+8
   \   00000072   0x1C43             ADDS     R3,R0,#+1
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0xF100 0x024C      ADD      R2,R0,#+76
   \   0000007A   0x69E0             LDR      R0,[R4, #+28]
   \   0000007C   0x.... 0x....      BL       HAL_DMA_Start_IT
   3403              }
   3404              break;
   \   00000080   0xE064             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3405              case TIM_DMA_CC1:
   3406              {  
   3407                /* Set the DMA Period elapsed callback */
   3408                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_4: (+1)
   \   00000082   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   00000086   0x6A22             LDR      R2,[R4, #+32]
   \   00000088   0x63D0             STR      R0,[R2, #+60]
   3409               
   3410                /* Set the DMA error callback */
   3411                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   0000008A   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000008E   0x6A22             LDR      R2,[R4, #+32]
   \   00000090   0x64D0             STR      R0,[R2, #+76]
   3412            
   3413                /* Enable the DMA Stream */
   3414                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
   \   00000092   0x0A38             LSRS     R0,R7,#+8
   \   00000094   0x1C43             ADDS     R3,R0,#+1
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0xF100 0x024C      ADD      R2,R0,#+76
   \   0000009C   0x6A20             LDR      R0,[R4, #+32]
   \   0000009E   0x.... 0x....      BL       HAL_DMA_Start_IT
   3415              }
   3416              break;
   \   000000A2   0xE053             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3417              case TIM_DMA_CC2:
   3418              {  
   3419                /* Set the DMA Period elapsed callback */
   3420                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_5: (+1)
   \   000000A4   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000A8   0x6A62             LDR      R2,[R4, #+36]
   \   000000AA   0x63D0             STR      R0,[R2, #+60]
   3421               
   3422                /* Set the DMA error callback */
   3423                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   000000AC   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000B0   0x6A62             LDR      R2,[R4, #+36]
   \   000000B2   0x64D0             STR      R0,[R2, #+76]
   3424            
   3425                /* Enable the DMA Stream */
   3426                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
   \   000000B4   0x0A38             LSRS     R0,R7,#+8
   \   000000B6   0x1C43             ADDS     R3,R0,#+1
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0xF100 0x024C      ADD      R2,R0,#+76
   \   000000BE   0x6A60             LDR      R0,[R4, #+36]
   \   000000C0   0x.... 0x....      BL       HAL_DMA_Start_IT
   3427              }
   3428              break;
   \   000000C4   0xE042             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3429              case TIM_DMA_CC3:
   3430              {  
   3431                /* Set the DMA Period elapsed callback */
   3432                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_6: (+1)
   \   000000C6   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000CA   0x6AA2             LDR      R2,[R4, #+40]
   \   000000CC   0x63D0             STR      R0,[R2, #+60]
   3433               
   3434                /* Set the DMA error callback */
   3435                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000CE   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000D2   0x6AA2             LDR      R2,[R4, #+40]
   \   000000D4   0x64D0             STR      R0,[R2, #+76]
   3436            
   3437                /* Enable the DMA Stream */
   3438                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
   \   000000D6   0x0A38             LSRS     R0,R7,#+8
   \   000000D8   0x1C43             ADDS     R3,R0,#+1
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0xF100 0x024C      ADD      R2,R0,#+76
   \   000000E0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000E2   0x.... 0x....      BL       HAL_DMA_Start_IT
   3439              }
   3440              break;
   \   000000E6   0xE031             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3441              case TIM_DMA_CC4:
   3442              {  
   3443                /* Set the DMA Period elapsed callback */
   3444                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_7: (+1)
   \   000000E8   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000EC   0x6AE2             LDR      R2,[R4, #+44]
   \   000000EE   0x63D0             STR      R0,[R2, #+60]
   3445               
   3446                /* Set the DMA error callback */
   3447                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000F0   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000F4   0x6AE2             LDR      R2,[R4, #+44]
   \   000000F6   0x64D0             STR      R0,[R2, #+76]
   3448            
   3449                /* Enable the DMA Stream */
   3450                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
   \   000000F8   0x0A38             LSRS     R0,R7,#+8
   \   000000FA   0x1C43             ADDS     R3,R0,#+1
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0xF100 0x024C      ADD      R2,R0,#+76
   \   00000102   0x6AE0             LDR      R0,[R4, #+44]
   \   00000104   0x.... 0x....      BL       HAL_DMA_Start_IT
   3451              }
   3452              break;
   \   00000108   0xE020             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3453              case TIM_DMA_COM:
   3454              {  
   3455                /* Set the DMA Period elapsed callback */
   3456                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_8: (+1)
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable28
   \   0000010E   0x6B22             LDR      R2,[R4, #+48]
   \   00000110   0x63D0             STR      R0,[R2, #+60]
   3457               
   3458                /* Set the DMA error callback */
   3459                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   \   00000112   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000116   0x6B22             LDR      R2,[R4, #+48]
   \   00000118   0x64D0             STR      R0,[R2, #+76]
   3460            
   3461                /* Enable the DMA Stream */
   3462                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
   \   0000011A   0x0A38             LSRS     R0,R7,#+8
   \   0000011C   0x1C43             ADDS     R3,R0,#+1
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0xF100 0x024C      ADD      R2,R0,#+76
   \   00000124   0x6B20             LDR      R0,[R4, #+48]
   \   00000126   0x.... 0x....      BL       HAL_DMA_Start_IT
   3463              }
   3464              break;
   \   0000012A   0xE00F             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3465              case TIM_DMA_TRIGGER:
   3466              {  
   3467                /* Set the DMA Period elapsed callback */
   3468                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_9: (+1)
   \   0000012C   0x.... 0x....      ADR.W    R0,TIM_DMATriggerCplt
   \   00000130   0x6B62             LDR      R2,[R4, #+52]
   \   00000132   0x63D0             STR      R0,[R2, #+60]
   3469               
   3470                /* Set the DMA error callback */
   3471                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   \   00000134   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000138   0x6B62             LDR      R2,[R4, #+52]
   \   0000013A   0x64D0             STR      R0,[R2, #+76]
   3472            
   3473                /* Enable the DMA Stream */
   3474                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
   \   0000013C   0x0A38             LSRS     R0,R7,#+8
   \   0000013E   0x1C43             ADDS     R3,R0,#+1
   \   00000140   0x6820             LDR      R0,[R4, #+0]
   \   00000142   0xF100 0x024C      ADD      R2,R0,#+76
   \   00000146   0x6B60             LDR      R0,[R4, #+52]
   \   00000148   0x.... 0x....      BL       HAL_DMA_Start_IT
   3475              }
   3476              break;
   3477              default:
   3478              break;  
   3479            }
   3480             /* configure the DMA Burst Mode */
   3481             htim->Instance->DCR = BurstBaseAddress | BurstLength;  
   \                     ??HAL_TIM_DMABurst_WriteStart_10: (+1)
   \   0000014C   0xEA47 0x0006      ORR      R0,R7,R6
   \   00000150   0x6821             LDR      R1,[R4, #+0]
   \   00000152   0x6488             STR      R0,[R1, #+72]
   3482             
   3483             /* Enable the TIM DMA Request */
   3484             __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
   \   00000154   0x6820             LDR      R0,[R4, #+0]
   \   00000156   0x68C1             LDR      R1,[R0, #+12]
   \   00000158   0x4329             ORRS     R1,R5,R1
   \   0000015A   0x60C1             STR      R1,[R0, #+12]
   3485             
   3486             htim->State = HAL_TIM_STATE_READY;
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0xF884 0x0039      STRB     R0,[R4, #+57]
   3487            
   3488            /* Return function status */
   3489            return HAL_OK;
   \   00000162   0x2000             MOVS     R0,#+0
   \   00000164   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3490          }
   3491          
   3492          /**
   3493            * @brief  Stops the TIM DMA Burst mode 
   3494            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3495            *                the configuration information for TIM module.
   3496            * @param  BurstRequestSrc: TIM DMA Request sources to disable
   3497            * @retval HAL status
   3498            */

   \                                 In section .text, align 2, keep-with-next
   3499          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3500          {
   \                     HAL_TIM_DMABurst_WriteStop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   3501            /* Check the parameters */
   3502            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3503            
   3504            /* Abort the DMA transfer (at least disable the DMA channel) */
   3505            switch(BurstRequestSrc)
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000000C   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_0
   \   0000000E   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000012   0xD013             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_1
   \   00000014   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000018   0xD014             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_2
   \   0000001A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000001E   0xD015             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_3
   \   00000020   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000024   0xD016             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_4
   \   00000026   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000002A   0xD017             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_5
   \   0000002C   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000030   0xD018             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_6
   \   00000032   0xE01A             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3506            {
   3507              case TIM_DMA_UPDATE:
   3508              {  
   3509                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_WriteStop_0: (+1)
   \   00000034   0x69E0             LDR      R0,[R4, #+28]
   \   00000036   0x.... 0x....      BL       HAL_DMA_Abort
   3510              }
   3511              break;
   \   0000003A   0xE016             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3512              case TIM_DMA_CC1:
   3513              {  
   3514                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_WriteStop_1: (+1)
   \   0000003C   0x6A20             LDR      R0,[R4, #+32]
   \   0000003E   0x.... 0x....      BL       HAL_DMA_Abort
   3515              }
   3516              break;
   \   00000042   0xE012             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3517              case TIM_DMA_CC2:
   3518              {  
   3519                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_WriteStop_2: (+1)
   \   00000044   0x6A60             LDR      R0,[R4, #+36]
   \   00000046   0x.... 0x....      BL       HAL_DMA_Abort
   3520              }
   3521              break;
   \   0000004A   0xE00E             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3522              case TIM_DMA_CC3:
   3523              {  
   3524                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_WriteStop_3: (+1)
   \   0000004C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Abort
   3525              }
   3526              break;
   \   00000052   0xE00A             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3527              case TIM_DMA_CC4:
   3528              {  
   3529                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_WriteStop_4: (+1)
   \   00000054   0x6AE0             LDR      R0,[R4, #+44]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Abort
   3530              }
   3531              break;
   \   0000005A   0xE006             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3532              case TIM_DMA_COM:
   3533              {  
   3534                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_WriteStop_5: (+1)
   \   0000005C   0x6B20             LDR      R0,[R4, #+48]
   \   0000005E   0x.... 0x....      BL       HAL_DMA_Abort
   3535              }
   3536              break;
   \   00000062   0xE002             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3537              case TIM_DMA_TRIGGER:
   3538              {  
   3539                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_WriteStop_6: (+1)
   \   00000064   0x6B60             LDR      R0,[R4, #+52]
   \   00000066   0x.... 0x....      BL       HAL_DMA_Abort
   3540              }
   3541              break;
   3542              default:
   3543              break;
   3544            }
   3545          
   3546            /* Disable the TIM Update DMA request */
   3547            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??HAL_TIM_DMABurst_WriteStop_7: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x68C1             LDR      R1,[R0, #+12]
   \   0000006E   0x43A9             BICS     R1,R1,R5
   \   00000070   0x60C1             STR      R1,[R0, #+12]
   3548                
   3549            /* Return function status */
   3550            return HAL_OK;  
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3551          }
   3552          
   3553          /**
   3554            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory 
   3555            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3556            *                the configuration information for TIM module.
   3557            * @param  BurstBaseAddress: TIM Base address from when the DMA will starts the Data read.
   3558            *         This parameters can be on of the following values:
   3559            *            @arg TIM_DMABASE_CR1  
   3560            *            @arg TIM_DMABASE_CR2
   3561            *            @arg TIM_DMABASE_SMCR
   3562            *            @arg TIM_DMABASE_DIER
   3563            *            @arg TIM_DMABASE_SR
   3564            *            @arg TIM_DMABASE_EGR
   3565            *            @arg TIM_DMABASE_CCMR1
   3566            *            @arg TIM_DMABASE_CCMR2
   3567            *            @arg TIM_DMABASE_CCER
   3568            *            @arg TIM_DMABASE_CNT   
   3569            *            @arg TIM_DMABASE_PSC   
   3570            *            @arg TIM_DMABASE_ARR
   3571            *            @arg TIM_DMABASE_RCR
   3572            *            @arg TIM_DMABASE_CCR1
   3573            *            @arg TIM_DMABASE_CCR2
   3574            *            @arg TIM_DMABASE_CCR3  
   3575            *            @arg TIM_DMABASE_CCR4
   3576            *            @arg TIM_DMABASE_BDTR
   3577            *            @arg TIM_DMABASE_DCR
   3578            * @param  BurstRequestSrc: TIM DMA Request sources.
   3579            *         This parameters can be on of the following values:
   3580            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3581            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3582            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3583            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3584            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3585            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3586            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3587            * @param  BurstBuffer: The Buffer address.
   3588            * @param  BurstLength: DMA Burst length. This parameter can be one value
   3589            *         between TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3590            * @retval HAL status
   3591            */

   \                                 In section .text, align 2, keep-with-next
   3592          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3593                                                       uint32_t  *BurstBuffer, uint32_t  BurstLength)
   3594          {
   \                     HAL_TIM_DMABurst_ReadStart: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x461A             MOV      R2,R3
   3595            /* Check the parameters */
   3596            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3597            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3598            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3599            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3600            
   3601            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD101             BNE.N    ??HAL_TIM_DMABurst_ReadStart_0
   3602            {
   3603               return HAL_BUSY;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
   3604            }
   \                     ??HAL_TIM_DMABurst_ReadStart_0: (+1)
   \   00000016   0x9F06             LDR      R7,[SP, #+24]
   3605            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000018   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD108             BNE.N    ??HAL_TIM_DMABurst_ReadStart_1
   3606            {
   3607              if((BurstBuffer == 0U) && (BurstLength > 0U)) 
   \   00000020   0x2A00             CMP      R2,#+0
   \   00000022   0xD103             BNE.N    ??HAL_TIM_DMABurst_ReadStart_2
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_2
   3608              {
   3609                return HAL_ERROR;                                    
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}
   3610              }
   3611              else
   3612              {
   3613                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_ReadStart_2: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF884 0x0039      STRB     R0,[R4, #+57]
   3614              }
   3615            }  
   3616            switch(BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_ReadStart_1: (+1)
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000038   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_3
   \   0000003A   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000003E   0xD020             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_4
   \   00000040   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000044   0xD02E             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_5
   \   00000046   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000004A   0xD03C             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_6
   \   0000004C   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000050   0xD04A             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_7
   \   00000052   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000056   0xD058             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_8
   \   00000058   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000005C   0xD066             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_9
   \   0000005E   0xE075             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3617            {
   3618              case TIM_DMA_UPDATE:
   3619              {  
   3620                /* Set the DMA Period elapsed callback */
   3621                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_3: (+1)
   \   00000060   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedCplt
   \   00000064   0x69E1             LDR      R1,[R4, #+28]
   \   00000066   0x63C8             STR      R0,[R1, #+60]
   3622               
   3623                /* Set the DMA error callback */
   3624                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \   00000068   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000006C   0x69E1             LDR      R1,[R4, #+28]
   \   0000006E   0x64C8             STR      R0,[R1, #+76]
   3625            
   3626                /* Enable the DMA Stream */
   3627                 HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);     
   \   00000070   0x0A38             LSRS     R0,R7,#+8
   \   00000072   0x1C43             ADDS     R3,R0,#+1
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0xF100 0x014C      ADD      R1,R0,#+76
   \   0000007A   0x69E0             LDR      R0,[R4, #+28]
   \   0000007C   0x.... 0x....      BL       HAL_DMA_Start_IT
   3628              }
   3629              break;
   \   00000080   0xE064             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3630              case TIM_DMA_CC1:
   3631              {  
   3632                /* Set the DMA Period elapsed callback */
   3633                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_4: (+1)
   \   00000082   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   00000086   0x6A21             LDR      R1,[R4, #+32]
   \   00000088   0x63C8             STR      R0,[R1, #+60]
   3634               
   3635                /* Set the DMA error callback */
   3636                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   0000008A   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000008E   0x6A21             LDR      R1,[R4, #+32]
   \   00000090   0x64C8             STR      R0,[R1, #+76]
   3637            
   3638                /* Enable the DMA Stream */
   3639                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);      
   \   00000092   0x0A38             LSRS     R0,R7,#+8
   \   00000094   0x1C43             ADDS     R3,R0,#+1
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0xF100 0x014C      ADD      R1,R0,#+76
   \   0000009C   0x6A20             LDR      R0,[R4, #+32]
   \   0000009E   0x.... 0x....      BL       HAL_DMA_Start_IT
   3640              }
   3641              break;
   \   000000A2   0xE053             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3642              case TIM_DMA_CC2:
   3643              {  
   3644                /* Set the DMA Period elapsed callback */
   3645                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_5: (+1)
   \   000000A4   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000A8   0x6A61             LDR      R1,[R4, #+36]
   \   000000AA   0x63C8             STR      R0,[R1, #+60]
   3646               
   3647                /* Set the DMA error callback */
   3648                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   000000AC   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000B0   0x6A61             LDR      R1,[R4, #+36]
   \   000000B2   0x64C8             STR      R0,[R1, #+76]
   3649            
   3650                /* Enable the DMA Stream */
   3651                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);     
   \   000000B4   0x0A38             LSRS     R0,R7,#+8
   \   000000B6   0x1C43             ADDS     R3,R0,#+1
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0xF100 0x014C      ADD      R1,R0,#+76
   \   000000BE   0x6A60             LDR      R0,[R4, #+36]
   \   000000C0   0x.... 0x....      BL       HAL_DMA_Start_IT
   3652              }
   3653              break;
   \   000000C4   0xE042             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3654              case TIM_DMA_CC3:
   3655              {  
   3656                /* Set the DMA Period elapsed callback */
   3657                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_6: (+1)
   \   000000C6   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000CA   0x6AA1             LDR      R1,[R4, #+40]
   \   000000CC   0x63C8             STR      R0,[R1, #+60]
   3658               
   3659                /* Set the DMA error callback */
   3660                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000CE   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000D2   0x6AA1             LDR      R1,[R4, #+40]
   \   000000D4   0x64C8             STR      R0,[R1, #+76]
   3661            
   3662                /* Enable the DMA Stream */
   3663                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);      
   \   000000D6   0x0A38             LSRS     R0,R7,#+8
   \   000000D8   0x1C43             ADDS     R3,R0,#+1
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0xF100 0x014C      ADD      R1,R0,#+76
   \   000000E0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000E2   0x.... 0x....      BL       HAL_DMA_Start_IT
   3664              }
   3665              break;
   \   000000E6   0xE031             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3666              case TIM_DMA_CC4:
   3667              {  
   3668                /* Set the DMA Period elapsed callback */
   3669                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_7: (+1)
   \   000000E8   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000EC   0x6AE1             LDR      R1,[R4, #+44]
   \   000000EE   0x63C8             STR      R0,[R1, #+60]
   3670               
   3671                /* Set the DMA error callback */
   3672                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000F0   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000F4   0x6AE1             LDR      R1,[R4, #+44]
   \   000000F6   0x64C8             STR      R0,[R1, #+76]
   3673            
   3674                /* Enable the DMA Stream */
   3675                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);      
   \   000000F8   0x0A38             LSRS     R0,R7,#+8
   \   000000FA   0x1C43             ADDS     R3,R0,#+1
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0xF100 0x014C      ADD      R1,R0,#+76
   \   00000102   0x6AE0             LDR      R0,[R4, #+44]
   \   00000104   0x.... 0x....      BL       HAL_DMA_Start_IT
   3676              }
   3677              break;
   \   00000108   0xE020             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3678              case TIM_DMA_COM:
   3679              {  
   3680                /* Set the DMA Period elapsed callback */
   3681                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_8: (+1)
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable28
   \   0000010E   0x6B21             LDR      R1,[R4, #+48]
   \   00000110   0x63C8             STR      R0,[R1, #+60]
   3682               
   3683                /* Set the DMA error callback */
   3684                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   \   00000112   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000116   0x6B21             LDR      R1,[R4, #+48]
   \   00000118   0x64C8             STR      R0,[R1, #+76]
   3685            
   3686                /* Enable the DMA Stream */
   3687                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);      
   \   0000011A   0x0A38             LSRS     R0,R7,#+8
   \   0000011C   0x1C43             ADDS     R3,R0,#+1
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0xF100 0x014C      ADD      R1,R0,#+76
   \   00000124   0x6B20             LDR      R0,[R4, #+48]
   \   00000126   0x.... 0x....      BL       HAL_DMA_Start_IT
   3688              }
   3689              break;
   \   0000012A   0xE00F             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3690              case TIM_DMA_TRIGGER:
   3691              {  
   3692                /* Set the DMA Period elapsed callback */
   3693                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_9: (+1)
   \   0000012C   0x.... 0x....      ADR.W    R0,TIM_DMATriggerCplt
   \   00000130   0x6B61             LDR      R1,[R4, #+52]
   \   00000132   0x63C8             STR      R0,[R1, #+60]
   3694               
   3695                /* Set the DMA error callback */
   3696                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   \   00000134   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000138   0x6B61             LDR      R1,[R4, #+52]
   \   0000013A   0x64C8             STR      R0,[R1, #+76]
   3697            
   3698                /* Enable the DMA Stream */
   3699                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1);      
   \   0000013C   0x0A38             LSRS     R0,R7,#+8
   \   0000013E   0x1C43             ADDS     R3,R0,#+1
   \   00000140   0x6820             LDR      R0,[R4, #+0]
   \   00000142   0xF100 0x014C      ADD      R1,R0,#+76
   \   00000146   0x6B60             LDR      R0,[R4, #+52]
   \   00000148   0x.... 0x....      BL       HAL_DMA_Start_IT
   3700              }
   3701              break;
   3702              default:
   3703              break;  
   3704            }
   3705          
   3706            /* configure the DMA Burst Mode */
   3707            htim->Instance->DCR = BurstBaseAddress | BurstLength;  
   \                     ??HAL_TIM_DMABurst_ReadStart_10: (+1)
   \   0000014C   0xEA47 0x0006      ORR      R0,R7,R6
   \   00000150   0x6821             LDR      R1,[R4, #+0]
   \   00000152   0x6488             STR      R0,[R1, #+72]
   3708            
   3709            /* Enable the TIM DMA Request */
   3710            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \   00000154   0x6820             LDR      R0,[R4, #+0]
   \   00000156   0x68C1             LDR      R1,[R0, #+12]
   \   00000158   0x4329             ORRS     R1,R5,R1
   \   0000015A   0x60C1             STR      R1,[R0, #+12]
   3711            
   3712            htim->State = HAL_TIM_STATE_READY;
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0xF884 0x0039      STRB     R0,[R4, #+57]
   3713            
   3714            /* Return function status */
   3715            return HAL_OK;
   \   00000162   0x2000             MOVS     R0,#+0
   \   00000164   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3716          }
   3717          
   3718          /**
   3719            * @brief  Stop the DMA burst reading 
   3720            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3721            *                the configuration information for TIM module.
   3722            * @param  BurstRequestSrc: TIM DMA Request sources to disable.
   3723            * @retval HAL status
   3724            */

   \                                 In section .text, align 2, keep-with-next
   3725          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3726          {
   \                     HAL_TIM_DMABurst_ReadStop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   3727            /* Check the parameters */
   3728            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3729            
   3730            /* Abort the DMA transfer (at least disable the DMA channel) */
   3731            switch(BurstRequestSrc)
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000000C   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_0
   \   0000000E   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000012   0xD013             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_1
   \   00000014   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000018   0xD014             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_2
   \   0000001A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000001E   0xD015             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_3
   \   00000020   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000024   0xD016             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_4
   \   00000026   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000002A   0xD017             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_5
   \   0000002C   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000030   0xD018             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_6
   \   00000032   0xE01A             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3732            {
   3733              case TIM_DMA_UPDATE:
   3734              {  
   3735                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_ReadStop_0: (+1)
   \   00000034   0x69E0             LDR      R0,[R4, #+28]
   \   00000036   0x.... 0x....      BL       HAL_DMA_Abort
   3736              }
   3737              break;
   \   0000003A   0xE016             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3738              case TIM_DMA_CC1:
   3739              {  
   3740                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_ReadStop_1: (+1)
   \   0000003C   0x6A20             LDR      R0,[R4, #+32]
   \   0000003E   0x.... 0x....      BL       HAL_DMA_Abort
   3741              }
   3742              break;
   \   00000042   0xE012             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3743              case TIM_DMA_CC2:
   3744              {  
   3745                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_ReadStop_2: (+1)
   \   00000044   0x6A60             LDR      R0,[R4, #+36]
   \   00000046   0x.... 0x....      BL       HAL_DMA_Abort
   3746              }
   3747              break;
   \   0000004A   0xE00E             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3748              case TIM_DMA_CC3:
   3749              {  
   3750                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_ReadStop_3: (+1)
   \   0000004C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Abort
   3751              }
   3752              break;
   \   00000052   0xE00A             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3753              case TIM_DMA_CC4:
   3754              {  
   3755                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_ReadStop_4: (+1)
   \   00000054   0x6AE0             LDR      R0,[R4, #+44]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Abort
   3756              }
   3757              break;
   \   0000005A   0xE006             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3758              case TIM_DMA_COM:
   3759              {  
   3760                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_ReadStop_5: (+1)
   \   0000005C   0x6B20             LDR      R0,[R4, #+48]
   \   0000005E   0x.... 0x....      BL       HAL_DMA_Abort
   3761              }
   3762              break;
   \   00000062   0xE002             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3763              case TIM_DMA_TRIGGER:
   3764              {  
   3765                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_ReadStop_6: (+1)
   \   00000064   0x6B60             LDR      R0,[R4, #+52]
   \   00000066   0x.... 0x....      BL       HAL_DMA_Abort
   3766              }
   3767              break;
   3768              default:
   3769              break;  
   3770            }
   3771            
   3772            /* Disable the TIM Update DMA request */
   3773            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??HAL_TIM_DMABurst_ReadStop_7: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x68C1             LDR      R1,[R0, #+12]
   \   0000006E   0x43A9             BICS     R1,R1,R5
   \   00000070   0x60C1             STR      R1,[R0, #+12]
   3774                
   3775            /* Return function status */
   3776            return HAL_OK;  
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3777          }
   3778          
   3779          /**
   3780            * @brief  Generate a software event
   3781            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3782            *                the configuration information for TIM module.
   3783            * @param  EventSource: specifies the event source.
   3784            *          This parameter can be one of the following values:
   3785            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   3786            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   3787            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   3788            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   3789            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   3790            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source  
   3791            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   3792            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   3793            * @note   TIM6 and TIM7 can only generate an update event. 
   3794            * @note   TIM_EVENTSOURCE_COM and TIM_EVENTSOURCE_BREAK are used only with TIM1 and TIM8.
   3795            * @retval HAL status
   3796            */ 
   3797          

   \                                 In section .text, align 2, keep-with-next
   3798          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   3799          {
   3800            /* Check the parameters */
   3801            assert_param(IS_TIM_INSTANCE(htim->Instance));
   3802            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   3803            
   3804            /* Process Locked */
   3805            __HAL_LOCK(htim);
   \                     HAL_TIM_GenerateEvent: (+1)
   \   00000000   0xF990 0x2038      LDRSB    R2,[R0, #+56]
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD101             BNE.N    ??HAL_TIM_GenerateEvent_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_TIM_GenerateEvent_0: (+1)
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xF880 0x2038      STRB     R2,[R0, #+56]
   3806            
   3807            /* Change the TIM state */
   3808            htim->State = HAL_TIM_STATE_BUSY;
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0xF880 0x2039      STRB     R2,[R0, #+57]
   3809            
   3810            /* Set the event sources */
   3811            htim->Instance->EGR = EventSource;
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x6151             STR      R1,[R2, #+20]
   3812            
   3813            /* Change the TIM state */
   3814            htim->State = HAL_TIM_STATE_READY;
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0xF880 0x1039      STRB     R1,[R0, #+57]
   3815            
   3816            __HAL_UNLOCK(htim);
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xF880 0x1038      STRB     R1,[R0, #+56]
   3817            
   3818            /* Return function status */
   3819            return HAL_OK;  
   \   00000028   0x4608             MOV      R0,R1
   \   0000002A   0x4770             BX       LR               ;; return
   3820          }
   3821          
   3822          /**
   3823            * @brief  Configures the OCRef clear feature
   3824            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3825            *                the configuration information for TIM module.
   3826            * @param  sClearInputConfig: pointer to a TIM_ClearInputConfigTypeDef structure that
   3827            *         contains the OCREF clear feature and parameters for the TIM peripheral. 
   3828            * @param  Channel: specifies the TIM Channel.
   3829            *          This parameter can be one of the following values:
   3830            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3831            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3832            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3833            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3834            * @retval HAL status
   3835            */ 

   \                                 In section .text, align 2, keep-with-next
   3836          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
   3837          { 
   \                     HAL_TIM_ConfigOCrefClear: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   3838            /* Check the parameters */
   3839            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3840            assert_param(IS_TIM_CHANNELS(Channel));
   3841            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   3842            assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   3843            assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   3844            assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   3845             
   3846            /* Process Locked */
   3847            __HAL_LOCK(htim);
   \   00000008   0xF994 0x0038      LDRSB    R0,[R4, #+56]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_ConfigOCrefClear_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_TIM_ConfigOCrefClear_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
   3848            
   3849            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0039      STRB     R0,[R4, #+57]
   3850            
   3851            if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
   \   00000020   0x6868             LDR      R0,[R5, #+4]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD105             BNE.N    ??HAL_TIM_ConfigOCrefClear_1
   3852            {
   3853              TIM_ETR_SetConfig(htim->Instance, 
   3854                                sClearInputConfig->ClearInputPrescaler,
   3855                                sClearInputConfig->ClearInputPolarity,
   3856                                sClearInputConfig->ClearInputFilter);
   \   00000026   0x692B             LDR      R3,[R5, #+16]
   \   00000028   0x68AA             LDR      R2,[R5, #+8]
   \   0000002A   0x68E9             LDR      R1,[R5, #+12]
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      BL       TIM_ETR_SetConfig
   3857            }
   3858            
   3859            switch (Channel)
   \                     ??HAL_TIM_ConfigOCrefClear_1: (+1)
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_2
   \   00000036   0x2E04             CMP      R6,#+4
   \   00000038   0xD011             BEQ.N    ??HAL_TIM_ConfigOCrefClear_3
   \   0000003A   0x2E08             CMP      R6,#+8
   \   0000003C   0xD01C             BEQ.N    ??HAL_TIM_ConfigOCrefClear_4
   \   0000003E   0x2E0C             CMP      R6,#+12
   \   00000040   0xD027             BEQ.N    ??HAL_TIM_ConfigOCrefClear_5
   \   00000042   0xE032             B.N      ??HAL_TIM_ConfigOCrefClear_6
   3860            {
   3861              case TIM_CHANNEL_1:
   3862              {        
   3863                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_2: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6829             LDR      R1,[R5, #+0]
   \   00000048   0x2900             CMP      R1,#+0
   \   0000004A   0x6981             LDR      R1,[R0, #+24]
   \   0000004C   0xD003             BEQ.N    ??HAL_TIM_ConfigOCrefClear_7
   3864                {
   3865                  /* Enable the Ocref clear feature for Channel 1 */
   3866                  htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
   \   0000004E   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000052   0x6181             STR      R1,[R0, #+24]
   \   00000054   0xE029             B.N      ??HAL_TIM_ConfigOCrefClear_6
   3867                }
   3868                else
   3869                {
   3870                  /* Disable the Ocref clear feature for Channel 1 */
   3871                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
   \                     ??HAL_TIM_ConfigOCrefClear_7: (+1)
   \   00000056   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000005A   0x6181             STR      R1,[R0, #+24]
   \   0000005C   0xE025             B.N      ??HAL_TIM_ConfigOCrefClear_6
   3872                }
   3873              }    
   3874              break;
   3875              case TIM_CHANNEL_2:    
   3876              { 
   3877                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
   3878                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_3: (+1)
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6829             LDR      R1,[R5, #+0]
   \   00000062   0x2900             CMP      R1,#+0
   \   00000064   0x6981             LDR      R1,[R0, #+24]
   \   00000066   0xD003             BEQ.N    ??HAL_TIM_ConfigOCrefClear_8
   3879                {
   3880                  /* Enable the Ocref clear feature for Channel 2 */
   3881                  htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
   \   00000068   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000006C   0x6181             STR      R1,[R0, #+24]
   \   0000006E   0xE01C             B.N      ??HAL_TIM_ConfigOCrefClear_6
   3882                }
   3883                else
   3884                {
   3885                  /* Disable the Ocref clear feature for Channel 2 */
   3886                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
   \                     ??HAL_TIM_ConfigOCrefClear_8: (+1)
   \   00000070   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000074   0x6181             STR      R1,[R0, #+24]
   \   00000076   0xE018             B.N      ??HAL_TIM_ConfigOCrefClear_6
   3887                }
   3888              } 
   3889              break;
   3890              case TIM_CHANNEL_3:   
   3891              {  
   3892                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3893                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_4: (+1)
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6829             LDR      R1,[R5, #+0]
   \   0000007C   0x2900             CMP      R1,#+0
   \   0000007E   0x69C1             LDR      R1,[R0, #+28]
   \   00000080   0xD003             BEQ.N    ??HAL_TIM_ConfigOCrefClear_9
   3894                {
   3895                  /* Enable the Ocref clear feature for Channel 3 */
   3896                  htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
   \   00000082   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000086   0x61C1             STR      R1,[R0, #+28]
   \   00000088   0xE00F             B.N      ??HAL_TIM_ConfigOCrefClear_6
   3897                }
   3898                else
   3899                {
   3900                  /* Disable the Ocref clear feature for Channel 3 */
   3901                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
   \                     ??HAL_TIM_ConfigOCrefClear_9: (+1)
   \   0000008A   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000008E   0x61C1             STR      R1,[R0, #+28]
   \   00000090   0xE00B             B.N      ??HAL_TIM_ConfigOCrefClear_6
   3902                }
   3903              } 
   3904              break;
   3905              case TIM_CHANNEL_4:    
   3906              {  
   3907                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3908                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_5: (+1)
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6829             LDR      R1,[R5, #+0]
   \   00000096   0x2900             CMP      R1,#+0
   \   00000098   0x69C1             LDR      R1,[R0, #+28]
   \   0000009A   0xD003             BEQ.N    ??HAL_TIM_ConfigOCrefClear_10
   3909                {
   3910                  /* Enable the Ocref clear feature for Channel 4 */
   3911                  htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
   \   0000009C   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000A0   0x61C1             STR      R1,[R0, #+28]
   \   000000A2   0xE002             B.N      ??HAL_TIM_ConfigOCrefClear_6
   3912                }
   3913                else
   3914                {
   3915                  /* Disable the Ocref clear feature for Channel 4 */
   3916                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
   \                     ??HAL_TIM_ConfigOCrefClear_10: (+1)
   \   000000A4   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   000000A8   0x61C1             STR      R1,[R0, #+28]
   3917                }
   3918              } 
   3919              break;
   3920              default:  
   3921              break;
   3922            } 
   3923          
   3924            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigOCrefClear_6: (+1)
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0xF884 0x0039      STRB     R0,[R4, #+57]
   3925            
   3926            __HAL_UNLOCK(htim);
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF884 0x0038      STRB     R0,[R4, #+56]
   3927            
   3928            return HAL_OK;  
   \   000000B6   0xBD70             POP      {R4-R6,PC}       ;; return
   3929          }  
   3930          
   3931          /**
   3932            * @brief   Configures the clock source to be used
   3933            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3934            *                the configuration information for TIM module.
   3935            * @param  sClockSourceConfig: pointer to a TIM_ClockConfigTypeDef structure that
   3936            *         contains the clock source information for the TIM peripheral. 
   3937            * @retval HAL status
   3938            */ 

   \                                 In section .text, align 2, keep-with-next
   3939          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
   3940          {
   \                     HAL_TIM_ConfigClockSource: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   3941            uint32_t tmpsmcr = 0U;
   3942              
   3943            /* Process Locked */
   3944            __HAL_LOCK(htim);
   \   00000004   0xF994 0x0038      LDRSB    R0,[R4, #+56]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_ConfigClockSource_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_TIM_ConfigClockSource_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   3945            
   3946            htim->State = HAL_TIM_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF884 0x0039      STRB     R0,[R4, #+57]
   3947            
   3948            /* Check the parameters */
   3949            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   3950            
   3951            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   3952            tmpsmcr = htim->Instance->SMCR;
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6882             LDR      R2,[R0, #+8]
   3953            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3954            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   3955            htim->Instance->SMCR = tmpsmcr;
   \   00000020   0x.... 0x....      LDR.W    R3,??DataTable28_1  ;; 0xffff0088
   \   00000024   0x401A             ANDS     R2,R3,R2
   \   00000026   0x6082             STR      R2,[R0, #+8]
   3956            
   3957            switch (sClockSourceConfig->ClockSource)
   \   00000028   0x6808             LDR      R0,[R1, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD050             BEQ.N    ??HAL_TIM_ConfigClockSource_1
   \   0000002E   0x2810             CMP      R0,#+16
   \   00000030   0xD053             BEQ.N    ??HAL_TIM_ConfigClockSource_2
   \   00000032   0x2820             CMP      R0,#+32
   \   00000034   0xD056             BEQ.N    ??HAL_TIM_ConfigClockSource_3
   \   00000036   0x2830             CMP      R0,#+48
   \   00000038   0xD059             BEQ.N    ??HAL_TIM_ConfigClockSource_4
   \   0000003A   0x2840             CMP      R0,#+64
   \   0000003C   0xD03E             BEQ.N    ??HAL_TIM_ConfigClockSource_5
   \   0000003E   0x2850             CMP      R0,#+80
   \   00000040   0xD028             BEQ.N    ??HAL_TIM_ConfigClockSource_6
   \   00000042   0x2860             CMP      R0,#+96
   \   00000044   0xD030             BEQ.N    ??HAL_TIM_ConfigClockSource_7
   \   00000046   0x2870             CMP      R0,#+112
   \   00000048   0xD00C             BEQ.N    ??HAL_TIM_ConfigClockSource_8
   \   0000004A   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000004E   0xD003             BEQ.N    ??HAL_TIM_ConfigClockSource_9
   \   00000050   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000054   0xD012             BEQ.N    ??HAL_TIM_ConfigClockSource_10
   \   00000056   0xE04E             B.N      ??HAL_TIM_ConfigClockSource_11
   3958            {
   3959              case TIM_CLOCKSOURCE_INTERNAL:
   3960              { 
   3961                assert_param(IS_TIM_INSTANCE(htim->Instance));
   3962                
   3963                /* Disable slave mode to clock the prescaler directly with the internal clock */
   3964                htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \                     ??HAL_TIM_ConfigClockSource_9: (+1)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6881             LDR      R1,[R0, #+8]
   \   0000005C   0x08C9             LSRS     R1,R1,#+3
   \   0000005E   0x00C9             LSLS     R1,R1,#+3
   \   00000060   0x6081             STR      R1,[R0, #+8]
   3965              }
   3966              break;
   \   00000062   0xE048             B.N      ??HAL_TIM_ConfigClockSource_11
   3967              
   3968              case TIM_CLOCKSOURCE_ETRMODE1:
   3969              {
   3970                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   3971          
   3972                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3973                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   3974                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3975          
   3976                /* Configure the ETR Clock source */
   3977                TIM_ETR_SetConfig(htim->Instance, 
   3978                                  sClockSourceConfig->ClockPrescaler, 
   3979                                  sClockSourceConfig->ClockPolarity, 
   3980                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_8: (+1)
   \   00000064   0x68CB             LDR      R3,[R1, #+12]
   \   00000066   0x684A             LDR      R2,[R1, #+4]
   \   00000068   0x6889             LDR      R1,[R1, #+8]
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x.... 0x....      BL       TIM_ETR_SetConfig
   3981                /* Get the TIMx SMCR register value */
   3982                tmpsmcr = htim->Instance->SMCR;
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6882             LDR      R2,[R0, #+8]
   3983                /* Reset the SMS and TS Bits */
   3984                tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3985                /* Select the External clock mode1 and the ETRF trigger */
   3986                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   3987                /* Write to TIMx SMCR */
   3988                htim->Instance->SMCR = tmpsmcr;
   \   00000074   0xF042 0x0177      ORR      R1,R2,#0x77
   \   00000078   0x6081             STR      R1,[R0, #+8]
   3989              }
   3990              break;
   \   0000007A   0xE03C             B.N      ??HAL_TIM_ConfigClockSource_11
   3991              
   3992              case TIM_CLOCKSOURCE_ETRMODE2:
   3993              {
   3994                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   3995          
   3996                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3997                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   3998                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3999          
   4000                /* Configure the ETR Clock source */
   4001                TIM_ETR_SetConfig(htim->Instance, 
   4002                                  sClockSourceConfig->ClockPrescaler, 
   4003                                  sClockSourceConfig->ClockPolarity,
   4004                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_10: (+1)
   \   0000007C   0x68CB             LDR      R3,[R1, #+12]
   \   0000007E   0x684A             LDR      R2,[R1, #+4]
   \   00000080   0x6889             LDR      R1,[R1, #+8]
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x.... 0x....      BL       TIM_ETR_SetConfig
   4005                /* Enable the External clock mode2 */
   4006                htim->Instance->SMCR |= TIM_SMCR_ECE;
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6881             LDR      R1,[R0, #+8]
   \   0000008C   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000090   0x6081             STR      R1,[R0, #+8]
   4007              }
   4008              break;
   \   00000092   0xE030             B.N      ??HAL_TIM_ConfigClockSource_11
   4009              
   4010              case TIM_CLOCKSOURCE_TI1:
   4011              {
   4012                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4013          
   4014                /* Check TI1 input conditioning related parameters */
   4015                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4016                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4017          
   4018                TIM_TI1_ConfigInputStage(htim->Instance, 
   4019                                  sClockSourceConfig->ClockPolarity, 
   4020                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_6: (+1)
   \   00000094   0x68CA             LDR      R2,[R1, #+12]
   \   00000096   0x6849             LDR      R1,[R1, #+4]
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   4021                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   \   0000009E   0x2150             MOVS     R1,#+80
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4022              }
   4023              break;
   \   000000A6   0xE026             B.N      ??HAL_TIM_ConfigClockSource_11
   4024              case TIM_CLOCKSOURCE_TI2:
   4025              {
   4026                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4027          
   4028                /* Check TI1 input conditioning related parameters */
   4029                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4030                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4031          
   4032                TIM_TI2_ConfigInputStage(htim->Instance, 
   4033                                  sClockSourceConfig->ClockPolarity, 
   4034                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_7: (+1)
   \   000000A8   0x68CA             LDR      R2,[R1, #+12]
   \   000000AA   0x6849             LDR      R1,[R1, #+4]
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x.... 0x....      BL       TIM_TI2_ConfigInputStage
   4035                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   \   000000B2   0x2160             MOVS     R1,#+96
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4036              }
   4037              break;
   \   000000BA   0xE01C             B.N      ??HAL_TIM_ConfigClockSource_11
   4038              case TIM_CLOCKSOURCE_TI1ED:
   4039              {
   4040                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4041          
   4042                /* Check TI1 input conditioning related parameters */
   4043                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4044                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4045          
   4046                TIM_TI1_ConfigInputStage(htim->Instance, 
   4047                                  sClockSourceConfig->ClockPolarity,
   4048                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_5: (+1)
   \   000000BC   0x68CA             LDR      R2,[R1, #+12]
   \   000000BE   0x6849             LDR      R1,[R1, #+4]
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   4049                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   \   000000C6   0x2140             MOVS     R1,#+64
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4050              }
   4051              break;
   \   000000CE   0xE012             B.N      ??HAL_TIM_ConfigClockSource_11
   4052              case TIM_CLOCKSOURCE_ITR0:
   4053              {
   4054                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4055                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
   \                     ??HAL_TIM_ConfigClockSource_1: (+1)
   \   000000D0   0x2100             MOVS     R1,#+0
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4056              }
   4057              break;
   \   000000D8   0xE00D             B.N      ??HAL_TIM_ConfigClockSource_11
   4058              case TIM_CLOCKSOURCE_ITR1:
   4059              {
   4060                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4061                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
   \                     ??HAL_TIM_ConfigClockSource_2: (+1)
   \   000000DA   0x2110             MOVS     R1,#+16
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4062              }
   4063              break;
   \   000000E2   0xE008             B.N      ??HAL_TIM_ConfigClockSource_11
   4064              case TIM_CLOCKSOURCE_ITR2:
   4065              {
   4066                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4067                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
   \                     ??HAL_TIM_ConfigClockSource_3: (+1)
   \   000000E4   0x2120             MOVS     R1,#+32
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4068              }
   4069              break;
   \   000000EC   0xE003             B.N      ??HAL_TIM_ConfigClockSource_11
   4070              case TIM_CLOCKSOURCE_ITR3:
   4071              {
   4072                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4073                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
   \                     ??HAL_TIM_ConfigClockSource_4: (+1)
   \   000000EE   0x2130             MOVS     R1,#+48
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4074              }
   4075              break;
   4076              
   4077              default:
   4078              break;    
   4079            }
   4080            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigClockSource_11: (+1)
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0xF884 0x0039      STRB     R0,[R4, #+57]
   4081            
   4082            __HAL_UNLOCK(htim);
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xF884 0x0038      STRB     R0,[R4, #+56]
   4083            
   4084            return HAL_OK;
   \   00000102   0xBD10             POP      {R4,PC}          ;; return
   4085          }
   4086          
   4087          /**
   4088            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4089            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4090            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4091            *                the configuration information for TIM module.
   4092            * @param  TI1_Selection: Indicate whether or not channel 1 is connected to the
   4093            *         output of a XOR gate.
   4094            *         This parameter can be one of the following values:
   4095            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4096            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4097            *            pins are connected to the TI1 input (XOR combination)
   4098            * @retval HAL status
   4099            */

   \                                 In section .text, align 2, keep-with-next
   4100          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4101          {
   4102            uint32_t tmpcr2 = 0U;
   4103            
   4104            /* Check the parameters */
   4105            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
   4106            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4107          
   4108            /* Get the TIMx CR2 register value */
   4109            tmpcr2 = htim->Instance->CR2;
   \                     HAL_TIM_ConfigTI1Input: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6842             LDR      R2,[R0, #+4]
   4110          
   4111            /* Reset the TI1 selection */
   4112            tmpcr2 &= ~TIM_CR2_TI1S;
   4113          
   4114            /* Set the TI1 selection */
   4115            tmpcr2 |= TI1_Selection;
   4116            
   4117            /* Write to TIMxCR2 */
   4118            htim->Instance->CR2 = tmpcr2;
   \   00000004   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000008   0x4311             ORRS     R1,R1,R2
   \   0000000A   0x6041             STR      R1,[R0, #+4]
   4119          
   4120            return HAL_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
   4121          }
   4122          
   4123          /**
   4124            * @brief  Configures the TIM in Slave mode
   4125            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4126            *                the configuration information for TIM module.
   4127            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   4128            *         contains the selected trigger (internal trigger input, filtered
   4129            *         timer input or external trigger input) and the ) and the Slave 
   4130            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   4131            * @retval HAL status
   4132            */

   \                                 In section .text, align 2, keep-with-next
   4133          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
   4134          {
   \                     HAL_TIM_SlaveConfigSynchronization: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   4135            /* Check the parameters */
   4136            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4137            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4138            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4139             
   4140            __HAL_LOCK(htim);
   \   00000004   0xF994 0x0038      LDRSB    R0,[R4, #+56]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_SlaveConfigSynchronization_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_TIM_SlaveConfigSynchronization_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   4141            
   4142            htim->State = HAL_TIM_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF884 0x0039      STRB     R0,[R4, #+57]
   4143          
   4144            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       TIM_SlaveTimer_SetConfig
   4145            
   4146            /* Disable Trigger Interrupt */
   4147            __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C1             LDR      R1,[R0, #+12]
   \   00000026   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000002A   0x60C1             STR      R1,[R0, #+12]
   4148            
   4149            /* Disable Trigger DMA request */
   4150            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x68C1             LDR      R1,[R0, #+12]
   \   00000030   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000034   0x60C1             STR      R1,[R0, #+12]
   4151            
   4152            htim->State = HAL_TIM_STATE_READY;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF884 0x0039      STRB     R0,[R4, #+57]
   4153               
   4154            __HAL_UNLOCK(htim);  
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF884 0x0038      STRB     R0,[R4, #+56]
   4155            
   4156            return HAL_OK;
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   4157          } 
   4158          
   4159          /**
   4160            * @brief  Configures the TIM in Slave mode in interrupt mode
   4161            * @param  htim: TIM handle.
   4162            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   4163            *         contains the selected trigger (internal trigger input, filtered
   4164            *         timer input or external trigger input) and the ) and the Slave 
   4165            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   4166            * @retval HAL status
   4167            */

   \                                 In section .text, align 2, keep-with-next
   4168          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, 
   4169                                                                  TIM_SlaveConfigTypeDef * sSlaveConfig)
   4170          {
   \                     HAL_TIM_SlaveConfigSynchronization_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   4171            /* Check the parameters */
   4172            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4173            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4174            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4175            
   4176            __HAL_LOCK(htim);
   \   00000004   0xF994 0x0038      LDRSB    R0,[R4, #+56]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_SlaveConfigSynchronization_IT_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   4177          
   4178            htim->State = HAL_TIM_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF884 0x0039      STRB     R0,[R4, #+57]
   4179            
   4180            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       TIM_SlaveTimer_SetConfig
   4181            
   4182            /* Enable Trigger Interrupt */
   4183            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C1             LDR      R1,[R0, #+12]
   \   00000026   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000002A   0x60C1             STR      R1,[R0, #+12]
   4184            
   4185            /* Disable Trigger DMA request */
   4186            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x68C1             LDR      R1,[R0, #+12]
   \   00000030   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000034   0x60C1             STR      R1,[R0, #+12]
   4187            
   4188            htim->State = HAL_TIM_STATE_READY;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF884 0x0039      STRB     R0,[R4, #+57]
   4189               
   4190            __HAL_UNLOCK(htim);  
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF884 0x0038      STRB     R0,[R4, #+56]
   4191            
   4192            return HAL_OK;
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   4193          }
   4194          
   4195          /**
   4196            * @brief  Read the captured value from Capture Compare unit
   4197            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4198            *                the configuration information for TIM module.
   4199            * @param  Channel: TIM Channels to be enabled.
   4200            *          This parameter can be one of the following values:
   4201            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4202            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4203            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4204            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4205            * @retval Captured value
   4206            */

   \                                 In section .text, align 2, keep-with-next
   4207          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4208          {
   4209            uint32_t tmpreg = 0U;
   \                     HAL_TIM_ReadCapturedValue: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   4210            
   4211            __HAL_LOCK(htim);
   \   00000002   0xF990 0x3038      LDRSB    R3,[R0, #+56]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIM_ReadCapturedValue_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR
   \                     ??HAL_TIM_ReadCapturedValue_0: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF880 0x3038      STRB     R3,[R0, #+56]
   4212            
   4213            switch (Channel)
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD006             BEQ.N    ??HAL_TIM_ReadCapturedValue_1
   \   00000018   0x2904             CMP      R1,#+4
   \   0000001A   0xD007             BEQ.N    ??HAL_TIM_ReadCapturedValue_2
   \   0000001C   0x2908             CMP      R1,#+8
   \   0000001E   0xD008             BEQ.N    ??HAL_TIM_ReadCapturedValue_3
   \   00000020   0x290C             CMP      R1,#+12
   \   00000022   0xD009             BEQ.N    ??HAL_TIM_ReadCapturedValue_4
   \   00000024   0xE00A             B.N      ??HAL_TIM_ReadCapturedValue_5
   4214            {
   4215              case TIM_CHANNEL_1:
   4216              {
   4217                /* Check the parameters */
   4218                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4219                
   4220                /* Return the capture 1 value */
   4221                tmpreg = htim->Instance->CCR1;
   \                     ??HAL_TIM_ReadCapturedValue_1: (+1)
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x6B4A             LDR      R2,[R1, #+52]
   4222                
   4223                break;
   \   0000002A   0xE007             B.N      ??HAL_TIM_ReadCapturedValue_5
   4224              }
   4225              case TIM_CHANNEL_2:
   4226              {
   4227                /* Check the parameters */
   4228                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4229                
   4230                /* Return the capture 2 value */
   4231                tmpreg = htim->Instance->CCR2;
   \                     ??HAL_TIM_ReadCapturedValue_2: (+1)
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x6B8A             LDR      R2,[R1, #+56]
   4232                
   4233                break;
   \   00000030   0xE004             B.N      ??HAL_TIM_ReadCapturedValue_5
   4234              }
   4235              
   4236              case TIM_CHANNEL_3:
   4237              {
   4238                /* Check the parameters */
   4239                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4240                
   4241                /* Return the capture 3 value */
   4242                tmpreg = htim->Instance->CCR3;
   \                     ??HAL_TIM_ReadCapturedValue_3: (+1)
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0x6BCA             LDR      R2,[R1, #+60]
   4243                
   4244                break;
   \   00000036   0xE001             B.N      ??HAL_TIM_ReadCapturedValue_5
   4245              }
   4246              
   4247              case TIM_CHANNEL_4:
   4248              {
   4249                /* Check the parameters */
   4250                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4251                
   4252                /* Return the capture 4 value */
   4253                tmpreg = htim->Instance->CCR4;
   \                     ??HAL_TIM_ReadCapturedValue_4: (+1)
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x6C0A             LDR      R2,[R1, #+64]
   4254                
   4255                break;
   4256              }
   4257              
   4258              default:
   4259              break;  
   4260            }
   4261               
   4262            __HAL_UNLOCK(htim);  
   \                     ??HAL_TIM_ReadCapturedValue_5: (+1)
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0xF880 0x1038      STRB     R1,[R0, #+56]
   4263            return tmpreg;
   \   00000042   0x4610             MOV      R0,R2
   \   00000044   0x4770             BX       LR               ;; return
   4264          }
   4265          /**
   4266            * @}
   4267            */
   4268            
   4269          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4270           *  @brief    TIM Callbacks functions 
   4271           *
   4272          @verbatim   
   4273            ==============================================================================
   4274                                  ##### TIM Callbacks functions #####
   4275            ==============================================================================  
   4276           [..]  
   4277             This section provides TIM callback functions:
   4278             (+) Timer Period elapsed callback
   4279             (+) Timer Output Compare callback
   4280             (+) Timer Input capture callback
   4281             (+) Timer Trigger callback
   4282             (+) Timer Error callback
   4283          
   4284          @endverbatim
   4285            * @{
   4286            */
   4287          
   4288          /**
   4289            * @brief  Period elapsed callback in non blocking mode 
   4290            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4291            *                the configuration information for TIM module.
   4292            * @retval None
   4293            */

   \                                 In section .text, align 2, keep-with-next
   4294          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4295          {
   4296            /* Prevent unused argument(s) compilation warning */
   4297            UNUSED(htim);
   4298            /* NOTE : This function Should not be modified, when the callback is needed,
   4299                      the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   4300             */
   4301          }
   \                     HAL_TIM_PeriodElapsedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4302          
   4303          /**
   4304            * @brief  Output Compare callback in non blocking mode 
   4305            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4306            *                the configuration information for TIM module.
   4307            * @retval None
   4308            */

   \                                 In section .text, align 2, keep-with-next
   4309          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   4310          {
   4311            /* Prevent unused argument(s) compilation warning */
   4312            UNUSED(htim);
   4313            /* NOTE : This function Should not be modified, when the callback is needed,
   4314                      the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   4315             */
   4316          }
   \                     HAL_TIM_OC_DelayElapsedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4317          
   4318          /**
   4319            * @brief  Input Capture callback in non blocking mode 
   4320            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4321            *                the configuration information for TIM module.
   4322            * @retval None
   4323            */

   \                                 In section .text, align 2, keep-with-next
   4324          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   4325          {
   4326            /* Prevent unused argument(s) compilation warning */
   4327            UNUSED(htim);
   4328            /* NOTE : This function Should not be modified, when the callback is needed,
   4329                      the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   4330             */
   4331          }
   \                     HAL_TIM_IC_CaptureCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4332          
   4333          /**
   4334            * @brief  PWM Pulse finished callback in non blocking mode 
   4335            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4336            *                the configuration information for TIM module.
   4337            * @retval None
   4338            */

   \                                 In section .text, align 2, keep-with-next
   4339          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   4340          {
   4341            /* Prevent unused argument(s) compilation warning */
   4342            UNUSED(htim);
   4343            /* NOTE : This function Should not be modified, when the callback is needed,
   4344                      the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   4345             */
   4346          }
   \                     HAL_TIM_PWM_PulseFinishedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4347          
   4348          /**
   4349            * @brief  Hall Trigger detection callback in non blocking mode 
   4350            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4351            *                the configuration information for TIM module.
   4352            * @retval None
   4353            */

   \                                 In section .text, align 2, keep-with-next
   4354          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   4355          {
   4356            /* Prevent unused argument(s) compilation warning */
   4357            UNUSED(htim);
   4358            /* NOTE : This function Should not be modified, when the callback is needed,
   4359                      the HAL_TIM_TriggerCallback could be implemented in the user file
   4360             */
   4361          }
   \                     HAL_TIM_TriggerCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4362          
   4363          /**
   4364            * @brief  Timer error callback in non blocking mode 
   4365            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4366            *                the configuration information for TIM module.
   4367            * @retval None
   4368            */

   \                                 In section .text, align 2, keep-with-next
   4369          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   4370          {
   4371            /* Prevent unused argument(s) compilation warning */
   4372            UNUSED(htim);
   4373            /* NOTE : This function Should not be modified, when the callback is needed,
   4374                      the HAL_TIM_ErrorCallback could be implemented in the user file
   4375             */
   4376          }
   \                     HAL_TIM_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4377          /**
   4378            * @}
   4379            */
   4380          
   4381          /** @defgroup TIM_Exported_Functions_Group10 Peripheral State functions 
   4382           *  @brief   Peripheral State functions 
   4383           *
   4384          @verbatim   
   4385            ==============================================================================
   4386                                  ##### Peripheral State functions #####
   4387            ==============================================================================  
   4388            [..]
   4389              This subsection permits to get in run-time the status of the peripheral 
   4390              and the data flow.
   4391          
   4392          @endverbatim
   4393            * @{
   4394            */
   4395          
   4396          /**
   4397            * @brief  Return the TIM Base state
   4398            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4399            *                the configuration information for TIM module.
   4400            * @retval HAL state
   4401            */

   \                                 In section .text, align 2, keep-with-next
   4402          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   4403          {
   4404            return htim->State;
   \                     HAL_TIM_Base_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4405          }
   4406          
   4407          /**
   4408            * @brief  Return the TIM OC state
   4409            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4410            *                the configuration information for TIM module.
   4411            * @retval HAL state
   4412            */

   \                                 In section .text, align 2, keep-with-next
   4413          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   4414          {
   4415            return htim->State;
   \                     HAL_TIM_OC_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4416          }
   4417          
   4418          /**
   4419            * @brief  Return the TIM PWM state
   4420            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4421            *                the configuration information for TIM module.
   4422            * @retval HAL state
   4423            */

   \                                 In section .text, align 2, keep-with-next
   4424          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   4425          {
   4426            return htim->State;
   \                     HAL_TIM_PWM_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4427          }
   4428          
   4429          /**
   4430            * @brief  Return the TIM Input Capture state
   4431            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4432            *                the configuration information for TIM module.
   4433            * @retval HAL state
   4434            */

   \                                 In section .text, align 2, keep-with-next
   4435          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   4436          {
   4437            return htim->State;
   \                     HAL_TIM_IC_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4438          }
   4439          
   4440          /**
   4441            * @brief  Return the TIM One Pulse Mode state
   4442            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4443            *                the configuration information for TIM module.
   4444            * @retval HAL state
   4445            */

   \                                 In section .text, align 2, keep-with-next
   4446          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   4447          {
   4448            return htim->State;
   \                     HAL_TIM_OnePulse_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4449          }
   4450          
   4451          /**
   4452            * @brief  Return the TIM Encoder Mode state
   4453            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4454            *                the configuration information for TIM module.
   4455            * @retval HAL state
   4456            */

   \                                 In section .text, align 2, keep-with-next
   4457          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   4458          {
   4459            return htim->State;
   \                     HAL_TIM_Encoder_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4460          }
   4461          /**
   4462            * @}
   4463            */
   4464          
   4465          /**
   4466            * @brief  Time Base configuration
   4467            * @param  TIMx: TIM peripheral
   4468            * @param  Structure: pointer on TIM Time Base required parameters  
   4469            * @retval None
   4470            */

   \                                 In section .text, align 2, keep-with-next
   4471          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   4472          {
   \                     TIM_Base_SetConfig: (+1)
   \   00000000   0xB410             PUSH     {R4}
   4473            uint32_t tmpcr1 = 0U;
   4474            tmpcr1 = TIMx->CR1;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   4475            
   4476            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   4477            if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable28_2  ;; 0x40010000
   \   00000008   0x4290             CMP      R0,R2
   \   0000000A   0xD012             BEQ.N    ??TIM_Base_SetConfig_0
   \   0000000C   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000010   0xD00F             BEQ.N    ??TIM_Base_SetConfig_0
   \   00000012   0x.... 0x....      LDR.W    R4,??DataTable28_3  ;; 0x40000400
   \   00000016   0x42A0             CMP      R0,R4
   \   00000018   0xD00B             BEQ.N    ??TIM_Base_SetConfig_0
   \   0000001A   0x.... 0x....      LDR.W    R4,??DataTable28_4  ;; 0x40000800
   \   0000001E   0x42A0             CMP      R0,R4
   \   00000020   0xD007             BEQ.N    ??TIM_Base_SetConfig_0
   \   00000022   0x.... 0x....      LDR.W    R4,??DataTable28_5  ;; 0x40000c00
   \   00000026   0x42A0             CMP      R0,R4
   \   00000028   0xD003             BEQ.N    ??TIM_Base_SetConfig_0
   \   0000002A   0x.... 0x....      LDR.W    R4,??DataTable28_6  ;; 0x40010400
   \   0000002E   0x42A0             CMP      R0,R4
   \   00000030   0xD101             BNE.N    ??TIM_Base_SetConfig_1
   \                     ??TIM_Base_SetConfig_0: (+1)
   \   00000032   0x2401             MOVS     R4,#+1
   \   00000034   0xE000             B.N      ??TIM_Base_SetConfig_2
   \                     ??TIM_Base_SetConfig_1: (+1)
   \   00000036   0x2400             MOVS     R4,#+0
   \                     ??TIM_Base_SetConfig_2: (+1)
   \   00000038   0x2C00             CMP      R4,#+0
   \   0000003A   0xD003             BEQ.N    ??TIM_Base_SetConfig_3
   4478            {
   4479              /* Select the Counter Mode */
   4480              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   4481              tmpcr1 |= Structure->CounterMode;
   \   0000003C   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000040   0x684C             LDR      R4,[R1, #+4]
   \   00000042   0x4323             ORRS     R3,R4,R3
   4482            }
   4483           
   4484            if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
   \                     ??TIM_Base_SetConfig_3: (+1)
   \   00000044   0x4290             CMP      R0,R2
   \   00000046   0xD023             BEQ.N    ??TIM_Base_SetConfig_4
   \   00000048   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   0000004C   0xD020             BEQ.N    ??TIM_Base_SetConfig_4
   \   0000004E   0x.... 0x....      LDR.W    R4,??DataTable28_3  ;; 0x40000400
   \   00000052   0x42A0             CMP      R0,R4
   \   00000054   0xD01C             BEQ.N    ??TIM_Base_SetConfig_4
   \   00000056   0x.... 0x....      LDR.W    R4,??DataTable28_4  ;; 0x40000800
   \   0000005A   0x42A0             CMP      R0,R4
   \   0000005C   0xD018             BEQ.N    ??TIM_Base_SetConfig_4
   \   0000005E   0x.... 0x....      LDR.W    R4,??DataTable28_5  ;; 0x40000c00
   \   00000062   0x42A0             CMP      R0,R4
   \   00000064   0xD014             BEQ.N    ??TIM_Base_SetConfig_4
   \   00000066   0x....             LDR.N    R4,??DataTable28_6  ;; 0x40010400
   \   00000068   0x42A0             CMP      R0,R4
   \   0000006A   0xD011             BEQ.N    ??TIM_Base_SetConfig_4
   \   0000006C   0x....             LDR.N    R4,??DataTable28_7  ;; 0x40014000
   \   0000006E   0x42A0             CMP      R0,R4
   \   00000070   0xD00E             BEQ.N    ??TIM_Base_SetConfig_4
   \   00000072   0x....             LDR.N    R4,??DataTable28_8  ;; 0x40014400
   \   00000074   0x42A0             CMP      R0,R4
   \   00000076   0xD00B             BEQ.N    ??TIM_Base_SetConfig_4
   \   00000078   0x....             LDR.N    R4,??DataTable28_9  ;; 0x40014800
   \   0000007A   0x42A0             CMP      R0,R4
   \   0000007C   0xD008             BEQ.N    ??TIM_Base_SetConfig_4
   \   0000007E   0x....             LDR.N    R4,??DataTable28_10  ;; 0x40001800
   \   00000080   0x42A0             CMP      R0,R4
   \   00000082   0xD005             BEQ.N    ??TIM_Base_SetConfig_4
   \   00000084   0x....             LDR.N    R4,??DataTable28_11  ;; 0x40001c00
   \   00000086   0x42A0             CMP      R0,R4
   \   00000088   0xD002             BEQ.N    ??TIM_Base_SetConfig_4
   \   0000008A   0x....             LDR.N    R4,??DataTable28_12  ;; 0x40002000
   \   0000008C   0x42A0             CMP      R0,R4
   \   0000008E   0xD101             BNE.N    ??TIM_Base_SetConfig_5
   \                     ??TIM_Base_SetConfig_4: (+1)
   \   00000090   0x2401             MOVS     R4,#+1
   \   00000092   0xE000             B.N      ??TIM_Base_SetConfig_6
   \                     ??TIM_Base_SetConfig_5: (+1)
   \   00000094   0x2400             MOVS     R4,#+0
   \                     ??TIM_Base_SetConfig_6: (+1)
   \   00000096   0x2C00             CMP      R4,#+0
   \   00000098   0xD003             BEQ.N    ??TIM_Base_SetConfig_7
   4485            {
   4486              /* Set the clock division */
   4487              tmpcr1 &= ~TIM_CR1_CKD;
   4488              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   \   0000009A   0xF423 0x7340      BIC      R3,R3,#0x300
   \   0000009E   0x68CC             LDR      R4,[R1, #+12]
   \   000000A0   0x4323             ORRS     R3,R4,R3
   4489            }
   4490          
   4491            TIMx->CR1 = tmpcr1;
   \                     ??TIM_Base_SetConfig_7: (+1)
   \   000000A2   0x6003             STR      R3,[R0, #+0]
   4492          
   4493            /* Set the Auto-reload value */
   4494            TIMx->ARR = (uint32_t)Structure->Period ;
   \   000000A4   0x688B             LDR      R3,[R1, #+8]
   \   000000A6   0x62C3             STR      R3,[R0, #+44]
   4495           
   4496            /* Set the Prescaler value */
   4497            TIMx->PSC = (uint32_t)Structure->Prescaler;
   \   000000A8   0x680B             LDR      R3,[R1, #+0]
   \   000000AA   0x6283             STR      R3,[R0, #+40]
   4498              
   4499            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
   \   000000AC   0x4290             CMP      R0,R2
   \   000000AE   0xD002             BEQ.N    ??TIM_Base_SetConfig_8
   \   000000B0   0x....             LDR.N    R2,??DataTable28_6  ;; 0x40010400
   \   000000B2   0x4290             CMP      R0,R2
   \   000000B4   0xD101             BNE.N    ??TIM_Base_SetConfig_9
   \                     ??TIM_Base_SetConfig_8: (+1)
   \   000000B6   0x2201             MOVS     R2,#+1
   \   000000B8   0xE000             B.N      ??TIM_Base_SetConfig_10
   \                     ??TIM_Base_SetConfig_9: (+1)
   \   000000BA   0x2200             MOVS     R2,#+0
   \                     ??TIM_Base_SetConfig_10: (+1)
   \   000000BC   0x2A00             CMP      R2,#+0
   \   000000BE   0xD001             BEQ.N    ??TIM_Base_SetConfig_11
   4500            {
   4501              /* Set the Repetition Counter value */
   4502              TIMx->RCR = Structure->RepetitionCounter;
   \   000000C0   0x6909             LDR      R1,[R1, #+16]
   \   000000C2   0x6301             STR      R1,[R0, #+48]
   4503            }
   4504          
   4505            /* Generate an update event to reload the Prescaler 
   4506               and the repetition counter(only for TIM1 and TIM8) value immediately */
   4507            TIMx->EGR = TIM_EGR_UG;
   \                     ??TIM_Base_SetConfig_11: (+1)
   \   000000C4   0x2101             MOVS     R1,#+1
   \   000000C6   0x6141             STR      R1,[R0, #+20]
   4508          }
   \   000000C8   0xBC10             POP      {R4}
   \   000000CA   0x4770             BX       LR               ;; return
   4509          
   4510          /**
   4511            * @brief  Configure the TI1 as Input.
   4512            * @param  TIMx to select the TIM peripheral.
   4513            * @param  TIM_ICPolarity : The Input Polarity.
   4514            *          This parameter can be one of the following values:
   4515            *            @arg TIM_ICPolarity_Rising
   4516            *            @arg TIM_ICPolarity_Falling
   4517            *            @arg TIM_ICPolarity_BothEdge  
   4518            * @param  TIM_ICSelection: specifies the input to be used.
   4519            *          This parameter can be one of the following values:
   4520            *            @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   4521            *            @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   4522            *            @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   4523            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   4524            *          This parameter must be a value between 0x00 and 0x0F.
   4525            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1 
   4526            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be 
   4527            *        protected against un-initialized filter and polarity values.
   4528            * @retval None
   4529            */

   \                                 In section .text, align 2, keep-with-next
   4530          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   4531                                 uint32_t TIM_ICFilter)
   4532          {
   \                     TIM_TI1_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   4533            uint32_t tmpccmr1 = 0U;
   4534            uint32_t tmpccer = 0U;
   4535            
   4536            /* Disable the Channel 1: Reset the CC1E Bit */
   4537            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   \   00000004   0x0864             LSRS     R4,R4,#+1
   \   00000006   0x0064             LSLS     R4,R4,#+1
   \   00000008   0x6204             STR      R4,[R0, #+32]
   4538            tmpccmr1 = TIMx->CCMR1;
   \   0000000A   0x6985             LDR      R5,[R0, #+24]
   4539            tmpccer = TIMx->CCER;
   \   0000000C   0x6A04             LDR      R4,[R0, #+32]
   4540          
   4541            /* Select the Input */
   4542            if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   \   0000000E   0x....             LDR.N    R6,??DataTable28_2  ;; 0x40010000
   \   00000010   0x42B0             CMP      R0,R6
   \   00000012   0xD014             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000014   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000018   0xD011             BEQ.N    ??TIM_TI1_SetConfig_0
   \   0000001A   0x....             LDR.N    R6,??DataTable28_3  ;; 0x40000400
   \   0000001C   0x42B0             CMP      R0,R6
   \   0000001E   0xD00E             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000020   0x....             LDR.N    R6,??DataTable28_4  ;; 0x40000800
   \   00000022   0x42B0             CMP      R0,R6
   \   00000024   0xD00B             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000026   0x....             LDR.N    R6,??DataTable28_5  ;; 0x40000c00
   \   00000028   0x42B0             CMP      R0,R6
   \   0000002A   0xD008             BEQ.N    ??TIM_TI1_SetConfig_0
   \   0000002C   0x....             LDR.N    R6,??DataTable28_6  ;; 0x40010400
   \   0000002E   0x42B0             CMP      R0,R6
   \   00000030   0xD005             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000032   0x....             LDR.N    R6,??DataTable28_7  ;; 0x40014000
   \   00000034   0x42B0             CMP      R0,R6
   \   00000036   0xD002             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000038   0x....             LDR.N    R6,??DataTable28_10  ;; 0x40001800
   \   0000003A   0x42B0             CMP      R0,R6
   \   0000003C   0xD101             BNE.N    ??TIM_TI1_SetConfig_1
   \                     ??TIM_TI1_SetConfig_0: (+1)
   \   0000003E   0x2601             MOVS     R6,#+1
   \   00000040   0xE000             B.N      ??TIM_TI1_SetConfig_2
   \                     ??TIM_TI1_SetConfig_1: (+1)
   \   00000042   0x2600             MOVS     R6,#+0
   \                     ??TIM_TI1_SetConfig_2: (+1)
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD003             BEQ.N    ??TIM_TI1_SetConfig_3
   4543            {
   4544              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   4545              tmpccmr1 |= TIM_ICSelection;
   \   00000048   0x08AD             LSRS     R5,R5,#+2
   \   0000004A   0xEA52 0x0585      ORRS     R5,R2,R5, LSL #+2
   \   0000004E   0xE002             B.N      ??TIM_TI1_SetConfig_4
   4546            } 
   4547            else
   4548            {
   4549              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   4550              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   \                     ??TIM_TI1_SetConfig_3: (+1)
   \   00000050   0x2201             MOVS     R2,#+1
   \   00000052   0xF362 0x0501      BFI      R5,R2,#+0,#+2
   4551            }
   4552          
   4553            /* Set the filter */
   4554            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   4555            tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
   4556          
   4557            /* Select the Polarity and set the CC1E Bit */
   4558            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   4559            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   4560          
   4561            /* Write to TIMx CCMR1 and CCER registers */
   4562            TIMx->CCMR1 = tmpccmr1;
   \                     ??TIM_TI1_SetConfig_4: (+1)
   \   00000056   0xF025 0x02F0      BIC      R2,R5,#0xF0
   \   0000005A   0x011B             LSLS     R3,R3,#+4
   \   0000005C   0xF003 0x03F0      AND      R3,R3,#0xF0
   \   00000060   0x431A             ORRS     R2,R3,R2
   \   00000062   0x6182             STR      R2,[R0, #+24]
   4563            TIMx->CCER = tmpccer;
   \   00000064   0xF024 0x020A      BIC      R2,R4,#0xA
   \   00000068   0xF001 0x010A      AND      R1,R1,#0xA
   \   0000006C   0x4311             ORRS     R1,R1,R2
   \   0000006E   0x6201             STR      R1,[R0, #+32]
   4564          }
   \   00000070   0xBC70             POP      {R4-R6}
   \   00000072   0x4770             BX       LR               ;; return
   4565          
   4566          /**
   4567            * @brief  Time Output Compare 2 configuration
   4568            * @param  TIMx to select the TIM peripheral
   4569            * @param  OC_Config: The output configuration structure
   4570            * @retval None
   4571            */

   \                                 In section .text, align 2, keep-with-next
   4572          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4573          {
   \                     TIM_OC2_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   4574            uint32_t tmpccmrx = 0U;
   4575            uint32_t tmpccer = 0U;
   4576            uint32_t tmpcr2 = 0U;
   4577             
   4578            /* Disable the Channel 2: Reset the CC2E Bit */
   4579            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   \   00000004   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000008   0x6202             STR      R2,[R0, #+32]
   4580            
   4581            /* Get the TIMx CCER register value */  
   4582            tmpccer = TIMx->CCER;
   \   0000000A   0x6A04             LDR      R4,[R0, #+32]
   4583            /* Get the TIMx CR2 register value */
   4584            tmpcr2 = TIMx->CR2;
   \   0000000C   0x6842             LDR      R2,[R0, #+4]
   4585            
   4586            /* Get the TIMx CCMR1 register value */
   4587            tmpccmrx = TIMx->CCMR1;
   \   0000000E   0x6983             LDR      R3,[R0, #+24]
   4588              
   4589            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4590            tmpccmrx &= ~TIM_CCMR1_OC2M;
   4591            tmpccmrx &= ~TIM_CCMR1_CC2S;
   4592            
   4593            /* Select the Output Compare Mode */
   4594            tmpccmrx |= (OC_Config->OCMode << 8U);
   \   00000010   0xF423 0x43E6      BIC      R3,R3,#0x7300
   \   00000014   0x680D             LDR      R5,[R1, #+0]
   \   00000016   0xEA43 0x2305      ORR      R3,R3,R5, LSL #+8
   4595            
   4596            /* Reset the Output Polarity level */
   4597            tmpccer &= ~TIM_CCER_CC2P;
   4598            /* Set the Output Compare Polarity */
   4599            tmpccer |= (OC_Config->OCPolarity << 4U);
   \   0000001A   0xF024 0x0420      BIC      R4,R4,#0x20
   \   0000001E   0x688D             LDR      R5,[R1, #+8]
   \   00000020   0xEA44 0x1405      ORR      R4,R4,R5, LSL #+4
   4600              
   4601            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000024   0x....             LDR.N    R5,??DataTable28_2  ;; 0x40010000
   \   00000026   0x42A8             CMP      R0,R5
   \   00000028   0xD002             BEQ.N    ??TIM_OC2_SetConfig_0
   \   0000002A   0x....             LDR.N    R5,??DataTable28_6  ;; 0x40010400
   \   0000002C   0x42A8             CMP      R0,R5
   \   0000002E   0xD101             BNE.N    ??TIM_OC2_SetConfig_1
   \                     ??TIM_OC2_SetConfig_0: (+1)
   \   00000030   0x2501             MOVS     R5,#+1
   \   00000032   0xE000             B.N      ??TIM_OC2_SetConfig_2
   \                     ??TIM_OC2_SetConfig_1: (+1)
   \   00000034   0x2500             MOVS     R5,#+0
   \                     ??TIM_OC2_SetConfig_2: (+1)
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD00D             BEQ.N    ??TIM_OC2_SetConfig_3
   4602            {
   4603              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4604              
   4605              /* Reset the Output N Polarity level */
   4606              tmpccer &= ~TIM_CCER_CC2NP;
   4607              /* Set the Output N Polarity */
   4608              tmpccer |= (OC_Config->OCNPolarity << 4U);
   4609              /* Reset the Output N State */
   4610              tmpccer &= ~TIM_CCER_CC2NE;
   \   0000003A   0xF024 0x0480      BIC      R4,R4,#0x80
   \   0000003E   0x68CD             LDR      R5,[R1, #+12]
   \   00000040   0xEA44 0x1405      ORR      R4,R4,R5, LSL #+4
   \   00000044   0xF024 0x0440      BIC      R4,R4,#0x40
   4611              
   4612              /* Reset the Output Compare and Output Compare N IDLE State */
   4613              tmpcr2 &= ~TIM_CR2_OIS2;
   4614              tmpcr2 &= ~TIM_CR2_OIS2N;
   4615              /* Set the Output Idle state */
   4616              tmpcr2 |= (OC_Config->OCIdleState << 2U);
   4617              /* Set the Output N Idle state */
   4618              tmpcr2 |= (OC_Config->OCNIdleState << 2U);
   \   00000048   0xF422 0x6240      BIC      R2,R2,#0xC00
   \   0000004C   0x694D             LDR      R5,[R1, #+20]
   \   0000004E   0x698E             LDR      R6,[R1, #+24]
   \   00000050   0x4335             ORRS     R5,R6,R5
   \   00000052   0xEA42 0x0285      ORR      R2,R2,R5, LSL #+2
   4619            }
   4620            /* Write to TIMx CR2 */
   4621            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2_SetConfig_3: (+1)
   \   00000056   0x6042             STR      R2,[R0, #+4]
   4622            
   4623            /* Write to TIMx CCMR1 */
   4624            TIMx->CCMR1 = tmpccmrx;
   \   00000058   0x6183             STR      R3,[R0, #+24]
   4625            
   4626            /* Set the Capture Compare Register value */
   4627            TIMx->CCR2 = OC_Config->Pulse;
   \   0000005A   0x6849             LDR      R1,[R1, #+4]
   \   0000005C   0x6381             STR      R1,[R0, #+56]
   4628            
   4629            /* Write to TIMx CCER */
   4630            TIMx->CCER = tmpccer;
   \   0000005E   0x6204             STR      R4,[R0, #+32]
   4631          }
   \   00000060   0xBC70             POP      {R4-R6}
   \   00000062   0x4770             BX       LR               ;; return
   4632          
   4633          /**
   4634            * @brief  TIM DMA Delay Pulse complete callback. 
   4635            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4636            *               the configuration information for the specified DMA module.
   4637            * @retval None
   4638            */

   \                                 In section .text, align 4, keep-with-next
   4639          void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   4640          {
   \                     TIM_DMADelayPulseCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   4641            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B84             LDR      R4,[R0, #+56]
   4642            
   4643            htim->State= HAL_TIM_STATE_READY; 
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF884 0x1039      STRB     R1,[R4, #+57]
   4644            
   4645            if(hdma == htim->hdma[TIM_DMA_ID_CC1])
   \   0000000A   0xF104 0x0118      ADD      R1,R4,#+24
   \   0000000E   0x688A             LDR      R2,[R1, #+8]
   \   00000010   0x4290             CMP      R0,R2
   \   00000012   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_0
   4646            {
   4647              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7620             STRB     R0,[R4, #+24]
   \   00000018   0xE010             B.N      ??TIM_DMADelayPulseCplt_1
   4648            }
   4649            else if(hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMADelayPulseCplt_0: (+1)
   \   0000001A   0x68CA             LDR      R2,[R1, #+12]
   \   0000001C   0x4290             CMP      R0,R2
   \   0000001E   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_2
   4650            {
   4651              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x7620             STRB     R0,[R4, #+24]
   \   00000024   0xE00A             B.N      ??TIM_DMADelayPulseCplt_1
   4652            }
   4653            else if(hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMADelayPulseCplt_2: (+1)
   \   00000026   0x690A             LDR      R2,[R1, #+16]
   \   00000028   0x4290             CMP      R0,R2
   \   0000002A   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_3
   4654            {
   4655              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0x7620             STRB     R0,[R4, #+24]
   \   00000030   0xE004             B.N      ??TIM_DMADelayPulseCplt_1
   4656            }
   4657            else if(hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMADelayPulseCplt_3: (+1)
   \   00000032   0x6949             LDR      R1,[R1, #+20]
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD101             BNE.N    ??TIM_DMADelayPulseCplt_1
   4658            {
   4659              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   00000038   0x2008             MOVS     R0,#+8
   \   0000003A   0x7620             STRB     R0,[R4, #+24]
   4660            }
   4661          
   4662            HAL_TIM_PWM_PulseFinishedCallback(htim);
   \                     ??TIM_DMADelayPulseCplt_1: (+1)
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   4663          
   4664            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;  
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x7620             STRB     R0,[R4, #+24]
   4665          }
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
   4666          
   4667          /**
   4668            * @brief  TIM DMA error callback 
   4669            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4670            *                the configuration information for the specified DMA module.
   4671            * @retval None
   4672            */

   \                                 In section .text, align 4, keep-with-next
   4673          void TIM_DMAError(DMA_HandleTypeDef *hdma)
   4674          {
   \                     TIM_DMAError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   4675            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   4676            
   4677            htim->State= HAL_TIM_STATE_READY;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF880 0x1039      STRB     R1,[R0, #+57]
   4678             
   4679            HAL_TIM_ErrorCallback(htim);
   \   0000000A   0x.... 0x....      BL       HAL_TIM_ErrorCallback
   4680          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   4681          
   4682          /**
   4683            * @brief  TIM DMA Capture complete callback. 
   4684            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4685            *                the configuration information for the specified DMA module.
   4686            * @retval None
   4687            */

   \                                 In section .text, align 4, keep-with-next
   4688          void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   4689          {
   \                     TIM_DMACaptureCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   4690            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B84             LDR      R4,[R0, #+56]
   4691            
   4692            htim->State= HAL_TIM_STATE_READY;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF884 0x1039      STRB     R1,[R4, #+57]
   4693            
   4694            if(hdma == htim->hdma[TIM_DMA_ID_CC1])
   \   0000000A   0xF104 0x0118      ADD      R1,R4,#+24
   \   0000000E   0x688A             LDR      R2,[R1, #+8]
   \   00000010   0x4290             CMP      R0,R2
   \   00000012   0xD102             BNE.N    ??TIM_DMACaptureCplt_0
   4695            {
   4696              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7620             STRB     R0,[R4, #+24]
   \   00000018   0xE010             B.N      ??TIM_DMACaptureCplt_1
   4697            }
   4698            else if(hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMACaptureCplt_0: (+1)
   \   0000001A   0x68CA             LDR      R2,[R1, #+12]
   \   0000001C   0x4290             CMP      R0,R2
   \   0000001E   0xD102             BNE.N    ??TIM_DMACaptureCplt_2
   4699            {
   4700              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x7620             STRB     R0,[R4, #+24]
   \   00000024   0xE00A             B.N      ??TIM_DMACaptureCplt_1
   4701            }
   4702            else if(hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMACaptureCplt_2: (+1)
   \   00000026   0x690A             LDR      R2,[R1, #+16]
   \   00000028   0x4290             CMP      R0,R2
   \   0000002A   0xD102             BNE.N    ??TIM_DMACaptureCplt_3
   4703            {
   4704              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0x7620             STRB     R0,[R4, #+24]
   \   00000030   0xE004             B.N      ??TIM_DMACaptureCplt_1
   4705            }
   4706            else if(hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMACaptureCplt_3: (+1)
   \   00000032   0x6949             LDR      R1,[R1, #+20]
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD101             BNE.N    ??TIM_DMACaptureCplt_1
   4707            {
   4708              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   00000038   0x2008             MOVS     R0,#+8
   \   0000003A   0x7620             STRB     R0,[R4, #+24]
   4709            }
   4710            
   4711            HAL_TIM_IC_CaptureCallback(htim); 
   \                     ??TIM_DMACaptureCplt_1: (+1)
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   4712            
   4713            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x7620             STRB     R0,[R4, #+24]
   4714          }
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
   4715          
   4716          /**
   4717            * @brief  Enables or disables the TIM Capture Compare Channel x.
   4718            * @param  TIMx to select the TIM peripheral
   4719            * @param  Channel: specifies the TIM Channel
   4720            *          This parameter can be one of the following values:
   4721            *            @arg TIM_Channel_1: TIM Channel 1
   4722            *            @arg TIM_Channel_2: TIM Channel 2
   4723            *            @arg TIM_Channel_3: TIM Channel 3
   4724            *            @arg TIM_Channel_4: TIM Channel 4
   4725            * @param  ChannelState: specifies the TIM Channel CCxE bit new state.
   4726            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable. 
   4727            * @retval None
   4728            */

   \                                 In section .text, align 2, keep-with-next
   4729          void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
   4730          {
   \                     TIM_CCxChannelCmd: (+1)
   \   00000000   0xB410             PUSH     {R4}
   4731            uint32_t tmp = 0U;
   4732          
   4733            /* Check the parameters */
   4734            assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
   4735            assert_param(IS_TIM_CHANNELS(Channel));
   4736          
   4737            tmp = TIM_CCER_CC1E << Channel;
   4738          
   4739            /* Reset the CCxE Bit */
   4740            TIMx->CCER &= ~tmp;
   \   00000002   0x6A03             LDR      R3,[R0, #+32]
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0x6203             STR      R3,[R0, #+32]
   4741          
   4742            /* Set or reset the CCxE Bit */ 
   4743            TIMx->CCER |= (uint32_t)(ChannelState << Channel);
   \   0000000C   0x6A03             LDR      R3,[R0, #+32]
   \   0000000E   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000012   0x4319             ORRS     R1,R1,R3
   \   00000014   0x6201             STR      R1,[R0, #+32]
   4744          }
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
   4745          
   4746          /**
   4747            * @brief  TIM DMA Period Elapse complete callback. 
   4748            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4749            *                the configuration information for the specified DMA module.
   4750            * @retval None
   4751            */

   \                                 In section .text, align 4, keep-with-next
   4752          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   4753          {
   \                     TIM_DMAPeriodElapsedCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   4754            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   4755            
   4756            htim->State= HAL_TIM_STATE_READY;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF880 0x1039      STRB     R1,[R0, #+57]
   4757            
   4758            HAL_TIM_PeriodElapsedCallback(htim);
   \   0000000A   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   4759          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   4760          
   4761          /**
   4762            * @brief  TIM DMA Trigger callback. 
   4763            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4764            *                the configuration information for the specified DMA module.
   4765            * @retval None
   4766            */

   \                                 In section .text, align 4, keep-with-next
   4767          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   4768          {
   \                     TIM_DMATriggerCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   4769            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   4770            
   4771            htim->State= HAL_TIM_STATE_READY; 
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF880 0x1039      STRB     R1,[R0, #+57]
   4772            
   4773            HAL_TIM_TriggerCallback(htim);
   \   0000000A   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   4774          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   4775          
   4776          /**
   4777            * @brief  Time Output Compare 1 configuration
   4778            * @param  TIMx to select the TIM peripheral
   4779            * @param  OC_Config: The output configuration structure
   4780            * @retval None
   4781            */

   \                                 In section .text, align 2, keep-with-next
   4782          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4783          {
   \                     TIM_OC1_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4784            uint32_t tmpccmrx = 0U;
   4785            uint32_t tmpccer = 0U;
   4786            uint32_t tmpcr2 = 0U;  
   4787          
   4788            /* Disable the Channel 1: Reset the CC1E Bit */
   4789            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   \   00000004   0x0852             LSRS     R2,R2,#+1
   \   00000006   0x0052             LSLS     R2,R2,#+1
   \   00000008   0x6202             STR      R2,[R0, #+32]
   4790            
   4791            /* Get the TIMx CCER register value */
   4792            tmpccer = TIMx->CCER;
   \   0000000A   0x6A04             LDR      R4,[R0, #+32]
   4793            /* Get the TIMx CR2 register value */
   4794            tmpcr2 = TIMx->CR2;
   \   0000000C   0x6842             LDR      R2,[R0, #+4]
   4795            
   4796            /* Get the TIMx CCMR1 register value */
   4797            tmpccmrx = TIMx->CCMR1;
   \   0000000E   0x6983             LDR      R3,[R0, #+24]
   4798              
   4799            /* Reset the Output Compare Mode Bits */
   4800            tmpccmrx &= ~TIM_CCMR1_OC1M;
   4801            tmpccmrx &= ~TIM_CCMR1_CC1S;
   4802            /* Select the Output Compare Mode */
   4803            tmpccmrx |= OC_Config->OCMode;
   \   00000010   0xF023 0x0373      BIC      R3,R3,#0x73
   \   00000014   0x680D             LDR      R5,[R1, #+0]
   \   00000016   0x432B             ORRS     R3,R5,R3
   4804            
   4805            /* Reset the Output Polarity level */
   4806            tmpccer &= ~TIM_CCER_CC1P;
   4807            /* Set the Output Compare Polarity */
   4808            tmpccer |= OC_Config->OCPolarity;
   \   00000018   0xF024 0x0402      BIC      R4,R4,#0x2
   \   0000001C   0x688D             LDR      R5,[R1, #+8]
   \   0000001E   0x432C             ORRS     R4,R5,R4
   4809          
   4810              
   4811            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000020   0x....             LDR.N    R5,??DataTable28_2  ;; 0x40010000
   \   00000022   0x42A8             CMP      R0,R5
   \   00000024   0xD002             BEQ.N    ??TIM_OC1_SetConfig_0
   \   00000026   0x....             LDR.N    R5,??DataTable28_6  ;; 0x40010400
   \   00000028   0x42A8             CMP      R0,R5
   \   0000002A   0xD101             BNE.N    ??TIM_OC1_SetConfig_1
   \                     ??TIM_OC1_SetConfig_0: (+1)
   \   0000002C   0x2501             MOVS     R5,#+1
   \   0000002E   0xE000             B.N      ??TIM_OC1_SetConfig_2
   \                     ??TIM_OC1_SetConfig_1: (+1)
   \   00000030   0x2500             MOVS     R5,#+0
   \                     ??TIM_OC1_SetConfig_2: (+1)
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD00B             BEQ.N    ??TIM_OC1_SetConfig_3
   4812            {   
   4813              /* Reset the Output N Polarity level */
   4814              tmpccer &= ~TIM_CCER_CC1NP;
   4815              /* Set the Output N Polarity */
   4816              tmpccer |= OC_Config->OCNPolarity;
   4817              /* Reset the Output N State */
   4818              tmpccer &= ~TIM_CCER_CC1NE;
   \   00000036   0xF024 0x0408      BIC      R4,R4,#0x8
   \   0000003A   0x68CD             LDR      R5,[R1, #+12]
   \   0000003C   0x432C             ORRS     R4,R5,R4
   \   0000003E   0xF024 0x0404      BIC      R4,R4,#0x4
   4819              
   4820              /* Reset the Output Compare and Output Compare N IDLE State */
   4821              tmpcr2 &= ~TIM_CR2_OIS1;
   4822              tmpcr2 &= ~TIM_CR2_OIS1N;
   4823              /* Set the Output Idle state */
   4824              tmpcr2 |= OC_Config->OCIdleState;
   4825              /* Set the Output N Idle state */
   4826              tmpcr2 |= OC_Config->OCNIdleState;
   \   00000042   0xF422 0x7240      BIC      R2,R2,#0x300
   \   00000046   0x694D             LDR      R5,[R1, #+20]
   \   00000048   0x432A             ORRS     R2,R5,R2
   \   0000004A   0x698D             LDR      R5,[R1, #+24]
   \   0000004C   0x432A             ORRS     R2,R5,R2
   4827            }
   4828            /* Write to TIMx CR2 */
   4829            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1_SetConfig_3: (+1)
   \   0000004E   0x6042             STR      R2,[R0, #+4]
   4830            
   4831            /* Write to TIMx CCMR1 */
   4832            TIMx->CCMR1 = tmpccmrx;
   \   00000050   0x6183             STR      R3,[R0, #+24]
   4833            
   4834            /* Set the Capture Compare Register value */
   4835            TIMx->CCR1 = OC_Config->Pulse;
   \   00000052   0x6849             LDR      R1,[R1, #+4]
   \   00000054   0x6341             STR      R1,[R0, #+52]
   4836            
   4837            /* Write to TIMx CCER */
   4838            TIMx->CCER = tmpccer;  
   \   00000056   0x6204             STR      R4,[R0, #+32]
   4839          } 
   \   00000058   0xBC30             POP      {R4,R5}
   \   0000005A   0x4770             BX       LR               ;; return
   4840          
   4841          /**
   4842            * @brief  Time Output Compare 3 configuration
   4843            * @param  TIMx to select the TIM peripheral
   4844            * @param  OC_Config: The output configuration structure
   4845            * @retval None
   4846            */

   \                                 In section .text, align 2, keep-with-next
   4847          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4848          {
   \                     TIM_OC3_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   4849            uint32_t tmpccmrx = 0U;
   4850            uint32_t tmpccer = 0U;
   4851            uint32_t tmpcr2 = 0U;   
   4852          
   4853            /* Disable the Channel 3: Reset the CC2E Bit */
   4854            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   \   00000004   0xF422 0x7280      BIC      R2,R2,#0x100
   \   00000008   0x6202             STR      R2,[R0, #+32]
   4855            
   4856            /* Get the TIMx CCER register value */
   4857            tmpccer = TIMx->CCER;
   \   0000000A   0x6A04             LDR      R4,[R0, #+32]
   4858            /* Get the TIMx CR2 register value */
   4859            tmpcr2 = TIMx->CR2;
   \   0000000C   0x6842             LDR      R2,[R0, #+4]
   4860            
   4861            /* Get the TIMx CCMR2 register value */
   4862            tmpccmrx = TIMx->CCMR2;
   \   0000000E   0x69C3             LDR      R3,[R0, #+28]
   4863              
   4864            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4865            tmpccmrx &= ~TIM_CCMR2_OC3M;
   4866            tmpccmrx &= ~TIM_CCMR2_CC3S;  
   4867            /* Select the Output Compare Mode */
   4868            tmpccmrx |= OC_Config->OCMode;
   \   00000010   0xF023 0x0373      BIC      R3,R3,#0x73
   \   00000014   0x680D             LDR      R5,[R1, #+0]
   \   00000016   0x432B             ORRS     R3,R5,R3
   4869            
   4870            /* Reset the Output Polarity level */
   4871            tmpccer &= ~TIM_CCER_CC3P;
   4872            /* Set the Output Compare Polarity */
   4873            tmpccer |= (OC_Config->OCPolarity << 8U);
   \   00000018   0xF424 0x7400      BIC      R4,R4,#0x200
   \   0000001C   0x688D             LDR      R5,[R1, #+8]
   \   0000001E   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   4874              
   4875            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000022   0x....             LDR.N    R5,??DataTable28_2  ;; 0x40010000
   \   00000024   0x42A8             CMP      R0,R5
   \   00000026   0xD002             BEQ.N    ??TIM_OC3_SetConfig_0
   \   00000028   0x....             LDR.N    R5,??DataTable28_6  ;; 0x40010400
   \   0000002A   0x42A8             CMP      R0,R5
   \   0000002C   0xD101             BNE.N    ??TIM_OC3_SetConfig_1
   \                     ??TIM_OC3_SetConfig_0: (+1)
   \   0000002E   0x2501             MOVS     R5,#+1
   \   00000030   0xE000             B.N      ??TIM_OC3_SetConfig_2
   \                     ??TIM_OC3_SetConfig_1: (+1)
   \   00000032   0x2500             MOVS     R5,#+0
   \                     ??TIM_OC3_SetConfig_2: (+1)
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD00D             BEQ.N    ??TIM_OC3_SetConfig_3
   4876            {
   4877              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4878              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4879              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4880              
   4881              /* Reset the Output N Polarity level */
   4882              tmpccer &= ~TIM_CCER_CC3NP;
   4883              /* Set the Output N Polarity */
   4884              tmpccer |= (OC_Config->OCNPolarity << 8U);
   4885              /* Reset the Output N State */
   4886              tmpccer &= ~TIM_CCER_CC3NE;
   \   00000038   0xF424 0x6400      BIC      R4,R4,#0x800
   \   0000003C   0x68CD             LDR      R5,[R1, #+12]
   \   0000003E   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   \   00000042   0xF424 0x6480      BIC      R4,R4,#0x400
   4887              
   4888              /* Reset the Output Compare and Output Compare N IDLE State */
   4889              tmpcr2 &= ~TIM_CR2_OIS3;
   4890              tmpcr2 &= ~TIM_CR2_OIS3N;
   4891              /* Set the Output Idle state */
   4892              tmpcr2 |= (OC_Config->OCIdleState << 4U);
   4893              /* Set the Output N Idle state */
   4894              tmpcr2 |= (OC_Config->OCNIdleState << 4U);
   \   00000046   0xF422 0x5240      BIC      R2,R2,#0x3000
   \   0000004A   0x694D             LDR      R5,[R1, #+20]
   \   0000004C   0x698E             LDR      R6,[R1, #+24]
   \   0000004E   0x4335             ORRS     R5,R6,R5
   \   00000050   0xEA42 0x1205      ORR      R2,R2,R5, LSL #+4
   4895            }
   4896            /* Write to TIMx CR2 */
   4897            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3_SetConfig_3: (+1)
   \   00000054   0x6042             STR      R2,[R0, #+4]
   4898            
   4899            /* Write to TIMx CCMR2 */
   4900            TIMx->CCMR2 = tmpccmrx;
   \   00000056   0x61C3             STR      R3,[R0, #+28]
   4901            
   4902            /* Set the Capture Compare Register value */
   4903            TIMx->CCR3 = OC_Config->Pulse;
   \   00000058   0x6849             LDR      R1,[R1, #+4]
   \   0000005A   0x63C1             STR      R1,[R0, #+60]
   4904            
   4905            /* Write to TIMx CCER */
   4906            TIMx->CCER = tmpccer;
   \   0000005C   0x6204             STR      R4,[R0, #+32]
   4907          }
   \   0000005E   0xBC70             POP      {R4-R6}
   \   00000060   0x4770             BX       LR               ;; return
   4908          
   4909          /**
   4910            * @brief  Time Output Compare 4 configuration
   4911            * @param  TIMx to select the TIM peripheral
   4912            * @param  OC_Config: The output configuration structure
   4913            * @retval None
   4914            */

   \                                 In section .text, align 2, keep-with-next
   4915          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4916          {
   \                     TIM_OC4_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4917            uint32_t tmpccmrx = 0U;
   4918            uint32_t tmpccer = 0U;
   4919            uint32_t tmpcr2 = 0U;
   4920          
   4921            /* Disable the Channel 4: Reset the CC4E Bit */
   4922            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   \   00000004   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000008   0x6202             STR      R2,[R0, #+32]
   4923            
   4924            /* Get the TIMx CCER register value */
   4925            tmpccer = TIMx->CCER;
   \   0000000A   0x6A02             LDR      R2,[R0, #+32]
   4926            /* Get the TIMx CR2 register value */
   4927            tmpcr2 = TIMx->CR2;
   \   0000000C   0x6843             LDR      R3,[R0, #+4]
   4928            
   4929            /* Get the TIMx CCMR2 register value */
   4930            tmpccmrx = TIMx->CCMR2;
   \   0000000E   0x69C4             LDR      R4,[R0, #+28]
   4931              
   4932            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4933            tmpccmrx &= ~TIM_CCMR2_OC4M;
   4934            tmpccmrx &= ~TIM_CCMR2_CC4S;
   4935            
   4936            /* Select the Output Compare Mode */
   4937            tmpccmrx |= (OC_Config->OCMode << 8U);
   \   00000010   0xF424 0x44E6      BIC      R4,R4,#0x7300
   \   00000014   0x680D             LDR      R5,[R1, #+0]
   \   00000016   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   4938            
   4939            /* Reset the Output Polarity level */
   4940            tmpccer &= ~TIM_CCER_CC4P;
   4941            /* Set the Output Compare Polarity */
   4942            tmpccer |= (OC_Config->OCPolarity << 12U);
   \   0000001A   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   0000001E   0x688D             LDR      R5,[R1, #+8]
   \   00000020   0xEA42 0x3205      ORR      R2,R2,R5, LSL #+12
   4943             
   4944            /*if((TIMx == TIM1) || (TIMx == TIM8))*/
   4945            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000024   0x....             LDR.N    R5,??DataTable28_2  ;; 0x40010000
   \   00000026   0x42A8             CMP      R0,R5
   \   00000028   0xD002             BEQ.N    ??TIM_OC4_SetConfig_0
   \   0000002A   0x....             LDR.N    R5,??DataTable28_6  ;; 0x40010400
   \   0000002C   0x42A8             CMP      R0,R5
   \   0000002E   0xD101             BNE.N    ??TIM_OC4_SetConfig_1
   \                     ??TIM_OC4_SetConfig_0: (+1)
   \   00000030   0x2501             MOVS     R5,#+1
   \   00000032   0xE000             B.N      ??TIM_OC4_SetConfig_2
   \                     ??TIM_OC4_SetConfig_1: (+1)
   \   00000034   0x2500             MOVS     R5,#+0
   \                     ??TIM_OC4_SetConfig_2: (+1)
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD004             BEQ.N    ??TIM_OC4_SetConfig_3
   4946            {
   4947              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4948              /* Reset the Output Compare IDLE State */
   4949              tmpcr2 &= ~TIM_CR2_OIS4;
   4950              /* Set the Output Idle state */
   4951              tmpcr2 |= (OC_Config->OCIdleState << 6U);
   \   0000003A   0xF423 0x4380      BIC      R3,R3,#0x4000
   \   0000003E   0x694D             LDR      R5,[R1, #+20]
   \   00000040   0xEA43 0x1385      ORR      R3,R3,R5, LSL #+6
   4952            }
   4953            /* Write to TIMx CR2 */
   4954            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4_SetConfig_3: (+1)
   \   00000044   0x6043             STR      R3,[R0, #+4]
   4955            
   4956            /* Write to TIMx CCMR2 */  
   4957            TIMx->CCMR2 = tmpccmrx;
   \   00000046   0x61C4             STR      R4,[R0, #+28]
   4958              
   4959            /* Set the Capture Compare Register value */
   4960            TIMx->CCR4 = OC_Config->Pulse;
   \   00000048   0x6849             LDR      R1,[R1, #+4]
   \   0000004A   0x6401             STR      R1,[R0, #+64]
   4961            
   4962            /* Write to TIMx CCER */
   4963            TIMx->CCER = tmpccer;
   \   0000004C   0x6202             STR      R2,[R0, #+32]
   4964          }
   \   0000004E   0xBC30             POP      {R4,R5}
   \   00000050   0x4770             BX       LR               ;; return
   4965          
   4966          /**
   4967            * @brief  Time Output Compare 4 configuration
   4968            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4969            *                the configuration information for TIM module.
   4970            * @param  sSlaveConfig: The slave configuration structure
   4971            * @retval None
   4972            */

   \                                 In section .text, align 2, keep-with-next
   4973          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   4974                                        TIM_SlaveConfigTypeDef * sSlaveConfig)
   4975          {
   \                     TIM_SlaveTimer_SetConfig: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   4976            uint32_t tmpsmcr = 0U;
   4977            uint32_t tmpccmr1 = 0U;
   4978            uint32_t tmpccer = 0U;
   4979          
   4980           /* Get the TIMx SMCR register value */
   4981            tmpsmcr = htim->Instance->SMCR;
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0x6893             LDR      R3,[R2, #+8]
   4982          
   4983            /* Reset the Trigger Selection Bits */
   4984            tmpsmcr &= ~TIM_SMCR_TS;
   4985            /* Set the Input Trigger source */
   4986            tmpsmcr |= sSlaveConfig->InputTrigger;
   4987          
   4988            /* Reset the slave mode Bits */
   4989            tmpsmcr &= ~TIM_SMCR_SMS;
   4990            /* Set the slave mode */
   4991            tmpsmcr |= sSlaveConfig->SlaveMode;
   4992          
   4993            /* Write to TIMx SMCR */
   4994            htim->Instance->SMCR = tmpsmcr;
   \   00000006   0xF023 0x0370      BIC      R3,R3,#0x70
   \   0000000A   0x684C             LDR      R4,[R1, #+4]
   \   0000000C   0x4323             ORRS     R3,R4,R3
   \   0000000E   0x08DB             LSRS     R3,R3,#+3
   \   00000010   0x680C             LDR      R4,[R1, #+0]
   \   00000012   0xEA54 0x03C3      ORRS     R3,R4,R3, LSL #+3
   \   00000016   0x6093             STR      R3,[R2, #+8]
   4995            
   4996            /* Configure the trigger prescaler, filter, and polarity */
   4997            switch (sSlaveConfig->InputTrigger)
   \   00000018   0x684A             LDR      R2,[R1, #+4]
   \   0000001A   0x2A40             CMP      R2,#+64
   \   0000001C   0xD00C             BEQ.N    ??TIM_SlaveTimer_SetConfig_0
   \   0000001E   0x2A50             CMP      R2,#+80
   \   00000020   0xD01B             BEQ.N    ??TIM_SlaveTimer_SetConfig_1
   \   00000022   0x2A60             CMP      R2,#+96
   \   00000024   0xD01E             BEQ.N    ??TIM_SlaveTimer_SetConfig_2
   \   00000026   0x2A70             CMP      R2,#+112
   \   00000028   0xD121             BNE.N    ??TIM_SlaveTimer_SetConfig_3
   4998            {
   4999            case TIM_TS_ETRF:
   5000              {
   5001                /* Check the parameters */
   5002                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   5003                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   5004                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5005                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5006                /* Configure the ETR Trigger source */
   5007                TIM_ETR_SetConfig(htim->Instance, 
   5008                                  sSlaveConfig->TriggerPrescaler, 
   5009                                  sSlaveConfig->TriggerPolarity, 
   5010                                  sSlaveConfig->TriggerFilter);
   \   0000002A   0x690B             LDR      R3,[R1, #+16]
   \   0000002C   0x688A             LDR      R2,[R1, #+8]
   \   0000002E   0x68C9             LDR      R1,[R1, #+12]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xB001             ADD      SP,SP,#+4
   \   00000034   0xBC10             POP      {R4}
   \   00000036   0x....             B.N      TIM_ETR_SetConfig
   5011              }
   5012              break;
   5013              
   5014            case TIM_TS_TI1F_ED:
   5015              {
   5016                /* Check the parameters */
   5017                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5018                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5019                
   5020                /* Disable the Channel 1: Reset the CC1E Bit */
   5021                tmpccer = htim->Instance->CCER;
   \                     ??TIM_SlaveTimer_SetConfig_0: (+1)
   \   00000038   0x6802             LDR      R2,[R0, #+0]
   \   0000003A   0x6A13             LDR      R3,[R2, #+32]
   5022                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   \   0000003C   0x6A14             LDR      R4,[R2, #+32]
   \   0000003E   0x0864             LSRS     R4,R4,#+1
   \   00000040   0x0064             LSLS     R4,R4,#+1
   \   00000042   0x6214             STR      R4,[R2, #+32]
   5023                tmpccmr1 = htim->Instance->CCMR1;    
   \   00000044   0x6802             LDR      R2,[R0, #+0]
   \   00000046   0x6994             LDR      R4,[R2, #+24]
   5024                
   5025                /* Set the filter */
   5026                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5027                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
   5028                
   5029                /* Write to TIMx CCMR1 and CCER registers */
   5030                htim->Instance->CCMR1 = tmpccmr1;
   \   00000048   0xF024 0x04F0      BIC      R4,R4,#0xF0
   \   0000004C   0x6909             LDR      R1,[R1, #+16]
   \   0000004E   0xEA44 0x1101      ORR      R1,R4,R1, LSL #+4
   \   00000052   0x6191             STR      R1,[R2, #+24]
   5031                htim->Instance->CCER = tmpccer;                               
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x6203             STR      R3,[R0, #+32]
   5032                                         
   5033              }
   5034              break;
   \   00000058   0xE009             B.N      ??TIM_SlaveTimer_SetConfig_3
   5035              
   5036            case TIM_TS_TI1FP1:
   5037              {
   5038                /* Check the parameters */
   5039                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5040                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5041                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5042          
   5043                /* Configure TI1 Filter and Polarity */
   5044                TIM_TI1_ConfigInputStage(htim->Instance,
   5045                                         sSlaveConfig->TriggerPolarity,
   5046                                         sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_1: (+1)
   \   0000005A   0x690A             LDR      R2,[R1, #+16]
   \   0000005C   0x6889             LDR      R1,[R1, #+8]
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xBC18             POP      {R3,R4}
   \   00000062   0x....             B.N      TIM_TI1_ConfigInputStage
   5047              }
   5048              break;
   5049              
   5050            case TIM_TS_TI2FP2:
   5051              {
   5052                /* Check the parameters */
   5053                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5054                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5055                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5056                
   5057                /* Configure TI2 Filter and Polarity */
   5058                TIM_TI2_ConfigInputStage(htim->Instance,
   5059                                          sSlaveConfig->TriggerPolarity,
   5060                                          sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_2: (+1)
   \   00000064   0x690A             LDR      R2,[R1, #+16]
   \   00000066   0x6889             LDR      R1,[R1, #+8]
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xBC18             POP      {R3,R4}
   \   0000006C   0x....             B.N      TIM_TI2_ConfigInputStage
   5061              }
   5062              break;
   5063              
   5064            case TIM_TS_ITR0:
   5065              {
   5066                /* Check the parameter */
   5067                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5068              }
   5069              break;
   5070              
   5071            case TIM_TS_ITR1:
   5072              {
   5073                /* Check the parameter */
   5074                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5075              }
   5076              break;
   5077              
   5078            case TIM_TS_ITR2:
   5079              {
   5080                /* Check the parameter */
   5081                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5082              }
   5083              break;
   5084              
   5085            case TIM_TS_ITR3:
   5086              {
   5087                /* Check the parameter */
   5088                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5089              }
   5090              break;
   5091                 
   5092            default:
   5093              break;
   5094            }
   5095          }
   \                     ??TIM_SlaveTimer_SetConfig_3: (+1)
   \   0000006E   0xBC11             POP      {R0,R4}
   \   00000070   0x4770             BX       LR               ;; return
   5096          
   5097          
   5098          /**
   5099            * @brief  Configure the Polarity and Filter for TI1.
   5100            * @param  TIMx to select the TIM peripheral.
   5101            * @param  TIM_ICPolarity : The Input Polarity.
   5102            *          This parameter can be one of the following values:
   5103            *            @arg TIM_ICPolarity_Rising
   5104            *            @arg TIM_ICPolarity_Falling
   5105            *            @arg TIM_ICPolarity_BothEdge
   5106            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5107            *          This parameter must be a value between 0x00 and 0x0F.
   5108            * @retval None
   5109            */

   \                                 In section .text, align 2, keep-with-next
   5110          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5111          {
   \                     TIM_TI1_ConfigInputStage: (+1)
   \   00000000   0xB410             PUSH     {R4}
   5112            uint32_t tmpccmr1 = 0U;
   5113            uint32_t tmpccer = 0U;
   5114            
   5115            /* Disable the Channel 1: Reset the CC1E Bit */
   5116            tmpccer = TIMx->CCER;
   \   00000002   0x6A03             LDR      R3,[R0, #+32]
   5117            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000004   0x6A04             LDR      R4,[R0, #+32]
   \   00000006   0x0864             LSRS     R4,R4,#+1
   \   00000008   0x0064             LSLS     R4,R4,#+1
   \   0000000A   0x6204             STR      R4,[R0, #+32]
   5118            tmpccmr1 = TIMx->CCMR1;    
   \   0000000C   0x6984             LDR      R4,[R0, #+24]
   5119            
   5120            /* Set the filter */
   5121            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5122            tmpccmr1 |= (TIM_ICFilter << 4U);
   5123            
   5124            /* Select the Polarity and set the CC1E Bit */
   5125            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   5126            tmpccer |= TIM_ICPolarity;
   5127            
   5128            /* Write to TIMx CCMR1 and CCER registers */
   5129            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0xF024 0x04F0      BIC      R4,R4,#0xF0
   \   00000012   0xEA44 0x1202      ORR      R2,R4,R2, LSL #+4
   \   00000016   0x6182             STR      R2,[R0, #+24]
   5130            TIMx->CCER = tmpccer;
   \   00000018   0xF023 0x020A      BIC      R2,R3,#0xA
   \   0000001C   0x4311             ORRS     R1,R1,R2
   \   0000001E   0x6201             STR      R1,[R0, #+32]
   5131          }
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
   5132          
   5133          /**
   5134            * @brief  Configure the TI2 as Input.
   5135            * @param  TIMx to select the TIM peripheral
   5136            * @param  TIM_ICPolarity : The Input Polarity.
   5137            *          This parameter can be one of the following values:
   5138            *            @arg TIM_ICPolarity_Rising
   5139            *            @arg TIM_ICPolarity_Falling
   5140            *            @arg TIM_ICPolarity_BothEdge   
   5141            * @param  TIM_ICSelection: specifies the input to be used.
   5142            *          This parameter can be one of the following values:
   5143            *            @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   5144            *            @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   5145            *            @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   5146            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5147            *          This parameter must be a value between 0x00 and 0x0F.
   5148            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2 
   5149            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be 
   5150            *        protected against un-initialized filter and polarity values.
   5151            * @retval None
   5152            */

   \                                 In section .text, align 2, keep-with-next
   5153          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5154                                 uint32_t TIM_ICFilter)
   5155          {
   \                     TIM_TI2_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   5156            uint32_t tmpccmr1 = 0U;
   5157            uint32_t tmpccer = 0U;
   5158          
   5159            /* Disable the Channel 2: Reset the CC2E Bit */
   5160            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   \   00000004   0xF024 0x0410      BIC      R4,R4,#0x10
   \   00000008   0x6204             STR      R4,[R0, #+32]
   5161            tmpccmr1 = TIMx->CCMR1;
   \   0000000A   0x6984             LDR      R4,[R0, #+24]
   5162            tmpccer = TIMx->CCER;
   \   0000000C   0x6A05             LDR      R5,[R0, #+32]
   5163            
   5164            /* Select the Input */
   5165            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   5166            tmpccmr1 |= (TIM_ICSelection << 8U);
   5167            
   5168            /* Set the filter */
   5169            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   5170            tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
   5171          
   5172            /* Select the Polarity and set the CC2E Bit */
   5173            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   5174            tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   5175          
   5176            /* Write to TIMx CCMR1 and CCER registers */
   5177            TIMx->CCMR1 = tmpccmr1 ;
   \   0000000E   0xF424 0x7440      BIC      R4,R4,#0x300
   \   00000012   0xEA44 0x2202      ORR      R2,R4,R2, LSL #+8
   \   00000016   0xF422 0x4270      BIC      R2,R2,#0xF000
   \   0000001A   0x031B             LSLS     R3,R3,#+12
   \   0000001C   0xF403 0x4370      AND      R3,R3,#0xF000
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x6182             STR      R2,[R0, #+24]
   5178            TIMx->CCER = tmpccer;
   \   00000024   0xF025 0x02A0      BIC      R2,R5,#0xA0
   \   00000028   0x0109             LSLS     R1,R1,#+4
   \   0000002A   0xF001 0x01A0      AND      R1,R1,#0xA0
   \   0000002E   0x4311             ORRS     R1,R1,R2
   \   00000030   0x6201             STR      R1,[R0, #+32]
   5179          }
   \   00000032   0xBC30             POP      {R4,R5}
   \   00000034   0x4770             BX       LR               ;; return
   5180          
   5181          /**
   5182            * @brief  Configure the Polarity and Filter for TI2.
   5183            * @param  TIMx to select the TIM peripheral.
   5184            * @param  TIM_ICPolarity : The Input Polarity.
   5185            *          This parameter can be one of the following values:
   5186            *            @arg TIM_ICPolarity_Rising
   5187            *            @arg TIM_ICPolarity_Falling
   5188            *            @arg TIM_ICPolarity_BothEdge
   5189            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5190            *          This parameter must be a value between 0x00 and 0x0F.
   5191            * @retval None
   5192            */

   \                                 In section .text, align 2, keep-with-next
   5193          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5194          {
   \                     TIM_TI2_ConfigInputStage: (+1)
   \   00000000   0xB410             PUSH     {R4}
   5195            uint32_t tmpccmr1 = 0U;
   5196            uint32_t tmpccer = 0U;
   5197            
   5198            /* Disable the Channel 2: Reset the CC2E Bit */
   5199            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000002   0x6A03             LDR      R3,[R0, #+32]
   \   00000004   0xF023 0x0310      BIC      R3,R3,#0x10
   \   00000008   0x6203             STR      R3,[R0, #+32]
   5200            tmpccmr1 = TIMx->CCMR1;
   \   0000000A   0x6983             LDR      R3,[R0, #+24]
   5201            tmpccer = TIMx->CCER;
   \   0000000C   0x6A04             LDR      R4,[R0, #+32]
   5202            
   5203            /* Set the filter */
   5204            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   5205            tmpccmr1 |= (TIM_ICFilter << 12U);
   5206          
   5207            /* Select the Polarity and set the CC2E Bit */
   5208            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   5209            tmpccer |= (TIM_ICPolarity << 4U);
   5210          
   5211            /* Write to TIMx CCMR1 and CCER registers */
   5212            TIMx->CCMR1 = tmpccmr1 ;
   \   0000000E   0xF423 0x4370      BIC      R3,R3,#0xF000
   \   00000012   0xEA43 0x3202      ORR      R2,R3,R2, LSL #+12
   \   00000016   0x6182             STR      R2,[R0, #+24]
   5213            TIMx->CCER = tmpccer;
   \   00000018   0xF024 0x02A0      BIC      R2,R4,#0xA0
   \   0000001C   0xEA42 0x1101      ORR      R1,R2,R1, LSL #+4
   \   00000020   0x6201             STR      R1,[R0, #+32]
   5214          }
   \   00000022   0xBC10             POP      {R4}
   \   00000024   0x4770             BX       LR               ;; return
   5215          
   5216          /**
   5217            * @brief  Configure the TI3 as Input.
   5218            * @param  TIMx to select the TIM peripheral
   5219            * @param  TIM_ICPolarity : The Input Polarity.
   5220            *          This parameter can be one of the following values:
   5221            *            @arg TIM_ICPolarity_Rising
   5222            *            @arg TIM_ICPolarity_Falling
   5223            *            @arg TIM_ICPolarity_BothEdge         
   5224            * @param  TIM_ICSelection: specifies the input to be used.
   5225            *          This parameter can be one of the following values:
   5226            *            @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   5227            *            @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   5228            *            @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   5229            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5230            *          This parameter must be a value between 0x00 and 0x0F.
   5231            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3 
   5232            *       (on channel4 path) is used as the input signal. Therefore CCMR2 must be 
   5233            *        protected against un-initialized filter and polarity values.
   5234            * @retval None
   5235            */

   \                                 In section .text, align 2, keep-with-next
   5236          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5237                                 uint32_t TIM_ICFilter)
   5238          {
   \                     TIM_TI3_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   5239            uint32_t tmpccmr2 = 0U;
   5240            uint32_t tmpccer = 0U;
   5241          
   5242            /* Disable the Channel 3: Reset the CC3E Bit */
   5243            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   \   00000004   0xF424 0x7480      BIC      R4,R4,#0x100
   \   00000008   0x6204             STR      R4,[R0, #+32]
   5244            tmpccmr2 = TIMx->CCMR2;
   \   0000000A   0x69C4             LDR      R4,[R0, #+28]
   5245            tmpccer = TIMx->CCER;
   \   0000000C   0x6A05             LDR      R5,[R0, #+32]
   5246          
   5247            /* Select the Input */
   5248            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   5249            tmpccmr2 |= TIM_ICSelection;
   5250          
   5251            /* Set the filter */
   5252            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   5253            tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
   5254          
   5255            /* Select the Polarity and set the CC3E Bit */
   5256            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   5257            tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   5258          
   5259            /* Write to TIMx CCMR2 and CCER registers */
   5260            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   0x08A4             LSRS     R4,R4,#+2
   \   00000010   0xEA52 0x0284      ORRS     R2,R2,R4, LSL #+2
   \   00000014   0xF022 0x02F0      BIC      R2,R2,#0xF0
   \   00000018   0x011B             LSLS     R3,R3,#+4
   \   0000001A   0xF003 0x03F0      AND      R3,R3,#0xF0
   \   0000001E   0x431A             ORRS     R2,R3,R2
   \   00000020   0x61C2             STR      R2,[R0, #+28]
   5261            TIMx->CCER = tmpccer;
   \   00000022   0xF425 0x6220      BIC      R2,R5,#0xA00
   \   00000026   0x0209             LSLS     R1,R1,#+8
   \   00000028   0xF401 0x6120      AND      R1,R1,#0xA00
   \   0000002C   0x4311             ORRS     R1,R1,R2
   \   0000002E   0x6201             STR      R1,[R0, #+32]
   5262          }
   \   00000030   0xBC30             POP      {R4,R5}
   \   00000032   0x4770             BX       LR               ;; return
   5263          
   5264          /**
   5265            * @brief  Configure the TI4 as Input.
   5266            * @param  TIMx to select the TIM peripheral
   5267            * @param  TIM_ICPolarity : The Input Polarity.
   5268            *          This parameter can be one of the following values:
   5269            *            @arg TIM_ICPolarity_Rising
   5270            *            @arg TIM_ICPolarity_Falling
   5271            *            @arg TIM_ICPolarity_BothEdge     
   5272            * @param  TIM_ICSelection: specifies the input to be used.
   5273            *          This parameter can be one of the following values:
   5274            *            @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   5275            *            @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   5276            *            @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   5277            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5278            *          This parameter must be a value between 0x00 and 0x0F.
   5279            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4 
   5280            *       (on channel3 path) is used as the input signal. Therefore CCMR2 must be 
   5281            *        protected against un-initialized filter and polarity values.
   5282            * @retval None
   5283            */

   \                                 In section .text, align 2, keep-with-next
   5284          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5285                                 uint32_t TIM_ICFilter)
   5286          {
   \                     TIM_TI4_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   5287            uint32_t tmpccmr2 = 0U;
   5288            uint32_t tmpccer = 0U;
   5289          
   5290            /* Disable the Channel 4: Reset the CC4E Bit */
   5291            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   \   00000004   0xF424 0x5480      BIC      R4,R4,#0x1000
   \   00000008   0x6204             STR      R4,[R0, #+32]
   5292            tmpccmr2 = TIMx->CCMR2;
   \   0000000A   0x69C4             LDR      R4,[R0, #+28]
   5293            tmpccer = TIMx->CCER;
   \   0000000C   0x6A05             LDR      R5,[R0, #+32]
   5294          
   5295            /* Select the Input */
   5296            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   5297            tmpccmr2 |= (TIM_ICSelection << 8U);
   5298          
   5299            /* Set the filter */
   5300            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   5301            tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
   5302          
   5303            /* Select the Polarity and set the CC4E Bit */
   5304            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   5305            tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   5306          
   5307            /* Write to TIMx CCMR2 and CCER registers */
   5308            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   0xF424 0x7440      BIC      R4,R4,#0x300
   \   00000012   0xEA44 0x2202      ORR      R2,R4,R2, LSL #+8
   \   00000016   0xF422 0x4270      BIC      R2,R2,#0xF000
   \   0000001A   0x031B             LSLS     R3,R3,#+12
   \   0000001C   0xF403 0x4370      AND      R3,R3,#0xF000
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x61C2             STR      R2,[R0, #+28]
   5309            TIMx->CCER = tmpccer ;
   \   00000024   0xF425 0x4220      BIC      R2,R5,#0xA000
   \   00000028   0x0309             LSLS     R1,R1,#+12
   \   0000002A   0xF401 0x4120      AND      R1,R1,#0xA000
   \   0000002E   0x4311             ORRS     R1,R1,R2
   \   00000030   0x6201             STR      R1,[R0, #+32]
   5310          }
   \   00000032   0xBC30             POP      {R4,R5}
   \   00000034   0x4770             BX       LR               ;; return
   5311          
   5312          /**
   5313            * @brief  Selects the Input Trigger source
   5314            * @param  TIMx to select the TIM peripheral
   5315            * @param  TIM_ITRx: The Input Trigger source.
   5316            *          This parameter can be one of the following values:
   5317            *            @arg TIM_TS_ITR0: Internal Trigger 0
   5318            *            @arg TIM_TS_ITR1: Internal Trigger 1
   5319            *            @arg TIM_TS_ITR2: Internal Trigger 2
   5320            *            @arg TIM_TS_ITR3: Internal Trigger 3
   5321            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   5322            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   5323            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   5324            *            @arg TIM_TS_ETRF: External Trigger input
   5325            * @retval None
   5326            */

   \                                 In section .text, align 2, keep-with-next
   5327          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t TIM_ITRx)
   5328          {
   5329            uint32_t tmpsmcr = 0U;
   5330            
   5331             /* Get the TIMx SMCR register value */
   5332             tmpsmcr = TIMx->SMCR;
   \                     TIM_ITRx_SetConfig: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
   5333             /* Reset the TS Bits */
   5334             tmpsmcr &= ~TIM_SMCR_TS;
   5335             /* Set the Input Trigger source and the slave mode*/
   5336             tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
   5337             /* Write to TIMx SMCR */
   5338             TIMx->SMCR = tmpsmcr;
   \   00000002   0xF022 0x0270      BIC      R2,R2,#0x70
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0xF041 0x0107      ORR      R1,R1,#0x7
   \   0000000C   0x6081             STR      R1,[R0, #+8]
   5339          }
   \   0000000E   0x4770             BX       LR               ;; return
   5340          
   5341          /**
   5342            * @brief  Configures the TIMx External Trigger (ETR).
   5343            * @param  TIMx to select the TIM peripheral
   5344            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   5345            *          This parameter can be one of the following values:
   5346            *            @arg TIM_ETRPRESCALER_DIV1 : ETRP Prescaler OFF.
   5347            *            @arg TIM_ETRPRESCALER_DIV2 : ETRP frequency divided by 2.
   5348            *            @arg TIM_ETRPRESCALER_DIV4 : ETRP frequency divided by 4.
   5349            *            @arg TIM_ETRPRESCALER_DIV8 : ETRP frequency divided by 8.
   5350            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   5351            *          This parameter can be one of the following values:
   5352            *            @arg TIM_ETRPOLARITY_INVERTED : active low or falling edge active.
   5353            *            @arg TIM_ETRPOLARITY_NONINVERTED : active high or rising edge active.
   5354            * @param  ExtTRGFilter: External Trigger Filter.
   5355            *          This parameter must be a value between 0x00 and 0x0F
   5356            * @retval None
   5357            */

   \                                 In section .text, align 2, keep-with-next
   5358          static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
   5359                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   5360          {
   \                     TIM_ETR_SetConfig: (+1)
   \   00000000   0xB410             PUSH     {R4}
   5361            uint32_t tmpsmcr = 0U;
   5362          
   5363            tmpsmcr = TIMx->SMCR;
   \   00000002   0x6884             LDR      R4,[R0, #+8]
   5364          
   5365            /* Reset the ETR Bits */
   5366            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   5367          
   5368            /* Set the Prescaler, the Filter value and the Polarity */
   5369            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
   5370          
   5371            /* Write to TIMx SMCR */
   5372            TIMx->SMCR = tmpsmcr;
   \   00000004   0xF424 0x447F      BIC      R4,R4,#0xFF00
   \   00000008   0x4321             ORRS     R1,R1,R4
   \   0000000A   0x4311             ORRS     R1,R2,R1
   \   0000000C   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \   00000010   0x6081             STR      R1,[R0, #+8]
   5373          } 
   \   00000012   0xBC10             POP      {R4}
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0xFFFFFCFC         DC32     0xfffffcfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0xFFFF0303         DC32     0xffff0303

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x........         DC32     TIMEx_DMACommutationCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0xFFFF0088         DC32     0xffff0088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \   00000000   0x40000C00         DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \   00000000   0x40014000         DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_8:
   \   00000000   0x40014400         DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_9:
   \   00000000   0x40014800         DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_10:
   \   00000000   0x40001800         DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_11:
   \   00000000   0x40001C00         DC32     0x40001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_12:
   \   00000000   0x40002000         DC32     0x40002000
   5374          
   5375          /**
   5376            * @}
   5377            */
   5378          
   5379          #endif /* HAL_TIM_MODULE_ENABLED */
   5380          /**
   5381            * @}
   5382            */ 
   5383          
   5384          /**
   5385            * @}
   5386            */ 
   5387          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_TIM_Base_DeInit
         8   -> HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_GetState
       8   HAL_TIM_Base_Init
         8   -> HAL_TIM_Base_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_MspInit
       0   HAL_TIM_Base_Start
       8   HAL_TIM_Base_Start_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_TIM_Base_Start_IT
       0   HAL_TIM_Base_Stop
       0   HAL_TIM_Base_Stop_DMA
       0   HAL_TIM_Base_Stop_IT
       8   HAL_TIM_ConfigClockSource
         8   -> TIM_ETR_SetConfig
         8   -> TIM_ITRx_SetConfig
         8   -> TIM_TI1_ConfigInputStage
         8   -> TIM_TI2_ConfigInputStage
      16   HAL_TIM_ConfigOCrefClear
        16   -> TIM_ETR_SetConfig
       0   HAL_TIM_ConfigTI1Input
      24   HAL_TIM_DMABurst_ReadStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_ReadStop
        16   -> HAL_DMA_Abort
      24   HAL_TIM_DMABurst_WriteStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_WriteStop
        16   -> HAL_DMA_Abort
       8   HAL_TIM_Encoder_DeInit
         8   -> HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_GetState
      16   HAL_TIM_Encoder_Init
        16   -> HAL_TIM_Encoder_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_MspInit
       8   HAL_TIM_Encoder_Start
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_Encoder_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Stop_DMA
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Stop_IT
         8   -> TIM_CCxChannelCmd
       0   HAL_TIM_ErrorCallback
       0   HAL_TIM_GenerateEvent
       0   HAL_TIM_IC_CaptureCallback
      16   HAL_TIM_IC_ConfigChannel
        16   -> TIM_TI1_SetConfig
        16   -> TIM_TI2_SetConfig
        16   -> TIM_TI3_SetConfig
        16   -> TIM_TI4_SetConfig
       8   HAL_TIM_IC_DeInit
         8   -> HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_GetState
       8   HAL_TIM_IC_Init
         8   -> HAL_TIM_IC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_MspInit
       8   HAL_TIM_IC_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Stop_DMA
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Stop_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_IRQHandler
         8   -> HAL_TIMEx_BreakCallback
         0   -> HAL_TIMEx_CommutationCallback
         8   -> HAL_TIM_IC_CaptureCallback
         8   -> HAL_TIM_OC_DelayElapsedCallback
         8   -> HAL_TIM_PWM_PulseFinishedCallback
         8   -> HAL_TIM_PeriodElapsedCallback
         8   -> HAL_TIM_TriggerCallback
       8   HAL_TIM_OC_ConfigChannel
         8   -> TIM_OC1_SetConfig
         8   -> TIM_OC2_SetConfig
         8   -> TIM_OC3_SetConfig
         8   -> TIM_OC4_SetConfig
       8   HAL_TIM_OC_DeInit
         8   -> HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_DelayElapsedCallback
       0   HAL_TIM_OC_GetState
       8   HAL_TIM_OC_Init
         8   -> HAL_TIM_OC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_MspInit
       8   HAL_TIM_OC_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Stop_DMA
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Stop_IT
         8   -> TIM_CCxChannelCmd
      48   HAL_TIM_OnePulse_ConfigChannel
        48   -> TIM_OC1_SetConfig
        48   -> TIM_OC2_SetConfig
        48   -> TIM_TI1_SetConfig
        48   -> TIM_TI2_SetConfig
       8   HAL_TIM_OnePulse_DeInit
         8   -> HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_GetState
      16   HAL_TIM_OnePulse_Init
        16   -> HAL_TIM_OnePulse_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_MspInit
       8   HAL_TIM_OnePulse_Start
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Stop_IT
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_PWM_DeInit
         8   -> HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_GetState
       8   HAL_TIM_PWM_Init
         8   -> HAL_TIM_PWM_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_PulseFinishedCallback
       8   HAL_TIM_PWM_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_PWM_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_PWM_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_PWM_Stop_DMA
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_PWM_Stop_IT
         8   -> TIM_CCxChannelCmd
       0   HAL_TIM_PeriodElapsedCallback
       0   HAL_TIM_ReadCapturedValue
       8   HAL_TIM_SlaveConfigSynchronization
         8   -> TIM_SlaveTimer_SetConfig
       8   HAL_TIM_SlaveConfigSynchronization_IT
         8   -> TIM_SlaveTimer_SetConfig
       0   HAL_TIM_TriggerCallback
       4   TIM_Base_SetConfig
       4   TIM_CCxChannelCmd
       8   TIM_DMACaptureCplt
         8   -> HAL_TIM_IC_CaptureCallback
       8   TIM_DMADelayPulseCplt
         8   -> HAL_TIM_PWM_PulseFinishedCallback
       8   TIM_DMAError
         8   -> HAL_TIM_ErrorCallback
       8   TIM_DMAPeriodElapsedCplt
         8   -> HAL_TIM_PeriodElapsedCallback
       8   TIM_DMATriggerCplt
         8   -> HAL_TIM_TriggerCallback
       4   TIM_ETR_SetConfig
       0   TIM_ITRx_SetConfig
       8   TIM_OC1_SetConfig
      12   TIM_OC2_SetConfig
      12   TIM_OC3_SetConfig
       8   TIM_OC4_SetConfig
       8   TIM_SlaveTimer_SetConfig
         0   -> TIM_ETR_SetConfig
         0   -> TIM_TI1_ConfigInputStage
         0   -> TIM_TI2_ConfigInputStage
       4   TIM_TI1_ConfigInputStage
      12   TIM_TI1_SetConfig
       4   TIM_TI2_ConfigInputStage
       8   TIM_TI2_SetConfig
       8   TIM_TI3_SetConfig
       8   TIM_TI4_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable22
       4  ??DataTable23
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_10
       4  ??DataTable28_11
       4  ??DataTable28_12
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
       4  ??DataTable28_8
       4  ??DataTable28_9
      58  HAL_TIM_Base_DeInit
       6  HAL_TIM_Base_GetState
      54  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
      26  HAL_TIM_Base_Start
      96  HAL_TIM_Base_Start_DMA
      24  HAL_TIM_Base_Start_IT
      46  HAL_TIM_Base_Stop
      50  HAL_TIM_Base_Stop_DMA
      44  HAL_TIM_Base_Stop_IT
     260  HAL_TIM_ConfigClockSource
     184  HAL_TIM_ConfigOCrefClear
      16  HAL_TIM_ConfigTI1Input
     358  HAL_TIM_DMABurst_ReadStart
     118  HAL_TIM_DMABurst_ReadStop
     358  HAL_TIM_DMABurst_WriteStart
     118  HAL_TIM_DMABurst_WriteStop
      58  HAL_TIM_Encoder_DeInit
       6  HAL_TIM_Encoder_GetState
     148  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
      72  HAL_TIM_Encoder_Start
     306  HAL_TIM_Encoder_Start_DMA
     112  HAL_TIM_Encoder_Start_IT
      92  HAL_TIM_Encoder_Stop
     132  HAL_TIM_Encoder_Stop_DMA
     132  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      44  HAL_TIM_GenerateEvent
       2  HAL_TIM_IC_CaptureCallback
     176  HAL_TIM_IC_ConfigChannel
      58  HAL_TIM_IC_DeInit
       6  HAL_TIM_IC_GetState
      54  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
      26  HAL_TIM_IC_Start
     240  HAL_TIM_IC_Start_DMA
      90  HAL_TIM_IC_Start_IT
      46  HAL_TIM_IC_Stop
     116  HAL_TIM_IC_Stop_DMA
     110  HAL_TIM_IC_Stop_IT
     338  HAL_TIM_IRQHandler
      90  HAL_TIM_OC_ConfigChannel
      58  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       6  HAL_TIM_OC_GetState
      54  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
      62  HAL_TIM_OC_Start
     282  HAL_TIM_OC_Start_DMA
     126  HAL_TIM_OC_Start_IT
      98  HAL_TIM_OC_Stop
     168  HAL_TIM_OC_Stop_DMA
     162  HAL_TIM_OC_Stop_IT
     246  HAL_TIM_OnePulse_ConfigChannel
      58  HAL_TIM_OnePulse_DeInit
       6  HAL_TIM_OnePulse_GetState
      76  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
      60  HAL_TIM_OnePulse_Start
      80  HAL_TIM_OnePulse_Start_IT
     106  HAL_TIM_OnePulse_Stop
     128  HAL_TIM_OnePulse_Stop_IT
     216  HAL_TIM_PWM_ConfigChannel
      58  HAL_TIM_PWM_DeInit
       6  HAL_TIM_PWM_GetState
      54  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
      62  HAL_TIM_PWM_Start
     282  HAL_TIM_PWM_Start_DMA
     126  HAL_TIM_PWM_Start_IT
     104  HAL_TIM_PWM_Stop
     168  HAL_TIM_PWM_Stop_DMA
     162  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
      70  HAL_TIM_ReadCapturedValue
      68  HAL_TIM_SlaveConfigSynchronization
      68  HAL_TIM_SlaveConfigSynchronization_IT
       2  HAL_TIM_TriggerCallback
     204  TIM_Base_SetConfig
      26  TIM_CCxChannelCmd
      72  TIM_DMACaptureCplt
      72  TIM_DMADelayPulseCplt
      16  TIM_DMAError
      16  TIM_DMAPeriodElapsedCplt
      16  TIM_DMATriggerCplt
      22  TIM_ETR_SetConfig
      16  TIM_ITRx_SetConfig
      92  TIM_OC1_SetConfig
     100  TIM_OC2_SetConfig
      98  TIM_OC3_SetConfig
      82  TIM_OC4_SetConfig
     114  TIM_SlaveTimer_SetConfig
      36  TIM_TI1_ConfigInputStage
     116  TIM_TI1_SetConfig
      38  TIM_TI2_ConfigInputStage
      54  TIM_TI2_SetConfig
      52  TIM_TI3_SetConfig
      54  TIM_TI4_SetConfig

 
 8 916 bytes in section .text
 
 8 916 bytes of CODE memory

Errors: none
Warnings: none
