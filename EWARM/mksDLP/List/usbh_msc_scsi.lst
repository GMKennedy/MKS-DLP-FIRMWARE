###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:34
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_scsi.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_scsi.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\usbh_msc_scsi.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\usbh_msc_scsi.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\ST\STM32_USB_Host_Library\Class\MSC\Src\usbh_msc_scsi.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_msc_scsi.c 
      4            * @author  MCD Application Team
      5            * @version V3.2.2
      6            * @date    07-July-2015
      7            * @brief   This file implements the SCSI commands
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbh_msc.h"
     30          #include "usbh_msc_scsi.h"
     31          #include "usbh_msc_bot.h"
     32          
     33          
     34          /** @addtogroup USBH_LIB
     35            * @{
     36            */
     37          
     38          /** @addtogroup USBH_CLASS
     39            * @{
     40            */
     41          
     42          /** @addtogroup USBH_MSC_CLASS
     43            * @{
     44            */
     45            
     46          /** @defgroup USBH_MSC_SCSI 
     47            * @brief    This file includes the mass storage related functions
     48            * @{
     49            */ 
     50          
     51          
     52          /** @defgroup USBH_MSC_SCSI_Private_TypesDefinitions
     53            * @{
     54            */ 
     55          
     56          /**
     57            * @}
     58            */ 
     59          
     60          /** @defgroup USBH_MSC_SCSI_Private_Defines
     61            * @{
     62            */ 
     63          /**
     64            * @}
     65            */ 
     66          
     67          /** @defgroup USBH_MSC_SCSI_Private_Macros
     68            * @{
     69            */ 
     70          /**
     71            * @}
     72            */ 
     73          
     74          
     75          /** @defgroup USBH_MSC_SCSI_Private_FunctionPrototypes
     76            * @{
     77            */ 
     78          /**
     79            * @}
     80            */ 
     81          
     82          
     83          /** @defgroup USBH_MSC_SCSI_Exported_Variables
     84            * @{
     85            */ 
     86          
     87          /**
     88            * @}
     89            */ 
     90          
     91          
     92          /** @defgroup USBH_MSC_SCSI_Private_Functions
     93            * @{
     94            */ 
     95          
     96          
     97          /**
     98            * @brief  USBH_MSC_SCSI_TestUnitReady 
     99            *         Issue TestUnitReady command.
    100            * @param  phost: Host handle
    101            * @param  lun: Logical Unit Number
    102            * @retval USBH Status
    103            */

   \                                 In section .text, align 2, keep-with-next
    104          USBH_StatusTypeDef USBH_MSC_SCSI_TestUnitReady (USBH_HandleTypeDef *phost, 
    105                                                          uint8_t lun)
    106          {
   \                     USBH_MSC_SCSI_TestUnitReady: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4602             MOV      R2,R0
    107            USBH_StatusTypeDef    error = USBH_FAIL ;
   \   00000004   0x2002             MOVS     R0,#+2
    108            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000006   0xF8D2 0x3374      LDR      R3,[R2, #+884]
   \   0000000A   0x69DC             LDR      R4,[R3, #+28]
    109            
    110            switch(MSC_Handle->hbot.cmd_state)
   \   0000000C   0xF104 0x0550      ADD      R5,R4,#+80
   \   00000010   0xF995 0x3002      LDRSB    R3,[R5, #+2]
   \   00000014   0x2B01             CMP      R3,#+1
   \   00000016   0xD002             BEQ.N    ??USBH_MSC_SCSI_TestUnitReady_0
   \   00000018   0x2B02             CMP      R3,#+2
   \   0000001A   0xD014             BEQ.N    ??USBH_MSC_SCSI_TestUnitReady_1
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}
    111            {
    112            case BOT_CMD_SEND:  
    113              
    114              /*Prepare the CBW and relevent field*/
    115              MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_MODE_TEST_UNIT_READY;     
   \                     ??USBH_MSC_SCSI_TestUnitReady_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x60E8             STR      R0,[R5, #+12]
    116              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
   \   00000022   0x7428             STRB     R0,[R5, #+16]
    117              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
   \   00000024   0x200A             MOVS     R0,#+10
   \   00000026   0x74A8             STRB     R0,[R5, #+18]
    118              
    119              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
   \   00000028   0x2210             MOVS     R2,#+16
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xF104 0x0063      ADD      R0,R4,#+99
   \   00000030   0x.... 0x....      BL       memset
    120              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_TEST_UNIT_READY; 
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x74E8             STRB     R0,[R5, #+19]
    121              
    122              MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xF884 0x0050      STRB     R0,[R4, #+80]
    123              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x70A8             STRB     R0,[R5, #+2]
    124              error = USBH_BUSY; 
   \   00000042   0x2001             MOVS     R0,#+1
    125              break;
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}
    126              
    127            case BOT_CMD_WAIT: 
    128              error = USBH_MSC_BOT_Process(phost, lun);
   \                     ??USBH_MSC_SCSI_TestUnitReady_1: (+1)
   \   00000046   0x4610             MOV      R0,R2
   \   00000048   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000004C   0x.... 0x....      B.W      USBH_MSC_BOT_Process
    129              break;
    130              
    131            default:
    132              break;
    133            }
    134            
    135            return error;
    136          }
    137          
    138          /**
    139            * @brief  USBH_MSC_SCSI_ReadCapacity 
    140            *         Issue Read Capacity command.
    141            * @param  phost: Host handle
    142            * @param  lun: Logical Unit Number
    143            * @param  capacity: pointer to the capacity structure
    144            * @retval USBH Status
    145            */

   \                                 In section .text, align 2, keep-with-next
    146          USBH_StatusTypeDef USBH_MSC_SCSI_ReadCapacity (USBH_HandleTypeDef *phost, 
    147                                                         uint8_t lun,
    148                                                         SCSI_CapacityTypeDef *capacity)
    149          {
   \                     USBH_MSC_SCSI_ReadCapacity: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4617             MOV      R7,R2
    150            USBH_StatusTypeDef    error = USBH_BUSY ;
   \   00000004   0x2401             MOVS     R4,#+1
    151            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000006   0xF8D0 0x2374      LDR      R2,[R0, #+884]
   \   0000000A   0x69D6             LDR      R6,[R2, #+28]
    152            
    153            switch(MSC_Handle->hbot.cmd_state)
   \   0000000C   0xF106 0x0550      ADD      R5,R6,#+80
   \   00000010   0xF995 0x2002      LDRSB    R2,[R5, #+2]
   \   00000014   0x2A01             CMP      R2,#+1
   \   00000016   0xD002             BEQ.N    ??USBH_MSC_SCSI_ReadCapacity_0
   \   00000018   0x2A02             CMP      R2,#+2
   \   0000001A   0xD017             BEQ.N    ??USBH_MSC_SCSI_ReadCapacity_1
   \   0000001C   0xE02C             B.N      ??USBH_MSC_SCSI_ReadCapacity_2
    154            {
    155            case BOT_CMD_SEND:  
    156              
    157              /*Prepare the CBW and relevent field*/
    158              MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_READ_CAPACITY10;
   \                     ??USBH_MSC_SCSI_ReadCapacity_0: (+1)
   \   0000001E   0x2008             MOVS     R0,#+8
   \   00000020   0x60E8             STR      R0,[R5, #+12]
    159              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
   \   00000022   0x2080             MOVS     R0,#+128
   \   00000024   0x7428             STRB     R0,[R5, #+16]
    160              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
   \   00000026   0x200A             MOVS     R0,#+10
   \   00000028   0x74A8             STRB     R0,[R5, #+18]
    161              
    162              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
   \   0000002A   0x2210             MOVS     R2,#+16
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xF106 0x0063      ADD      R0,R6,#+99
   \   00000032   0x.... 0x....      BL       memset
    163              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_READ_CAPACITY10; 
   \   00000036   0x2025             MOVS     R0,#+37
   \   00000038   0x74E8             STRB     R0,[R5, #+19]
    164              
    165              MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0xF886 0x0050      STRB     R0,[R6, #+80]
    166              
    167              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0x70A8             STRB     R0,[R5, #+2]
    168              MSC_Handle->hbot.pbuf = (uint8_t *)MSC_Handle->hbot.data;
   \   00000044   0xF106 0x0010      ADD      R0,R6,#+16
   \   00000048   0x63E8             STR      R0,[R5, #+60]
    169              error = USBH_BUSY; 
    170              break;
   \   0000004A   0xE015             B.N      ??USBH_MSC_SCSI_ReadCapacity_2
    171              
    172            case BOT_CMD_WAIT: 
    173              
    174              error = USBH_MSC_BOT_Process(phost, lun);
   \                     ??USBH_MSC_SCSI_ReadCapacity_1: (+1)
   \   0000004C   0x.... 0x....      BL       USBH_MSC_BOT_Process
   \   00000050   0x0004             MOVS     R4,R0
    175              
    176              if(error == USBH_OK)
   \   00000052   0xD111             BNE.N    ??USBH_MSC_SCSI_ReadCapacity_2
    177              {
    178                /*assign the capacity*/
    179                capacity->block_nbr = MSC_Handle->hbot.pbuf[3] | (MSC_Handle->hbot.pbuf[2] << 8) |\
    180                                     (MSC_Handle->hbot.pbuf[1] << 16) | (MSC_Handle->hbot.pbuf[0] << 24);
   \   00000054   0x6BE8             LDR      R0,[R5, #+60]
   \   00000056   0x78C1             LDRB     R1,[R0, #+3]
   \   00000058   0x7882             LDRB     R2,[R0, #+2]
   \   0000005A   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   0000005E   0x7842             LDRB     R2,[R0, #+1]
   \   00000060   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   0000006A   0x6038             STR      R0,[R7, #+0]
    181          
    182                /*assign the page length*/
    183                capacity->block_size = MSC_Handle->hbot.pbuf[7] | (MSC_Handle->hbot.pbuf[6] << 8); 
   \   0000006C   0x6BE8             LDR      R0,[R5, #+60]
   \   0000006E   0x79C1             LDRB     R1,[R0, #+7]
   \   00000070   0x7980             LDRB     R0,[R0, #+6]
   \   00000072   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000076   0x80B8             STRH     R0,[R7, #+4]
    184              }
    185              break;
    186              
    187            default:
    188              break;
    189            }
    190            
    191            return error;
   \                     ??USBH_MSC_SCSI_ReadCapacity_2: (+1)
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    192          }
    193          
    194          /**
    195            * @brief  USBH_MSC_SCSI_Inquiry 
    196            *         Issue Inquiry command.
    197            * @param  phost: Host handle
    198            * @param  lun: Logical Unit Number
    199            * @param  capacity: pointer to the inquiry structure
    200            * @retval USBH Status
    201            */

   \                                 In section .text, align 2, keep-with-next
    202          USBH_StatusTypeDef USBH_MSC_SCSI_Inquiry (USBH_HandleTypeDef *phost, 
    203                                                         uint8_t lun, 
    204                                                         SCSI_StdInquiryDataTypeDef *inquiry)
    205          {
   \                     USBH_MSC_SCSI_Inquiry: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4617             MOV      R7,R2
    206            USBH_StatusTypeDef    error = USBH_FAIL ;
   \   00000008   0xF04F 0x0802      MOV      R8,#+2
    207            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   0000000C   0xF8D0 0x1374      LDR      R1,[R0, #+884]
   \   00000010   0x69CD             LDR      R5,[R1, #+28]
    208            switch(MSC_Handle->hbot.cmd_state)
   \   00000012   0xF105 0x0650      ADD      R6,R5,#+80
   \   00000016   0xF996 0x1002      LDRSB    R1,[R6, #+2]
   \   0000001A   0x2901             CMP      R1,#+1
   \   0000001C   0xD002             BEQ.N    ??USBH_MSC_SCSI_Inquiry_0
   \   0000001E   0x2902             CMP      R1,#+2
   \   00000020   0xD022             BEQ.N    ??USBH_MSC_SCSI_Inquiry_1
   \   00000022   0xE051             B.N      ??USBH_MSC_SCSI_Inquiry_2
    209            {
    210            case BOT_CMD_SEND:  
    211              
    212              /*Prepare the CBW and relevent field*/
    213              MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_INQUIRY;
   \                     ??USBH_MSC_SCSI_Inquiry_0: (+1)
   \   00000024   0x2024             MOVS     R0,#+36
   \   00000026   0x60F0             STR      R0,[R6, #+12]
    214              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
   \   00000028   0x2080             MOVS     R0,#+128
   \   0000002A   0x7430             STRB     R0,[R6, #+16]
    215              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
   \   0000002C   0x200A             MOVS     R0,#+10
   \   0000002E   0x74B0             STRB     R0,[R6, #+18]
    216              
    217              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_LENGTH);
   \   00000030   0x4602             MOV      R2,R0
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0xF105 0x0063      ADD      R0,R5,#+99
   \   00000038   0x.... 0x....      BL       memset
    218              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_INQUIRY; 
   \   0000003C   0x2012             MOVS     R0,#+18
   \   0000003E   0x74F0             STRB     R0,[R6, #+19]
    219              MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5);    
   \   00000040   0x0160             LSLS     R0,R4,#+5
   \   00000042   0x7530             STRB     R0,[R6, #+20]
    220              MSC_Handle->hbot.cbw.field.CB[2]  = 0;    
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x7570             STRB     R0,[R6, #+21]
    221              MSC_Handle->hbot.cbw.field.CB[3]  = 0;    
   \   00000048   0x75B0             STRB     R0,[R6, #+22]
    222              MSC_Handle->hbot.cbw.field.CB[4]  = 0x24;    
   \   0000004A   0x2024             MOVS     R0,#+36
   \   0000004C   0x75F0             STRB     R0,[R6, #+23]
    223              MSC_Handle->hbot.cbw.field.CB[5]  = 0;    
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x7630             STRB     R0,[R6, #+24]
    224                  
    225              MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xF885 0x0050      STRB     R0,[R5, #+80]
    226          
    227              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x70B0             STRB     R0,[R6, #+2]
    228              MSC_Handle->hbot.pbuf = (uint8_t *)MSC_Handle->hbot.data;
   \   0000005C   0xF105 0x0010      ADD      R0,R5,#+16
   \   00000060   0x63F0             STR      R0,[R6, #+60]
    229              error = USBH_BUSY; 
   \   00000062   0xF04F 0x0801      MOV      R8,#+1
    230              break;
   \   00000066   0xE02F             B.N      ??USBH_MSC_SCSI_Inquiry_2
    231              
    232            case BOT_CMD_WAIT: 
    233              
    234              error = USBH_MSC_BOT_Process(phost, lun);
   \                     ??USBH_MSC_SCSI_Inquiry_1: (+1)
   \   00000068   0x4621             MOV      R1,R4
   \   0000006A   0x.... 0x....      BL       USBH_MSC_BOT_Process
   \   0000006E   0x4680             MOV      R8,R0
    235              
    236              if(error == USBH_OK)
   \   00000070   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000074   0xD128             BNE.N    ??USBH_MSC_SCSI_Inquiry_2
    237              {
    238                USBH_memset(inquiry, 0, sizeof(SCSI_StdInquiryDataTypeDef));
   \   00000076   0x2222             MOVS     R2,#+34
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x4638             MOV      R0,R7
   \   0000007C   0x.... 0x....      BL       memset
    239                /*assign Inquiry Data */
    240                inquiry->DeviceType = MSC_Handle->hbot.pbuf[0] & 0x1F;
   \   00000080   0x6BF0             LDR      R0,[R6, #+60]
   \   00000082   0x7800             LDRB     R0,[R0, #+0]
   \   00000084   0xF000 0x001F      AND      R0,R0,#0x1F
   \   00000088   0x7078             STRB     R0,[R7, #+1]
    241                inquiry->PeripheralQualifier = MSC_Handle->hbot.pbuf[0] >> 5;  
   \   0000008A   0x6BF0             LDR      R0,[R6, #+60]
   \   0000008C   0x7800             LDRB     R0,[R0, #+0]
   \   0000008E   0x0940             LSRS     R0,R0,#+5
   \   00000090   0x7038             STRB     R0,[R7, #+0]
    242                inquiry->RemovableMedia = (MSC_Handle->hbot.pbuf[1] & 0x80)== 0x80;
   \   00000092   0x6BF0             LDR      R0,[R6, #+60]
   \   00000094   0x7840             LDRB     R0,[R0, #+1]
   \   00000096   0x09C0             LSRS     R0,R0,#+7
   \   00000098   0x70B8             STRB     R0,[R7, #+2]
    243                USBH_memcpy (inquiry->vendor_id, &MSC_Handle->hbot.pbuf[8], 8);
   \   0000009A   0x2208             MOVS     R2,#+8
   \   0000009C   0x6BF0             LDR      R0,[R6, #+60]
   \   0000009E   0xF100 0x0108      ADD      R1,R0,#+8
   \   000000A2   0x1CF8             ADDS     R0,R7,#+3
   \   000000A4   0x.... 0x....      BL       memcpy
    244                USBH_memcpy (inquiry->product_id, &MSC_Handle->hbot.pbuf[16], 16);
   \   000000A8   0x2210             MOVS     R2,#+16
   \   000000AA   0x6BF0             LDR      R0,[R6, #+60]
   \   000000AC   0xF100 0x0110      ADD      R1,R0,#+16
   \   000000B0   0xF107 0x000C      ADD      R0,R7,#+12
   \   000000B4   0x.... 0x....      BL       memcpy
    245                USBH_memcpy (inquiry->revision_id, &MSC_Handle->hbot.pbuf[32], 4);    
   \   000000B8   0x2204             MOVS     R2,#+4
   \   000000BA   0x6BF0             LDR      R0,[R6, #+60]
   \   000000BC   0xF100 0x0120      ADD      R1,R0,#+32
   \   000000C0   0xF107 0x001D      ADD      R0,R7,#+29
   \   000000C4   0x.... 0x....      BL       memcpy
    246              }
    247              break;
    248              
    249            default:
    250              break;
    251            }
    252            
    253            return error;
   \                     ??USBH_MSC_SCSI_Inquiry_2: (+1)
   \   000000C8   0x4640             MOV      R0,R8
   \   000000CA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    254          }
    255          
    256          /**
    257            * @brief  USBH_MSC_SCSI_RequestSense 
    258            *         Issue RequestSense command.
    259            * @param  phost: Host handle
    260            * @param  lun: Logical Unit Number
    261            * @param  capacity: pointer to the sense data structure
    262            * @retval USBH Status
    263            */

   \                                 In section .text, align 2, keep-with-next
    264          USBH_StatusTypeDef USBH_MSC_SCSI_RequestSense (USBH_HandleTypeDef *phost, 
    265                                                         uint8_t lun, 
    266                                                         SCSI_SenseTypeDef *sense_data)
    267          {
   \                     USBH_MSC_SCSI_RequestSense: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4603             MOV      R3,R0
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4617             MOV      R7,R2
    268            USBH_StatusTypeDef    error = USBH_FAIL ;
   \   00000008   0x2002             MOVS     R0,#+2
    269            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   0000000A   0xF8D3 0x1374      LDR      R1,[R3, #+884]
   \   0000000E   0x69CD             LDR      R5,[R1, #+28]
    270            
    271            switch(MSC_Handle->hbot.cmd_state)
   \   00000010   0xF105 0x0650      ADD      R6,R5,#+80
   \   00000014   0xF996 0x1002      LDRSB    R1,[R6, #+2]
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD002             BEQ.N    ??USBH_MSC_SCSI_RequestSense_0
   \   0000001C   0x2902             CMP      R1,#+2
   \   0000001E   0xD021             BEQ.N    ??USBH_MSC_SCSI_RequestSense_1
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}
    272            {
    273            case BOT_CMD_SEND:  
    274              
    275              /*Prepare the CBW and relevent field*/
    276              MSC_Handle->hbot.cbw.field.DataTransferLength = DATA_LEN_REQUEST_SENSE;
   \                     ??USBH_MSC_SCSI_RequestSense_0: (+1)
   \   00000022   0x200E             MOVS     R0,#+14
   \   00000024   0x60F0             STR      R0,[R6, #+12]
    277              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
   \   00000026   0x2080             MOVS     R0,#+128
   \   00000028   0x7430             STRB     R0,[R6, #+16]
    278              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
   \   0000002A   0x200A             MOVS     R0,#+10
   \   0000002C   0x74B0             STRB     R0,[R6, #+18]
    279              
    280              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
   \   0000002E   0x2210             MOVS     R2,#+16
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xF105 0x0063      ADD      R0,R5,#+99
   \   00000036   0x.... 0x....      BL       memset
    281              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_REQUEST_SENSE; 
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0x74F0             STRB     R0,[R6, #+19]
    282              MSC_Handle->hbot.cbw.field.CB[1]  = (lun << 5); 
   \   0000003E   0x0160             LSLS     R0,R4,#+5
   \   00000040   0x7530             STRB     R0,[R6, #+20]
    283              MSC_Handle->hbot.cbw.field.CB[2]  = 0; 
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x7570             STRB     R0,[R6, #+21]
    284              MSC_Handle->hbot.cbw.field.CB[3]  = 0; 
   \   00000046   0x75B0             STRB     R0,[R6, #+22]
    285              MSC_Handle->hbot.cbw.field.CB[4]  = DATA_LEN_REQUEST_SENSE;
   \   00000048   0x200E             MOVS     R0,#+14
   \   0000004A   0x75F0             STRB     R0,[R6, #+23]
    286              MSC_Handle->hbot.cbw.field.CB[5]  = 0;       
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x7630             STRB     R0,[R6, #+24]
    287              
    288              MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xF885 0x0050      STRB     R0,[R5, #+80]
    289              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
   \   00000056   0x2002             MOVS     R0,#+2
   \   00000058   0x70B0             STRB     R0,[R6, #+2]
    290              MSC_Handle->hbot.pbuf = (uint8_t *)MSC_Handle->hbot.data;
   \   0000005A   0xF105 0x0010      ADD      R0,R5,#+16
   \   0000005E   0x63F0             STR      R0,[R6, #+60]
    291              error = USBH_BUSY; 
   \   00000060   0x2001             MOVS     R0,#+1
    292              break;
   \   00000062   0xBDF2             POP      {R1,R4-R7,PC}
    293              
    294            case BOT_CMD_WAIT: 
    295              
    296              error = USBH_MSC_BOT_Process(phost, lun);
   \                     ??USBH_MSC_SCSI_RequestSense_1: (+1)
   \   00000064   0x4621             MOV      R1,R4
   \   00000066   0x4618             MOV      R0,R3
   \   00000068   0x.... 0x....      BL       USBH_MSC_BOT_Process
    297              
    298              if(error == USBH_OK)
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD10A             BNE.N    ??USBH_MSC_SCSI_RequestSense_2
    299              {
    300                sense_data->key  = MSC_Handle->hbot.pbuf[2] & 0x0F;  
   \   00000070   0x6BF1             LDR      R1,[R6, #+60]
   \   00000072   0x7889             LDRB     R1,[R1, #+2]
   \   00000074   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000078   0x7039             STRB     R1,[R7, #+0]
    301                sense_data->asc  = MSC_Handle->hbot.pbuf[12];
   \   0000007A   0x6BF1             LDR      R1,[R6, #+60]
   \   0000007C   0x7B09             LDRB     R1,[R1, #+12]
   \   0000007E   0x7079             STRB     R1,[R7, #+1]
    302                sense_data->ascq = MSC_Handle->hbot.pbuf[13];
   \   00000080   0x6BF1             LDR      R1,[R6, #+60]
   \   00000082   0x7B49             LDRB     R1,[R1, #+13]
   \   00000084   0x70B9             STRB     R1,[R7, #+2]
    303              }
    304              break;
    305              
    306            default:
    307              break;
    308            }
    309            
    310            return error;
   \                     ??USBH_MSC_SCSI_RequestSense_2: (+1)
   \   00000086   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    311          }
    312          
    313          /**
    314            * @brief  USBH_MSC_SCSI_Write 
    315            *         Issue write10 command.
    316            * @param  phost: Host handle
    317            * @param  lun: Logical Unit Number
    318            * @param  address: sector address
    319            * @param  pbuf: pointer to data
    320            * @param  length: number of sector to write
    321            * @retval USBH Status
    322            */

   \                                 In section .text, align 2, keep-with-next
    323          USBH_StatusTypeDef USBH_MSC_SCSI_Write(USBH_HandleTypeDef *phost,
    324                                               uint8_t lun,
    325                                               uint32_t address,
    326                                               uint8_t *pbuf,
    327                                               uint32_t length)
    328          {
   \                     USBH_MSC_SCSI_Write: (+1)
   \   00000000   0xB576             PUSH     {R1,R2,R4-R6,LR}
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0x461C             MOV      R4,R3
    329            USBH_StatusTypeDef    error = USBH_FAIL ;
   \   00000006   0x2002             MOVS     R0,#+2
    330          
    331            MSC_HandleTypeDef *MSC_Handle =  (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000008   0xF8D2 0x3374      LDR      R3,[R2, #+884]
   \   0000000C   0x69DD             LDR      R5,[R3, #+28]
    332            
    333            switch(MSC_Handle->hbot.cmd_state)
   \   0000000E   0xF105 0x0650      ADD      R6,R5,#+80
   \   00000012   0xF996 0x3002      LDRSB    R3,[R6, #+2]
   \   00000016   0x2B01             CMP      R3,#+1
   \   00000018   0xD002             BEQ.N    ??USBH_MSC_SCSI_Write_0
   \   0000001A   0x2B02             CMP      R3,#+2
   \   0000001C   0xD029             BEQ.N    ??USBH_MSC_SCSI_Write_1
   \   0000001E   0xBD76             POP      {R1,R2,R4-R6,PC}
    334            {
    335            case BOT_CMD_SEND:  
    336              
    337              /*Prepare the CBW and relevent field*/
    338              MSC_Handle->hbot.cbw.field.DataTransferLength = length * 512;
   \                     ??USBH_MSC_SCSI_Write_0: (+1)
   \   00000020   0x9806             LDR      R0,[SP, #+24]
   \   00000022   0x0240             LSLS     R0,R0,#+9
   \   00000024   0x60F0             STR      R0,[R6, #+12]
    339              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_OUT;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x7430             STRB     R0,[R6, #+16]
    340              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
   \   0000002A   0x200A             MOVS     R0,#+10
   \   0000002C   0x74B0             STRB     R0,[R6, #+18]
    341              
    342              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
   \   0000002E   0x2210             MOVS     R2,#+16
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xF105 0x0063      ADD      R0,R5,#+99
   \   00000036   0x.... 0x....      BL       memset
    343              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_WRITE10; 
   \   0000003A   0x202A             MOVS     R0,#+42
   \   0000003C   0x74F0             STRB     R0,[R6, #+19]
    344              
    345              /*logical block address*/
    346              MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t*)&address)[3]);
   \   0000003E   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   00000042   0x7570             STRB     R0,[R6, #+21]
    347              MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t*)&address)[2]);
   \   00000044   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   00000048   0x75B0             STRB     R0,[R6, #+22]
    348              MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t*)&address)[1]);
   \   0000004A   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000004E   0x75F0             STRB     R0,[R6, #+23]
    349              MSC_Handle->hbot.cbw.field.CB[5]  = (((uint8_t*)&address)[0]);
   \   00000050   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000054   0x7630             STRB     R0,[R6, #+24]
    350              
    351              
    352              /*Transfer length */
    353              MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)&length)[1]) ; 
   \   00000056   0xF89D 0x0019      LDRB     R0,[SP, #+25]
   \   0000005A   0x76B0             STRB     R0,[R6, #+26]
    354              MSC_Handle->hbot.cbw.field.CB[8]  = (((uint8_t *)&length)[0]) ; 
   \   0000005C   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   00000060   0x76F0             STRB     R0,[R6, #+27]
    355          
    356              
    357              MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xF885 0x0050      STRB     R0,[R5, #+80]
    358              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
   \   00000068   0x2002             MOVS     R0,#+2
   \   0000006A   0x70B0             STRB     R0,[R6, #+2]
    359              MSC_Handle->hbot.pbuf = pbuf;
   \   0000006C   0x63F4             STR      R4,[R6, #+60]
    360              error = USBH_BUSY; 
   \   0000006E   0x2001             MOVS     R0,#+1
    361              break;
   \   00000070   0xBD76             POP      {R1,R2,R4-R6,PC}
    362              
    363            case BOT_CMD_WAIT: 
    364              error = USBH_MSC_BOT_Process(phost, lun);
   \                     ??USBH_MSC_SCSI_Write_1: (+1)
   \   00000072   0x4610             MOV      R0,R2
   \   00000074   0xE8BD 0x407C      POP      {R2-R6,LR}
   \   00000078   0x.... 0x....      B.W      USBH_MSC_BOT_Process
    365              break;
    366              
    367            default:
    368              break;
    369            }
    370            
    371            return error;
    372          }
    373          
    374          /**
    375            * @brief  USBH_MSC_SCSI_Read 
    376            *         Issue Read10 command.
    377            * @param  phost: Host handle
    378            * @param  lun: Logical Unit Number
    379            * @param  address: sector address
    380            * @param  pbuf: pointer to data
    381            * @param  length: number of sector to read
    382            * @retval USBH Status
    383            */

   \                                 In section .text, align 2, keep-with-next
    384          USBH_StatusTypeDef USBH_MSC_SCSI_Read(USBH_HandleTypeDef *phost,
    385                                               uint8_t lun,
    386                                               uint32_t address,
    387                                               uint8_t *pbuf,
    388                                               uint32_t length)
    389          {
   \                     USBH_MSC_SCSI_Read: (+1)
   \   00000000   0xB576             PUSH     {R1,R2,R4-R6,LR}
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0x461C             MOV      R4,R3
    390            USBH_StatusTypeDef    error = USBH_FAIL ;
   \   00000006   0x2002             MOVS     R0,#+2
    391            MSC_HandleTypeDef *MSC_Handle = (MSC_HandleTypeDef *) phost->pActiveClass->pData;
   \   00000008   0xF8D2 0x3374      LDR      R3,[R2, #+884]
   \   0000000C   0x69DD             LDR      R5,[R3, #+28]
    392            
    393            switch(MSC_Handle->hbot.cmd_state)
   \   0000000E   0xF105 0x0650      ADD      R6,R5,#+80
   \   00000012   0xF996 0x3002      LDRSB    R3,[R6, #+2]
   \   00000016   0x2B01             CMP      R3,#+1
   \   00000018   0xD002             BEQ.N    ??USBH_MSC_SCSI_Read_0
   \   0000001A   0x2B02             CMP      R3,#+2
   \   0000001C   0xD029             BEQ.N    ??USBH_MSC_SCSI_Read_1
   \   0000001E   0xBD76             POP      {R1,R2,R4-R6,PC}
    394            {
    395            case BOT_CMD_SEND:  
    396              
    397              /*Prepare the CBW and relevent field*/
    398              MSC_Handle->hbot.cbw.field.DataTransferLength = length * 512;
   \                     ??USBH_MSC_SCSI_Read_0: (+1)
   \   00000020   0x9806             LDR      R0,[SP, #+24]
   \   00000022   0x0240             LSLS     R0,R0,#+9
   \   00000024   0x60F0             STR      R0,[R6, #+12]
    399              MSC_Handle->hbot.cbw.field.Flags = USB_EP_DIR_IN;
   \   00000026   0x2080             MOVS     R0,#+128
   \   00000028   0x7430             STRB     R0,[R6, #+16]
    400              MSC_Handle->hbot.cbw.field.CBLength = CBW_LENGTH;
   \   0000002A   0x200A             MOVS     R0,#+10
   \   0000002C   0x74B0             STRB     R0,[R6, #+18]
    401              
    402              USBH_memset(MSC_Handle->hbot.cbw.field.CB, 0, CBW_CB_LENGTH);
   \   0000002E   0x2210             MOVS     R2,#+16
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xF105 0x0063      ADD      R0,R5,#+99
   \   00000036   0x.... 0x....      BL       memset
    403              MSC_Handle->hbot.cbw.field.CB[0]  = OPCODE_READ10; 
   \   0000003A   0x2028             MOVS     R0,#+40
   \   0000003C   0x74F0             STRB     R0,[R6, #+19]
    404              
    405              /*logical block address*/
    406              MSC_Handle->hbot.cbw.field.CB[2]  = (((uint8_t*)&address)[3]);
   \   0000003E   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   00000042   0x7570             STRB     R0,[R6, #+21]
    407              MSC_Handle->hbot.cbw.field.CB[3]  = (((uint8_t*)&address)[2]);
   \   00000044   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   00000048   0x75B0             STRB     R0,[R6, #+22]
    408              MSC_Handle->hbot.cbw.field.CB[4]  = (((uint8_t*)&address)[1]);
   \   0000004A   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000004E   0x75F0             STRB     R0,[R6, #+23]
    409              MSC_Handle->hbot.cbw.field.CB[5]  = (((uint8_t*)&address)[0]);
   \   00000050   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000054   0x7630             STRB     R0,[R6, #+24]
    410              
    411              
    412              /*Transfer length */
    413              MSC_Handle->hbot.cbw.field.CB[7]  = (((uint8_t *)&length)[1]) ; 
   \   00000056   0xF89D 0x0019      LDRB     R0,[SP, #+25]
   \   0000005A   0x76B0             STRB     R0,[R6, #+26]
    414              MSC_Handle->hbot.cbw.field.CB[8]  = (((uint8_t *)&length)[0]) ; 
   \   0000005C   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   00000060   0x76F0             STRB     R0,[R6, #+27]
    415          
    416              
    417              MSC_Handle->hbot.state = BOT_SEND_CBW;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xF885 0x0050      STRB     R0,[R5, #+80]
    418              MSC_Handle->hbot.cmd_state = BOT_CMD_WAIT;
   \   00000068   0x2002             MOVS     R0,#+2
   \   0000006A   0x70B0             STRB     R0,[R6, #+2]
    419              MSC_Handle->hbot.pbuf = pbuf;
   \   0000006C   0x63F4             STR      R4,[R6, #+60]
    420              error = USBH_BUSY; 
   \   0000006E   0x2001             MOVS     R0,#+1
    421              break;
   \   00000070   0xBD76             POP      {R1,R2,R4-R6,PC}
    422              
    423            case BOT_CMD_WAIT: 
    424              error = USBH_MSC_BOT_Process(phost, lun);
   \                     ??USBH_MSC_SCSI_Read_1: (+1)
   \   00000072   0x4610             MOV      R0,R2
   \   00000074   0xE8BD 0x407C      POP      {R2-R6,LR}
   \   00000078   0x.... 0x....      B.W      USBH_MSC_BOT_Process
    425              break;
    426              
    427            default:
    428              break;
    429            }
    430            
    431            return error;
    432          }
    433          
    434          
    435          /**
    436            * @}
    437            */ 
    438          
    439          /**
    440            * @}
    441            */ 
    442          
    443          /**
    444            * @}
    445            */
    446          
    447          /**
    448            * @}
    449            */ 
    450          
    451          /**
    452            * @}
    453            */
    454          
    455          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    456          
    457          
    458          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   USBH_MSC_SCSI_Inquiry
        24   -> USBH_MSC_BOT_Process
        24   -> memcpy
        24   -> memset
      24   USBH_MSC_SCSI_Read
         0   -> USBH_MSC_BOT_Process
        24   -> memset
      24   USBH_MSC_SCSI_ReadCapacity
        24   -> USBH_MSC_BOT_Process
        24   -> memset
      24   USBH_MSC_SCSI_RequestSense
        24   -> USBH_MSC_BOT_Process
        24   -> memset
      16   USBH_MSC_SCSI_TestUnitReady
         0   -> USBH_MSC_BOT_Process
        16   -> memset
      24   USBH_MSC_SCSI_Write
         0   -> USBH_MSC_BOT_Process
        24   -> memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     206  USBH_MSC_SCSI_Inquiry
     124  USBH_MSC_SCSI_Read
     124  USBH_MSC_SCSI_ReadCapacity
     136  USBH_MSC_SCSI_RequestSense
      80  USBH_MSC_SCSI_TestUnitReady
     124  USBH_MSC_SCSI_Write

 
 794 bytes in section .text
 
 794 bytes of CODE memory

Errors: none
Warnings: none
