###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:22
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_uart.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_uart.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\stm32f4xx_hal_uart.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\stm32f4xx_hal_uart.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_uart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_uart.c
      4            * @author  MCD Application Team
      5            * @version V1.5.2
      6            * @date    22-September-2016
      7            * @brief   UART HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Universal Asynchronous Receiver Transmitter (UART) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions  
     13            *           + Peripheral State and Errors functions  
     14            *           
     15            @verbatim       
     16            ==============================================================================
     17                                  ##### How to use this driver #####
     18            ==============================================================================
     19            [..]
     20              The UART HAL driver can be used as follows:
     21              
     22              (#) Declare a UART_HandleTypeDef handle structure.
     23            
     24              (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:
     25                  (##) Enable the USARTx interface clock.
     26                  (##) UART pins configuration:
     27                      (+++) Enable the clock for the UART GPIOs.
     28                      (+++) Configure these UART pins as alternate function pull-up.
     29                  (##) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()
     30                       and HAL_UART_Receive_IT() APIs):
     31                      (+++) Configure the USARTx interrupt priority.
     32                      (+++) Enable the NVIC USART IRQ handle.
     33                  (##) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()
     34                       and HAL_UART_Receive_DMA() APIs):
     35                      (+++) Declare a DMA handle structure for the Tx/Rx stream.
     36                      (+++) Enable the DMAx interface clock.
     37                      (+++) Configure the declared DMA handle structure with the required 
     38                            Tx/Rx parameters.                
     39                      (+++) Configure the DMA Tx/Rx Stream.
     40                      (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.
     41                      (+++) Configure the priority and enable the NVIC for the transfer complete 
     42                            interrupt on the DMA Tx/Rx Stream.
     43          
     44              (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware 
     45                  flow control and Mode(Receiver/Transmitter) in the Init structure.
     46          
     47              (#) For the UART asynchronous mode, initialize the UART registers by calling
     48                  the HAL_UART_Init() API.
     49              
     50              (#) For the UART Half duplex mode, initialize the UART registers by calling 
     51                  the HAL_HalfDuplex_Init() API.
     52              
     53              (#) For the LIN mode, initialize the UART registers by calling the HAL_LIN_Init() API.
     54              
     55              (#) For the Multi-Processor mode, initialize the UART registers by calling 
     56                  the HAL_MultiProcessor_Init() API.
     57                  
     58               [..] 
     59                 (@) The specific UART interrupts (Transmission complete interrupt, 
     60                      RXNE interrupt and Error Interrupts) will be managed using the macros
     61                      __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT() inside the transmit 
     62                      and receive process.
     63                    
     64               [..] 
     65                 (@) These APIs (HAL_UART_Init() and HAL_HalfDuplex_Init()) configure also the 
     66                      low level Hardware GPIO, CLOCK, CORTEX...etc) by calling the customized 
     67                      HAL_UART_MspInit() API.
     68                    
     69               [..] 
     70                  Three operation modes are available within this driver :     
     71            
     72               *** Polling mode IO operation ***
     73               =================================
     74               [..]    
     75                 (+) Send an amount of data in blocking mode using HAL_UART_Transmit() 
     76                 (+) Receive an amount of data in blocking mode using HAL_UART_Receive()
     77                 
     78               *** Interrupt mode IO operation ***    
     79               ===================================
     80               [..]    
     81                 (+) Send an amount of data in non blocking mode using HAL_UART_Transmit_IT() 
     82                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     83                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     84                 (+) Receive an amount of data in non blocking mode using HAL_UART_Receive_IT() 
     85                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
     86                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
     87                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
     88                      add his own code by customization of function pointer HAL_UART_ErrorCallback
     89          
     90               *** DMA mode IO operation ***    
     91               ==============================
     92               [..] 
     93                 (+) Send an amount of data in non blocking mode (DMA) using HAL_UART_Transmit_DMA() 
     94                 (+) At transmission end of half transfer HAL_UART_TxHalfCpltCallback is executed and user can 
     95                      add his own code by customization of function pointer HAL_UART_TxHalfCpltCallback 
     96                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     97                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     98                 (+) Receive an amount of data in non blocking mode (DMA) using HAL_UART_Receive_DMA() 
     99                 (+) At reception end of half transfer HAL_UART_RxHalfCpltCallback is executed and user can 
    100                      add his own code by customization of function pointer HAL_UART_RxHalfCpltCallback 
    101                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
    102                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
    103                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
    104                      add his own code by customization of function pointer HAL_UART_ErrorCallback
    105                 (+) Pause the DMA Transfer using HAL_UART_DMAPause()      
    106                 (+) Resume the DMA Transfer using HAL_UART_DMAResume()  
    107                 (+) Stop the DMA Transfer using HAL_UART_DMAStop()      
    108              
    109               *** UART HAL driver macros list ***
    110               ============================================= 
    111               [..]
    112                 Below the list of most used macros in UART HAL driver.
    113                 
    114                (+) __HAL_UART_ENABLE: Enable the UART peripheral 
    115                (+) __HAL_UART_DISABLE: Disable the UART peripheral     
    116                (+) __HAL_UART_GET_FLAG : Check whether the specified UART flag is set or not
    117                (+) __HAL_UART_CLEAR_FLAG : Clear the specified UART pending flag
    118                (+) __HAL_UART_ENABLE_IT: Enable the specified UART interrupt
    119                (+) __HAL_UART_DISABLE_IT: Disable the specified UART interrupt
    120                (+) __HAL_UART_GET_IT_SOURCE: Check whether the specified UART interrupt has occurred or not
    121                
    122               [..] 
    123                 (@) You can refer to the UART HAL driver header file for more useful macros 
    124                
    125            @endverbatim
    126            ******************************************************************************
    127            * @attention
    128            *
    129            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    130            *
    131            * Redistribution and use in source and binary forms, with or without modification,
    132            * are permitted provided that the following conditions are met:
    133            *   1. Redistributions of source code must retain the above copyright notice,
    134            *      this list of conditions and the following disclaimer.
    135            *   2. Redistributions in binary form must reproduce the above copyright notice,
    136            *      this list of conditions and the following disclaimer in the documentation
    137            *      and/or other materials provided with the distribution.
    138            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    139            *      may be used to endorse or promote products derived from this software
    140            *      without specific prior written permission.
    141            *
    142            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    143            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    144            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    145            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    146            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    147            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    148            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    149            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    150            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    151            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    152            *
    153            ******************************************************************************
    154            */ 
    155          
    156          /* Includes ------------------------------------------------------------------*/
    157          #include "stm32f4xx_hal.h"
    158          
    159          /** @addtogroup STM32F4xx_HAL_Driver
    160            * @{
    161            */
    162          
    163          /** @defgroup UART UART
    164            * @brief HAL UART module driver
    165            * @{
    166            */
    167          #ifdef HAL_UART_MODULE_ENABLED
    168              
    169          /* Private typedef -----------------------------------------------------------*/
    170          /* Private define ------------------------------------------------------------*/
    171          /** @addtogroup UART_Private_Constants
    172            * @{
    173            */
    174          /**
    175            * @}
    176            */
    177          /* Private macro -------------------------------------------------------------*/
    178          /* Private variables ---------------------------------------------------------*/
    179          /* Private function prototypes -----------------------------------------------*/
    180          /** @addtogroup UART_Private_Functions   UART Private Functions
    181            * @{
    182            */
    183          static void UART_EndTxTransfer(UART_HandleTypeDef *huart);
    184          static void UART_EndRxTransfer(UART_HandleTypeDef *huart);
    185          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    186          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    187          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    188          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    189          static void UART_DMAError(DMA_HandleTypeDef *hdma); 
    190          static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma);
    191          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart);
    192          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart);
    193          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart);
    194          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout);
    195          static void UART_SetConfig (UART_HandleTypeDef *huart);
    196          /**
    197            * @}
    198            */
    199          
    200          /* Exported functions ---------------------------------------------------------*/
    201          /** @defgroup UART_Exported_Functions UART Exported Functions
    202            * @{
    203            */
    204          
    205          /** @defgroup UART_Exported_Functions_Group1 Initialization and de-initialization functions 
    206            *  @brief    Initialization and Configuration functions 
    207            *
    208          @verbatim    
    209          ===============================================================================
    210                      ##### Initialization and Configuration functions #####
    211           ===============================================================================  
    212              [..]
    213              This subsection provides a set of functions allowing to initialize the USARTx or the UARTy 
    214              in asynchronous mode.
    215                (+) For the asynchronous mode only these parameters can be configured: 
    216                  (++) Baud Rate
    217                  (++) Word Length 
    218                  (++) Stop Bit
    219                  (++) Parity: If the parity is enabled, then the MSB bit of the data written
    220                       in the data register is transmitted but is changed by the parity bit.
    221                       Depending on the frame length defined by the M bit (8-bits or 9-bits),
    222                       please refer to Reference manual for possible UART frame formats.           
    223                  (++) Hardware flow control
    224                  (++) Receiver/transmitter modes
    225                  (++) Over Sampling Method
    226              [..]
    227              The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init() and HAL_MultiProcessor_Init() APIs 
    228              follow respectively the UART asynchronous, UART Half duplex, LIN and Multi-Processor
    229              configuration procedures (details for the procedures are available in reference manual (RM0329)).
    230          
    231          @endverbatim
    232            * @{
    233            */
    234          
    235          /**
    236            * @brief  Initializes the UART mode according to the specified parameters in
    237            *         the UART_InitTypeDef and create the associated handle.
    238            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
    239            *                the configuration information for the specified UART module.
    240            * @retval HAL status
    241            */

   \                                 In section .text, align 2, keep-with-next
    242          HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
    243          {
   \                     HAL_UART_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    244            /* Check the UART handle allocation */
    245            if(huart == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_UART_Init_0
    246            {
    247              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    248            }
    249          
    250            /* Check the parameters */
    251            if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
    252            { 
    253              /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
    254              assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
    255              assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
    256            }
    257            else
    258            {
    259              assert_param(IS_UART_INSTANCE(huart->Instance));
    260            }
    261            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    262            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    263            
    264            if(huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_UART_Init_0: (+1)
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE.N    ??HAL_UART_Init_1
    265            {  
    266              /* Allocate lock resource and initialize it */
    267              huart->Lock = HAL_UNLOCKED;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF884 0x0038      STRB     R0,[R4, #+56]
    268              /* Init the low level hardware */
    269              HAL_UART_MspInit(huart);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_UART_MspInit
    270            }
    271          
    272            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_Init_1: (+1)
   \   0000001E   0x2024             MOVS     R0,#+36
   \   00000020   0xF884 0x0039      STRB     R0,[R4, #+57]
    273          
    274            /* Disable the peripheral */
    275            __HAL_UART_DISABLE(huart);
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x68C1             LDR      R1,[R0, #+12]
   \   00000028   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   0000002C   0x60C1             STR      R1,[R0, #+12]
    276            
    277            /* Set the UART Communication parameters */
    278            UART_SetConfig(huart);
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       UART_SetConfig
    279            
    280            /* In asynchronous mode, the following bits must be kept cleared: 
    281               - LINEN and CLKEN bits in the USART_CR2 register,
    282               - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
    283            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6901             LDR      R1,[R0, #+16]
   \   00000038   0xF421 0x4190      BIC      R1,R1,#0x4800
   \   0000003C   0x6101             STR      R1,[R0, #+16]
    284            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6941             LDR      R1,[R0, #+20]
   \   00000042   0xF021 0x012A      BIC      R1,R1,#0x2A
   \   00000046   0x6141             STR      R1,[R0, #+20]
    285            
    286            /* Enable the peripheral */
    287            __HAL_UART_ENABLE(huart);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x68C1             LDR      R1,[R0, #+12]
   \   0000004C   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000050   0x60C1             STR      R1,[R0, #+12]
    288            
    289            /* Initialize the UART state */
    290            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x63E0             STR      R0,[R4, #+60]
    291            huart->gState= HAL_UART_STATE_READY;
   \   00000056   0x2020             MOVS     R0,#+32
   \   00000058   0xF884 0x0039      STRB     R0,[R4, #+57]
    292            huart->RxState= HAL_UART_STATE_READY;
   \   0000005C   0xF884 0x003A      STRB     R0,[R4, #+58]
    293            
    294            return HAL_OK;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
    295          }
    296          
    297          /**
    298            * @brief  Initializes the half-duplex mode according to the specified
    299            *         parameters in the UART_InitTypeDef and create the associated handle.
    300            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
    301            *                the configuration information for the specified UART module.
    302            * @retval HAL status
    303            */

   \                                 In section .text, align 2, keep-with-next
    304          HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
    305          {
   \                     HAL_HalfDuplex_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    306            /* Check the UART handle allocation */
    307            if(huart == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_HalfDuplex_Init_0
    308            {
    309              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    310            }
    311           
    312            /* Check the parameters */ 
    313            assert_param(IS_UART_INSTANCE(huart->Instance));
    314            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    315            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    316          
    317            if(huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_HalfDuplex_Init_0: (+1)
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE.N    ??HAL_HalfDuplex_Init_1
    318            { 
    319              /* Allocate lock resource and initialize it */
    320              huart->Lock = HAL_UNLOCKED;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF884 0x0038      STRB     R0,[R4, #+56]
    321              /* Init the low level hardware */
    322              HAL_UART_MspInit(huart);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_UART_MspInit
    323            }
    324          
    325            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_HalfDuplex_Init_1: (+1)
   \   0000001E   0x2024             MOVS     R0,#+36
   \   00000020   0xF884 0x0039      STRB     R0,[R4, #+57]
    326          
    327            /* Disable the peripheral */
    328            __HAL_UART_DISABLE(huart);
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x68C1             LDR      R1,[R0, #+12]
   \   00000028   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   0000002C   0x60C1             STR      R1,[R0, #+12]
    329            
    330            /* Set the UART Communication parameters */
    331            UART_SetConfig(huart);
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       UART_SetConfig
    332            
    333            /* In half-duplex mode, the following bits must be kept cleared: 
    334               - LINEN and CLKEN bits in the USART_CR2 register,
    335               - SCEN and IREN bits in the USART_CR3 register.*/
    336            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6901             LDR      R1,[R0, #+16]
   \   00000038   0xF421 0x4190      BIC      R1,R1,#0x4800
   \   0000003C   0x6101             STR      R1,[R0, #+16]
    337            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6941             LDR      R1,[R0, #+20]
   \   00000042   0xF021 0x0122      BIC      R1,R1,#0x22
   \   00000046   0x6141             STR      R1,[R0, #+20]
    338            
    339            /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    340            SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6941             LDR      R1,[R0, #+20]
   \   0000004C   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000050   0x6141             STR      R1,[R0, #+20]
    341           
    342            /* Enable the peripheral */
    343            __HAL_UART_ENABLE(huart);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C1             LDR      R1,[R0, #+12]
   \   00000056   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000005A   0x60C1             STR      R1,[R0, #+12]
    344            
    345            /* Initialize the UART state*/
    346            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x63E0             STR      R0,[R4, #+60]
    347            huart->gState= HAL_UART_STATE_READY;
   \   00000060   0x2020             MOVS     R0,#+32
   \   00000062   0xF884 0x0039      STRB     R0,[R4, #+57]
    348            huart->RxState= HAL_UART_STATE_READY;
   \   00000066   0xF884 0x003A      STRB     R0,[R4, #+58]
    349            
    350            return HAL_OK;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
    351          }
    352          
    353          /**
    354            * @brief  Initializes the LIN mode according to the specified
    355            *         parameters in the UART_InitTypeDef and create the associated handle.
    356            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
    357            *                the configuration information for the specified UART module.
    358            * @param  BreakDetectLength: Specifies the LIN break detection length.
    359            *         This parameter can be one of the following values:
    360            *            @arg UART_LINBREAKDETECTLENGTH_10B: 10-bit break detection
    361            *            @arg UART_LINBREAKDETECTLENGTH_11B: 11-bit break detection
    362            * @retval HAL status
    363            */

   \                                 In section .text, align 2, keep-with-next
    364          HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
    365          {
   \                     HAL_LIN_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    366            /* Check the UART handle allocation */
    367            if(huart == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_LIN_Init_0
    368            {
    369              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
    370            }
    371             
    372            /* Check the parameters */
    373            assert_param(IS_UART_INSTANCE(huart->Instance));
    374            assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
    375            assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
    376            assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
    377            
    378            if(huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_LIN_Init_0: (+1)
   \   0000000E   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD105             BNE.N    ??HAL_LIN_Init_1
    379            {
    380              /* Allocate lock resource and initialize it */
    381              huart->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x0038      STRB     R0,[R4, #+56]
    382              /* Init the low level hardware */
    383              HAL_UART_MspInit(huart);
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_UART_MspInit
    384            }
    385          
    386            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_LIN_Init_1: (+1)
   \   00000022   0x2024             MOVS     R0,#+36
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
    387          
    388            /* Disable the peripheral */
    389            __HAL_UART_DISABLE(huart);
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C1             LDR      R1,[R0, #+12]
   \   0000002C   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   00000030   0x60C1             STR      R1,[R0, #+12]
    390            
    391            /* Set the UART Communication parameters */
    392            UART_SetConfig(huart);
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       UART_SetConfig
    393            
    394            /* In LIN mode, the following bits must be kept cleared: 
    395               - LINEN and CLKEN bits in the USART_CR2 register,
    396               - SCEN and IREN bits in the USART_CR3 register.*/
    397            CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6901             LDR      R1,[R0, #+16]
   \   0000003C   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000040   0x6101             STR      R1,[R0, #+16]
    398            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6941             LDR      R1,[R0, #+20]
   \   00000046   0xF021 0x012A      BIC      R1,R1,#0x2A
   \   0000004A   0x6141             STR      R1,[R0, #+20]
    399            
    400            /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    401            SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6901             LDR      R1,[R0, #+16]
   \   00000050   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000054   0x6101             STR      R1,[R0, #+16]
    402            
    403            /* Set the USART LIN Break detection length. */
    404            CLEAR_BIT(huart->Instance->CR2, USART_CR2_LBDL);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6901             LDR      R1,[R0, #+16]
   \   0000005A   0xF021 0x0120      BIC      R1,R1,#0x20
   \   0000005E   0x6101             STR      R1,[R0, #+16]
    405            SET_BIT(huart->Instance->CR2, BreakDetectLength);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6901             LDR      R1,[R0, #+16]
   \   00000064   0x4329             ORRS     R1,R5,R1
   \   00000066   0x6101             STR      R1,[R0, #+16]
    406            
    407            /* Enable the peripheral */
    408            __HAL_UART_ENABLE(huart);
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x68C1             LDR      R1,[R0, #+12]
   \   0000006C   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000070   0x60C1             STR      R1,[R0, #+12]
    409            
    410            /* Initialize the UART state*/
    411            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x63E0             STR      R0,[R4, #+60]
    412            huart->gState= HAL_UART_STATE_READY;
   \   00000076   0x2020             MOVS     R0,#+32
   \   00000078   0xF884 0x0039      STRB     R0,[R4, #+57]
    413            huart->RxState= HAL_UART_STATE_READY;
   \   0000007C   0xF884 0x003A      STRB     R0,[R4, #+58]
    414            
    415            return HAL_OK;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    416          }
    417          
    418          /**
    419            * @brief  Initializes the Multi-Processor mode according to the specified
    420            *         parameters in the UART_InitTypeDef and create the associated handle.
    421            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
    422            *                the configuration information for the specified UART module.
    423            * @param  Address: USART address
    424            * @param  WakeUpMethod: specifies the USART wake-up method.
    425            *          This parameter can be one of the following values:
    426            *            @arg UART_WAKEUPMETHOD_IDLELINE: Wake-up by an idle line detection
    427            *            @arg UART_WAKEUPMETHOD_ADDRESSMARK: Wake-up by an address mark
    428            * @retval HAL status
    429            */

   \                                 In section .text, align 2, keep-with-next
    430          HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
    431          {
   \                     HAL_MultiProcessor_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
    432            /* Check the UART handle allocation */
    433            if(huart == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_MultiProcessor_Init_0
    434            {
    435              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD70             POP      {R4-R6,PC}
    436            }
    437          
    438            /* Check the parameters */
    439            assert_param(IS_UART_INSTANCE(huart->Instance));
    440            assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
    441            assert_param(IS_UART_ADDRESS(Address));
    442            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    443            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    444          
    445            if(huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_MultiProcessor_Init_0: (+1)
   \   00000010   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE.N    ??HAL_MultiProcessor_Init_1
    446            {
    447              /* Allocate lock resource and initialize it */
    448              huart->Lock = HAL_UNLOCKED;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x0038      STRB     R0,[R4, #+56]
    449              /* Init the low level hardware */
    450              HAL_UART_MspInit(huart);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       HAL_UART_MspInit
    451            }
    452          
    453            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_MultiProcessor_Init_1: (+1)
   \   00000024   0x2024             MOVS     R0,#+36
   \   00000026   0xF884 0x0039      STRB     R0,[R4, #+57]
    454          
    455            /* Disable the peripheral */
    456            __HAL_UART_DISABLE(huart);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x68C1             LDR      R1,[R0, #+12]
   \   0000002E   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   00000032   0x60C1             STR      R1,[R0, #+12]
    457            
    458            /* Set the UART Communication parameters */
    459            UART_SetConfig(huart);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       UART_SetConfig
    460            
    461            /* In Multi-Processor mode, the following bits must be kept cleared: 
    462               - LINEN and CLKEN bits in the USART_CR2 register,
    463               - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
    464            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6901             LDR      R1,[R0, #+16]
   \   0000003E   0xF421 0x4190      BIC      R1,R1,#0x4800
   \   00000042   0x6101             STR      R1,[R0, #+16]
    465            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6941             LDR      R1,[R0, #+20]
   \   00000048   0xF021 0x012A      BIC      R1,R1,#0x2A
   \   0000004C   0x6141             STR      R1,[R0, #+20]
    466            
    467            /* Clear the USART address */
    468            CLEAR_BIT(huart->Instance->CR2, USART_CR2_ADD);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6901             LDR      R1,[R0, #+16]
   \   00000052   0x0909             LSRS     R1,R1,#+4
   \   00000054   0x0109             LSLS     R1,R1,#+4
   \   00000056   0x6101             STR      R1,[R0, #+16]
    469            /* Set the USART address node */
    470            SET_BIT(huart->Instance->CR2, Address);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6901             LDR      R1,[R0, #+16]
   \   0000005C   0x4331             ORRS     R1,R6,R1
   \   0000005E   0x6101             STR      R1,[R0, #+16]
    471            
    472            /* Set the wake up method by setting the WAKE bit in the CR1 register */
    473            CLEAR_BIT(huart->Instance->CR1, USART_CR1_WAKE);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x68C1             LDR      R1,[R0, #+12]
   \   00000064   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000068   0x60C1             STR      R1,[R0, #+12]
    474            SET_BIT(huart->Instance->CR1, WakeUpMethod);
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x68C1             LDR      R1,[R0, #+12]
   \   0000006E   0x4329             ORRS     R1,R5,R1
   \   00000070   0x60C1             STR      R1,[R0, #+12]
    475            
    476            /* Enable the peripheral */
    477            __HAL_UART_ENABLE(huart);
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x68C1             LDR      R1,[R0, #+12]
   \   00000076   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000007A   0x60C1             STR      R1,[R0, #+12]
    478            
    479            /* Initialize the UART state */
    480            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x63E0             STR      R0,[R4, #+60]
    481            huart->gState= HAL_UART_STATE_READY;
   \   00000080   0x2020             MOVS     R0,#+32
   \   00000082   0xF884 0x0039      STRB     R0,[R4, #+57]
    482            huart->RxState= HAL_UART_STATE_READY;
   \   00000086   0xF884 0x003A      STRB     R0,[R4, #+58]
    483            
    484            return HAL_OK;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xBD70             POP      {R4-R6,PC}       ;; return
    485          }
    486          
    487          /**
    488            * @brief  DeInitializes the UART peripheral. 
    489            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
    490            *                the configuration information for the specified UART module.
    491            * @retval HAL status
    492            */

   \                                 In section .text, align 2, keep-with-next
    493          HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
    494          {
   \                     HAL_UART_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    495            /* Check the UART handle allocation */
    496            if(huart == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_UART_DeInit_0
    497            {
    498              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    499            }
    500            
    501            /* Check the parameters */
    502            assert_param(IS_UART_INSTANCE(huart->Instance));
    503          
    504            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_DeInit_0: (+1)
   \   0000000A   0x2024             MOVS     R0,#+36
   \   0000000C   0xF884 0x0039      STRB     R0,[R4, #+57]
    505          	
    506            /* Disable the Peripheral */
    507            __HAL_UART_DISABLE(huart); 
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x68C1             LDR      R1,[R0, #+12]
   \   00000014   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   00000018   0x60C1             STR      R1,[R0, #+12]
    508          	
    509            huart->Instance->CR1 = 0x0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0x60C8             STR      R0,[R1, #+12]
    510            huart->Instance->CR2 = 0x0;
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x6108             STR      R0,[R1, #+16]
    511            huart->Instance->CR3 = 0x0;
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6148             STR      R0,[R1, #+20]
    512          
    513          	
    514            /* DeInit the low level hardware */
    515            HAL_UART_MspDeInit(huart);
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_UART_MspDeInit
    516            
    517            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x63E0             STR      R0,[R4, #+60]
    518            huart->gState = HAL_UART_STATE_RESET;
   \   00000032   0xF884 0x0039      STRB     R0,[R4, #+57]
    519            huart->RxState = HAL_UART_STATE_RESET;
   \   00000036   0xF884 0x003A      STRB     R0,[R4, #+58]
    520          
    521            /* Process Lock */
    522            __HAL_UNLOCK(huart);
   \   0000003A   0xF884 0x0038      STRB     R0,[R4, #+56]
    523          
    524            return HAL_OK;
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    525          }
    526          
    527          /**
    528            * @brief  UART MSP Init.
    529            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
    530            *                the configuration information for the specified UART module.
    531            * @retval None
    532            */

   \                                 In section .text, align 2, keep-with-next
    533           __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
    534          {
    535             /* Prevent unused argument(s) compilation warning */
    536            UNUSED(huart);
    537            /* NOTE: This function Should not be modified, when the callback is needed,
    538                     the HAL_UART_MspInit could be implemented in the user file
    539             */ 
    540          }
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    541          
    542          /**
    543            * @brief  UART MSP DeInit.
    544            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
    545            *                the configuration information for the specified UART module.
    546            * @retval None
    547            */

   \                                 In section .text, align 2, keep-with-next
    548           __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
    549          {
    550            /* Prevent unused argument(s) compilation warning */
    551            UNUSED(huart);
    552            /* NOTE: This function Should not be modified, when the callback is needed,
    553                     the HAL_UART_MspDeInit could be implemented in the user file
    554             */ 
    555          }
   \                     HAL_UART_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    556          
    557          /**
    558            * @}
    559            */
    560          
    561          /** @defgroup UART_Exported_Functions_Group2 IO operation functions 
    562            *  @brief UART Transmit and Receive functions 
    563            *
    564          @verbatim   
    565            ==============================================================================
    566                                ##### IO operation functions #####
    567            ==============================================================================  
    568            [..]
    569              This subsection provides a set of functions allowing to manage the UART asynchronous
    570              and Half duplex data transfers.
    571          
    572              (#) There are two modes of transfer:
    573                 (++) Blocking mode: The communication is performed in polling mode. 
    574                      The HAL status of all data processing is returned by the same function 
    575                      after finishing transfer.  
    576                 (++) Non blocking mode: The communication is performed using Interrupts 
    577                      or DMA, these APIs return the HAL status.
    578                      The end of the data processing will be indicated through the 
    579                      dedicated UART IRQ when using Interrupt mode or the DMA IRQ when 
    580                      using DMA mode.
    581                      The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks 
    582                      will be executed respectively at the end of the transmit or receive process.
    583                      The HAL_UART_ErrorCallback() user callback will be executed when 
    584                      a communication error is detected.
    585          
    586              (#) Blocking mode APIs are:
    587                  (++) HAL_UART_Transmit()
    588                  (++) HAL_UART_Receive() 
    589                  
    590              (#) Non Blocking mode APIs with Interrupt are:
    591                  (++) HAL_UART_Transmit_IT()
    592                  (++) HAL_UART_Receive_IT()
    593                  (++) HAL_UART_IRQHandler()
    594          
    595              (#) Non Blocking mode functions with DMA are:
    596                  (++) HAL_UART_Transmit_DMA()
    597                  (++) HAL_UART_Receive_DMA()
    598          
    599              (#) A set of Transfer Complete Callbacks are provided in non blocking mode:
    600                  (++) HAL_UART_TxCpltCallback()
    601                  (++) HAL_UART_RxCpltCallback()
    602                  (++) HAL_UART_ErrorCallback()
    603          
    604              [..] 
    605                (@) In the Half duplex communication, it is forbidden to run the transmit 
    606                    and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX 
    607                    can't be useful.
    608                
    609          @endverbatim
    610            * @{
    611            */
    612          
    613          /**
    614            * @brief  Sends an amount of data in blocking mode. 
    615            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
    616            *                the configuration information for the specified UART module.
    617            * @param  pData: Pointer to data buffer
    618            * @param  Size: Amount of data to be sent
    619            * @param  Timeout: Timeout duration  
    620            * @retval HAL status
    621            */

   \                                 In section .text, align 2, keep-with-next
    622          HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    623          {
   \                     HAL_UART_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
    624            uint16_t* tmp;
    625            uint32_t tickstart = 0U;
    626            
    627            /* Check that a Tx process is not already ongoing */
    628            if(huart->gState == HAL_UART_STATE_READY) 
   \   0000000E   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000012   0x2820             CMP      R0,#+32
   \   00000014   0xD157             BNE.N    ??HAL_UART_Transmit_0
    629            {
    630              if((pData == NULL ) || (Size == 0U)) 
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD001             BEQ.N    ??HAL_UART_Transmit_1
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_UART_Transmit_2
    631              {
    632                return  HAL_ERROR;
   \                     ??HAL_UART_Transmit_1: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE052             B.N      ??HAL_UART_Transmit_3
    633              }
    634              
    635              /* Process Locked */
    636              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_2: (+1)
   \   00000022   0xF994 0x0038      LDRSB    R0,[R4, #+56]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD04D             BEQ.N    ??HAL_UART_Transmit_0
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF884 0x0038      STRB     R0,[R4, #+56]
    637              
    638              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x63E0             STR      R0,[R4, #+60]
    639              huart->gState = HAL_UART_STATE_BUSY_TX;
   \   00000034   0x2021             MOVS     R0,#+33
   \   00000036   0xF884 0x0039      STRB     R0,[R4, #+57]
    640          	
    641              /* Init tickstart for timeout managment */
    642              tickstart = HAL_GetTick();
   \   0000003A   0x.... 0x....      BL       HAL_GetTick
   \   0000003E   0x4680             MOV      R8,R0
    643          
    644              huart->TxXferSize = Size;
   \   00000040   0x84A6             STRH     R6,[R4, #+36]
    645              huart->TxXferCount = Size;
   \   00000042   0x84E6             STRH     R6,[R4, #+38]
   \   00000044   0xE003             B.N      ??HAL_UART_Transmit_4
    646              while(huart->TxXferCount > 0U)
    647              {
    648                huart->TxXferCount--;
    649                if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    650                {
    651                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
    652                  { 
    653                    return HAL_TIMEOUT;
    654                  }
    655                  tmp = (uint16_t*) pData;
    656                  huart->Instance->DR = (*tmp & (uint16_t)0x01FFU);
    657                  if(huart->Init.Parity == UART_PARITY_NONE)
    658                  {
    659                    pData +=2U;
    660                  }
    661                  else
    662                  { 
    663                    pData +=1U;
    664                  }
    665                } 
    666                else
    667                {
    668                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
    669                  {
    670                    return HAL_TIMEOUT;
    671                  }
    672                  huart->Instance->DR = (*pData++ & (uint8_t)0xFFU);
   \                     ??HAL_UART_Transmit_5: (+1)
   \   00000046   0xF815 0x0B01      LDRB     R0,[R5], #+1
   \   0000004A   0x6821             LDR      R1,[R4, #+0]
   \   0000004C   0x6048             STR      R0,[R1, #+4]
   \                     ??HAL_UART_Transmit_4: (+1)
   \   0000004E   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD026             BEQ.N    ??HAL_UART_Transmit_6
   \   00000054   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000056   0x1E40             SUBS     R0,R0,#+1
   \   00000058   0x84E0             STRH     R0,[R4, #+38]
   \   0000005A   0x68A0             LDR      R0,[R4, #+8]
   \   0000005C   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000060   0x9700             STR      R7,[SP, #+0]
   \   00000062   0x4643             MOV      R3,R8
   \   00000064   0xD114             BNE.N    ??HAL_UART_Transmit_7
   \   00000066   0x2200             MOVS     R2,#+0
   \   00000068   0x2180             MOVS     R1,#+128
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD001             BEQ.N    ??HAL_UART_Transmit_8
   \   00000074   0x2003             MOVS     R0,#+3
   \   00000076   0xE027             B.N      ??HAL_UART_Transmit_3
   \                     ??HAL_UART_Transmit_8: (+1)
   \   00000078   0x8828             LDRH     R0,[R5, #+0]
   \   0000007A   0x05C0             LSLS     R0,R0,#+23
   \   0000007C   0x0DC0             LSRS     R0,R0,#+23
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x6048             STR      R0,[R1, #+4]
   \   00000082   0x6920             LDR      R0,[R4, #+16]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD101             BNE.N    ??HAL_UART_Transmit_9
   \   00000088   0x1CAD             ADDS     R5,R5,#+2
   \   0000008A   0xE7E0             B.N      ??HAL_UART_Transmit_4
   \                     ??HAL_UART_Transmit_9: (+1)
   \   0000008C   0x1C6D             ADDS     R5,R5,#+1
   \   0000008E   0xE7DE             B.N      ??HAL_UART_Transmit_4
   \                     ??HAL_UART_Transmit_7: (+1)
   \   00000090   0x2200             MOVS     R2,#+0
   \   00000092   0x2180             MOVS     R1,#+128
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD0D3             BEQ.N    ??HAL_UART_Transmit_5
   \   0000009E   0x2003             MOVS     R0,#+3
   \   000000A0   0xE012             B.N      ??HAL_UART_Transmit_3
    673                } 
    674              }
    675              
    676              if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
   \                     ??HAL_UART_Transmit_6: (+1)
   \   000000A2   0x9700             STR      R7,[SP, #+0]
   \   000000A4   0x4643             MOV      R3,R8
   \   000000A6   0x2200             MOVS     R2,#+0
   \   000000A8   0x2140             MOVS     R1,#+64
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD001             BEQ.N    ??HAL_UART_Transmit_10
    677              { 
    678                return HAL_TIMEOUT;
   \   000000B4   0x2003             MOVS     R0,#+3
   \   000000B6   0xE007             B.N      ??HAL_UART_Transmit_3
    679              }
    680              
    681              /* At end of Tx process, restore huart->gState to Ready */
    682                huart->gState = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Transmit_10: (+1)
   \   000000B8   0x2020             MOVS     R0,#+32
   \   000000BA   0xF884 0x0039      STRB     R0,[R4, #+57]
    683              
    684              /* Process Unlocked */
    685              __HAL_UNLOCK(huart);
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xF884 0x0038      STRB     R0,[R4, #+56]
    686              
    687              return HAL_OK;
   \   000000C4   0xE000             B.N      ??HAL_UART_Transmit_3
    688            }
    689            else
    690            {
    691              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_0: (+1)
   \   000000C6   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_3: (+1)
   \   000000C8   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    692            }
    693          }
    694          
    695          /**
    696            * @brief  Receives an amount of data in blocking mode. 
    697            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
    698            *                the configuration information for the specified UART module.
    699            * @param  pData: Pointer to data buffer
    700            * @param  Size: Amount of data to be received
    701            * @param  Timeout: Timeout duration
    702            * @retval HAL status
    703            */

   \                                 In section .text, align 2, keep-with-next
    704          HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    705          { 
   \                     HAL_UART_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4617             MOV      R7,R2
   \   0000000C   0x461E             MOV      R6,R3
    706            uint16_t* tmp;
    707            uint32_t tickstart = 0U;
    708            
    709            /* Check that a Rx process is not already ongoing */
    710            if(huart->RxState == HAL_UART_STATE_READY) 
   \   0000000E   0xF894 0x003A      LDRB     R0,[R4, #+58]
   \   00000012   0x2820             CMP      R0,#+32
   \   00000014   0xD154             BNE.N    ??HAL_UART_Receive_0
    711            { 
    712              if((pData == NULL ) || (Size == 0U)) 
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD001             BEQ.N    ??HAL_UART_Receive_1
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_UART_Receive_2
    713              {
    714                return  HAL_ERROR;
   \                     ??HAL_UART_Receive_1: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE04F             B.N      ??HAL_UART_Receive_3
    715              }
    716              
    717              /* Process Locked */
    718              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_2: (+1)
   \   00000022   0xF994 0x0038      LDRSB    R0,[R4, #+56]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD04A             BEQ.N    ??HAL_UART_Receive_0
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF884 0x0038      STRB     R0,[R4, #+56]
    719              
    720              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x63E0             STR      R0,[R4, #+60]
    721              huart->RxState = HAL_UART_STATE_BUSY_RX;
   \   00000034   0x2022             MOVS     R0,#+34
   \   00000036   0xF884 0x003A      STRB     R0,[R4, #+58]
    722          	
    723              /* Init tickstart for timeout managment */
    724              tickstart = HAL_GetTick();
   \   0000003A   0x.... 0x....      BL       HAL_GetTick
   \   0000003E   0x4680             MOV      R8,R0
    725                  
    726              huart->RxXferSize = Size; 
   \   00000040   0x85A7             STRH     R7,[R4, #+44]
    727              huart->RxXferCount = Size;
   \   00000042   0x85E7             STRH     R7,[R4, #+46]
   \   00000044   0xE003             B.N      ??HAL_UART_Receive_4
    728              
    729              /* Check the remain data to be received */
    730              while(huart->RxXferCount > 0U)
    731              {
    732                huart->RxXferCount--;
    733                if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    734                {
    735                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
    736                  { 
    737                    return HAL_TIMEOUT;
    738                  }
    739                  tmp = (uint16_t*) pData;
    740                  if(huart->Init.Parity == UART_PARITY_NONE)
    741                  {
    742                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FFU);
   \                     ??HAL_UART_Receive_5: (+1)
   \   00000046   0x05C0             LSLS     R0,R0,#+23
   \   00000048   0x0DC0             LSRS     R0,R0,#+23
   \   0000004A   0xF825 0x0B02      STRH     R0,[R5], #+2
    743                    pData +=2U;
    744                  }
   \                     ??HAL_UART_Receive_4: (+1)
   \   0000004E   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD02E             BEQ.N    ??HAL_UART_Receive_6
   \   00000054   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000056   0x1E40             SUBS     R0,R0,#+1
   \   00000058   0x85E0             STRH     R0,[R4, #+46]
   \   0000005A   0x68A0             LDR      R0,[R4, #+8]
   \   0000005C   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000060   0x9600             STR      R6,[SP, #+0]
   \   00000062   0x4643             MOV      R3,R8
   \   00000064   0xD10F             BNE.N    ??HAL_UART_Receive_7
   \   00000066   0x2200             MOVS     R2,#+0
   \   00000068   0x2120             MOVS     R1,#+32
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD10F             BNE.N    ??HAL_UART_Receive_8
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6921             LDR      R1,[R4, #+16]
   \   00000078   0x2900             CMP      R1,#+0
   \   0000007A   0x6840             LDR      R0,[R0, #+4]
   \   0000007C   0xD0E3             BEQ.N    ??HAL_UART_Receive_5
    745                  else
    746                  {
    747                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FFU);
   \   0000007E   0xB2C0             UXTB     R0,R0
   \   00000080   0xF825 0x0B01      STRH     R0,[R5], #+1
    748                    pData +=1U;
   \   00000084   0xE7E3             B.N      ??HAL_UART_Receive_4
    749                  }
    750          
    751                } 
    752                else
    753                {
    754                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
   \                     ??HAL_UART_Receive_7: (+1)
   \   00000086   0x2200             MOVS     R2,#+0
   \   00000088   0x2120             MOVS     R1,#+32
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD001             BEQ.N    ??HAL_UART_Receive_9
    755                  { 
    756                    return HAL_TIMEOUT;
   \                     ??HAL_UART_Receive_8: (+1)
   \   00000094   0x2003             MOVS     R0,#+3
   \   00000096   0xE014             B.N      ??HAL_UART_Receive_3
    757                  }
    758                  if(huart->Init.Parity == UART_PARITY_NONE)
   \                     ??HAL_UART_Receive_9: (+1)
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x6921             LDR      R1,[R4, #+16]
   \   0000009C   0x2900             CMP      R1,#+0
   \   0000009E   0x6840             LDR      R0,[R0, #+4]
   \   000000A0   0xD102             BNE.N    ??HAL_UART_Receive_10
    759                  {
    760                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FFU);
   \   000000A2   0xF805 0x0B01      STRB     R0,[R5], #+1
   \   000000A6   0xE7D2             B.N      ??HAL_UART_Receive_4
    761                  }
    762                  else
    763                  {
    764                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007FU);
   \                     ??HAL_UART_Receive_10: (+1)
   \   000000A8   0xF000 0x007F      AND      R0,R0,#0x7F
   \   000000AC   0xF805 0x0B01      STRB     R0,[R5], #+1
   \   000000B0   0xE7CD             B.N      ??HAL_UART_Receive_4
    765                  }
    766                  
    767                }
    768              }
    769              
    770              /* At end of Rx process, restore huart->RxState to Ready */
    771              huart->RxState = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Receive_6: (+1)
   \   000000B2   0x2020             MOVS     R0,#+32
   \   000000B4   0xF884 0x003A      STRB     R0,[R4, #+58]
    772              
    773              /* Process Unlocked */
    774              __HAL_UNLOCK(huart);
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF884 0x0038      STRB     R0,[R4, #+56]
    775              
    776              return HAL_OK;
   \   000000BE   0xE000             B.N      ??HAL_UART_Receive_3
    777            }
    778            else
    779            {
    780              return HAL_BUSY;   
   \                     ??HAL_UART_Receive_0: (+1)
   \   000000C0   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_3: (+1)
   \   000000C2   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    781            }
    782          }
    783          
    784          /**
    785            * @brief  Sends an amount of data in non blocking mode.
    786            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
    787            *                the configuration information for the specified UART module.
    788            * @param  pData: Pointer to data buffer
    789            * @param  Size: Amount of data to be sent
    790            * @retval HAL status
    791            */

   \                                 In section .text, align 2, keep-with-next
    792          HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    793          {
    794            /* Check that a Tx process is not already ongoing */
    795            if(huart->gState == HAL_UART_STATE_READY)
   \                     HAL_UART_Transmit_IT: (+1)
   \   00000000   0xF890 0x3039      LDRB     R3,[R0, #+57]
   \   00000004   0x2B20             CMP      R3,#+32
   \   00000006   0xD120             BNE.N    ??HAL_UART_Transmit_IT_0
    796            {
    797              if((pData == NULL ) || (Size == 0U)) 
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD001             BEQ.N    ??HAL_UART_Transmit_IT_1
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD101             BNE.N    ??HAL_UART_Transmit_IT_2
    798              {
    799                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_IT_1: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
    800              }
    801              
    802              /* Process Locked */
    803              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_IT_2: (+1)
   \   00000014   0xF990 0x3038      LDRSB    R3,[R0, #+56]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0xD101             BNE.N    ??HAL_UART_Transmit_IT_3
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x4770             BX       LR
   \                     ??HAL_UART_Transmit_IT_3: (+1)
   \   00000020   0x2301             MOVS     R3,#+1
   \   00000022   0xF880 0x3038      STRB     R3,[R0, #+56]
    804              
    805              huart->pTxBuffPtr = pData;
   \   00000026   0x6201             STR      R1,[R0, #+32]
    806              huart->TxXferSize = Size;
   \   00000028   0x8482             STRH     R2,[R0, #+36]
    807              huart->TxXferCount = Size;
   \   0000002A   0x84C2             STRH     R2,[R0, #+38]
    808          
    809              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x63C1             STR      R1,[R0, #+60]
    810              huart->gState = HAL_UART_STATE_BUSY_TX;
   \   00000030   0x2121             MOVS     R1,#+33
   \   00000032   0xF880 0x1039      STRB     R1,[R0, #+57]
    811          
    812              /* Process Unlocked */
    813              __HAL_UNLOCK(huart);
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0xF880 0x1038      STRB     R1,[R0, #+56]
    814          
    815              /* Enable the UART Transmit data register empty Interrupt */
    816              SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x68C1             LDR      R1,[R0, #+12]
   \   00000040   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000044   0x60C1             STR      R1,[R0, #+12]
    817              
    818              return HAL_OK;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x4770             BX       LR
    819            }
    820            else
    821            {
    822              return HAL_BUSY;   
   \                     ??HAL_UART_Transmit_IT_0: (+1)
   \   0000004A   0x2002             MOVS     R0,#+2
   \   0000004C   0x4770             BX       LR               ;; return
    823            }
    824          }
    825          
    826          /**
    827            * @brief  Receives an amount of data in non blocking mode 
    828            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
    829            *                the configuration information for the specified UART module.
    830            * @param  pData: Pointer to data buffer
    831            * @param  Size: Amount of data to be received
    832            * @retval HAL status
    833            */

   \                                 In section .text, align 2, keep-with-next
    834          HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    835          {
    836            /* Check that a Rx process is not already ongoing */ 
    837            if(huart->RxState == HAL_UART_STATE_READY)
   \                     HAL_UART_Receive_IT: (+1)
   \   00000000   0xF890 0x303A      LDRB     R3,[R0, #+58]
   \   00000004   0x2B20             CMP      R3,#+32
   \   00000006   0xD125             BNE.N    ??HAL_UART_Receive_IT_0
    838            {
    839              if((pData == NULL ) || (Size == 0U)) 
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD001             BEQ.N    ??HAL_UART_Receive_IT_1
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD101             BNE.N    ??HAL_UART_Receive_IT_2
    840              {
    841                return HAL_ERROR;
   \                     ??HAL_UART_Receive_IT_1: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
    842              }
    843              
    844              /* Process Locked */
    845              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_IT_2: (+1)
   \   00000014   0xF990 0x3038      LDRSB    R3,[R0, #+56]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0xD101             BNE.N    ??HAL_UART_Receive_IT_3
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x4770             BX       LR
   \                     ??HAL_UART_Receive_IT_3: (+1)
   \   00000020   0x2301             MOVS     R3,#+1
   \   00000022   0xF880 0x3038      STRB     R3,[R0, #+56]
    846              
    847              huart->pRxBuffPtr = pData;
   \   00000026   0x6281             STR      R1,[R0, #+40]
    848              huart->RxXferSize = Size;
   \   00000028   0x8582             STRH     R2,[R0, #+44]
    849              huart->RxXferCount = Size;
   \   0000002A   0x85C2             STRH     R2,[R0, #+46]
    850              
    851              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x63C1             STR      R1,[R0, #+60]
    852              huart->RxState = HAL_UART_STATE_BUSY_RX;
   \   00000030   0x2122             MOVS     R1,#+34
   \   00000032   0xF880 0x103A      STRB     R1,[R0, #+58]
    853              
    854              /* Process Unlocked */
    855              __HAL_UNLOCK(huart);
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0xF880 0x1038      STRB     R1,[R0, #+56]
    856          
    857              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    858              SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x694A             LDR      R2,[R1, #+20]
   \   00000040   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000044   0x614A             STR      R2,[R1, #+20]
    859          
    860              /* Enable the UART Parity Error and Data Register not empty Interrupts */
    861              SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x68C1             LDR      R1,[R0, #+12]
   \   0000004A   0xF441 0x7190      ORR      R1,R1,#0x120
   \   0000004E   0x60C1             STR      R1,[R0, #+12]
    862              
    863              return HAL_OK;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x4770             BX       LR
    864            }
    865            else
    866            {
    867              return HAL_BUSY; 
   \                     ??HAL_UART_Receive_IT_0: (+1)
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x4770             BX       LR               ;; return
    868            }
    869          }
    870          
    871          /**
    872            * @brief  Sends an amount of data in non blocking mode. 
    873            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
    874            *                the configuration information for the specified UART module.
    875            * @param  pData: Pointer to data buffer
    876            * @param  Size: Amount of data to be sent
    877            * @retval HAL status
    878            */

   \                                 In section .text, align 2, keep-with-next
    879          HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    880          {
   \                     HAL_UART_Transmit_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    881            uint32_t *tmp;
    882            
    883            /* Check that a Tx process is not already ongoing */
    884            if(huart->gState == HAL_UART_STATE_READY)
   \   00000004   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000008   0x2820             CMP      R0,#+32
   \   0000000A   0xD139             BNE.N    ??HAL_UART_Transmit_DMA_0
    885            {
    886              if((pData == NULL ) || (Size == 0U))
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ.N    ??HAL_UART_Transmit_DMA_1
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_2
    887              {
    888                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_DMA_1: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xBD10             POP      {R4,PC}
    889              }
    890          
    891              /* Process Locked */
    892              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_DMA_2: (+1)
   \   00000018   0xF994 0x0038      LDRSB    R0,[R4, #+56]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_3
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xBD10             POP      {R4,PC}
   \                     ??HAL_UART_Transmit_DMA_3: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF884 0x0038      STRB     R0,[R4, #+56]
    893          
    894              huart->pTxBuffPtr = pData;
   \   0000002A   0x6221             STR      R1,[R4, #+32]
    895              huart->TxXferSize = Size;
   \   0000002C   0x84A2             STRH     R2,[R4, #+36]
    896              huart->TxXferCount = Size;
   \   0000002E   0x84E2             STRH     R2,[R4, #+38]
    897          
    898              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x63E0             STR      R0,[R4, #+60]
    899              huart->gState = HAL_UART_STATE_BUSY_TX;
   \   00000034   0x2021             MOVS     R0,#+33
   \   00000036   0xF884 0x0039      STRB     R0,[R4, #+57]
    900          
    901              /* Set the UART DMA transfer complete callback */
    902              huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
   \   0000003A   0x.... 0x....      ADR.W    R0,UART_DMATransmitCplt
   \   0000003E   0x6B23             LDR      R3,[R4, #+48]
   \   00000040   0x63D8             STR      R0,[R3, #+60]
    903          
    904              /* Set the UART DMA Half transfer complete callback */
    905              huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
   \   00000042   0x.... 0x....      ADR.W    R0,UART_DMATxHalfCplt
   \   00000046   0x6B23             LDR      R3,[R4, #+48]
   \   00000048   0x6418             STR      R0,[R3, #+64]
    906          
    907              /* Set the DMA error callback */
    908              huart->hdmatx->XferErrorCallback = UART_DMAError;
   \   0000004A   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   0000004E   0x6B23             LDR      R3,[R4, #+48]
   \   00000050   0x64D8             STR      R0,[R3, #+76]
    909          
    910              /* Set the DMA abort callback */
    911              huart->hdmatx->XferAbortCallback = NULL;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x6B23             LDR      R3,[R4, #+48]
   \   00000056   0x6518             STR      R0,[R3, #+80]
    912          
    913              /* Enable the UART transmit DMA Stream */
    914              tmp = (uint32_t*)&pData;
    915              HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
   \   00000058   0x4613             MOV      R3,R2
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x1D02             ADDS     R2,R0,#+4
   \   0000005E   0x6B20             LDR      R0,[R4, #+48]
   \   00000060   0x.... 0x....      BL       HAL_DMA_Start_IT
    916              
    917              /* Clear the TC flag in the SR register by writing 0 to it */
    918              __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
   \   00000064   0xF06F 0x0040      MVN      R0,#+64
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    919              
    920              /* Process Unlocked */
    921              __HAL_UNLOCK(huart);
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF884 0x0038      STRB     R0,[R4, #+56]
    922              
    923              /* Enable the DMA transfer for transmit request by setting the DMAT bit
    924                 in the UART CR3 register */
    925              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x6941             LDR      R1,[R0, #+20]
   \   00000076   0xF041 0x0180      ORR      R1,R1,#0x80
   \   0000007A   0x6141             STR      R1,[R0, #+20]
    926              
    927              return HAL_OK;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xBD10             POP      {R4,PC}
    928            }
    929            else
    930            {
    931              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_DMA_0: (+1)
   \   00000080   0x2002             MOVS     R0,#+2
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
    932            }
    933          }
    934          
    935          /**
    936            * @brief  Receives an amount of data in non blocking mode. 
    937            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
    938            *                the configuration information for the specified UART module.
    939            * @param  pData: Pointer to data buffer
    940            * @param  Size: Amount of data to be received
    941            * @note   When the UART parity is enabled (PCE = 1) the data received contain the parity bit.
    942            * @retval HAL status
    943            */

   \                                 In section .text, align 2, keep-with-next
    944          HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    945          {  
   \                     HAL_UART_Receive_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    946            uint32_t *tmp;
    947            
    948            /* Check that a Rx process is not already ongoing */
    949            if(huart->RxState == HAL_UART_STATE_READY) 
   \   00000004   0xF894 0x003A      LDRB     R0,[R4, #+58]
   \   00000008   0x2820             CMP      R0,#+32
   \   0000000A   0xD13E             BNE.N    ??HAL_UART_Receive_DMA_0
    950            {
    951              if((pData == NULL ) || (Size == 0U)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ.N    ??HAL_UART_Receive_DMA_1
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD101             BNE.N    ??HAL_UART_Receive_DMA_2
    952              {
    953                return HAL_ERROR;
   \                     ??HAL_UART_Receive_DMA_1: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xBD10             POP      {R4,PC}
    954              }
    955              
    956              /* Process Locked */
    957              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_DMA_2: (+1)
   \   00000018   0xF994 0x0038      LDRSB    R0,[R4, #+56]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD101             BNE.N    ??HAL_UART_Receive_DMA_3
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xBD10             POP      {R4,PC}
   \                     ??HAL_UART_Receive_DMA_3: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF884 0x0038      STRB     R0,[R4, #+56]
    958              
    959              huart->pRxBuffPtr = pData;
   \   0000002A   0x62A1             STR      R1,[R4, #+40]
    960              huart->RxXferSize = Size;
   \   0000002C   0x85A2             STRH     R2,[R4, #+44]
    961              
    962              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x63E0             STR      R0,[R4, #+60]
    963              huart->RxState = HAL_UART_STATE_BUSY_RX;
   \   00000032   0x2022             MOVS     R0,#+34
   \   00000034   0xF884 0x003A      STRB     R0,[R4, #+58]
    964                  
    965              /* Set the UART DMA transfer complete callback */
    966              huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
   \   00000038   0x.... 0x....      ADR.W    R0,UART_DMAReceiveCplt
   \   0000003C   0x6B63             LDR      R3,[R4, #+52]
   \   0000003E   0x63D8             STR      R0,[R3, #+60]
    967              
    968              /* Set the UART DMA Half transfer complete callback */
    969              huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
   \   00000040   0x.... 0x....      ADR.W    R0,UART_DMARxHalfCplt
   \   00000044   0x6B63             LDR      R3,[R4, #+52]
   \   00000046   0x6418             STR      R0,[R3, #+64]
    970              
    971              /* Set the DMA error callback */
    972              huart->hdmarx->XferErrorCallback = UART_DMAError;
   \   00000048   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   0000004C   0x6B63             LDR      R3,[R4, #+52]
   \   0000004E   0x64D8             STR      R0,[R3, #+76]
    973              
    974              /* Set the DMA abort callback */
    975              huart->hdmarx->XferAbortCallback = NULL;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6B63             LDR      R3,[R4, #+52]
   \   00000054   0x6518             STR      R0,[R3, #+80]
    976          
    977              /* Enable the DMA Stream */
    978              tmp = (uint32_t*)&pData;
    979              HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size); 
   \   00000056   0x4613             MOV      R3,R2
   \   00000058   0x460A             MOV      R2,R1
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x1D01             ADDS     R1,R0,#+4
   \   0000005E   0x6B60             LDR      R0,[R4, #+52]
   \   00000060   0x.... 0x....      BL       HAL_DMA_Start_IT
    980          
    981              /* Enable the UART Parity Error Interrupt */
    982              SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x68C1             LDR      R1,[R0, #+12]
   \   00000068   0xF441 0x7180      ORR      R1,R1,#0x100
   \   0000006C   0x60C1             STR      R1,[R0, #+12]
    983          
    984              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    985              SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6941             LDR      R1,[R0, #+20]
   \   00000072   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000076   0x6141             STR      R1,[R0, #+20]
    986              
    987              /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
    988              in the UART CR3 register */
    989              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6941             LDR      R1,[R0, #+20]
   \   0000007C   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000080   0x6141             STR      R1,[R0, #+20]
    990              
    991              /* Process Unlocked */
    992              __HAL_UNLOCK(huart);
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF884 0x0038      STRB     R0,[R4, #+56]
    993              
    994              return HAL_OK;
   \   00000088   0xBD10             POP      {R4,PC}
    995            }
    996            else
    997            {
    998              return HAL_BUSY; 
   \                     ??HAL_UART_Receive_DMA_0: (+1)
   \   0000008A   0x2002             MOVS     R0,#+2
   \   0000008C   0xBD10             POP      {R4,PC}          ;; return
    999            }
   1000          }
   1001              
   1002          /**
   1003            * @brief Pauses the DMA Transfer.
   1004            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1005            *                the configuration information for the specified UART module.
   1006            * @retval HAL status
   1007            */

   \                                 In section .text, align 2, keep-with-next
   1008          HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
   1009          {
   1010             uint32_t dmarequest = 0x00U;
   1011          
   1012            /* Process Locked */
   1013            __HAL_LOCK(huart);
   \                     HAL_UART_DMAPause: (+1)
   \   00000000   0xF990 0x1038      LDRSB    R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_UART_DMAPause_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_UART_DMAPause_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1014            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x694A             LDR      R2,[R1, #+20]
   \   00000016   0x09D2             LSRS     R2,R2,#+7
   \   00000018   0xF002 0x0201      AND      R2,R2,#0x1
   1015            if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
   \   0000001C   0xF890 0x3039      LDRB     R3,[R0, #+57]
   \   00000020   0x2B21             CMP      R3,#+33
   \   00000022   0xD105             BNE.N    ??HAL_UART_DMAPause_1
   \   00000024   0x2A00             CMP      R2,#+0
   \   00000026   0xD003             BEQ.N    ??HAL_UART_DMAPause_1
   1016            {
   1017              /* Disable the UART DMA Tx request */
   1018              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000028   0x694A             LDR      R2,[R1, #+20]
   \   0000002A   0xF022 0x0280      BIC      R2,R2,#0x80
   \   0000002E   0x614A             STR      R2,[R1, #+20]
   1019            }
   1020            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_DMAPause_1: (+1)
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0x694A             LDR      R2,[R1, #+20]
   \   00000034   0x0992             LSRS     R2,R2,#+6
   \   00000036   0xF002 0x0201      AND      R2,R2,#0x1
   1021            if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
   \   0000003A   0xF890 0x303A      LDRB     R3,[R0, #+58]
   \   0000003E   0x2B22             CMP      R3,#+34
   \   00000040   0xD10F             BNE.N    ??HAL_UART_DMAPause_2
   \   00000042   0x2A00             CMP      R2,#+0
   \   00000044   0xD00D             BEQ.N    ??HAL_UART_DMAPause_2
   1022            {
   1023              /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   1024              CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \   00000046   0x68CA             LDR      R2,[R1, #+12]
   \   00000048   0xF422 0x7280      BIC      R2,R2,#0x100
   \   0000004C   0x60CA             STR      R2,[R1, #+12]
   1025              CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0x694A             LDR      R2,[R1, #+20]
   \   00000052   0x0852             LSRS     R2,R2,#+1
   \   00000054   0x0052             LSLS     R2,R2,#+1
   \   00000056   0x614A             STR      R2,[R1, #+20]
   1026              
   1027              /* Disable the UART DMA Rx request */
   1028              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0x694A             LDR      R2,[R1, #+20]
   \   0000005C   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000060   0x614A             STR      R2,[R1, #+20]
   1029            }
   1030            
   1031            /* Process Unlocked */
   1032            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAPause_2: (+1)
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0xF880 0x1038      STRB     R1,[R0, #+56]
   1033            
   1034            return HAL_OK; 
   \   00000068   0x4608             MOV      R0,R1
   \   0000006A   0x4770             BX       LR               ;; return
   1035          }
   1036          
   1037          /**
   1038            * @brief Resumes the DMA Transfer.
   1039            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1040            *                the configuration information for the specified UART module.
   1041            * @retval HAL status
   1042            */

   \                                 In section .text, align 2, keep-with-next
   1043          HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
   1044          {
   \                     HAL_UART_DMAResume: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   1045            /* Process Locked */
   1046            __HAL_LOCK(huart);
   \   00000002   0xF990 0x1038      LDRSB    R1,[R0, #+56]
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD101             BNE.N    ??HAL_UART_DMAResume_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE029             B.N      ??HAL_UART_DMAResume_1
   \                     ??HAL_UART_DMAResume_0: (+1)
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF880 0x1038      STRB     R1,[R0, #+56]
   1047            
   1048            if(huart->gState == HAL_UART_STATE_BUSY_TX)
   \   00000014   0xF890 0x1039      LDRB     R1,[R0, #+57]
   \   00000018   0x2921             CMP      R1,#+33
   \   0000001A   0xD104             BNE.N    ??HAL_UART_DMAResume_2
   1049            {
   1050              /* Enable the UART DMA Tx request */
   1051              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x694A             LDR      R2,[R1, #+20]
   \   00000020   0xF042 0x0280      ORR      R2,R2,#0x80
   \   00000024   0x614A             STR      R2,[R1, #+20]
   1052            }
   1053            if(huart->RxState == HAL_UART_STATE_BUSY_RX)
   \                     ??HAL_UART_DMAResume_2: (+1)
   \   00000026   0xF890 0x103A      LDRB     R1,[R0, #+58]
   \   0000002A   0x2922             CMP      R1,#+34
   \   0000002C   0xD115             BNE.N    ??HAL_UART_DMAResume_3
   1054            {
   1055              /* Clear the Overrun flag before resuming the Rx transfer*/
   1056              __HAL_UART_CLEAR_OREFLAG(huart);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x9100             STR      R1,[SP, #+0]
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0x680A             LDR      R2,[R1, #+0]
   \   00000036   0x9200             STR      R2,[SP, #+0]
   \   00000038   0x684A             LDR      R2,[R1, #+4]
   \   0000003A   0x9200             STR      R2,[SP, #+0]
   \   0000003C   0x9A00             LDR      R2,[SP, #+0]
   1057              
   1058              /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
   1059              SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \   0000003E   0x68CA             LDR      R2,[R1, #+12]
   \   00000040   0xF442 0x7280      ORR      R2,R2,#0x100
   \   00000044   0x60CA             STR      R2,[R1, #+12]
   1060              SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x694A             LDR      R2,[R1, #+20]
   \   0000004A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000004E   0x614A             STR      R2,[R1, #+20]
   1061              
   1062              /* Enable the UART DMA Rx request */
   1063              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x694A             LDR      R2,[R1, #+20]
   \   00000054   0xF042 0x0240      ORR      R2,R2,#0x40
   \   00000058   0x614A             STR      R2,[R1, #+20]
   1064            }
   1065            
   1066            /* Process Unlocked */
   1067            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAResume_3: (+1)
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0xF880 0x1038      STRB     R1,[R0, #+56]
   1068            
   1069            return HAL_OK;
   \   00000060   0x4608             MOV      R0,R1
   \                     ??HAL_UART_DMAResume_1: (+1)
   \   00000062   0xB001             ADD      SP,SP,#+4
   \   00000064   0x4770             BX       LR               ;; return
   1070          }
   1071          
   1072          /**
   1073            * @brief Stops the DMA Transfer.
   1074            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1075            *                the configuration information for the specified UART module.
   1076            * @retval HAL status
   1077            */

   \                                 In section .text, align 2, keep-with-next
   1078          HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
   1079          {
   \                     HAL_UART_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1080            uint32_t dmarequest = 0x00U;
   1081            /* The Lock is not implemented on this API to allow the user application
   1082               to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
   1083               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1084               and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
   1085               */
   1086            
   1087            /* Stop UART DMA Tx request if ongoing */
   1088            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6941             LDR      R1,[R0, #+20]
   \   00000008   0x09C9             LSRS     R1,R1,#+7
   \   0000000A   0xF001 0x0101      AND      R1,R1,#0x1
   1089            if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
   \   0000000E   0xF894 0x2039      LDRB     R2,[R4, #+57]
   \   00000012   0x2A21             CMP      R2,#+33
   \   00000014   0xD10D             BNE.N    ??HAL_UART_DMAStop_0
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD00B             BEQ.N    ??HAL_UART_DMAStop_0
   1090            {
   1091              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000001A   0x6941             LDR      R1,[R0, #+20]
   \   0000001C   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000020   0x6141             STR      R1,[R0, #+20]
   1092          
   1093              /* Abort the UART DMA Tx channel */
   1094              if(huart->hdmatx != NULL)
   \   00000022   0x6B20             LDR      R0,[R4, #+48]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_UART_DMAStop_1
   1095              {
   1096                HAL_DMA_Abort(huart->hdmatx);
   \   00000028   0x.... 0x....      BL       HAL_DMA_Abort
   1097              }
   1098              UART_EndTxTransfer(huart);
   \                     ??HAL_UART_DMAStop_1: (+1)
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       UART_EndTxTransfer
   1099            }
   1100          
   1101            /* Stop UART DMA Rx request if ongoing */
   1102            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_DMAStop_0: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6941             LDR      R1,[R0, #+20]
   \   00000036   0x0989             LSRS     R1,R1,#+6
   \   00000038   0xF001 0x0101      AND      R1,R1,#0x1
   1103            if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
   \   0000003C   0xF894 0x203A      LDRB     R2,[R4, #+58]
   \   00000040   0x2A22             CMP      R2,#+34
   \   00000042   0xD10D             BNE.N    ??HAL_UART_DMAStop_2
   \   00000044   0x2900             CMP      R1,#+0
   \   00000046   0xD00B             BEQ.N    ??HAL_UART_DMAStop_2
   1104            {
   1105              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000048   0x6941             LDR      R1,[R0, #+20]
   \   0000004A   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000004E   0x6141             STR      R1,[R0, #+20]
   1106          
   1107              /* Abort the UART DMA Rx channel */
   1108              if(huart->hdmarx != NULL)
   \   00000050   0x6B60             LDR      R0,[R4, #+52]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD001             BEQ.N    ??HAL_UART_DMAStop_3
   1109              {
   1110                HAL_DMA_Abort(huart->hdmarx);
   \   00000056   0x.... 0x....      BL       HAL_DMA_Abort
   1111              }
   1112              UART_EndRxTransfer(huart);
   \                     ??HAL_UART_DMAStop_3: (+1)
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       UART_EndRxTransfer
   1113            }
   1114          
   1115            return HAL_OK;
   \                     ??HAL_UART_DMAStop_2: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
   1116          }
   1117          
   1118          /**
   1119            * @brief  This function handles UART interrupt request.
   1120            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1121            *                the configuration information for the specified UART module.
   1122            * @retval None
   1123            */

   \                                 In section .text, align 2, keep-with-next
   1124          void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
   1125          {
   \                     HAL_UART_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1126             uint32_t isrflags   = READ_REG(huart->Instance->SR);
   \   00000004   0x6822             LDR      R2,[R4, #+0]
   \   00000006   0x6810             LDR      R0,[R2, #+0]
   1127             uint32_t cr1its     = READ_REG(huart->Instance->CR1);
   \   00000008   0x68D1             LDR      R1,[R2, #+12]
   1128             uint32_t cr3its     = READ_REG(huart->Instance->CR3);
   \   0000000A   0x6952             LDR      R2,[R2, #+20]
   1129             uint32_t errorflags = 0x00U;
   1130             uint32_t dmarequest = 0x00U;
   1131          
   1132            /* If no error occurs */
   1133            errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
   \   0000000C   0xF010 0x030F      ANDS     R3,R0,#0xF
   1134            if(errorflags == RESET)
   \   00000010   0xD107             BNE.N    ??HAL_UART_IRQHandler_0
   1135            {
   1136              /* UART in mode Receiver -------------------------------------------------*/
   1137              if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
   \   00000012   0x0685             LSLS     R5,R0,#+26
   \   00000014   0xD505             BPL.N    ??HAL_UART_IRQHandler_0
   \   00000016   0x068D             LSLS     R5,R1,#+26
   \   00000018   0xD503             BPL.N    ??HAL_UART_IRQHandler_0
   1138              {
   1139                UART_Receive_IT(huart);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000020   0x....             B.N      UART_Receive_IT
   1140                return;
   1141              }
   1142            }
   1143          
   1144            /* If some errors occur */
   1145            if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
   \                     ??HAL_UART_IRQHandler_0: (+1)
   \   00000022   0x2B00             CMP      R3,#+0
   \   00000024   0xD060             BEQ.N    ??HAL_UART_IRQHandler_1
   \   00000026   0x07D3             LSLS     R3,R2,#+31
   \   00000028   0xD402             BMI.N    ??HAL_UART_IRQHandler_2
   \   0000002A   0xF411 0x7F90      TST      R1,#0x120
   \   0000002E   0xD05B             BEQ.N    ??HAL_UART_IRQHandler_1
   1146            {
   1147              /* UART parity error interrupt occurred ----------------------------------*/
   1148              if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
   \                     ??HAL_UART_IRQHandler_2: (+1)
   \   00000030   0x4603             MOV      R3,R0
   \   00000032   0x07DB             LSLS     R3,R3,#+31
   \   00000034   0xD505             BPL.N    ??HAL_UART_IRQHandler_3
   \   00000036   0x05CB             LSLS     R3,R1,#+23
   \   00000038   0xD503             BPL.N    ??HAL_UART_IRQHandler_3
   1149              {
   1150                huart->ErrorCode |= HAL_UART_ERROR_PE;
   \   0000003A   0x6BE3             LDR      R3,[R4, #+60]
   \   0000003C   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000040   0x63E3             STR      R3,[R4, #+60]
   1151              }
   1152              
   1153              /* UART noise error interrupt occurred -----------------------------------*/
   1154              if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
   \                     ??HAL_UART_IRQHandler_3: (+1)
   \   00000042   0x0743             LSLS     R3,R0,#+29
   \   00000044   0xD506             BPL.N    ??HAL_UART_IRQHandler_4
   \   00000046   0x4613             MOV      R3,R2
   \   00000048   0x07DB             LSLS     R3,R3,#+31
   \   0000004A   0xD503             BPL.N    ??HAL_UART_IRQHandler_4
   1155              {
   1156                huart->ErrorCode |= HAL_UART_ERROR_NE;
   \   0000004C   0x6BE3             LDR      R3,[R4, #+60]
   \   0000004E   0xF043 0x0302      ORR      R3,R3,#0x2
   \   00000052   0x63E3             STR      R3,[R4, #+60]
   1157              }
   1158              
   1159              /* UART frame error interrupt occurred -----------------------------------*/
   1160              if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
   \                     ??HAL_UART_IRQHandler_4: (+1)
   \   00000054   0x0783             LSLS     R3,R0,#+30
   \   00000056   0xD506             BPL.N    ??HAL_UART_IRQHandler_5
   \   00000058   0x4613             MOV      R3,R2
   \   0000005A   0x07DB             LSLS     R3,R3,#+31
   \   0000005C   0xD503             BPL.N    ??HAL_UART_IRQHandler_5
   1161              {
   1162                huart->ErrorCode |= HAL_UART_ERROR_FE;
   \   0000005E   0x6BE3             LDR      R3,[R4, #+60]
   \   00000060   0xF043 0x0304      ORR      R3,R3,#0x4
   \   00000064   0x63E3             STR      R3,[R4, #+60]
   1163              }
   1164              
   1165              /* UART Over-Run interrupt occurred --------------------------------------*/
   1166              if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
   \                     ??HAL_UART_IRQHandler_5: (+1)
   \   00000066   0x0703             LSLS     R3,R0,#+28
   \   00000068   0xD505             BPL.N    ??HAL_UART_IRQHandler_6
   \   0000006A   0x07D2             LSLS     R2,R2,#+31
   \   0000006C   0xD503             BPL.N    ??HAL_UART_IRQHandler_6
   1167              { 
   1168                huart->ErrorCode |= HAL_UART_ERROR_ORE;
   \   0000006E   0x6BE2             LDR      R2,[R4, #+60]
   \   00000070   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000074   0x63E2             STR      R2,[R4, #+60]
   1169              }
   1170          
   1171              /* Call UART Error Call back function if need be --------------------------*/    
   1172              if(huart->ErrorCode != HAL_UART_ERROR_NONE)
   \                     ??HAL_UART_IRQHandler_6: (+1)
   \   00000076   0x6BE2             LDR      R2,[R4, #+60]
   \   00000078   0x2A00             CMP      R2,#+0
   \   0000007A   0xD045             BEQ.N    ??HAL_UART_IRQHandler_7
   1173              {
   1174                /* UART in mode Receiver -----------------------------------------------*/
   1175                if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
   \   0000007C   0x0680             LSLS     R0,R0,#+26
   \   0000007E   0xD504             BPL.N    ??HAL_UART_IRQHandler_8
   \   00000080   0x0688             LSLS     R0,R1,#+26
   \   00000082   0xD502             BPL.N    ??HAL_UART_IRQHandler_8
   1176                {
   1177                  UART_Receive_IT(huart);
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       UART_Receive_IT
   1178                }
   1179          
   1180                /* If Overrun error occurs, or if any error occurs in DMA mode reception,
   1181                   consider error as blocking */
   1182                dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_IRQHandler_8: (+1)
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6940             LDR      R0,[R0, #+20]
   \   0000008E   0x0980             LSRS     R0,R0,#+6
   \   00000090   0xF000 0x0001      AND      R0,R0,#0x1
   1183                if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
   \   00000094   0x6BE1             LDR      R1,[R4, #+60]
   \   00000096   0x0709             LSLS     R1,R1,#+28
   \   00000098   0xD401             BMI.N    ??HAL_UART_IRQHandler_9
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD01E             BEQ.N    ??HAL_UART_IRQHandler_10
   1184                {
   1185                  /* Blocking error : transfer is aborted
   1186                     Set the UART state ready to be able to start again the process,
   1187                     Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
   1188                  UART_EndRxTransfer(huart);
   \                     ??HAL_UART_IRQHandler_9: (+1)
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0x.... 0x....      BL       UART_EndRxTransfer
   1189                  
   1190                  /* Disable the UART DMA Rx request if enabled */
   1191                  if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x6941             LDR      R1,[R0, #+20]
   \   000000A8   0x0649             LSLS     R1,R1,#+25
   \   000000AA   0xD513             BPL.N    ??HAL_UART_IRQHandler_11
   1192                  {
   1193                    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   000000AC   0x6941             LDR      R1,[R0, #+20]
   \   000000AE   0xF021 0x0140      BIC      R1,R1,#0x40
   \   000000B2   0x6141             STR      R1,[R0, #+20]
   1194                    
   1195                    /* Abort the UART DMA Rx channel */
   1196                    if(huart->hdmarx != NULL)
   \   000000B4   0x6B60             LDR      R0,[R4, #+52]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD00C             BEQ.N    ??HAL_UART_IRQHandler_11
   1197                    {
   1198                      /* Set the UART DMA Abort callback : 
   1199                         will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
   1200                      huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
   \   000000BA   0x.... 0x....      ADR.W    R1,UART_DMAAbortOnError
   \   000000BE   0x6501             STR      R1,[R0, #+80]
   1201                      if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
   \   000000C0   0x6B60             LDR      R0,[R4, #+52]
   \   000000C2   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD01E             BEQ.N    ??HAL_UART_IRQHandler_7
   1202                      {
   1203                        /* Call Directly XferAbortCallback function in case of error */
   1204                        huart->hdmarx->XferAbortCallback(huart->hdmarx);
   \   000000CA   0x6B60             LDR      R0,[R4, #+52]
   \   000000CC   0x6D01             LDR      R1,[R0, #+80]
   \   000000CE   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000D2   0x4708             BX       R1
   1205                      }
   1206                    }
   1207                    else
   1208                    {
   1209                      /* Call user error callback */
   1210                      HAL_UART_ErrorCallback(huart);
   1211                    }
   1212                  }
   1213                  else
   1214                  {
   1215                    /* Call user error callback */
   1216                    HAL_UART_ErrorCallback(huart);
   \                     ??HAL_UART_IRQHandler_11: (+1)
   \   000000D4   0x4620             MOV      R0,R4
   \   000000D6   0x.... 0x....      BL       HAL_UART_ErrorCallback
   \   000000DA   0xBD31             POP      {R0,R4,R5,PC}
   1217                  }
   1218                }
   1219                else
   1220                {
   1221                  /* Non Blocking error : transfer could go on. 
   1222                     Error is notified to user through user error callback */
   1223                  HAL_UART_ErrorCallback(huart);
   \                     ??HAL_UART_IRQHandler_10: (+1)
   \   000000DC   0x4620             MOV      R0,R4
   \   000000DE   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1224                  huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x63E0             STR      R0,[R4, #+60]
   1225                }
   1226              }
   1227              return;
   \   000000E6   0xBD31             POP      {R0,R4,R5,PC}
   1228            } /* End if some error occurs */
   1229          
   1230            /* UART in mode Transmitter ------------------------------------------------*/
   1231            if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
   \                     ??HAL_UART_IRQHandler_1: (+1)
   \   000000E8   0x0602             LSLS     R2,R0,#+24
   \   000000EA   0xD505             BPL.N    ??HAL_UART_IRQHandler_12
   \   000000EC   0x060A             LSLS     R2,R1,#+24
   \   000000EE   0xD503             BPL.N    ??HAL_UART_IRQHandler_12
   1232            {
   1233              UART_Transmit_IT(huart);
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   000000F6   0x....             B.N      UART_Transmit_IT
   1234              return;
   1235            }
   1236            
   1237            /* UART in mode Transmitter end --------------------------------------------*/
   1238            if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
   \                     ??HAL_UART_IRQHandler_12: (+1)
   \   000000F8   0x0640             LSLS     R0,R0,#+25
   \   000000FA   0xD505             BPL.N    ??HAL_UART_IRQHandler_7
   \   000000FC   0x0648             LSLS     R0,R1,#+25
   \   000000FE   0xD503             BPL.N    ??HAL_UART_IRQHandler_7
   1239            {
   1240              UART_EndTransmit_IT(huart);
   \   00000100   0x4620             MOV      R0,R4
   \   00000102   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000106   0x....             B.N      UART_EndTransmit_IT
   1241              return;
   1242            }
   1243          }
   \                     ??HAL_UART_IRQHandler_7: (+1)
   \   00000108   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1244          
   1245          /**
   1246            * @brief  Tx Transfer completed callbacks.
   1247            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1248            *                the configuration information for the specified UART module.
   1249            * @retval None
   1250            */

   \                                 In section .text, align 2, keep-with-next
   1251           __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
   1252          {
   1253            /* Prevent unused argument(s) compilation warning */
   1254            UNUSED(huart);
   1255            /* NOTE: This function Should not be modified, when the callback is needed,
   1256                     the HAL_UART_TxCpltCallback could be implemented in the user file
   1257             */ 
   1258          }
   \                     HAL_UART_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1259          
   1260          /**
   1261            * @brief  Tx Half Transfer completed callbacks.
   1262            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1263            *                the configuration information for the specified UART module.
   1264            * @retval None
   1265            */

   \                                 In section .text, align 2, keep-with-next
   1266           __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
   1267          {
   1268            /* Prevent unused argument(s) compilation warning */
   1269            UNUSED(huart);
   1270            /* NOTE: This function Should not be modified, when the callback is needed,
   1271                     the HAL_UART_TxCpltCallback could be implemented in the user file
   1272             */ 
   1273          }
   \                     HAL_UART_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1274          
   1275          /**
   1276            * @brief  Rx Transfer completed callbacks.
   1277            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1278            *                the configuration information for the specified UART module.
   1279            * @retval None
   1280            */

   \                                 In section .text, align 2, keep-with-next
   1281          __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
   1282          {
   1283            /* Prevent unused argument(s) compilation warning */
   1284            UNUSED(huart);
   1285            /* NOTE: This function Should not be modified, when the callback is needed,
   1286                     the HAL_UART_TxCpltCallback could be implemented in the user file
   1287             */
   1288          }
   \                     HAL_UART_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1289          
   1290          /**
   1291            * @brief  Rx Half Transfer completed callbacks.
   1292            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1293            *                the configuration information for the specified UART module.
   1294            * @retval None
   1295            */

   \                                 In section .text, align 2, keep-with-next
   1296          __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
   1297          {
   1298            /* Prevent unused argument(s) compilation warning */
   1299            UNUSED(huart);
   1300            /* NOTE: This function Should not be modified, when the callback is needed,
   1301                     the HAL_UART_TxCpltCallback could be implemented in the user file
   1302             */
   1303          }
   \                     HAL_UART_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1304          
   1305          /**
   1306            * @brief  UART error callbacks.
   1307            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1308            *                the configuration information for the specified UART module.
   1309            * @retval None
   1310            */

   \                                 In section .text, align 2, keep-with-next
   1311           __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
   1312          {
   1313            /* Prevent unused argument(s) compilation warning */
   1314            UNUSED(huart); 
   1315            /* NOTE: This function Should not be modified, when the callback is needed,
   1316                     the HAL_UART_ErrorCallback could be implemented in the user file
   1317             */ 
   1318          }
   \                     HAL_UART_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1319          
   1320          /**
   1321            * @}
   1322            */
   1323          
   1324          /** @defgroup UART_Exported_Functions_Group3 Peripheral Control functions 
   1325            *  @brief   UART control functions 
   1326            *
   1327          @verbatim   
   1328            ==============================================================================
   1329                                ##### Peripheral Control functions #####
   1330            ==============================================================================  
   1331            [..]
   1332              This subsection provides a set of functions allowing to control the UART:
   1333              (+) HAL_LIN_SendBreak() API can be helpful to transmit the break character.
   1334              (+) HAL_MultiProcessor_EnterMuteMode() API can be helpful to enter the UART in mute mode. 
   1335              (+) HAL_MultiProcessor_ExitMuteMode() API can be helpful to exit the UART mute mode by software.
   1336              
   1337          @endverbatim
   1338            * @{
   1339            */
   1340          
   1341          /**
   1342            * @brief  Transmits break characters.
   1343            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1344            *                the configuration information for the specified UART module.
   1345            * @retval HAL status
   1346            */

   \                                 In section .text, align 2, keep-with-next
   1347          HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
   1348          {
   1349            /* Check the parameters */
   1350            assert_param(IS_UART_INSTANCE(huart->Instance));
   1351            
   1352            /* Process Locked */
   1353            __HAL_LOCK(huart);
   \                     HAL_LIN_SendBreak: (+1)
   \   00000000   0xF990 0x1038      LDRSB    R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_LIN_SendBreak_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_LIN_SendBreak_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1354            
   1355            huart->gState = HAL_UART_STATE_BUSY;
   \   00000012   0x2124             MOVS     R1,#+36
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1356            
   1357            /* Send break characters */
   1358            SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68CA             LDR      R2,[R1, #+12]
   \   0000001C   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000020   0x60CA             STR      R2,[R1, #+12]
   1359           
   1360            huart->gState = HAL_UART_STATE_READY;
   \   00000022   0x2120             MOVS     R1,#+32
   \   00000024   0xF880 0x1039      STRB     R1,[R0, #+57]
   1361            
   1362            /* Process Unlocked */
   1363            __HAL_UNLOCK(huart);
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xF880 0x1038      STRB     R1,[R0, #+56]
   1364            
   1365            return HAL_OK; 
   \   0000002E   0x4608             MOV      R0,R1
   \   00000030   0x4770             BX       LR               ;; return
   1366          }
   1367          
   1368          /**
   1369            * @brief  Enters the UART in mute mode. 
   1370            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1371            *                the configuration information for the specified UART module.
   1372            * @retval HAL status
   1373            */

   \                                 In section .text, align 2, keep-with-next
   1374          HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
   1375          {
   1376            /* Check the parameters */
   1377            assert_param(IS_UART_INSTANCE(huart->Instance));
   1378            
   1379            /* Process Locked */
   1380            __HAL_LOCK(huart);
   \                     HAL_MultiProcessor_EnterMuteMode: (+1)
   \   00000000   0xF990 0x1038      LDRSB    R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_MultiProcessor_EnterMuteMode_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_MultiProcessor_EnterMuteMode_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1381            
   1382            huart->gState = HAL_UART_STATE_BUSY;
   \   00000012   0x2124             MOVS     R1,#+36
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1383            
   1384            /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
   1385            SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68CA             LDR      R2,[R1, #+12]
   \   0000001C   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000020   0x60CA             STR      R2,[R1, #+12]
   1386            
   1387            huart->gState = HAL_UART_STATE_READY;
   \   00000022   0x2120             MOVS     R1,#+32
   \   00000024   0xF880 0x1039      STRB     R1,[R0, #+57]
   1388            
   1389            /* Process Unlocked */
   1390            __HAL_UNLOCK(huart);
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xF880 0x1038      STRB     R1,[R0, #+56]
   1391            
   1392            return HAL_OK; 
   \   0000002E   0x4608             MOV      R0,R1
   \   00000030   0x4770             BX       LR               ;; return
   1393          }
   1394          
   1395          /**
   1396            * @brief  Exits the UART mute mode: wake up software. 
   1397            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1398            *                the configuration information for the specified UART module.
   1399            * @retval HAL status
   1400            */

   \                                 In section .text, align 2, keep-with-next
   1401          HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
   1402          {
   1403            /* Check the parameters */
   1404            assert_param(IS_UART_INSTANCE(huart->Instance));
   1405            
   1406            /* Process Locked */
   1407            __HAL_LOCK(huart);
   \                     HAL_MultiProcessor_ExitMuteMode: (+1)
   \   00000000   0xF990 0x1038      LDRSB    R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_MultiProcessor_ExitMuteMode_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_MultiProcessor_ExitMuteMode_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1408            
   1409            huart->gState = HAL_UART_STATE_BUSY;
   \   00000012   0x2124             MOVS     R1,#+36
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1410            
   1411            /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
   1412            CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68CA             LDR      R2,[R1, #+12]
   \   0000001C   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000020   0x60CA             STR      R2,[R1, #+12]
   1413            
   1414            huart->gState = HAL_UART_STATE_READY;
   \   00000022   0x2120             MOVS     R1,#+32
   \   00000024   0xF880 0x1039      STRB     R1,[R0, #+57]
   1415            
   1416            /* Process Unlocked */
   1417            __HAL_UNLOCK(huart);
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xF880 0x1038      STRB     R1,[R0, #+56]
   1418            
   1419            return HAL_OK; 
   \   0000002E   0x4608             MOV      R0,R1
   \   00000030   0x4770             BX       LR               ;; return
   1420          }
   1421          
   1422          /**
   1423            * @brief  Enables the UART transmitter and disables the UART receiver.
   1424            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1425            *                the configuration information for the specified UART module.
   1426            * @retval HAL status
   1427            */

   \                                 In section .text, align 2, keep-with-next
   1428          HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
   1429          {
   1430            uint32_t tmpreg = 0x00U;
   1431          
   1432            /* Process Locked */
   1433            __HAL_LOCK(huart);
   \                     HAL_HalfDuplex_EnableTransmitter: (+1)
   \   00000000   0xF990 0x1038      LDRSB    R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_HalfDuplex_EnableTransmitter_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_HalfDuplex_EnableTransmitter_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1434            
   1435            huart->gState = HAL_UART_STATE_BUSY;
   \   00000012   0x2124             MOVS     R1,#+36
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1436          
   1437            /*-------------------------- USART CR1 Configuration -----------------------*/
   1438            tmpreg = huart->Instance->CR1;
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68CA             LDR      R2,[R1, #+12]
   1439            
   1440            /* Clear TE and RE bits */
   1441            tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
   1442            
   1443            /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
   1444            tmpreg |= (uint32_t)USART_CR1_TE;
   1445            
   1446            /* Write to USART CR1 */
   1447            WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
   \   0000001C   0xF022 0x020C      BIC      R2,R2,#0xC
   \   00000020   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000024   0x60CA             STR      R2,[R1, #+12]
   1448           
   1449            huart->gState = HAL_UART_STATE_READY;
   \   00000026   0x2120             MOVS     R1,#+32
   \   00000028   0xF880 0x1039      STRB     R1,[R0, #+57]
   1450            
   1451            /* Process Unlocked */
   1452            __HAL_UNLOCK(huart);
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1453            
   1454            return HAL_OK; 
   \   00000032   0x4608             MOV      R0,R1
   \   00000034   0x4770             BX       LR               ;; return
   1455          }
   1456          
   1457          /**
   1458            * @brief  Enables the UART receiver and disables the UART transmitter.
   1459            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1460            *                the configuration information for the specified UART module.
   1461            * @retval HAL status
   1462            */

   \                                 In section .text, align 2, keep-with-next
   1463          HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
   1464          {
   1465            uint32_t tmpreg = 0x00U;
   1466          
   1467            /* Process Locked */
   1468            __HAL_LOCK(huart);
   \                     HAL_HalfDuplex_EnableReceiver: (+1)
   \   00000000   0xF990 0x1038      LDRSB    R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_HalfDuplex_EnableReceiver_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_HalfDuplex_EnableReceiver_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1469            
   1470            huart->gState = HAL_UART_STATE_BUSY;
   \   00000012   0x2124             MOVS     R1,#+36
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1471          
   1472            /*-------------------------- USART CR1 Configuration -----------------------*/
   1473            tmpreg = huart->Instance->CR1;
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68CA             LDR      R2,[R1, #+12]
   1474            
   1475            /* Clear TE and RE bits */
   1476            tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
   1477            
   1478            /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
   1479            tmpreg |= (uint32_t)USART_CR1_RE;
   1480            
   1481            /* Write to USART CR1 */
   1482            WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
   \   0000001C   0xF022 0x020C      BIC      R2,R2,#0xC
   \   00000020   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000024   0x60CA             STR      R2,[R1, #+12]
   1483            
   1484            huart->gState = HAL_UART_STATE_READY;
   \   00000026   0x2120             MOVS     R1,#+32
   \   00000028   0xF880 0x1039      STRB     R1,[R0, #+57]
   1485            
   1486            /* Process Unlocked */
   1487            __HAL_UNLOCK(huart);
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1488            
   1489            return HAL_OK; 
   \   00000032   0x4608             MOV      R0,R1
   \   00000034   0x4770             BX       LR               ;; return
   1490          }
   1491          
   1492          /**
   1493            * @}
   1494            */
   1495          
   1496          /** @defgroup UART_Exported_Functions_Group4 Peripheral State and Errors functions 
   1497            *  @brief   UART State and Errors functions 
   1498            *
   1499          @verbatim   
   1500            ==============================================================================
   1501                           ##### Peripheral State and Errors functions #####
   1502            ==============================================================================  
   1503           [..]
   1504             This subsection provides a set of functions allowing to return the State of 
   1505             UART communication process, return Peripheral Errors occurred during communication 
   1506             process
   1507             (+) HAL_UART_GetState() API can be helpful to check in run-time the state of the UART peripheral.
   1508             (+) HAL_UART_GetError() check in run-time errors that could be occurred during communication. 
   1509          
   1510          @endverbatim
   1511            * @{
   1512            */
   1513            
   1514          /**
   1515            * @brief  Returns the UART state.
   1516            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1517            *                the configuration information for the specified UART module.
   1518            * @retval HAL state
   1519            */

   \                                 In section .text, align 2, keep-with-next
   1520          HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
   1521          {
   1522            uint32_t temp1= 0x00U, temp2 = 0x00U;
   1523            temp1 = huart->gState;
   \                     HAL_UART_GetState: (+1)
   \   00000000   0xF890 0x1039      LDRB     R1,[R0, #+57]
   1524            temp2 = huart->RxState;
   \   00000004   0xF890 0x003A      LDRB     R0,[R0, #+58]
   1525            
   1526            return (HAL_UART_StateTypeDef)(temp1 | temp2);
   \   00000008   0x4308             ORRS     R0,R0,R1
   \   0000000A   0x4770             BX       LR               ;; return
   1527          }
   1528          
   1529          /**
   1530            * @brief  Return the UART error code
   1531            * @param  huart : pointer to a UART_HandleTypeDef structure that contains
   1532            *              the configuration information for the specified UART.
   1533            * @retval UART Error Code
   1534            */

   \                                 In section .text, align 2, keep-with-next
   1535          uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
   1536          {
   1537            return huart->ErrorCode;
   \                     HAL_UART_GetError: (+1)
   \   00000000   0x6BC0             LDR      R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   1538          }
   1539          
   1540          /**
   1541            * @}
   1542            */
   1543          
   1544          /**
   1545            * @brief  DMA UART transmit process complete callback. 
   1546            * @param  hdma: DMA handle
   1547            * @retval None
   1548            */

   \                                 In section .text, align 4, keep-with-next
   1549          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   1550          {
   \                     UART_DMATransmitCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1551            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B81             LDR      R1,[R0, #+56]
   1552            /* DMA Normal mode*/
   1553            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x05C0             LSLS     R0,R0,#+23
   \   0000000A   0xD40C             BMI.N    ??UART_DMATransmitCplt_0
   1554            {
   1555              huart->TxXferCount = 0U;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x84C8             STRH     R0,[R1, #+38]
   1556          
   1557              /* Disable the DMA transfer for transmit request by setting the DMAT bit
   1558                 in the UART CR3 register */
   1559              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000010   0x6808             LDR      R0,[R1, #+0]
   \   00000012   0x6942             LDR      R2,[R0, #+20]
   \   00000014   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000018   0x6142             STR      R2,[R0, #+20]
   1560          
   1561              /* Enable the UART Transmit Complete Interrupt */
   1562              SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C1             LDR      R1,[R0, #+12]
   \   0000001E   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000022   0x60C1             STR      R1,[R0, #+12]
   \   00000024   0xBD01             POP      {R0,PC}
   1563          
   1564            }
   1565            /* DMA Circular mode */
   1566            else
   1567            {
   1568              HAL_UART_TxCpltCallback(huart);
   \                     ??UART_DMATransmitCplt_0: (+1)
   \   00000026   0x4608             MOV      R0,R1
   \   00000028   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1569            }
   1570          }
   \   0000002C   0xBD01             POP      {R0,PC}          ;; return
   1571          
   1572          /**
   1573            * @brief DMA UART transmit process half complete callback 
   1574            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1575            *                the configuration information for the specified DMA module.
   1576            * @retval None
   1577            */

   \                                 In section .text, align 4, keep-with-next
   1578          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   1579          {
   \                     UART_DMATxHalfCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1580            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   1581          
   1582            HAL_UART_TxHalfCpltCallback(huart);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_UART_TxHalfCpltCallback
   1583          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1584          
   1585          /**
   1586            * @brief  DMA UART receive process complete callback. 
   1587            * @param  hdma: DMA handle
   1588            * @retval None
   1589            */

   \                                 In section .text, align 4, keep-with-next
   1590          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   1591          {
   \                     UART_DMAReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x4601             MOV      R1,R0
   1592            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B88             LDR      R0,[R1, #+56]
   1593            /* DMA Normal mode*/
   1594            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x05C9             LSLS     R1,R1,#+23
   \   0000000C   0xD413             BMI.N    ??UART_DMAReceiveCplt_0
   1595            {
   1596              huart->RxXferCount = 0U;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x85C1             STRH     R1,[R0, #+46]
   1597            
   1598              /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   1599              CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x68CA             LDR      R2,[R1, #+12]
   \   00000016   0xF422 0x7280      BIC      R2,R2,#0x100
   \   0000001A   0x60CA             STR      R2,[R1, #+12]
   1600              CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x694A             LDR      R2,[R1, #+20]
   \   00000020   0x0852             LSRS     R2,R2,#+1
   \   00000022   0x0052             LSLS     R2,R2,#+1
   \   00000024   0x614A             STR      R2,[R1, #+20]
   1601              
   1602              /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
   1603                 in the UART CR3 register */
   1604              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x694A             LDR      R2,[R1, #+20]
   \   0000002A   0xF022 0x0240      BIC      R2,R2,#0x40
   \   0000002E   0x614A             STR      R2,[R1, #+20]
   1605          	
   1606              /* At end of Rx process, restore huart->RxState to Ready */
   1607              huart->RxState = HAL_UART_STATE_READY;
   \   00000030   0x2120             MOVS     R1,#+32
   \   00000032   0xF880 0x103A      STRB     R1,[R0, #+58]
   1608            }
   1609            HAL_UART_RxCpltCallback(huart);
   \                     ??UART_DMAReceiveCplt_0: (+1)
   \   00000036   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1610          }
   \   0000003A   0xBD01             POP      {R0,PC}          ;; return
   1611          
   1612          /**
   1613            * @brief DMA UART receive process half complete callback 
   1614            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1615            *                the configuration information for the specified DMA module.
   1616            * @retval None
   1617            */

   \                                 In section .text, align 4, keep-with-next
   1618          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   1619          {
   \                     UART_DMARxHalfCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1620            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   1621          
   1622            HAL_UART_RxHalfCpltCallback(huart); 
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_UART_RxHalfCpltCallback
   1623          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1624          
   1625          /**
   1626            * @brief  DMA UART communication error callback.
   1627            * @param  hdma: DMA handle
   1628            * @retval None
   1629            */

   \                                 In section .text, align 4, keep-with-next
   1630          static void UART_DMAError(DMA_HandleTypeDef *hdma)
   1631          {
   \                     UART_DMAError: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1632            uint32_t dmarequest = 0x00U;
   1633            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B84             LDR      R4,[R0, #+56]
   1634          
   1635            /* Stop UART DMA Tx request if ongoing */
   1636            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6940             LDR      R0,[R0, #+20]
   \   00000008   0x09C0             LSRS     R0,R0,#+7
   \   0000000A   0xF000 0x0001      AND      R0,R0,#0x1
   1637            if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
   \   0000000E   0xF894 0x1039      LDRB     R1,[R4, #+57]
   \   00000012   0x2921             CMP      R1,#+33
   \   00000014   0xD106             BNE.N    ??UART_DMAError_0
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??UART_DMAError_0
   1638            {
   1639              huart->TxXferCount = 0U;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x84E0             STRH     R0,[R4, #+38]
   1640              UART_EndTxTransfer(huart);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       UART_EndTxTransfer
   1641            }
   1642          
   1643            /* Stop UART DMA Rx request if ongoing */
   1644            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR); 
   \                     ??UART_DMAError_0: (+1)
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6940             LDR      R0,[R0, #+20]
   \   00000028   0x0980             LSRS     R0,R0,#+6
   \   0000002A   0xF000 0x0001      AND      R0,R0,#0x1
   1645            if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
   \   0000002E   0xF894 0x103A      LDRB     R1,[R4, #+58]
   \   00000032   0x2922             CMP      R1,#+34
   \   00000034   0xD106             BNE.N    ??UART_DMAError_1
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD004             BEQ.N    ??UART_DMAError_1
   1646            {
   1647              huart->RxXferCount = 0U;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x85E0             STRH     R0,[R4, #+46]
   1648              UART_EndRxTransfer(huart);
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       UART_EndRxTransfer
   1649            }
   1650          
   1651            huart->ErrorCode |= HAL_UART_ERROR_DMA;
   \                     ??UART_DMAError_1: (+1)
   \   00000044   0x6BE0             LDR      R0,[R4, #+60]
   \   00000046   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000004A   0x63E0             STR      R0,[R4, #+60]
   1652            HAL_UART_ErrorCallback(huart);
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1653          }
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
   1654          
   1655          /**
   1656            * @brief  This function handles UART Communication Timeout.
   1657            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1658            *                the configuration information for the specified UART module.
   1659            * @param  Flag: specifies the UART flag to check.
   1660            * @param  Status: The new Flag status (SET or RESET).
   1661            * @param  Tickstart Tick start value
   1662            * @param  Timeout: Timeout duration
   1663            * @retval HAL status
   1664            */

   \                                 In section .text, align 2, keep-with-next
   1665          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
   1666          {
   \                     UART_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
   \   0000000C   0xF8DD 0x8018      LDR      R8,[SP, #+24]
   1667            /* Wait until flag is set */
   1668            while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status) 
   \                     ??UART_WaitOnFlagUntilTimeout_0: (+1)
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x4028             ANDS     R0,R5,R0
   \   00000016   0x42A8             CMP      R0,R5
   \   00000018   0xD101             BNE.N    ??UART_WaitOnFlagUntilTimeout_1
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE000             B.N      ??UART_WaitOnFlagUntilTimeout_2
   \                     ??UART_WaitOnFlagUntilTimeout_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \                     ??UART_WaitOnFlagUntilTimeout_2: (+1)
   \   00000020   0x42B0             CMP      R0,R6
   \   00000022   0xD11E             BNE.N    ??UART_WaitOnFlagUntilTimeout_3
   1669            {
   1670              /* Check for the Timeout */
   1671              if(Timeout != HAL_MAX_DELAY)
   \   00000024   0xF118 0x0F01      CMN      R8,#+1
   \   00000028   0xD0F2             BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
   1672              {
   1673                if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
   \   0000002A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002E   0xD004             BEQ.N    ??UART_WaitOnFlagUntilTimeout_4
   \   00000030   0x.... 0x....      BL       HAL_GetTick
   \   00000034   0x1BC0             SUBS     R0,R0,R7
   \   00000036   0x4580             CMP      R8,R0
   \   00000038   0xD2EA             BCS.N    ??UART_WaitOnFlagUntilTimeout_0
   1674                {
   1675                  /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1676                  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
   \                     ??UART_WaitOnFlagUntilTimeout_4: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C1             LDR      R1,[R0, #+12]
   \   0000003E   0xF421 0x71D0      BIC      R1,R1,#0x1A0
   \   00000042   0x60C1             STR      R1,[R0, #+12]
   1677                  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6941             LDR      R1,[R0, #+20]
   \   00000048   0x0849             LSRS     R1,R1,#+1
   \   0000004A   0x0049             LSLS     R1,R1,#+1
   \   0000004C   0x6141             STR      R1,[R0, #+20]
   1678                  
   1679                  huart->gState  = HAL_UART_STATE_READY;
   \   0000004E   0x2020             MOVS     R0,#+32
   \   00000050   0xF884 0x0039      STRB     R0,[R4, #+57]
   1680                  huart->RxState = HAL_UART_STATE_READY;
   \   00000054   0xF884 0x003A      STRB     R0,[R4, #+58]
   1681                  
   1682                  /* Process Unlocked */
   1683                  __HAL_UNLOCK(huart);
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF884 0x0038      STRB     R0,[R4, #+56]
   1684                  
   1685                  return HAL_TIMEOUT;
   \   0000005E   0x2003             MOVS     R0,#+3
   \   00000060   0xE000             B.N      ??UART_WaitOnFlagUntilTimeout_5
   1686                }
   1687              }
   1688            }
   1689            
   1690            return HAL_OK;
   \                     ??UART_WaitOnFlagUntilTimeout_3: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??UART_WaitOnFlagUntilTimeout_5: (+1)
   \   00000064   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1691          }
   1692          
   1693          /**
   1694            * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).
   1695            * @param  huart: UART handle.
   1696            * @retval None
   1697            */

   \                                 In section .text, align 2, keep-with-next
   1698          static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
   1699          {
   1700            /* Disable TXEIE and TCIE interrupts */
   1701            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
   \                     UART_EndTxTransfer: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68CA             LDR      R2,[R1, #+12]
   \   00000004   0xF022 0x02C0      BIC      R2,R2,#0xC0
   \   00000008   0x60CA             STR      R2,[R1, #+12]
   1702          
   1703            /* At end of Tx process, restore huart->gState to Ready */
   1704            huart->gState = HAL_UART_STATE_READY;
   \   0000000A   0x2120             MOVS     R1,#+32
   \   0000000C   0xF880 0x1039      STRB     R1,[R0, #+57]
   1705          }
   \   00000010   0x4770             BX       LR               ;; return
   1706          
   1707          /**
   1708            * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
   1709            * @param  huart: UART handle.
   1710            * @retval None
   1711            */

   \                                 In section .text, align 2, keep-with-next
   1712          static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
   1713          {
   1714            /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   1715            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
   \                     UART_EndRxTransfer: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68CA             LDR      R2,[R1, #+12]
   \   00000004   0xF422 0x7290      BIC      R2,R2,#0x120
   \   00000008   0x60CA             STR      R2,[R1, #+12]
   1716            CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x694A             LDR      R2,[R1, #+20]
   \   0000000E   0x0852             LSRS     R2,R2,#+1
   \   00000010   0x0052             LSLS     R2,R2,#+1
   \   00000012   0x614A             STR      R2,[R1, #+20]
   1717          
   1718            /* At end of Rx process, restore huart->RxState to Ready */
   1719            huart->RxState = HAL_UART_STATE_READY;
   \   00000014   0x2120             MOVS     R1,#+32
   \   00000016   0xF880 0x103A      STRB     R1,[R0, #+58]
   1720          }
   \   0000001A   0x4770             BX       LR               ;; return
   1721          
   1722          /**
   1723            * @brief  DMA UART communication abort callback, when initiated by HAL services on Error
   1724            *         (To be called at end of DMA Abort procedure following error occurrence).
   1725            * @param  hdma DMA handle.
   1726            * @retval None
   1727            */

   \                                 In section .text, align 4, keep-with-next
   1728          static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
   1729          {
   \                     UART_DMAAbortOnError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1730            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   1731            huart->RxXferCount = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x85C1             STRH     R1,[R0, #+46]
   1732            huart->TxXferCount = 0;
   \   00000008   0x84C1             STRH     R1,[R0, #+38]
   1733          
   1734            HAL_UART_ErrorCallback(huart);
   \   0000000A   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1735          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   1736          
   1737          /**
   1738            * @brief  Sends an amount of data in non blocking mode.
   1739            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1740            *                the configuration information for the specified UART module.
   1741            * @retval HAL status
   1742            */

   \                                 In section .text, align 2, keep-with-next
   1743          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
   1744          {
   1745            uint16_t* tmp;
   1746            
   1747            /* Check that a Tx process is ongoing */
   1748            if(huart->gState == HAL_UART_STATE_BUSY_TX)
   \                     UART_Transmit_IT: (+1)
   \   00000000   0xF890 0x1039      LDRB     R1,[R0, #+57]
   \   00000004   0x2921             CMP      R1,#+33
   \   00000006   0xD12A             BNE.N    ??UART_Transmit_IT_0
   1749            {
   1750              if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \   00000008   0x6A01             LDR      R1,[R0, #+32]
   \   0000000A   0x6882             LDR      R2,[R0, #+8]
   \   0000000C   0xF5B2 0x5F80      CMP      R2,#+4096
   \   00000010   0xD10E             BNE.N    ??UART_Transmit_IT_1
   1751              {
   1752                tmp = (uint16_t*) huart->pTxBuffPtr;
   1753                huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FFU);
   \   00000012   0x8809             LDRH     R1,[R1, #+0]
   \   00000014   0x05C9             LSLS     R1,R1,#+23
   \   00000016   0x0DC9             LSRS     R1,R1,#+23
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x6051             STR      R1,[R2, #+4]
   1754                if(huart->Init.Parity == UART_PARITY_NONE)
   \   0000001C   0x6A01             LDR      R1,[R0, #+32]
   \   0000001E   0x6902             LDR      R2,[R0, #+16]
   \   00000020   0x2A00             CMP      R2,#+0
   \   00000022   0xD102             BNE.N    ??UART_Transmit_IT_2
   1755                {
   1756                  huart->pTxBuffPtr += 2U;
   \   00000024   0x1C89             ADDS     R1,R1,#+2
   \   00000026   0x6201             STR      R1,[R0, #+32]
   \   00000028   0xE007             B.N      ??UART_Transmit_IT_3
   1757                }
   1758                else
   1759                {
   1760                  huart->pTxBuffPtr += 1U;
   \                     ??UART_Transmit_IT_2: (+1)
   \   0000002A   0x1C49             ADDS     R1,R1,#+1
   \   0000002C   0x6201             STR      R1,[R0, #+32]
   \   0000002E   0xE004             B.N      ??UART_Transmit_IT_3
   1761                }
   1762              } 
   1763              else
   1764              {
   1765                huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FFU);
   \                     ??UART_Transmit_IT_1: (+1)
   \   00000030   0x1C4A             ADDS     R2,R1,#+1
   \   00000032   0x6202             STR      R2,[R0, #+32]
   \   00000034   0x7809             LDRB     R1,[R1, #+0]
   \   00000036   0x6802             LDR      R2,[R0, #+0]
   \   00000038   0x6051             STR      R1,[R2, #+4]
   1766              }
   1767          
   1768              if(--huart->TxXferCount == 0U)
   \                     ??UART_Transmit_IT_3: (+1)
   \   0000003A   0x8CC1             LDRH     R1,[R0, #+38]
   \   0000003C   0x1E49             SUBS     R1,R1,#+1
   \   0000003E   0x84C1             STRH     R1,[R0, #+38]
   \   00000040   0xB289             UXTH     R1,R1
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xD109             BNE.N    ??UART_Transmit_IT_4
   1769              {
   1770                /* Disable the UART Transmit Complete Interrupt */
   1771                CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x68CA             LDR      R2,[R1, #+12]
   \   0000004A   0xF022 0x0280      BIC      R2,R2,#0x80
   \   0000004E   0x60CA             STR      R2,[R1, #+12]
   1772          
   1773                /* Enable the UART Transmit Complete Interrupt */    
   1774                SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x68C1             LDR      R1,[R0, #+12]
   \   00000054   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000058   0x60C1             STR      R1,[R0, #+12]
   1775              }
   1776              return HAL_OK;
   \                     ??UART_Transmit_IT_4: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x4770             BX       LR
   1777            }
   1778            else
   1779            {
   1780              return HAL_BUSY;
   \                     ??UART_Transmit_IT_0: (+1)
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x4770             BX       LR               ;; return
   1781            }
   1782          }
   1783          
   1784          /**
   1785            * @brief  Wraps up transmission in non blocking mode.
   1786            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1787            *                the configuration information for the specified UART module.
   1788            * @retval HAL status
   1789            */

   \                                 In section .text, align 2, keep-with-next
   1790          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
   1791          {
   \                     UART_EndTransmit_IT: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1792            /* Disable the UART Transmit Complete Interrupt */    
   1793            CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x68CA             LDR      R2,[R1, #+12]
   \   00000006   0xF022 0x0240      BIC      R2,R2,#0x40
   \   0000000A   0x60CA             STR      R2,[R1, #+12]
   1794            
   1795            /* Tx process is ended, restore huart->gState to Ready */
   1796            huart->gState = HAL_UART_STATE_READY;
   \   0000000C   0x2120             MOVS     R1,#+32
   \   0000000E   0xF880 0x1039      STRB     R1,[R0, #+57]
   1797              
   1798            HAL_UART_TxCpltCallback(huart);
   \   00000012   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1799            
   1800            return HAL_OK;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
   1801          }
   1802          
   1803          /**
   1804            * @brief  Receives an amount of data in non blocking mode 
   1805            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1806            *                the configuration information for the specified UART module.
   1807            * @retval HAL status
   1808            */

   \                                 In section .text, align 2, keep-with-next
   1809          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
   1810          {
   \                     UART_Receive_IT: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1811            uint16_t* tmp;
   1812            
   1813            /* Check that a Rx process is ongoing */
   1814            if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
   \   00000002   0xF890 0x103A      LDRB     R1,[R0, #+58]
   \   00000006   0x2922             CMP      R1,#+34
   \   00000008   0xD13E             BNE.N    ??UART_Receive_IT_0
   1815            {
   1816              if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \   0000000A   0x6902             LDR      R2,[R0, #+16]
   \   0000000C   0x6A81             LDR      R1,[R0, #+40]
   \   0000000E   0x6883             LDR      R3,[R0, #+8]
   \   00000010   0xF5B3 0x5F80      CMP      R3,#+4096
   \   00000014   0xD110             BNE.N    ??UART_Receive_IT_1
   1817              {
   1818                tmp = (uint16_t*) huart->pRxBuffPtr;
   1819                if(huart->Init.Parity == UART_PARITY_NONE)
   \   00000016   0x6803             LDR      R3,[R0, #+0]
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0x685A             LDR      R2,[R3, #+4]
   \   0000001C   0xD106             BNE.N    ??UART_Receive_IT_2
   1820                {
   1821                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FFU);
   \   0000001E   0x05D2             LSLS     R2,R2,#+23
   \   00000020   0x0DD2             LSRS     R2,R2,#+23
   \   00000022   0x800A             STRH     R2,[R1, #+0]
   1822                  huart->pRxBuffPtr += 2U;
   \   00000024   0x6A81             LDR      R1,[R0, #+40]
   \   00000026   0x1C89             ADDS     R1,R1,#+2
   \   00000028   0x6281             STR      R1,[R0, #+40]
   \   0000002A   0xE014             B.N      ??UART_Receive_IT_3
   1823                }
   1824                else
   1825                {
   1826                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FFU);
   \                     ??UART_Receive_IT_2: (+1)
   \   0000002C   0xB2D2             UXTB     R2,R2
   \   0000002E   0x800A             STRH     R2,[R1, #+0]
   1827                  huart->pRxBuffPtr += 1U;
   \   00000030   0x6A81             LDR      R1,[R0, #+40]
   \   00000032   0x1C49             ADDS     R1,R1,#+1
   \   00000034   0x6281             STR      R1,[R0, #+40]
   \   00000036   0xE00E             B.N      ??UART_Receive_IT_3
   1828                }
   1829              }
   1830              else
   1831              {
   1832                if(huart->Init.Parity == UART_PARITY_NONE)
   \                     ??UART_Receive_IT_1: (+1)
   \   00000038   0x2A00             CMP      R2,#+0
   \   0000003A   0xD105             BNE.N    ??UART_Receive_IT_4
   1833                {
   1834                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FFU);
   \   0000003C   0x1C4A             ADDS     R2,R1,#+1
   \   0000003E   0x6282             STR      R2,[R0, #+40]
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x6852             LDR      R2,[R2, #+4]
   \   00000044   0x700A             STRB     R2,[R1, #+0]
   \   00000046   0xE006             B.N      ??UART_Receive_IT_3
   1835                }
   1836                else
   1837                {
   1838                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007FU);
   \                     ??UART_Receive_IT_4: (+1)
   \   00000048   0x1C4A             ADDS     R2,R1,#+1
   \   0000004A   0x6282             STR      R2,[R0, #+40]
   \   0000004C   0x6802             LDR      R2,[R0, #+0]
   \   0000004E   0x6852             LDR      R2,[R2, #+4]
   \   00000050   0xF002 0x027F      AND      R2,R2,#0x7F
   \   00000054   0x700A             STRB     R2,[R1, #+0]
   1839                }
   1840              }
   1841          
   1842              if(--huart->RxXferCount == 0U)
   \                     ??UART_Receive_IT_3: (+1)
   \   00000056   0x8DC1             LDRH     R1,[R0, #+46]
   \   00000058   0x1E49             SUBS     R1,R1,#+1
   \   0000005A   0x85C1             STRH     R1,[R0, #+46]
   \   0000005C   0xB289             UXTH     R1,R1
   \   0000005E   0x2900             CMP      R1,#+0
   \   00000060   0xD110             BNE.N    ??UART_Receive_IT_5
   1843              {
   1844                /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
   1845                CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0x68CA             LDR      R2,[R1, #+12]
   \   00000066   0xF422 0x7290      BIC      R2,R2,#0x120
   \   0000006A   0x60CA             STR      R2,[R1, #+12]
   1846          
   1847                /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1848                CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0x694A             LDR      R2,[R1, #+20]
   \   00000070   0x0852             LSRS     R2,R2,#+1
   \   00000072   0x0052             LSLS     R2,R2,#+1
   \   00000074   0x614A             STR      R2,[R1, #+20]
   1849          
   1850                /* Rx process is completed, restore huart->RxState to Ready */
   1851                huart->RxState = HAL_UART_STATE_READY;
   \   00000076   0x2120             MOVS     R1,#+32
   \   00000078   0xF880 0x103A      STRB     R1,[R0, #+58]
   1852               
   1853                HAL_UART_RxCpltCallback(huart);
   \   0000007C   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1854          
   1855                return HAL_OK;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xBD02             POP      {R1,PC}
   1856              }
   1857              return HAL_OK;
   \                     ??UART_Receive_IT_5: (+1)
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xBD02             POP      {R1,PC}
   1858            }
   1859            else
   1860            {
   1861              return HAL_BUSY;
   \                     ??UART_Receive_IT_0: (+1)
   \   00000088   0x2002             MOVS     R0,#+2
   \   0000008A   0xBD02             POP      {R1,PC}          ;; return
   1862            }
   1863          }
   1864          
   1865          /**
   1866            * @brief  Configures the UART peripheral. 
   1867            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1868            *                the configuration information for the specified UART module.
   1869            * @retval None
   1870            */

   \                                 In section .text, align 2, keep-with-next
   1871          static void UART_SetConfig(UART_HandleTypeDef *huart)
   1872          {
   \                     UART_SetConfig: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   1873            uint32_t tmpreg = 0x00U;
   1874            
   1875            /* Check the parameters */
   1876            assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
   1877            assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
   1878            assert_param(IS_UART_PARITY(huart->Init.Parity));
   1879            assert_param(IS_UART_MODE(huart->Init.Mode));
   1880          
   1881            /*-------------------------- USART CR2 Configuration -----------------------*/
   1882            tmpreg = huart->Instance->CR2;
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6901             LDR      R1,[R0, #+16]
   1883          
   1884            /* Clear STOP[13:12] bits */
   1885            tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
   1886          
   1887            /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
   1888            tmpreg |= (uint32_t)huart->Init.StopBits;
   1889            
   1890            /* Write to USART CR2 */
   1891            WRITE_REG(huart->Instance->CR2, (uint32_t)tmpreg);
   \   0000000A   0xF421 0x5140      BIC      R1,R1,#0x3000
   \   0000000E   0x68E2             LDR      R2,[R4, #+12]
   \   00000010   0x4311             ORRS     R1,R2,R1
   \   00000012   0x6101             STR      R1,[R0, #+16]
   1892          
   1893            /*-------------------------- USART CR1 Configuration -----------------------*/
   1894            tmpreg = huart->Instance->CR1;
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x68C1             LDR      R1,[R0, #+12]
   1895          
   1896            /* Clear M, PCE, PS, TE and RE bits */
   1897            tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
   1898                                             USART_CR1_RE | USART_CR1_OVER8));
   1899          
   1900            /* Configure the UART Word Length, Parity and mode: 
   1901               Set the M bits according to huart->Init.WordLength value 
   1902               Set PCE and PS bits according to huart->Init.Parity value
   1903               Set TE and RE bits according to huart->Init.Mode value
   1904               Set OVER8 bit according to huart->Init.OverSampling value */
   1905            tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
   1906            
   1907            /* Write to USART CR1 */
   1908            WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
   \   00000018   0x....             LDR.N    R2,??DataTable0  ;; 0xffff69f3
   \   0000001A   0x4011             ANDS     R1,R2,R1
   \   0000001C   0x68A2             LDR      R2,[R4, #+8]
   \   0000001E   0x4311             ORRS     R1,R2,R1
   \   00000020   0x6922             LDR      R2,[R4, #+16]
   \   00000022   0x4311             ORRS     R1,R2,R1
   \   00000024   0x6962             LDR      R2,[R4, #+20]
   \   00000026   0x4311             ORRS     R1,R2,R1
   \   00000028   0x69E2             LDR      R2,[R4, #+28]
   \   0000002A   0x4311             ORRS     R1,R2,R1
   \   0000002C   0x60C1             STR      R1,[R0, #+12]
   1909            
   1910            /*-------------------------- USART CR3 Configuration -----------------------*/  
   1911            tmpreg = huart->Instance->CR3;
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6941             LDR      R1,[R0, #+20]
   1912            
   1913            /* Clear CTSE and RTSE bits */
   1914            tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
   1915            
   1916            /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
   1917            tmpreg |= huart->Init.HwFlowCtl;
   1918            
   1919            /* Write to USART CR3 */
   1920            WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
   \   00000032   0xF421 0x7140      BIC      R1,R1,#0x300
   \   00000036   0x69A2             LDR      R2,[R4, #+24]
   \   00000038   0x4311             ORRS     R1,R2,R1
   \   0000003A   0x6141             STR      R1,[R0, #+20]
   1921            
   1922            /* Check the Over Sampling */
   1923            if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40011000
   \   00000040   0x69E2             LDR      R2,[R4, #+28]
   \   00000042   0xF5B2 0x4F00      CMP      R2,#+32768
   \   00000046   0xF040 0x808F      BNE.W    ??UART_SetConfig_0
   1924            {
   1925              /*-------------------------- USART BRR Configuration ---------------------*/
   1926              if((huart->Instance == USART1) || (huart->Instance == USART6))
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD002             BEQ.N    ??UART_SetConfig_1
   \   0000004E   0x....             LDR.N    R1,??DataTable0_2  ;; 0x40011400
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD144             BNE.N    ??UART_SetConfig_2
   1927              {
   1928                huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
   \                     ??UART_SetConfig_1: (+1)
   \   00000054   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000058   0x4682             MOV      R10,R0
   \   0000005A   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000005E   0x4607             MOV      R7,R0
   \   00000060   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000064   0x4680             MOV      R8,R0
   \   00000066   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000006A   0x6861             LDR      R1,[R4, #+4]
   \   0000006C   0xEA4F 0x0941      LSL      R9,R1,#+1
   \   00000070   0x2564             MOVS     R5,#+100
   \   00000072   0x2619             MOVS     R6,#+25
   \   00000074   0xFB06 0xF10A      MUL      R1,R6,R10
   \   00000078   0xFBB1 0xF1F9      UDIV     R1,R1,R9
   \   0000007C   0x462A             MOV      R2,R5
   \   0000007E   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000082   0xFB06 0xF207      MUL      R2,R6,R7
   \   00000086   0xFBB2 0xF2F9      UDIV     R2,R2,R9
   \   0000008A   0xFB06 0xF308      MUL      R3,R6,R8
   \   0000008E   0xFBB3 0xF3F9      UDIV     R3,R3,R9
   \   00000092   0x462F             MOV      R7,R5
   \   00000094   0xFBB3 0xF3F7      UDIV     R3,R3,R7
   \   00000098   0xFB05 0x2213      MLS      R2,R5,R3,R2
   \   0000009C   0x00D2             LSLS     R2,R2,#+3
   \   0000009E   0x3232             ADDS     R2,R2,#+50
   \   000000A0   0x462B             MOV      R3,R5
   \   000000A2   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000000A6   0xF002 0x02F8      AND      R2,R2,#0xF8
   \   000000AA   0x0052             LSLS     R2,R2,#+1
   \   000000AC   0xEB02 0x1701      ADD      R7,R2,R1, LSL #+4
   \   000000B0   0x4370             MULS     R0,R6,R0
   \   000000B2   0xFBB0 0xF8F9      UDIV     R8,R0,R9
   \   000000B6   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000000BA   0x4370             MULS     R0,R6,R0
   \   000000BC   0xFBB0 0xF0F9      UDIV     R0,R0,R9
   \   000000C0   0x4629             MOV      R1,R5
   \   000000C2   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000C6   0xFB05 0x8010      MLS      R0,R5,R0,R8
   \   000000CA   0x00C0             LSLS     R0,R0,#+3
   \   000000CC   0x3032             ADDS     R0,R0,#+50
   \   000000CE   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000D2   0xF000 0x0007      AND      R0,R0,#0x7
   \   000000D6   0x19C0             ADDS     R0,R0,R7
   \   000000D8   0x6821             LDR      R1,[R4, #+0]
   \   000000DA   0x6088             STR      R0,[R1, #+8]
   \   000000DC   0xE0D0             B.N      ??UART_SetConfig_3
   1929              }
   1930              else
   1931              {
   1932                huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
   \                     ??UART_SetConfig_2: (+1)
   \   000000DE   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000E2   0x4682             MOV      R10,R0
   \   000000E4   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000E8   0x4607             MOV      R7,R0
   \   000000EA   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000EE   0x4680             MOV      R8,R0
   \   000000F0   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000F4   0x6861             LDR      R1,[R4, #+4]
   \   000000F6   0xEA4F 0x0941      LSL      R9,R1,#+1
   \   000000FA   0x2564             MOVS     R5,#+100
   \   000000FC   0x2619             MOVS     R6,#+25
   \   000000FE   0xFB06 0xF10A      MUL      R1,R6,R10
   \   00000102   0xFBB1 0xF1F9      UDIV     R1,R1,R9
   \   00000106   0x462A             MOV      R2,R5
   \   00000108   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000010C   0xFB06 0xF207      MUL      R2,R6,R7
   \   00000110   0xFBB2 0xF2F9      UDIV     R2,R2,R9
   \   00000114   0xFB06 0xF308      MUL      R3,R6,R8
   \   00000118   0xFBB3 0xF3F9      UDIV     R3,R3,R9
   \   0000011C   0x462F             MOV      R7,R5
   \   0000011E   0xFBB3 0xF3F7      UDIV     R3,R3,R7
   \   00000122   0xFB05 0x2213      MLS      R2,R5,R3,R2
   \   00000126   0x00D2             LSLS     R2,R2,#+3
   \   00000128   0x3232             ADDS     R2,R2,#+50
   \   0000012A   0x462B             MOV      R3,R5
   \   0000012C   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000130   0xF002 0x02F8      AND      R2,R2,#0xF8
   \   00000134   0x0052             LSLS     R2,R2,#+1
   \   00000136   0xEB02 0x1701      ADD      R7,R2,R1, LSL #+4
   \   0000013A   0x4370             MULS     R0,R6,R0
   \   0000013C   0xFBB0 0xF8F9      UDIV     R8,R0,R9
   \   00000140   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000144   0x4370             MULS     R0,R6,R0
   \   00000146   0xFBB0 0xF0F9      UDIV     R0,R0,R9
   \   0000014A   0x4629             MOV      R1,R5
   \   0000014C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000150   0xFB05 0x8010      MLS      R0,R5,R0,R8
   \   00000154   0x00C0             LSLS     R0,R0,#+3
   \   00000156   0x3032             ADDS     R0,R0,#+50
   \   00000158   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000015C   0xF000 0x0007      AND      R0,R0,#0x7
   \   00000160   0x19C0             ADDS     R0,R0,R7
   \   00000162   0x6821             LDR      R1,[R4, #+0]
   \   00000164   0x6088             STR      R0,[R1, #+8]
   \   00000166   0xE08B             B.N      ??UART_SetConfig_3
   1933              }
   1934            }
   1935            else
   1936            {
   1937              /*-------------------------- USART BRR Configuration ---------------------*/
   1938              if((huart->Instance == USART1) || (huart->Instance == USART6))
   \                     ??UART_SetConfig_0: (+1)
   \   00000168   0x4288             CMP      R0,R1
   \   0000016A   0xD002             BEQ.N    ??UART_SetConfig_4
   \   0000016C   0x....             LDR.N    R1,??DataTable0_2  ;; 0x40011400
   \   0000016E   0x4288             CMP      R0,R1
   \   00000170   0xD143             BNE.N    ??UART_SetConfig_5
   1939              {
   1940                huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
   \                     ??UART_SetConfig_4: (+1)
   \   00000172   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000176   0x4682             MOV      R10,R0
   \   00000178   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000017C   0x4607             MOV      R7,R0
   \   0000017E   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000182   0x4680             MOV      R8,R0
   \   00000184   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000188   0x6861             LDR      R1,[R4, #+4]
   \   0000018A   0xEA4F 0x0981      LSL      R9,R1,#+2
   \   0000018E   0x2564             MOVS     R5,#+100
   \   00000190   0x2619             MOVS     R6,#+25
   \   00000192   0xFB06 0xF10A      MUL      R1,R6,R10
   \   00000196   0xFBB1 0xF1F9      UDIV     R1,R1,R9
   \   0000019A   0x462A             MOV      R2,R5
   \   0000019C   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000001A0   0xFB06 0xF207      MUL      R2,R6,R7
   \   000001A4   0xFBB2 0xF2F9      UDIV     R2,R2,R9
   \   000001A8   0xFB06 0xF308      MUL      R3,R6,R8
   \   000001AC   0xFBB3 0xF3F9      UDIV     R3,R3,R9
   \   000001B0   0x462F             MOV      R7,R5
   \   000001B2   0xFBB3 0xF3F7      UDIV     R3,R3,R7
   \   000001B6   0xFB05 0x2213      MLS      R2,R5,R3,R2
   \   000001BA   0x0112             LSLS     R2,R2,#+4
   \   000001BC   0x3232             ADDS     R2,R2,#+50
   \   000001BE   0x462B             MOV      R3,R5
   \   000001C0   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000001C4   0xF002 0x02F0      AND      R2,R2,#0xF0
   \   000001C8   0xEB02 0x1701      ADD      R7,R2,R1, LSL #+4
   \   000001CC   0x4370             MULS     R0,R6,R0
   \   000001CE   0xFBB0 0xF8F9      UDIV     R8,R0,R9
   \   000001D2   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000001D6   0x4370             MULS     R0,R6,R0
   \   000001D8   0xFBB0 0xF0F9      UDIV     R0,R0,R9
   \   000001DC   0x4629             MOV      R1,R5
   \   000001DE   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001E2   0xFB05 0x8010      MLS      R0,R5,R0,R8
   \   000001E6   0x0100             LSLS     R0,R0,#+4
   \   000001E8   0x3032             ADDS     R0,R0,#+50
   \   000001EA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001EE   0xF000 0x000F      AND      R0,R0,#0xF
   \   000001F2   0x19C0             ADDS     R0,R0,R7
   \   000001F4   0x6821             LDR      R1,[R4, #+0]
   \   000001F6   0x6088             STR      R0,[R1, #+8]
   \   000001F8   0xE042             B.N      ??UART_SetConfig_3
   1941              }
   1942              else
   1943              {
   1944                huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
   \                     ??UART_SetConfig_5: (+1)
   \   000001FA   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000001FE   0x4682             MOV      R10,R0
   \   00000200   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000204   0x4607             MOV      R7,R0
   \   00000206   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   0000020A   0x4680             MOV      R8,R0
   \   0000020C   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000210   0x6861             LDR      R1,[R4, #+4]
   \   00000212   0xEA4F 0x0981      LSL      R9,R1,#+2
   \   00000216   0x2564             MOVS     R5,#+100
   \   00000218   0x2619             MOVS     R6,#+25
   \   0000021A   0xFB06 0xF10A      MUL      R1,R6,R10
   \   0000021E   0xFBB1 0xF1F9      UDIV     R1,R1,R9
   \   00000222   0x462A             MOV      R2,R5
   \   00000224   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000228   0xFB06 0xF207      MUL      R2,R6,R7
   \   0000022C   0xFBB2 0xF2F9      UDIV     R2,R2,R9
   \   00000230   0xFB06 0xF308      MUL      R3,R6,R8
   \   00000234   0xFBB3 0xF3F9      UDIV     R3,R3,R9
   \   00000238   0x462F             MOV      R7,R5
   \   0000023A   0xFBB3 0xF3F7      UDIV     R3,R3,R7
   \   0000023E   0xFB05 0x2213      MLS      R2,R5,R3,R2
   \   00000242   0x0112             LSLS     R2,R2,#+4
   \   00000244   0x3232             ADDS     R2,R2,#+50
   \   00000246   0x462B             MOV      R3,R5
   \   00000248   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   0000024C   0xF002 0x02F0      AND      R2,R2,#0xF0
   \   00000250   0xEB02 0x1701      ADD      R7,R2,R1, LSL #+4
   \   00000254   0x4370             MULS     R0,R6,R0
   \   00000256   0xFBB0 0xF8F9      UDIV     R8,R0,R9
   \   0000025A   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   0000025E   0x4370             MULS     R0,R6,R0
   \   00000260   0xFBB0 0xF0F9      UDIV     R0,R0,R9
   \   00000264   0x4629             MOV      R1,R5
   \   00000266   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000026A   0xFB05 0x8010      MLS      R0,R5,R0,R8
   \   0000026E   0x0100             LSLS     R0,R0,#+4
   \   00000270   0x3032             ADDS     R0,R0,#+50
   \   00000272   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000276   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000027A   0x19C0             ADDS     R0,R0,R7
   \   0000027C   0x6821             LDR      R1,[R4, #+0]
   \   0000027E   0x6088             STR      R0,[R1, #+8]
   1945              }
   1946            }
   1947          }
   \                     ??UART_SetConfig_3: (+1)
   \   00000280   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0xFFFF69F3         DC32     0xffff69f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x40011400         DC32     0x40011400
   1948          
   1949          /**
   1950            * @}
   1951            */
   1952          
   1953          #endif /* HAL_UART_MODULE_ENABLED */
   1954          /**
   1955            * @}
   1956            */
   1957          
   1958          /**
   1959            * @}
   1960            */
   1961          
   1962          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HalfDuplex_EnableReceiver
       0   HAL_HalfDuplex_EnableTransmitter
       8   HAL_HalfDuplex_Init
         8   -> HAL_UART_MspInit
         8   -> UART_SetConfig
      16   HAL_LIN_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       0   HAL_LIN_SendBreak
       0   HAL_MultiProcessor_EnterMuteMode
       0   HAL_MultiProcessor_ExitMuteMode
      16   HAL_MultiProcessor_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       0   HAL_UART_DMAPause
       4   HAL_UART_DMAResume
       8   HAL_UART_DMAStop
         8   -> HAL_DMA_Abort
         8   -> UART_EndRxTransfer
         8   -> UART_EndTxTransfer
       8   HAL_UART_DeInit
         8   -> HAL_UART_MspDeInit
       0   HAL_UART_ErrorCallback
       0   HAL_UART_GetError
       0   HAL_UART_GetState
      16   HAL_UART_IRQHandler
         0   -- Indirect call
        16   -> HAL_DMA_Abort_IT
        16   -> HAL_UART_ErrorCallback
        16   -> UART_EndRxTransfer
         0   -> UART_EndTransmit_IT
         0   -> UART_Receive_IT
        16   -> UART_Receive_IT
         0   -> UART_Transmit_IT
       8   HAL_UART_Init
         8   -> HAL_UART_MspInit
         8   -> UART_SetConfig
       0   HAL_UART_MspDeInit
       0   HAL_UART_MspInit
      32   HAL_UART_Receive
        32   -> HAL_GetTick
        32   -> UART_WaitOnFlagUntilTimeout
       8   HAL_UART_Receive_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_UART_Receive_IT
       0   HAL_UART_RxCpltCallback
       0   HAL_UART_RxHalfCpltCallback
      32   HAL_UART_Transmit
        32   -> HAL_GetTick
        32   -> UART_WaitOnFlagUntilTimeout
       8   HAL_UART_Transmit_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_UART_Transmit_IT
       0   HAL_UART_TxCpltCallback
       0   HAL_UART_TxHalfCpltCallback
       8   UART_DMAAbortOnError
         8   -> HAL_UART_ErrorCallback
       8   UART_DMAError
         8   -> HAL_UART_ErrorCallback
         8   -> UART_EndRxTransfer
         8   -> UART_EndTxTransfer
       8   UART_DMAReceiveCplt
         8   -> HAL_UART_RxCpltCallback
       8   UART_DMARxHalfCplt
         8   -> HAL_UART_RxHalfCpltCallback
       8   UART_DMATransmitCplt
         8   -> HAL_UART_TxCpltCallback
       8   UART_DMATxHalfCplt
         8   -> HAL_UART_TxHalfCpltCallback
       0   UART_EndRxTransfer
       8   UART_EndTransmit_IT
         8   -> HAL_UART_TxCpltCallback
       0   UART_EndTxTransfer
       8   UART_Receive_IT
         8   -> HAL_UART_RxCpltCallback
      32   UART_SetConfig
        32   -> HAL_RCC_GetPCLK1Freq
        32   -> HAL_RCC_GetPCLK2Freq
       0   UART_Transmit_IT
      24   UART_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
      54  HAL_HalfDuplex_EnableReceiver
      54  HAL_HalfDuplex_EnableTransmitter
     110  HAL_HalfDuplex_Init
     132  HAL_LIN_Init
      50  HAL_LIN_SendBreak
      50  HAL_MultiProcessor_EnterMuteMode
      50  HAL_MultiProcessor_ExitMuteMode
     142  HAL_MultiProcessor_Init
     108  HAL_UART_DMAPause
     102  HAL_UART_DMAResume
     100  HAL_UART_DMAStop
      64  HAL_UART_DeInit
       2  HAL_UART_ErrorCallback
       4  HAL_UART_GetError
      12  HAL_UART_GetState
     266  HAL_UART_IRQHandler
     100  HAL_UART_Init
       2  HAL_UART_MspDeInit
       2  HAL_UART_MspInit
     198  HAL_UART_Receive
     142  HAL_UART_Receive_DMA
      88  HAL_UART_Receive_IT
       2  HAL_UART_RxCpltCallback
       2  HAL_UART_RxHalfCpltCallback
     204  HAL_UART_Transmit
     132  HAL_UART_Transmit_DMA
      78  HAL_UART_Transmit_IT
       2  HAL_UART_TxCpltCallback
       2  HAL_UART_TxHalfCpltCallback
      16  UART_DMAAbortOnError
      84  UART_DMAError
      60  UART_DMAReceiveCplt
      10  UART_DMARxHalfCplt
      46  UART_DMATransmitCplt
      10  UART_DMATxHalfCplt
      28  UART_EndRxTransfer
      26  UART_EndTransmit_IT
      18  UART_EndTxTransfer
     140  UART_Receive_IT
     644  UART_SetConfig
      98  UART_Transmit_IT
     104  UART_WaitOnFlagUntilTimeout

 
 3 550 bytes in section .text
 
 3 550 bytes of CODE memory

Errors: none
Warnings: none
