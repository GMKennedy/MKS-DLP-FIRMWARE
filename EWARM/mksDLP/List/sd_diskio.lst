###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:03
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\FatFs\src\drivers\sd_diskio.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\FatFs\src\drivers\sd_diskio.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\sd_diskio.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\sd_diskio.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\FatFs\src\drivers\sd_diskio.c
      1          /**
      2            ******************************************************************************
      3            * @file    sd_diskio.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-May-2015
      7            * @brief   SD Disk I/O driver
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include <string.h>
     30          #include "ff_gen_drv.h"
     31          
     32          /* Private typedef -----------------------------------------------------------*/
     33          /* Private define ------------------------------------------------------------*/
     34          /* Block Size in Bytes */
     35          #define BLOCK_SIZE                512
     36          
     37          /* Private variables ---------------------------------------------------------*/
     38          /* Disk status */

   \                                 In section .data, align 1
     39          static volatile DSTATUS Stat = STA_NOINIT;
   \                     Stat:
   \   00000000   0x01               DC8 1
     40          
     41          /* Private function prototypes -----------------------------------------------*/
     42          DSTATUS SD_initialize (BYTE);
     43          DSTATUS SD_status (BYTE);
     44          DRESULT SD_read (BYTE, BYTE*, DWORD, UINT);
     45          #if _USE_WRITE == 1
     46            DRESULT SD_write (BYTE, const BYTE*, DWORD, UINT);
     47          #endif /* _USE_WRITE == 1 */
     48          #if _USE_IOCTL == 1
     49            DRESULT SD_ioctl (BYTE, BYTE, void*);
     50          #endif  /* _USE_IOCTL == 1 */
     51            

   \                                 In section .rodata, align 4, keep-with-next
     52          const Diskio_drvTypeDef  SD_Driver =
   \                     SD_Driver:
   \   00000000   0x........         DC32 SD_initialize, SD_status, SD_read, SD_write, SD_ioctl
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
     53          {
     54            SD_initialize,
     55            SD_status,
     56            SD_read, 
     57          #if  _USE_WRITE == 1
     58            SD_write,
     59          #endif /* _USE_WRITE == 1 */
     60            
     61          #if  _USE_IOCTL == 1
     62            SD_ioctl,
     63          #endif /* _USE_IOCTL == 1 */
     64          };
     65          
     66          /* Private functions ---------------------------------------------------------*/
     67          
     68          /**
     69            * @brief  Initializes a Drive
     70            * @param  lun : not used 
     71            * @retval DSTATUS: Operation status
     72            */

   \                                 In section .text, align 2, keep-with-next
     73          DSTATUS SD_initialize(BYTE lun)
     74          {
   \                     SD_initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     75            Stat = STA_NOINIT;
   \   00000002   0x....             LDR.N    R4,??DataTable3
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x7020             STRB     R0,[R4, #+0]
     76            
     77            /* Configure the uSD device */
     78            if(BSP_SD_Init() == MSD_OK)
   \   00000008   0x.... 0x....      BL       BSP_SD_Init
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE.N    ??SD_initialize_0
     79            {
     80              Stat &= ~STA_NOINIT;
   \   00000010   0x7820             LDRB     R0,[R4, #+0]
   \   00000012   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   00000016   0x7020             STRB     R0,[R4, #+0]
     81            }
     82          
     83            return Stat;
   \                     ??SD_initialize_0: (+1)
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
     84          }
     85          
     86          /**
     87            * @brief  Gets Disk Status
     88            * @param  lun : not used
     89            * @retval DSTATUS: Operation status
     90            */

   \                                 In section .text, align 2, keep-with-next
     91          DSTATUS SD_status(BYTE lun)
     92          {
   \                     SD_status: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     93            Stat = STA_NOINIT;
   \   00000002   0x....             LDR.N    R4,??DataTable3
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x7020             STRB     R0,[R4, #+0]
     94          
     95            if(BSP_SD_GetStatus() == MSD_OK)
   \   00000008   0x.... 0x....      BL       BSP_SD_GetStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE.N    ??SD_status_0
     96            {
     97              Stat &= ~STA_NOINIT;
   \   00000010   0x7820             LDRB     R0,[R4, #+0]
   \   00000012   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   00000016   0x7020             STRB     R0,[R4, #+0]
     98            }
     99            
    100            return Stat;
   \                     ??SD_status_0: (+1)
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    101          }
    102          
    103          /**
    104            * @brief  Reads Sector(s)
    105            * @param  lun : not used
    106            * @param  *buff: Data buffer to store read data
    107            * @param  sector: Sector address (LBA)
    108            * @param  count: Number of sectors to read (1..128)
    109            * @retval DRESULT: Operation result
    110            */

   \                                 In section .text, align 2, keep-with-next
    111          DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
    112          {
   \                     SD_read: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    113            DRESULT res = RES_OK;
   \   00000002   0x2400             MOVS     R4,#+0
    114            
    115            if(BSP_SD_ReadBlocks_DMA((uint32_t*)buff, 
    116                                 (uint64_t) (sector * BLOCK_SIZE), 
    117                                 BLOCK_SIZE, 
    118                                 count) != MSD_OK)
   \   00000004   0x9301             STR      R3,[SP, #+4]
   \   00000006   0xF44F 0x7000      MOV      R0,#+512
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x0252             LSLS     R2,R2,#+9
   \   0000000E   0x4623             MOV      R3,R4
   \   00000010   0x4608             MOV      R0,R1
   \   00000012   0x.... 0x....      BL       BSP_SD_ReadBlocks_DMA
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD000             BEQ.N    ??SD_read_0
    119            {
    120              res = RES_ERROR;
   \   0000001A   0x2401             MOVS     R4,#+1
    121            }
    122            
    123            return res;
   \                     ??SD_read_0: (+1)
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    124          }
    125          
    126          /**
    127            * @brief  Writes Sector(s)
    128            * @param  lun : not used
    129            * @param  *buff: Data to be written
    130            * @param  sector: Sector address (LBA)
    131            * @param  count: Number of sectors to write (1..128)
    132            * @retval DRESULT: Operation result
    133            */
    134          #if _USE_WRITE == 1

   \                                 In section .text, align 2, keep-with-next
    135          DRESULT SD_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
    136          {
   \                     SD_write: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    137            DRESULT res = RES_OK;
   \   00000002   0x2400             MOVS     R4,#+0
    138            
    139            if(BSP_SD_WriteBlocks_DMA((uint32_t*)buff, 
    140                                  (uint64_t)(sector * BLOCK_SIZE), 
    141                                  BLOCK_SIZE, count) != MSD_OK)
   \   00000004   0x9301             STR      R3,[SP, #+4]
   \   00000006   0xF44F 0x7000      MOV      R0,#+512
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x0252             LSLS     R2,R2,#+9
   \   0000000E   0x4623             MOV      R3,R4
   \   00000010   0x4608             MOV      R0,R1
   \   00000012   0x.... 0x....      BL       BSP_SD_WriteBlocks_DMA
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD000             BEQ.N    ??SD_write_0
    142            {
    143              res = RES_ERROR;
   \   0000001A   0x2401             MOVS     R4,#+1
    144            }
    145            
    146            return res;
   \                     ??SD_write_0: (+1)
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    147          }
    148          #endif /* _USE_WRITE == 1 */
    149          
    150          /**
    151            * @brief  I/O control operation
    152            * @param  lun : not used
    153            * @param  cmd: Control code
    154            * @param  *buff: Buffer to send/receive control data
    155            * @retval DRESULT: Operation result
    156            */
    157          #if _USE_IOCTL == 1

   \                                 In section .text, align 2, keep-with-next
    158          DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
    159          {
   \                     SD_ioctl: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB096             SUB      SP,SP,#+88
   \   00000004   0x4614             MOV      R4,R2
    160            DRESULT res = RES_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
    161            SD_CardInfo CardInfo;
    162            
    163            if (Stat & STA_NOINIT) return RES_NOTRDY;
   \   00000008   0x....             LDR.N    R2,??DataTable3
   \   0000000A   0x7812             LDRB     R2,[R2, #+0]
   \   0000000C   0x07D2             LSLS     R2,R2,#+31
   \   0000000E   0xD501             BPL.N    ??SD_ioctl_0
   \   00000010   0x2003             MOVS     R0,#+3
   \   00000012   0xE01E             B.N      ??SD_ioctl_1
    164            
    165            switch (cmd)
   \                     ??SD_ioctl_0: (+1)
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD005             BEQ.N    ??SD_ioctl_2
   \   00000018   0x2902             CMP      R1,#+2
   \   0000001A   0xD010             BEQ.N    ??SD_ioctl_3
   \   0000001C   0xD304             BCC.N    ??SD_ioctl_4
   \   0000001E   0x2903             CMP      R1,#+3
   \   00000020   0xD012             BEQ.N    ??SD_ioctl_5
   \   00000022   0xE015             B.N      ??SD_ioctl_6
    166            {
    167            /* Make sure that no pending write process */
    168            case CTRL_SYNC :
    169              res = RES_OK;
   \                     ??SD_ioctl_2: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
    170              break;
   \   00000026   0xE014             B.N      ??SD_ioctl_1
    171            
    172            /* Get number of sectors on the disk (DWORD) */
    173            case GET_SECTOR_COUNT :
    174              BSP_SD_GetCardInfo(&CardInfo);
   \                     ??SD_ioctl_4: (+1)
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       BSP_SD_GetCardInfo
    175              *(DWORD*)buff = CardInfo.CardCapacity / BLOCK_SIZE;
   \   0000002E   0xE9DD 0x0112      LDRD     R0,R1,[SP, #+72]
   \   00000032   0x0A40             LSRS     R0,R0,#+9
   \   00000034   0xEA40 0x50C1      ORR      R0,R0,R1, LSL #+23
   \   00000038   0x6020             STR      R0,[R4, #+0]
    176              res = RES_OK;
   \   0000003A   0x2000             MOVS     R0,#+0
    177              break;
   \   0000003C   0xE009             B.N      ??SD_ioctl_1
    178            
    179            /* Get R/W sector size (WORD) */
    180            case GET_SECTOR_SIZE :
    181              *(WORD*)buff = BLOCK_SIZE;
   \                     ??SD_ioctl_3: (+1)
   \   0000003E   0xF44F 0x7000      MOV      R0,#+512
   \   00000042   0x8020             STRH     R0,[R4, #+0]
    182              res = RES_OK;
   \   00000044   0x2000             MOVS     R0,#+0
    183              break;
   \   00000046   0xE004             B.N      ??SD_ioctl_1
    184            
    185            /* Get erase block size in unit of sector (DWORD) */
    186            case GET_BLOCK_SIZE :
    187              *(DWORD*)buff = BLOCK_SIZE;
   \                     ??SD_ioctl_5: (+1)
   \   00000048   0xF44F 0x7100      MOV      R1,#+512
   \   0000004C   0x6021             STR      R1,[R4, #+0]
    188              break;
   \   0000004E   0xE000             B.N      ??SD_ioctl_1
    189            
    190            default:
    191              res = RES_PARERR;
   \                     ??SD_ioctl_6: (+1)
   \   00000050   0x2004             MOVS     R0,#+4
    192            }
    193            
    194            return res;
   \                     ??SD_ioctl_1: (+1)
   \   00000052   0xB016             ADD      SP,SP,#+88
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
    195          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     Stat
    196          #endif /* _USE_IOCTL == 1 */
    197            
    198          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    199          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SD_initialize
         8   -> BSP_SD_Init
      96   SD_ioctl
        96   -> BSP_SD_GetCardInfo
      16   SD_read
        16   -> BSP_SD_ReadBlocks_DMA
       8   SD_status
         8   -> BSP_SD_GetStatus
      16   SD_write
        16   -> BSP_SD_WriteBlocks_DMA


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
      20  SD_Driver
      28  SD_initialize
      86  SD_ioctl
      32  SD_read
      28  SD_status
      32  SD_write
       1  Stat

 
   1 byte  in section .data
  20 bytes in section .rodata
 210 bytes in section .text
 
 210 bytes of CODE  memory
  20 bytes of CONST memory
   1 byte  of DATA  memory

Errors: none
Warnings: none
