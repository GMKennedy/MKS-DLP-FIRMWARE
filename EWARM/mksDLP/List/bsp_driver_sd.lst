###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:14:29
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Src\bsp_driver_sd.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Src\bsp_driver_sd.c -D
#        USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\bsp_driver_sd.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\bsp_driver_sd.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Src\bsp_driver_sd.c
      1          /**
      2           ******************************************************************************
      3            * @file    bsp_driver_sd.c for F4 (based on stm324x9i_eval_sd.c)
      4            * @brief   This file includes a generic uSD card driver.
      5            ******************************************************************************
      6            *
      7            * Copyright (c) 2016 STMicroelectronics International N.V. 
      8            * All rights reserved.
      9            *
     10            * Redistribution and use in source and binary forms, with or without 
     11            * modification, are permitted, provided that the following conditions are met:
     12            *
     13            * 1. Redistribution of source code must retain the above copyright notice, 
     14            *    this list of conditions and the following disclaimer.
     15            * 2. Redistributions in binary form must reproduce the above copyright notice,
     16            *    this list of conditions and the following disclaimer in the documentation
     17            *    and/or other materials provided with the distribution.
     18            * 3. Neither the name of STMicroelectronics nor the names of other 
     19            *    contributors to this software may be used to endorse or promote products 
     20            *    derived from this software without specific written permission.
     21            * 4. This software, including modifications and/or derivative works of this 
     22            *    software, must execute solely and exclusively on microcontroller or
     23            *    microprocessor devices manufactured by or for STMicroelectronics.
     24            * 5. Redistribution and use of this software other than as permitted under 
     25            *    this license is void and will automatically terminate your rights under 
     26            *    this license. 
     27            *
     28            * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS" 
     29            * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT 
     30            * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
     31            * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
     32            * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT 
     33            * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
     34            * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     35            * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
     36            * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
     37            * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
     38            * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     39            * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     40            *
     41            ******************************************************************************
     42            */
     43          #define BUS_4BITS 1
     44          /* USER CODE BEGIN 0 */
     45          /* Includes ------------------------------------------------------------------*/
     46          #include "bsp_driver_sd.h"
     47          
     48          /* Extern variables ---------------------------------------------------------*/ 
     49            
     50          extern SD_HandleTypeDef hsd;
     51          extern HAL_SD_CardInfoTypedef SDCardInfo; 
     52          
     53          /**
     54            * @brief  Initializes the SD card device.
     55            * @retval SD status
     56            */

   \                                 In section .text, align 2, keep-with-next
     57          uint8_t BSP_SD_Init(void)
     58          {
   \                     BSP_SD_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     59            uint8_t sd_state = MSD_OK;
     60            /* Check if the SD card is plugged in the slot */
     61            if (BSP_SD_IsDetected() != SD_PRESENT)
   \   00000002   0x.... 0x....      BL       BSP_SD_IsDetected
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD001             BEQ.N    ??BSP_SD_Init_0
     62            {
     63              return MSD_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
     64            }
     65            /* HAL SD initialization */
     66            sd_state = HAL_SD_Init(&hsd, &SDCardInfo);
   \                     ??BSP_SD_Init_0: (+1)
   \   0000000E   0x....             LDR.N    R4,??DataTable10
   \   00000010   0x....             LDR.N    R1,??DataTable10_1
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       HAL_SD_Init
   \   00000018   0x4605             MOV      R5,R0
     67          #ifdef BUS_4BITS
     68            /* Configure SD Bus width */
     69            if (sd_state == MSD_OK)
   \   0000001A   0xB2ED             UXTB     R5,R5
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD107             BNE.N    ??BSP_SD_Init_1
     70            {
     71              /* Enable wide operation */
     72              if (HAL_SD_WideBusOperation_Config(&hsd, SDIO_BUS_WIDE_4B) != SD_OK)
   \   00000020   0xF44F 0x6100      MOV      R1,#+2048
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       HAL_SD_WideBusOperation_Config
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD000             BEQ.N    ??BSP_SD_Init_1
     73              {
     74                sd_state = MSD_ERROR;
   \   0000002E   0x2501             MOVS     R5,#+1
     75              }
     76              else
     77              {
     78                sd_state = MSD_OK;
     79              }
     80            }
     81          #endif
     82            return sd_state;
   \                     ??BSP_SD_Init_1: (+1)
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     83          }
     84          
     85          /**
     86            * @brief  Configures Interrupt mode for SD detection pin.
     87            * @retval Returns 0 in success otherwise 1. 
     88            */

   \                                 In section .text, align 2, keep-with-next
     89          uint8_t BSP_SD_ITConfig(void)
     90          {  
     91            /* TBI: add user code here depending on the hardware configuration used */
     92            
     93            return (uint8_t)0;
   \                     BSP_SD_ITConfig: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
     94          }
     95          
     96          /** @brief  SD detect IT treatment
     97            */

   \                                 In section .text, align 2, keep-with-next
     98          void BSP_SD_DetectIT(void)
     99          {
    100            /* TBI: add user code here depending on the hardware configuration used */
    101          }
   \                     BSP_SD_DetectIT: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    102          
    103          /** @brief  SD detect IT detection callback
    104            */

   \                                 In section .text, align 2, keep-with-next
    105          __weak void BSP_SD_DetectCallback(void)
    106          {
    107            /* NOTE: This function Should not be modified, when the callback is needed,
    108               the BSP_SD_DetectCallback could be implemented in the user file
    109            */ 
    110          }
   \                     BSP_SD_DetectCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    111          
    112          /**
    113            * @brief  Reads block(s) from a specified address in an SD card, in polling mode.
    114            * @param  pData: Pointer to the buffer that will contain the data to transmit
    115            * @param  ReadAddr: Address from where data is to be read  
    116            * @param  BlockSize: SD card data block size, that should be 512
    117            * @param  NumOfBlocks: Number of SD blocks to read 
    118            * @retval SD status
    119            */

   \                                 In section .text, align 2, keep-with-next
    120          uint8_t BSP_SD_ReadBlocks(uint32_t *pData, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumOfBlocks)
    121          {
   \                     BSP_SD_ReadBlocks: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    122            uint8_t sd_state;
    123            if(HAL_SD_ReadBlocks(&hsd, pData, ReadAddr, BlockSize, NumOfBlocks) != SD_OK)
   \   00000004   0x9905             LDR      R1,[SP, #+20]
   \   00000006   0x9101             STR      R1,[SP, #+4]
   \   00000008   0x9904             LDR      R1,[SP, #+16]
   \   0000000A   0x9100             STR      R1,[SP, #+0]
   \   0000000C   0x4601             MOV      R1,R0
   \   0000000E   0x....             LDR.N    R0,??DataTable10
   \   00000010   0x.... 0x....      BL       HAL_SD_ReadBlocks
   \   00000014   0x1E40             SUBS     R0,R0,#+1
   \   00000016   0x4180             SBCS     R0,R0,R0
   \   00000018   0x43C0             MVNS     R0,R0
   \   0000001A   0x0FC0             LSRS     R0,R0,#+31
    124            {
    125              sd_state = MSD_ERROR;
    126            }
    127            else
    128            {
    129              sd_state = MSD_OK;
    130            }
    131            return sd_state;  
   \   0000001C   0xBD0E             POP      {R1-R3,PC}       ;; return
    132          }
    133          
    134          /**
    135            * @brief  Writes block(s) to a specified address in an SD card, in polling mode. 
    136            * @param  pData: Pointer to the buffer that will contain the data to transmit
    137            * @param  WriteAddr: Address from where data is to be written  
    138            * @param  BlockSize: SD card data block size, that should be 512
    139            * @param  NumOfBlocks: Number of SD blocks to write
    140            * @retval SD status
    141            */

   \                                 In section .text, align 2, keep-with-next
    142          uint8_t BSP_SD_WriteBlocks(uint32_t *pData, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumOfBlocks)
    143          {
   \                     BSP_SD_WriteBlocks: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    144            uint8_t sd_state;
    145            if(HAL_SD_WriteBlocks(&hsd, pData, WriteAddr, BlockSize, NumOfBlocks) != SD_OK)  
   \   00000004   0x9905             LDR      R1,[SP, #+20]
   \   00000006   0x9101             STR      R1,[SP, #+4]
   \   00000008   0x9904             LDR      R1,[SP, #+16]
   \   0000000A   0x9100             STR      R1,[SP, #+0]
   \   0000000C   0x4601             MOV      R1,R0
   \   0000000E   0x....             LDR.N    R0,??DataTable10
   \   00000010   0x.... 0x....      BL       HAL_SD_WriteBlocks
   \   00000014   0x1E40             SUBS     R0,R0,#+1
   \   00000016   0x4180             SBCS     R0,R0,R0
   \   00000018   0x43C0             MVNS     R0,R0
   \   0000001A   0x0FC0             LSRS     R0,R0,#+31
    146            {
    147              sd_state = MSD_ERROR;
    148            }
    149            else
    150            {
    151              sd_state = MSD_OK;
    152            }
    153            return sd_state;  
   \   0000001C   0xBD0E             POP      {R1-R3,PC}       ;; return
    154          }
    155          
    156          /**
    157            * @brief  Reads block(s) from a specified address in an SD card, in DMA mode.
    158            * @param  pData: Pointer to the buffer that will contain the data to transmit
    159            * @param  ReadAddr: Address from where data is to be read  
    160            * @param  BlockSize: SD card data block size, that should be 512
    161            * @param  NumOfBlocks: Number of SD blocks to read 
    162            * @retval SD status
    163            */

   \                                 In section .text, align 2, keep-with-next
    164          uint8_t BSP_SD_ReadBlocks_DMA(uint32_t *pData, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumOfBlocks)
    165          {
   \                     BSP_SD_ReadBlocks_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    166            uint8_t sd_state = MSD_OK;
   \   00000004   0x2400             MOVS     R4,#+0
    167            
    168            /* Read block(s) in DMA transfer mode */
    169            if(HAL_SD_ReadBlocks_DMA(&hsd, pData, ReadAddr, BlockSize, NumOfBlocks) != SD_OK)  
   \   00000006   0x....             LDR.N    R5,??DataTable10
   \   00000008   0x9907             LDR      R1,[SP, #+28]
   \   0000000A   0x9101             STR      R1,[SP, #+4]
   \   0000000C   0x9906             LDR      R1,[SP, #+24]
   \   0000000E   0x9100             STR      R1,[SP, #+0]
   \   00000010   0x4601             MOV      R1,R0
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       HAL_SD_ReadBlocks_DMA
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD000             BEQ.N    ??BSP_SD_ReadBlocks_DMA_0
    170            {
    171              sd_state = MSD_ERROR;
   \   0000001C   0x2401             MOVS     R4,#+1
    172            }
    173            
    174            /* Wait until transfer is complete */
    175            if(sd_state == MSD_OK)
   \                     ??BSP_SD_ReadBlocks_DMA_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD106             BNE.N    ??BSP_SD_ReadBlocks_DMA_1
    176            {
    177              if(HAL_SD_CheckReadOperation(&hsd, (uint32_t)SD_DATATIMEOUT) != SD_OK)  
   \   00000022   0x....             LDR.N    R1,??DataTable10_2  ;; 0x5f5e100
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       HAL_SD_CheckReadOperation
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD000             BEQ.N    ??BSP_SD_ReadBlocks_DMA_1
    178              {
    179                sd_state = MSD_ERROR;
   \   0000002E   0x2401             MOVS     R4,#+1
    180              }
    181              else
    182              {
    183                sd_state = MSD_OK;
    184              }
    185            }
    186            
    187            return sd_state; 
   \                     ??BSP_SD_ReadBlocks_DMA_1: (+1)
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xBD3E             POP      {R1-R5,PC}       ;; return
    188          }
    189          
    190          /**
    191            * @brief  Writes block(s) to a specified address in an SD card, in DMA mode.
    192            * @param  pData: Pointer to the buffer that will contain the data to transmit
    193            * @param  WriteAddr: Address from where data is to be written  
    194            * @param  BlockSize: SD card data block size, that should be 512
    195            * @param  NumOfBlocks: Number of SD blocks to write 
    196            * @retval SD status
    197            */

   \                                 In section .text, align 2, keep-with-next
    198          uint8_t BSP_SD_WriteBlocks_DMA(uint32_t *pData, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumOfBlocks)
    199          {
   \                     BSP_SD_WriteBlocks_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    200            uint8_t sd_state = MSD_OK;
   \   00000004   0x2400             MOVS     R4,#+0
    201            
    202            /* Write block(s) in DMA transfer mode */
    203            if(HAL_SD_WriteBlocks_DMA(&hsd, pData, WriteAddr, BlockSize, NumOfBlocks) != SD_OK)  
   \   00000006   0x....             LDR.N    R5,??DataTable10
   \   00000008   0x9907             LDR      R1,[SP, #+28]
   \   0000000A   0x9101             STR      R1,[SP, #+4]
   \   0000000C   0x9906             LDR      R1,[SP, #+24]
   \   0000000E   0x9100             STR      R1,[SP, #+0]
   \   00000010   0x4601             MOV      R1,R0
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       HAL_SD_WriteBlocks_DMA
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD000             BEQ.N    ??BSP_SD_WriteBlocks_DMA_0
    204            {
    205              sd_state = MSD_ERROR;
   \   0000001C   0x2401             MOVS     R4,#+1
    206            }
    207            
    208            /* Wait until transfer is complete */
    209            if(sd_state == MSD_OK)
   \                     ??BSP_SD_WriteBlocks_DMA_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD106             BNE.N    ??BSP_SD_WriteBlocks_DMA_1
    210            {
    211              if(HAL_SD_CheckWriteOperation(&hsd, (uint32_t)SD_DATATIMEOUT) != SD_OK)  
   \   00000022   0x....             LDR.N    R1,??DataTable10_2  ;; 0x5f5e100
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       HAL_SD_CheckWriteOperation
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD000             BEQ.N    ??BSP_SD_WriteBlocks_DMA_1
    212              {
    213                sd_state = MSD_ERROR;
   \   0000002E   0x2401             MOVS     R4,#+1
    214              }
    215              else
    216              {
    217                sd_state = MSD_OK;
    218              }
    219            }
    220            
    221            return sd_state; 
   \                     ??BSP_SD_WriteBlocks_DMA_1: (+1)
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xBD3E             POP      {R1-R5,PC}       ;; return
    222          }
    223          
    224          /**
    225            * @brief  Erases the specified memory area of the given SD card. 
    226            * @param  StartAddr: Start byte address
    227            * @param  EndAddr: End byte address
    228            * @retval SD status
    229            */

   \                                 In section .text, align 2, keep-with-next
    230          uint8_t BSP_SD_Erase(uint64_t StartAddr, uint64_t EndAddr)
    231          {
   \                     BSP_SD_Erase: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    232            uint8_t sd_state;
    233            if(HAL_SD_Erase(&hsd, StartAddr, EndAddr) != SD_OK)  
   \   00000004   0xE9CD 0x2300      STRD     R2,R3,[SP, #+0]
   \   00000008   0x4602             MOV      R2,R0
   \   0000000A   0x460B             MOV      R3,R1
   \   0000000C   0x....             LDR.N    R0,??DataTable10
   \   0000000E   0x.... 0x....      BL       HAL_SD_Erase
   \   00000012   0x1E40             SUBS     R0,R0,#+1
   \   00000014   0x4180             SBCS     R0,R0,R0
   \   00000016   0x43C0             MVNS     R0,R0
   \   00000018   0x0FC0             LSRS     R0,R0,#+31
    234            {
    235              sd_state = MSD_ERROR;
    236            }
    237            else
    238            {
    239              sd_state = MSD_OK;
    240            }
    241            return sd_state;
   \   0000001A   0xBD0E             POP      {R1-R3,PC}       ;; return
    242          }
    243          
    244          /**
    245            * @brief  Handles SD card interrupt request.
    246            */

   \                                 In section .text, align 2, keep-with-next
    247          void BSP_SD_IRQHandler(void)
    248          {
    249            HAL_SD_IRQHandler(&hsd);
   \                     BSP_SD_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10
   \   00000002   0x.... 0x....      B.W      HAL_SD_IRQHandler
    250          }
    251          
    252          /**
    253            * @brief  Handles SD DMA Tx transfer interrupt request.
    254            */

   \                                 In section .text, align 2, keep-with-next
    255          void BSP_SD_DMA_Tx_IRQHandler(void)
    256          {
    257            HAL_DMA_IRQHandler(hsd.hdmatx); 
   \                     BSP_SD_DMA_Tx_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10
   \   00000002   0x6DC0             LDR      R0,[R0, #+92]
   \   00000004   0x.... 0x....      B.W      HAL_DMA_IRQHandler
    258          }
    259          
    260          /**
    261            * @brief  Handles SD DMA Rx transfer interrupt request.
    262            */

   \                                 In section .text, align 2, keep-with-next
    263          void BSP_SD_DMA_Rx_IRQHandler(void)
    264          {
    265            HAL_DMA_IRQHandler(hsd.hdmarx);
   \                     BSP_SD_DMA_Rx_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10
   \   00000002   0x6D80             LDR      R0,[R0, #+88]
   \   00000004   0x.... 0x....      B.W      HAL_DMA_IRQHandler
    266          }
    267          
    268          /**
    269            * @brief  Gets the current SD card data status.
    270            * @retval Data transfer state.
    271            *          This value can be one of the following values:
    272            *            @arg  SD_TRANSFER_OK: No data transfer is acting
    273            *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
    274            *            @arg  SD_TRANSFER_ERROR: Data transfer error 
    275            */

   \                                 In section .text, align 2, keep-with-next
    276          HAL_SD_TransferStateTypedef BSP_SD_GetStatus(void)
    277          {
    278            return(HAL_SD_GetStatus(&hsd));
   \                     BSP_SD_GetStatus: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10
   \   00000002   0x.... 0x....      B.W      HAL_SD_GetStatus
    279          }
    280          
    281          /**
    282            * @brief  Get SD information about specific SD card.
    283            * @param  CardInfo: Pointer to HAL_SD_CardInfoTypedef structure
    284            */

   \                                 In section .text, align 2, keep-with-next
    285          void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypedef* CardInfo)
    286          {
    287            /* Get SD card Information */
    288            HAL_SD_Get_CardInfo(&hsd, CardInfo);
   \                     BSP_SD_GetCardInfo: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0x....             LDR.N    R0,??DataTable10
   \   00000004   0x.... 0x....      B.W      HAL_SD_Get_CardInfo
    289          }
    290          /* USER CODE END 0 */
    291          
    292          /**
    293           * @brief  Detects if SD card is correctly plugged in the memory slot or not.
    294           * @retval Returns if SD is detected or not
    295           */

   \                                 In section .text, align 2, keep-with-next
    296          uint8_t BSP_SD_IsDetected(void)
    297          {
   \                     BSP_SD_IsDetected: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    298            __IO uint8_t status = SD_PRESENT;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
    299          
    300            /* USER CODE BEGIN 1 */
    301            /* user code can be inserted here */
    302            /* USER CODE END 1 */    	
    303          
    304            return status;
   \   00000008   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000000C   0xB001             ADD      SP,SP,#+4
   \   0000000E   0x4770             BX       LR               ;; return
    305          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     hsd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     SDCardInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x05F5E100         DC32     0x5f5e100
    306          
    307          /* USER CODE BEGIN AdditionalCode */
    308          /* user code can be inserted here */
    309          /* USER CODE END AdditionalCode */
    310          
    311          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   BSP_SD_DMA_Rx_IRQHandler
         0   -> HAL_DMA_IRQHandler
       0   BSP_SD_DMA_Tx_IRQHandler
         0   -> HAL_DMA_IRQHandler
       0   BSP_SD_DetectCallback
       0   BSP_SD_DetectIT
      16   BSP_SD_Erase
        16   -> HAL_SD_Erase
       0   BSP_SD_GetCardInfo
         0   -> HAL_SD_Get_CardInfo
       0   BSP_SD_GetStatus
         0   -> HAL_SD_GetStatus
       0   BSP_SD_IRQHandler
         0   -> HAL_SD_IRQHandler
       0   BSP_SD_ITConfig
      16   BSP_SD_Init
        16   -> BSP_SD_IsDetected
        16   -> HAL_SD_Init
        16   -> HAL_SD_WideBusOperation_Config
       4   BSP_SD_IsDetected
      16   BSP_SD_ReadBlocks
        16   -> HAL_SD_ReadBlocks
      24   BSP_SD_ReadBlocks_DMA
        24   -> HAL_SD_CheckReadOperation
        24   -> HAL_SD_ReadBlocks_DMA
      16   BSP_SD_WriteBlocks
        16   -> HAL_SD_WriteBlocks
      24   BSP_SD_WriteBlocks_DMA
        24   -> HAL_SD_CheckWriteOperation
        24   -> HAL_SD_WriteBlocks_DMA


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       8  BSP_SD_DMA_Rx_IRQHandler
       8  BSP_SD_DMA_Tx_IRQHandler
       2  BSP_SD_DetectCallback
       2  BSP_SD_DetectIT
      28  BSP_SD_Erase
       8  BSP_SD_GetCardInfo
       6  BSP_SD_GetStatus
       6  BSP_SD_IRQHandler
       4  BSP_SD_ITConfig
      52  BSP_SD_Init
      16  BSP_SD_IsDetected
      30  BSP_SD_ReadBlocks
      52  BSP_SD_ReadBlocks_DMA
      30  BSP_SD_WriteBlocks
      52  BSP_SD_WriteBlocks_DMA

 
 316 bytes in section .text
 
 316 bytes of CODE memory

Errors: none
Warnings: none
