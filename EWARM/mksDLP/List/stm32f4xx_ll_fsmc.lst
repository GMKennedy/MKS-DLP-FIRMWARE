###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:23
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_ll_fsmc.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_ll_fsmc.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\stm32f4xx_ll_fsmc.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\stm32f4xx_ll_fsmc.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_ll_fsmc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_ll_fsmc.c
      4            * @author  MCD Application Team
      5            * @version V1.5.2
      6            * @date    22-September-2016
      7            * @brief   FSMC Low Layer HAL module driver.
      8            *    
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities of the Flexible Static Memory Controller (FSMC) peripheral memories:
     11            *           + Initialization/de-initialization functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            *         
     15            @verbatim
     16            ==============================================================================
     17                                  ##### FSMC peripheral features #####
     18            ==============================================================================                  
     19              [..] The Flexible static memory controller (FSMC) includes two memory controllers:
     20                   (+) The NOR/PSRAM memory controller
     21                   (+) The NAND/PC Card memory controller
     22                 
     23              [..] The FSMC functional block makes the interface with synchronous and asynchronous static
     24                   memories, SDRAM memories, and 16-bit PC memory cards. Its main purposes are:
     25                   (+) to translate AHB transactions into the appropriate external device protocol.
     26                   (+) to meet the access time requirements of the external memory devices.
     27             
     28              [..] All external memories share the addresses, data and control signals with the controller.
     29                   Each external device is accessed by means of a unique Chip Select. The FSMC performs
     30                   only one access at a time to an external device.
     31                   The main features of the FSMC controller are the following:
     32                    (+) Interface with static-memory mapped devices including:
     33                       (++) Static random access memory (SRAM).
     34                       (++) Read-only memory (ROM).
     35                       (++) NOR Flash memory/OneNAND Flash memory.
     36                       (++) PSRAM (4 memory banks).
     37                       (++) 16-bit PC Card compatible devices.
     38                       (++) Two banks of NAND Flash memory with ECC hardware to check up to 8 Kbytes of
     39                            data.
     40                    (+) Independent Chip Select control for each memory bank.
     41                    (+) Independent configuration for each memory bank.          
     42                  
     43            @endverbatim
     44            ******************************************************************************
     45            * @attention
     46            *
     47            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     48            *
     49            * Redistribution and use in source and binary forms, with or without modification,
     50            * are permitted provided that the following conditions are met:
     51            *   1. Redistributions of source code must retain the above copyright notice,
     52            *      this list of conditions and the following disclaimer.
     53            *   2. Redistributions in binary form must reproduce the above copyright notice,
     54            *      this list of conditions and the following disclaimer in the documentation
     55            *      and/or other materials provided with the distribution.
     56            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     57            *      may be used to endorse or promote products derived from this software
     58            *      without specific prior written permission.
     59            *
     60            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     61            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     62            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     63            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     64            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     65            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     66            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     67            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     68            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     69            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     70            *
     71            ******************************************************************************
     72            */ 
     73          
     74          /* Includes ------------------------------------------------------------------*/
     75          #include "stm32f4xx_hal.h"
     76          
     77          /** @addtogroup STM32F4xx_HAL_Driver
     78            * @{
     79            */
     80          
     81          /** @defgroup FSMC_LL  FSMC Low Layer
     82            * @brief FSMC driver modules
     83            * @{
     84            */
     85          
     86          #if defined (HAL_SRAM_MODULE_ENABLED) || defined(HAL_NOR_MODULE_ENABLED) || defined(HAL_NAND_MODULE_ENABLED) || defined(HAL_PCCARD_MODULE_ENABLED)
     87          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx)
     88          /* Private typedef -----------------------------------------------------------*/
     89          /* Private define ------------------------------------------------------------*/
     90          /* Private macro -------------------------------------------------------------*/
     91          /* Private variables ---------------------------------------------------------*/
     92          /* Private function prototypes -----------------------------------------------*/
     93          /* Private functions ---------------------------------------------------------*/
     94          /** @addtogroup FSMC_LL_Private_Functions
     95            * @{
     96            */
     97          
     98          /** @addtogroup FSMC_LL_NORSRAM
     99            * @brief    NORSRAM Controller functions 
    100            *
    101            @verbatim 
    102            ==============================================================================
    103                             ##### How to use NORSRAM device driver #####
    104            ==============================================================================
    105           
    106            [..] 
    107              This driver contains a set of APIs to interface with the FSMC NORSRAM banks in order
    108              to run the NORSRAM external devices.
    109                
    110              (+) FSMC NORSRAM bank reset using the function FSMC_NORSRAM_DeInit() 
    111              (+) FSMC NORSRAM bank control configuration using the function FSMC_NORSRAM_Init()
    112              (+) FSMC NORSRAM bank timing configuration using the function FSMC_NORSRAM_Timing_Init()
    113              (+) FSMC NORSRAM bank extended timing configuration using the function 
    114                  FSMC_NORSRAM_Extended_Timing_Init()
    115              (+) FSMC NORSRAM bank enable/disable write operation using the functions
    116                  FSMC_NORSRAM_WriteOperation_Enable()/FSMC_NORSRAM_WriteOperation_Disable()
    117          
    118          @endverbatim
    119            * @{
    120            */
    121                 
    122          /** @addtogroup FSMC_LL_NORSRAM_Private_Functions_Group1
    123            * @brief    Initialization and Configuration functions 
    124            *
    125            @verbatim    
    126            ==============================================================================
    127                        ##### Initialization and de_initialization functions #####
    128            ==============================================================================
    129            [..]  
    130              This section provides functions allowing to:
    131              (+) Initialize and configure the FSMC NORSRAM interface
    132              (+) De-initialize the FSMC NORSRAM interface 
    133              (+) Configure the FSMC clock and associated GPIOs    
    134           
    135          @endverbatim
    136            * @{
    137            */
    138            
    139          /**
    140            * @brief  Initialize the FSMC_NORSRAM device according to the specified
    141            *         control parameters in the FSMC_NORSRAM_InitTypeDef
    142            * @param  Device: Pointer to NORSRAM device instance
    143            * @param  Init: Pointer to NORSRAM Initialization structure   
    144            * @retval HAL status
    145            */

   \                                 In section .text, align 2, keep-with-next
    146          HAL_StatusTypeDef  FSMC_NORSRAM_Init(FSMC_NORSRAM_TypeDef *Device, FSMC_NORSRAM_InitTypeDef* Init)
    147          { 
   \                     FSMC_NORSRAM_Init: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    148            uint32_t tmpr = 0U;
    149              
    150            /* Check the parameters */
    151            assert_param(IS_FSMC_NORSRAM_DEVICE(Device));
    152            assert_param(IS_FSMC_NORSRAM_BANK(Init->NSBank));
    153            assert_param(IS_FSMC_MUX(Init->DataAddressMux));
    154            assert_param(IS_FSMC_MEMORY(Init->MemoryType));
    155            assert_param(IS_FSMC_NORSRAM_MEMORY_WIDTH(Init->MemoryDataWidth));
    156            assert_param(IS_FSMC_BURSTMODE(Init->BurstAccessMode));
    157            assert_param(IS_FSMC_WAIT_POLARITY(Init->WaitSignalPolarity));
    158          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)
    159            assert_param(IS_FSMC_WRAP_MODE(Init->WrapMode));
    160          #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
    161            assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(Init->WaitSignalActive));
    162            assert_param(IS_FSMC_WRITE_OPERATION(Init->WriteOperation));
    163            assert_param(IS_FSMC_WAITE_SIGNAL(Init->WaitSignal));
    164            assert_param(IS_FSMC_EXTENDED_MODE(Init->ExtendedMode));
    165            assert_param(IS_FSMC_ASYNWAIT(Init->AsynchronousWait));
    166            assert_param(IS_FSMC_WRITE_BURST(Init->WriteBurst));
    167            assert_param(IS_FSMC_PAGESIZE(Init->PageSize));
    168          #if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx)
    169            assert_param(IS_FSMC_WRITE_FIFO(Init->WriteFifo));
    170            assert_param(IS_FSMC_CONTINOUS_CLOCK(Init->ContinuousClock));
    171          #endif /* STM32F412Zx || TM32F412Vx */
    172            
    173            /* Get the BTCR register value */
    174            tmpr = Device->BTCR[Init->NSBank];
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0xF850 0x4022      LDR      R4,[R0, R2, LSL #+2]
    175          
    176          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)
    177            /* Clear MBKEN, MUXEN, MTYP, MWID, FACCEN, BURSTEN, WAITPOL, WRAPMOD, WAITCFG, WREN,
    178                     WAITEN, EXTMOD, ASYNCWAIT, CPSIZE and CBURSTRW bits */
    179            tmpr &= ((uint32_t)~(FSMC_BCR1_MBKEN     | FSMC_BCR1_MUXEN    | FSMC_BCR1_MTYP     | \
    180                                 FSMC_BCR1_MWID      | FSMC_BCR1_FACCEN   | FSMC_BCR1_BURSTEN  | \
    181                                 FSMC_BCR1_WAITPOL   | FSMC_BCR1_WRAPMOD  | FSMC_BCR1_WAITCFG  | \
    182                                 FSMC_BCR1_WREN      | FSMC_BCR1_WAITEN   | FSMC_BCR1_EXTMOD   | \
    183                                 FSMC_BCR1_ASYNCWAIT | FSMC_BCR1_CPSIZE   | FSMC_BCR1_CBURSTRW));
    184            /* Set NORSRAM device control parameters */
    185            tmpr |= (uint32_t)(Init->DataAddressMux       |\
    186                               Init->MemoryType           |\
    187                               Init->MemoryDataWidth      |\
    188                               Init->BurstAccessMode      |\
    189                               Init->WaitSignalPolarity   |\
    190                               Init->WrapMode             |\
    191                               Init->WaitSignalActive     |\
    192                               Init->WriteOperation       |\
    193                               Init->WaitSignal           |\
    194                               Init->ExtendedMode         |\
    195                               Init->AsynchronousWait     |\
    196                               Init->PageSize             |\
    197                               Init->WriteBurst
    198                               );
   \   00000008   0x688B             LDR      R3,[R1, #+8]
   \   0000000A   0x....             LDR.N    R5,??DataTable3  ;; 0xfff00080
   \   0000000C   0x402C             ANDS     R4,R5,R4
   \   0000000E   0x684D             LDR      R5,[R1, #+4]
   \   00000010   0x432C             ORRS     R4,R5,R4
   \   00000012   0x431C             ORRS     R4,R3,R4
   \   00000014   0x68CD             LDR      R5,[R1, #+12]
   \   00000016   0x432C             ORRS     R4,R5,R4
   \   00000018   0x690D             LDR      R5,[R1, #+16]
   \   0000001A   0x432C             ORRS     R4,R5,R4
   \   0000001C   0x694D             LDR      R5,[R1, #+20]
   \   0000001E   0x432C             ORRS     R4,R5,R4
   \   00000020   0x698D             LDR      R5,[R1, #+24]
   \   00000022   0x432C             ORRS     R4,R5,R4
   \   00000024   0x69CD             LDR      R5,[R1, #+28]
   \   00000026   0x432C             ORRS     R4,R5,R4
   \   00000028   0x6A0D             LDR      R5,[R1, #+32]
   \   0000002A   0x432C             ORRS     R4,R5,R4
   \   0000002C   0x6A4D             LDR      R5,[R1, #+36]
   \   0000002E   0x432C             ORRS     R4,R5,R4
   \   00000030   0x6A8D             LDR      R5,[R1, #+40]
   \   00000032   0x432C             ORRS     R4,R5,R4
   \   00000034   0x6ACD             LDR      R5,[R1, #+44]
   \   00000036   0x432C             ORRS     R4,R5,R4
   \   00000038   0x6BCD             LDR      R5,[R1, #+60]
   \   0000003A   0x432C             ORRS     R4,R5,R4
   \   0000003C   0x6B09             LDR      R1,[R1, #+48]
   \   0000003E   0x4321             ORRS     R1,R1,R4
    199          #else /* STM32F412Zx || STM32F412Vx || STM32F412Rx */
    200            /* Clear MBKEN, MUXEN, MTYP, MWID, FACCEN, BURSTEN, WAITPOL, WAITCFG, WREN,
    201                     WAITEN, EXTMOD, ASYNCWAIT,CPSIZE,  CBURSTRW, CCLKEN and WFDIS bits */
    202            tmpr &= ((uint32_t)~(FSMC_BCR1_MBKEN     | FSMC_BCR1_MUXEN    | FSMC_BCR1_MTYP      | \
    203                                 FSMC_BCR1_MWID      | FSMC_BCR1_FACCEN   | FSMC_BCR1_BURSTEN   | \
    204                                 FSMC_BCR1_WAITPOL   | FSMC_BCR1_WAITCFG  | FSMC_BCR1_WREN      | \
    205                                 FSMC_BCR1_WAITEN    | FSMC_BCR1_EXTMOD   | FSMC_BCR1_ASYNCWAIT | \
    206                                 FSMC_BCR1_CPSIZE    | FSMC_BCR1_CBURSTRW | FSMC_BCR1_CCLKEN    | \
    207                                 FSMC_BCR1_WFDIS));
    208            /* Set NORSRAM device control parameters */
    209            tmpr |= (uint32_t)(Init->DataAddressMux       |\
    210                               Init->MemoryType           |\
    211                               Init->MemoryDataWidth      |\
    212                               Init->BurstAccessMode      |\
    213                               Init->WaitSignalPolarity   |\
    214                               Init->WaitSignalActive     |\
    215                               Init->WriteOperation       |\
    216                               Init->WaitSignal           |\
    217                               Init->ExtendedMode         |\
    218                               Init->AsynchronousWait     |\
    219                               Init->WriteBurst           |\
    220                               Init->ContinuousClock      |\
    221                               Init->PageSize             |\
    222                               Init->WriteFifo);
    223          #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */ 
    224                      
    225            if(Init->MemoryType == FSMC_MEMORY_TYPE_NOR)
   \   00000040   0x2B08             CMP      R3,#+8
   \   00000042   0xD101             BNE.N    ??FSMC_NORSRAM_Init_0
    226            {
    227              tmpr |= (uint32_t)FSMC_NORSRAM_FLASH_ACCESS_ENABLE;
   \   00000044   0xF041 0x0140      ORR      R1,R1,#0x40
    228            }
    229          
    230            Device->BTCR[Init->NSBank] = tmpr;
   \                     ??FSMC_NORSRAM_Init_0: (+1)
   \   00000048   0xF840 0x1022      STR      R1,[R0, R2, LSL #+2]
    231          
    232          #if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx)
    233            /* Configure synchronous mode when Continuous clock is enabled for bank2..4 */
    234            if((Init->ContinuousClock == FSMC_CONTINUOUS_CLOCK_SYNC_ASYNC) && (Init->NSBank != FSMC_NORSRAM_BANK1))
    235            {
    236              Device->BTCR[FSMC_NORSRAM_BANK1] |= (uint32_t)(Init->ContinuousClock);
    237            }
    238          
    239            if(Init->NSBank != FSMC_NORSRAM_BANK1)
    240            {
    241              Device->BTCR[FSMC_NORSRAM_BANK1] |= (uint32_t)(Init->WriteFifo);
    242            }
    243          #endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx */
    244          
    245            return HAL_OK;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBC30             POP      {R4,R5}
   \   00000050   0x4770             BX       LR               ;; return
    246          }
    247          
    248          /**
    249            * @brief  DeInitialize the FSMC_NORSRAM peripheral 
    250            * @param  Device: Pointer to NORSRAM device instance
    251            * @param  ExDevice: Pointer to NORSRAM extended mode device instance  
    252            * @param  Bank: NORSRAM bank number  
    253            * @retval HAL status
    254            */

   \                                 In section .text, align 2, keep-with-next
    255          HAL_StatusTypeDef FSMC_NORSRAM_DeInit(FSMC_NORSRAM_TypeDef *Device, FSMC_NORSRAM_EXTENDED_TypeDef *ExDevice, uint32_t Bank)
    256          {
    257            /* Check the parameters */
    258            assert_param(IS_FSMC_NORSRAM_DEVICE(Device));
    259            assert_param(IS_FSMC_NORSRAM_EXTENDED_DEVICE(ExDevice));
    260            assert_param(IS_FSMC_NORSRAM_BANK(Bank));
    261          
    262            /* Disable the FSMC_NORSRAM device */
    263            __FSMC_NORSRAM_DISABLE(Device, Bank);
   \                     FSMC_NORSRAM_DeInit: (+1)
   \   00000000   0xF850 0x3022      LDR      R3,[R0, R2, LSL #+2]
   \   00000004   0x085B             LSRS     R3,R3,#+1
   \   00000006   0x005B             LSLS     R3,R3,#+1
   \   00000008   0xF840 0x3022      STR      R3,[R0, R2, LSL #+2]
    264            
    265            /* De-initialize the FSMC_NORSRAM device */
    266            /* FSMC_NORSRAM_BANK1 */
    267            if(Bank == FSMC_NORSRAM_BANK1)
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD103             BNE.N    ??FSMC_NORSRAM_DeInit_0
    268            {
    269              Device->BTCR[Bank] = 0x000030DBU;    
   \   00000010   0xF243 0x03DB      MOVW     R3,#+12507
   \   00000014   0x6003             STR      R3,[R0, #+0]
   \   00000016   0xE003             B.N      ??FSMC_NORSRAM_DeInit_1
    270            }
    271            /* FSMC_NORSRAM_BANK2, FSMC_NORSRAM_BANK3 or FSMC_NORSRAM_BANK4 */
    272            else
    273            {   
    274              Device->BTCR[Bank] = 0x000030D2U; 
   \                     ??FSMC_NORSRAM_DeInit_0: (+1)
   \   00000018   0xF243 0x03D2      MOVW     R3,#+12498
   \   0000001C   0xF840 0x3022      STR      R3,[R0, R2, LSL #+2]
    275            }
    276            
    277            Device->BTCR[Bank + 1U] = 0x0FFFFFFFU;
   \                     ??FSMC_NORSRAM_DeInit_1: (+1)
   \   00000020   0xF06F 0x4370      MVN      R3,#-268435456
   \   00000024   0xEB00 0x0082      ADD      R0,R0,R2, LSL #+2
   \   00000028   0x6043             STR      R3,[R0, #+4]
    278            ExDevice->BWTR[Bank]    = 0x0FFFFFFFU;
   \   0000002A   0xF841 0x3022      STR      R3,[R1, R2, LSL #+2]
    279             
    280            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4770             BX       LR               ;; return
    281          }
    282          
    283          
    284          /**
    285            * @brief  Initialize the FSMC_NORSRAM Timing according to the specified
    286            *         parameters in the FSMC_NORSRAM_TimingTypeDef
    287            * @param  Device: Pointer to NORSRAM device instance
    288            * @param  Timing: Pointer to NORSRAM Timing structure
    289            * @param  Bank: NORSRAM bank number  
    290            * @retval HAL status
    291            */

   \                                 In section .text, align 2, keep-with-next
    292          HAL_StatusTypeDef FSMC_NORSRAM_Timing_Init(FSMC_NORSRAM_TypeDef *Device, FSMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank)
    293          {
    294            uint32_t tmpr = 0U;
    295            
    296            /* Check the parameters */
    297            assert_param(IS_FSMC_NORSRAM_DEVICE(Device));
    298            assert_param(IS_FSMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime));
    299            assert_param(IS_FSMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime));
    300            assert_param(IS_FSMC_DATASETUP_TIME(Timing->DataSetupTime));
    301            assert_param(IS_FSMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
    302            assert_param(IS_FSMC_CLK_DIV(Timing->CLKDivision));
    303            assert_param(IS_FSMC_DATA_LATENCY(Timing->DataLatency));
    304            assert_param(IS_FSMC_ACCESS_MODE(Timing->AccessMode));
    305            assert_param(IS_FSMC_NORSRAM_BANK(Bank));
    306            
    307            /* Get the BTCR register value */
    308            tmpr = Device->BTCR[Bank + 1U];
   \                     FSMC_NORSRAM_Timing_Init: (+1)
   \   00000000   0xEB00 0x0082      ADD      R0,R0,R2, LSL #+2
   \   00000004   0x6842             LDR      R2,[R0, #+4]
    309          
    310            /* Clear ADDSET, ADDHLD, DATAST, BUSTURN, CLKDIV, DATLAT and ACCMOD bits */
    311            tmpr &= ((uint32_t)~(FSMC_BTR1_ADDSET  | FSMC_BTR1_ADDHLD | FSMC_BTR1_DATAST | \
    312                                 FSMC_BTR1_BUSTURN | FSMC_BTR1_CLKDIV | FSMC_BTR1_DATLAT | \
    313                                 FSMC_BTR1_ACCMOD));
    314            
    315            /* Set FSMC_NORSRAM device timing parameters */  
    316            tmpr |= (uint32_t)(Timing->AddressSetupTime                  |\
    317                              ((Timing->AddressHoldTime) << 4U)          |\
    318                              ((Timing->DataSetupTime) << 8U)            |\
    319                              ((Timing->BusTurnAroundDuration) << 16U)   |\
    320                              (((Timing->CLKDivision)-1U) << 20U)        |\
    321                              (((Timing->DataLatency)-2U) << 24U)        |\
    322                              (Timing->AccessMode));
    323            
    324            Device->BTCR[Bank + 1] = tmpr; 
   \   00000006   0xF002 0x4240      AND      R2,R2,#0xC0000000
   \   0000000A   0x680B             LDR      R3,[R1, #+0]
   \   0000000C   0x431A             ORRS     R2,R3,R2
   \   0000000E   0x684B             LDR      R3,[R1, #+4]
   \   00000010   0xEA42 0x1203      ORR      R2,R2,R3, LSL #+4
   \   00000014   0x688B             LDR      R3,[R1, #+8]
   \   00000016   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   0000001A   0x68CB             LDR      R3,[R1, #+12]
   \   0000001C   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   00000020   0x690B             LDR      R3,[R1, #+16]
   \   00000022   0x1E5B             SUBS     R3,R3,#+1
   \   00000024   0xEA42 0x5203      ORR      R2,R2,R3, LSL #+20
   \   00000028   0x694B             LDR      R3,[R1, #+20]
   \   0000002A   0x1E9B             SUBS     R3,R3,#+2
   \   0000002C   0xEA42 0x6203      ORR      R2,R2,R3, LSL #+24
   \   00000030   0x6989             LDR      R1,[R1, #+24]
   \   00000032   0x4311             ORRS     R1,R1,R2
   \   00000034   0x6041             STR      R1,[R0, #+4]
    325          
    326          #if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx)
    327            /* Configure Clock division value (in NORSRAM bank 1) when continuous clock is enabled */
    328            if(HAL_IS_BIT_SET(Device->BTCR[FSMC_NORSRAM_BANK1], FSMC_BCR1_CCLKEN))
    329            {
    330              tmpr = (uint32_t)(Device->BTCR[FSMC_NORSRAM_BANK1 + 1U] & ~(((uint32_t)0x0FU) << 20U)); 
    331              tmpr |= (uint32_t)(((Timing->CLKDivision)-1U) << 20U);
    332              Device->BTCR[FSMC_NORSRAM_BANK1 + 1U] = tmpr;
    333            }
    334          #endif /* STM32F412Zx || STM32F412Vx || STM32F412Rx */
    335          
    336            return HAL_OK;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x4770             BX       LR               ;; return
    337          }
    338          
    339          /**
    340            * @brief  Initialize the FSMC_NORSRAM Extended mode Timing according to the specified
    341            *         parameters in the FSMC_NORSRAM_TimingTypeDef
    342            * @param  Device: Pointer to NORSRAM device instance
    343            * @param  Timing: Pointer to NORSRAM Timing structure
    344            * @param  Bank: NORSRAM bank number  
    345            * @retval HAL status
    346            */

   \                                 In section .text, align 2, keep-with-next
    347          HAL_StatusTypeDef  FSMC_NORSRAM_Extended_Timing_Init(FSMC_NORSRAM_EXTENDED_TypeDef *Device, FSMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank, uint32_t ExtendedMode)
    348          {
   \                     FSMC_NORSRAM_Extended_Timing_Init: (+1)
   \   00000000   0xB410             PUSH     {R4}
    349            uint32_t tmpr = 0U;
    350            
    351            /* Check the parameters */
    352            assert_param(IS_FSMC_EXTENDED_MODE(ExtendedMode));
    353          
    354            /* Set NORSRAM device timing register for write configuration, if extended mode is used */
    355            if(ExtendedMode == FSMC_EXTENDED_MODE_ENABLE)
   \   00000002   0xF5B3 0x4F80      CMP      R3,#+16384
   \   00000006   0xD113             BNE.N    ??FSMC_NORSRAM_Extended_Timing_Init_0
    356            {
    357              /* Check the parameters */
    358              assert_param(IS_FSMC_NORSRAM_EXTENDED_DEVICE(Device));
    359              assert_param(IS_FSMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime));
    360              assert_param(IS_FSMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime));
    361              assert_param(IS_FSMC_DATASETUP_TIME(Timing->DataSetupTime));
    362              assert_param(IS_FSMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
    363              assert_param(IS_FSMC_ACCESS_MODE(Timing->AccessMode));
    364              assert_param(IS_FSMC_NORSRAM_BANK(Bank));
    365            
    366              /* Get the BWTR register value */
    367              tmpr = Device->BWTR[Bank];
   \   00000008   0xF850 0x3022      LDR      R3,[R0, R2, LSL #+2]
    368              
    369              /* Clear ADDSET, ADDHLD, DATAST, BUSTURN and ACCMOD bits */
    370              tmpr &= ((uint32_t)~(FSMC_BWTR1_ADDSET  | FSMC_BWTR1_ADDHLD | FSMC_BWTR1_DATAST | \
    371                                   FSMC_BWTR1_BUSTURN | FSMC_BWTR1_ACCMOD));
    372          
    373              tmpr |= (uint32_t)(Timing->AddressSetupTime                  |\
    374                                ((Timing->AddressHoldTime) << 4U)          |\
    375                                ((Timing->DataSetupTime) << 8U)            |\
    376                                ((Timing->BusTurnAroundDuration) << 16U)   |\
    377                                (Timing->AccessMode));
    378              
    379              Device->BWTR[Bank] = tmpr;
   \   0000000C   0x....             LDR.N    R4,??DataTable3_1  ;; 0xcff00000
   \   0000000E   0x4023             ANDS     R3,R4,R3
   \   00000010   0x680C             LDR      R4,[R1, #+0]
   \   00000012   0x4323             ORRS     R3,R4,R3
   \   00000014   0x684C             LDR      R4,[R1, #+4]
   \   00000016   0xEA43 0x1304      ORR      R3,R3,R4, LSL #+4
   \   0000001A   0x688C             LDR      R4,[R1, #+8]
   \   0000001C   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   00000020   0x68CC             LDR      R4,[R1, #+12]
   \   00000022   0xEA43 0x4304      ORR      R3,R3,R4, LSL #+16
   \   00000026   0x6989             LDR      R1,[R1, #+24]
   \   00000028   0x4319             ORRS     R1,R1,R3
   \   0000002A   0xF840 0x1022      STR      R1,[R0, R2, LSL #+2]
   \   0000002E   0xE003             B.N      ??FSMC_NORSRAM_Extended_Timing_Init_1
    380            }
    381            else                                        
    382            {
    383              Device->BWTR[Bank] = 0x0FFFFFFFU;
   \                     ??FSMC_NORSRAM_Extended_Timing_Init_0: (+1)
   \   00000030   0xF06F 0x4170      MVN      R1,#-268435456
   \   00000034   0xF840 0x1022      STR      R1,[R0, R2, LSL #+2]
    384            }   
    385            
    386            return HAL_OK;  
   \                     ??FSMC_NORSRAM_Extended_Timing_Init_1: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBC10             POP      {R4}
   \   0000003C   0x4770             BX       LR               ;; return
    387          }
    388          /**
    389            * @}
    390            */
    391            
    392          /** @addtogroup FSMC_LL_NORSRAM_Private_Functions_Group2
    393            *  @brief   management functions 
    394            *
    395          @verbatim   
    396            ==============================================================================
    397                                ##### FSMC_NORSRAM Control functions #####
    398            ==============================================================================
    399            [..]
    400              This subsection provides a set of functions allowing to control dynamically
    401              the FSMC NORSRAM interface.
    402          
    403          @endverbatim
    404            * @{
    405            */
    406              
    407          /**
    408            * @brief  Enables dynamically FSMC_NORSRAM write operation.
    409            * @param  Device: Pointer to NORSRAM device instance
    410            * @param  Bank: NORSRAM bank number   
    411            * @retval HAL status
    412            */

   \                                 In section .text, align 2, keep-with-next
    413          HAL_StatusTypeDef FSMC_NORSRAM_WriteOperation_Enable(FSMC_NORSRAM_TypeDef *Device, uint32_t Bank)
    414          {
    415            /* Check the parameters */
    416            assert_param(IS_FSMC_NORSRAM_DEVICE(Device));
    417            assert_param(IS_FSMC_NORSRAM_BANK(Bank));
    418          
    419            /* Enable write operation */
    420            Device->BTCR[Bank] |= FSMC_WRITE_OPERATION_ENABLE; 
   \                     FSMC_NORSRAM_WriteOperation_Enable: (+1)
   \   00000000   0xF850 0x2021      LDR      R2,[R0, R1, LSL #+2]
   \   00000004   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   00000008   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
    421          
    422            return HAL_OK;  
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    423          }
    424          
    425          /**
    426            * @brief  Disables dynamically FSMC_NORSRAM write operation.
    427            * @param  Device: Pointer to NORSRAM device instance
    428            * @param  Bank: NORSRAM bank number   
    429            * @retval HAL status
    430            */

   \                                 In section .text, align 2, keep-with-next
    431          HAL_StatusTypeDef FSMC_NORSRAM_WriteOperation_Disable(FSMC_NORSRAM_TypeDef *Device, uint32_t Bank)
    432          {
    433            /* Check the parameters */
    434            assert_param(IS_FSMC_NORSRAM_DEVICE(Device));
    435            assert_param(IS_FSMC_NORSRAM_BANK(Bank));
    436            
    437            /* Disable write operation */
    438            Device->BTCR[Bank] &= ~FSMC_WRITE_OPERATION_ENABLE; 
   \                     FSMC_NORSRAM_WriteOperation_Disable: (+1)
   \   00000000   0xF850 0x2021      LDR      R2,[R0, R1, LSL #+2]
   \   00000004   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000008   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
    439          
    440            return HAL_OK;  
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    441          }
    442          /**
    443            * @}
    444            */
    445          
    446          /**
    447            * @}
    448            */
    449          
    450          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)
    451          /** @addtogroup FSMC_LL_NAND
    452            * @brief    NAND Controller functions 
    453            *
    454            @verbatim 
    455            ==============================================================================   
    456                              ##### How to use NAND device driver #####
    457            ==============================================================================
    458            [..]
    459              This driver contains a set of APIs to interface with the FSMC NAND banks in order
    460              to run the NAND external devices.
    461            
    462              (+) FSMC NAND bank reset using the function FSMC_NAND_DeInit() 
    463              (+) FSMC NAND bank control configuration using the function FSMC_NAND_Init()
    464              (+) FSMC NAND bank common space timing configuration using the function 
    465                  FSMC_NAND_CommonSpace_Timing_Init()
    466              (+) FSMC NAND bank attribute space timing configuration using the function 
    467                  FSMC_NAND_AttributeSpace_Timing_Init()
    468              (+) FSMC NAND bank enable/disable ECC correction feature using the functions
    469                  FSMC_NAND_ECC_Enable()/FSMC_NAND_ECC_Disable()
    470              (+) FSMC NAND bank get ECC correction code using the function FSMC_NAND_GetECC()  
    471          
    472          @endverbatim
    473            * @{
    474            */
    475              
    476          /** @addtogroup FSMC_LL_NAND_Private_Functions_Group1
    477            *  @brief    Initialization and Configuration functions 
    478            *
    479          @verbatim    
    480            ==============================================================================
    481                        ##### Initialization and de_initialization functions #####
    482            ==============================================================================
    483            [..]  
    484              This section provides functions allowing to:
    485              (+) Initialize and configure the FSMC NAND interface
    486              (+) De-initialize the FSMC NAND interface 
    487              (+) Configure the FSMC clock and associated GPIOs
    488                  
    489          @endverbatim
    490            * @{
    491            */
    492            
    493          /**
    494            * @brief  Initializes the FSMC_NAND device according to the specified
    495            *         control parameters in the FSMC_NAND_HandleTypeDef
    496            * @param  Device: Pointer to NAND device instance
    497            * @param  Init: Pointer to NAND Initialization structure
    498            * @retval HAL status
    499            */

   \                                 In section .text, align 2, keep-with-next
    500          HAL_StatusTypeDef FSMC_NAND_Init(FSMC_NAND_TypeDef *Device, FSMC_NAND_InitTypeDef *Init)
    501          {
   \                     FSMC_NAND_Init: (+1)
   \   00000000   0xB410             PUSH     {R4}
    502            uint32_t tmpr  = 0U; 
    503              
    504            /* Check the parameters */
    505            assert_param(IS_FSMC_NAND_BANK(Init->NandBank));
    506            assert_param(IS_FSMC_WAIT_FEATURE(Init->Waitfeature));
    507            assert_param(IS_FSMC_NAND_MEMORY_WIDTH(Init->MemoryDataWidth));
    508            assert_param(IS_FSMC_ECC_STATE(Init->EccComputation));
    509            assert_param(IS_FSMC_ECCPAGE_SIZE(Init->ECCPageSize));
    510            assert_param(IS_FSMC_TCLR_TIME(Init->TCLRSetupTime));
    511            assert_param(IS_FSMC_TAR_TIME(Init->TARSetupTime));   
    512          
    513              if(Init->NandBank == FSMC_NAND_BANK2)
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x2A10             CMP      R2,#+16
   \   00000006   0xD101             BNE.N    ??FSMC_NAND_Init_0
    514            {
    515              /* Get the NAND bank 2 register value */
    516              tmpr = Device->PCR2;
   \   00000008   0x6803             LDR      R3,[R0, #+0]
   \   0000000A   0xE000             B.N      ??FSMC_NAND_Init_1
    517            }
    518            else
    519            {
    520              /* Get the NAND bank 3 register value */
    521              tmpr = Device->PCR3;
   \                     ??FSMC_NAND_Init_0: (+1)
   \   0000000C   0x6A03             LDR      R3,[R0, #+32]
    522            }
    523            
    524            /* Clear PWAITEN, PBKEN, PTYP, PWID, ECCEN, TCLR, TAR and ECCPS bits */
    525            tmpr &= ((uint32_t)~(FSMC_PCR2_PWAITEN  | FSMC_PCR2_PBKEN | FSMC_PCR2_PTYP | \
    526                                 FSMC_PCR2_PWID | FSMC_PCR2_ECCEN | FSMC_PCR2_TCLR | \
    527                                 FSMC_PCR2_TAR | FSMC_PCR2_ECCPS));  
    528            
    529            /* Set NAND device control parameters */
    530            tmpr |= (uint32_t)(Init->Waitfeature                |\
    531                               FSMC_PCR_MEMORY_TYPE_NAND        |\
    532                               Init->MemoryDataWidth            |\
    533                               Init->EccComputation             |\
    534                               Init->ECCPageSize                |\
    535                               ((Init->TCLRSetupTime) << 9U)    |\
    536                               ((Init->TARSetupTime) << 13U));   
   \                     ??FSMC_NAND_Init_1: (+1)
   \   0000000E   0x....             LDR.N    R4,??DataTable3_2  ;; 0xfff00181
   \   00000010   0x4023             ANDS     R3,R4,R3
   \   00000012   0x684C             LDR      R4,[R1, #+4]
   \   00000014   0x4323             ORRS     R3,R4,R3
   \   00000016   0x688C             LDR      R4,[R1, #+8]
   \   00000018   0x4323             ORRS     R3,R4,R3
   \   0000001A   0x68CC             LDR      R4,[R1, #+12]
   \   0000001C   0x4323             ORRS     R3,R4,R3
   \   0000001E   0x690C             LDR      R4,[R1, #+16]
   \   00000020   0x4323             ORRS     R3,R4,R3
   \   00000022   0x694C             LDR      R4,[R1, #+20]
   \   00000024   0xEA43 0x2344      ORR      R3,R3,R4, LSL #+9
   \   00000028   0x6989             LDR      R1,[R1, #+24]
   \   0000002A   0xEA43 0x3141      ORR      R1,R3,R1, LSL #+13
   \   0000002E   0xF041 0x0108      ORR      R1,R1,#0x8
    537            
    538            if(Init->NandBank == FSMC_NAND_BANK2)
   \   00000032   0x2A10             CMP      R2,#+16
   \   00000034   0xD101             BNE.N    ??FSMC_NAND_Init_2
    539            {
    540              /* NAND bank 2 registers configuration */
    541              Device->PCR2  = tmpr;
   \   00000036   0x6001             STR      R1,[R0, #+0]
   \   00000038   0xE000             B.N      ??FSMC_NAND_Init_3
    542            }
    543            else
    544            {
    545              /* NAND bank 3 registers configuration */
    546              Device->PCR3  = tmpr;
   \                     ??FSMC_NAND_Init_2: (+1)
   \   0000003A   0x6201             STR      R1,[R0, #+32]
    547            }
    548            
    549            return HAL_OK;
   \                     ??FSMC_NAND_Init_3: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xBC10             POP      {R4}
   \   00000040   0x4770             BX       LR               ;; return
    550          }
    551          
    552          /**
    553            * @brief  Initializes the FSMC_NAND Common space Timing according to the specified
    554            *         parameters in the FSMC_NAND_PCC_TimingTypeDef
    555            * @param  Device: Pointer to NAND device instance
    556            * @param  Timing: Pointer to NAND timing structure
    557            * @param  Bank: NAND bank number   
    558            * @retval HAL status
    559            */

   \                                 In section .text, align 2, keep-with-next
    560          HAL_StatusTypeDef FSMC_NAND_CommonSpace_Timing_Init(FSMC_NAND_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank)
    561          {
   \                     FSMC_NAND_CommonSpace_Timing_Init: (+1)
   \   00000000   0xB410             PUSH     {R4}
    562            uint32_t tmpr = 0U;  
    563            
    564            /* Check the parameters */
    565            assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
    566            assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
    567            assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
    568            assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
    569            
    570            if(Bank == FSMC_NAND_BANK2)
   \   00000002   0x2A10             CMP      R2,#+16
   \   00000004   0xD101             BNE.N    ??FSMC_NAND_CommonSpace_Timing_Init_0
    571            {
    572              /* Get the NAND bank 2 register value */
    573              tmpr = Device->PMEM2;
   \   00000006   0x6883             LDR      R3,[R0, #+8]
   \   00000008   0xE000             B.N      ??FSMC_NAND_CommonSpace_Timing_Init_1
    574            }
    575            else
    576            {
    577              /* Get the NAND bank 3 register value */
    578              tmpr = Device->PMEM3;
   \                     ??FSMC_NAND_CommonSpace_Timing_Init_0: (+1)
   \   0000000A   0x6A83             LDR      R3,[R0, #+40]
    579            } 
    580            
    581            /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
    582            tmpr &= ((uint32_t)~(FSMC_PMEM2_MEMSET2  | FSMC_PMEM2_MEMWAIT2 | FSMC_PMEM2_MEMHOLD2 | \
    583                                 FSMC_PMEM2_MEMHIZ2));
    584            
    585            /* Set FSMC_NAND device timing parameters */
    586            tmpr |= (uint32_t)(Timing->SetupTime                     |\
    587                                 ((Timing->WaitSetupTime) << 8U)     |\
    588                                 ((Timing->HoldSetupTime) << 16U)    |\
    589                                 ((Timing->HiZSetupTime) << 24U)
    590                                 );
   \                     ??FSMC_NAND_CommonSpace_Timing_Init_1: (+1)
   \   0000000C   0x680B             LDR      R3,[R1, #+0]
   \   0000000E   0x684C             LDR      R4,[R1, #+4]
   \   00000010   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   00000014   0x688C             LDR      R4,[R1, #+8]
   \   00000016   0xEA43 0x4304      ORR      R3,R3,R4, LSL #+16
   \   0000001A   0x68C9             LDR      R1,[R1, #+12]
   \   0000001C   0xEA43 0x6101      ORR      R1,R3,R1, LSL #+24
    591                                      
    592            if(Bank == FSMC_NAND_BANK2)
   \   00000020   0xD101             BNE.N    ??FSMC_NAND_CommonSpace_Timing_Init_2
    593            {
    594              /* NAND bank 2 registers configuration */
    595              Device->PMEM2 = tmpr;
   \   00000022   0x6081             STR      R1,[R0, #+8]
   \   00000024   0xE000             B.N      ??FSMC_NAND_CommonSpace_Timing_Init_3
    596            }
    597            else
    598            {
    599              /* NAND bank 3 registers configuration */
    600              Device->PMEM3 = tmpr;
   \                     ??FSMC_NAND_CommonSpace_Timing_Init_2: (+1)
   \   00000026   0x6281             STR      R1,[R0, #+40]
    601            }  
    602            
    603            return HAL_OK;  
   \                     ??FSMC_NAND_CommonSpace_Timing_Init_3: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBC10             POP      {R4}
   \   0000002C   0x4770             BX       LR               ;; return
    604          }
    605          
    606          /**
    607            * @brief  Initializes the FSMC_NAND Attribute space Timing according to the specified
    608            *         parameters in the FSMC_NAND_PCC_TimingTypeDef
    609            * @param  Device: Pointer to NAND device instance
    610            * @param  Timing: Pointer to NAND timing structure
    611            * @param  Bank: NAND bank number 
    612            * @retval HAL status
    613            */

   \                                 In section .text, align 2, keep-with-next
    614          HAL_StatusTypeDef FSMC_NAND_AttributeSpace_Timing_Init(FSMC_NAND_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank)
    615          {
   \                     FSMC_NAND_AttributeSpace_Timing_Init: (+1)
   \   00000000   0xB410             PUSH     {R4}
    616            uint32_t tmpr = 0U;  
    617            
    618            /* Check the parameters */  
    619            assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
    620            assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
    621            assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
    622            assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
    623            
    624            if(Bank == FSMC_NAND_BANK2)
   \   00000002   0x2A10             CMP      R2,#+16
   \   00000004   0xD101             BNE.N    ??FSMC_NAND_AttributeSpace_Timing_Init_0
    625            {
    626              /* Get the NAND bank 2 register value */
    627              tmpr = Device->PATT2;
   \   00000006   0x68C3             LDR      R3,[R0, #+12]
   \   00000008   0xE000             B.N      ??FSMC_NAND_AttributeSpace_Timing_Init_1
    628            }
    629            else
    630            {
    631              /* Get the NAND bank 3 register value */
    632              tmpr = Device->PATT3;
   \                     ??FSMC_NAND_AttributeSpace_Timing_Init_0: (+1)
   \   0000000A   0x6AC3             LDR      R3,[R0, #+44]
    633            } 
    634            
    635            /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
    636            tmpr &= ((uint32_t)~(FSMC_PATT2_ATTSET2  | FSMC_PATT2_ATTWAIT2 | FSMC_PATT2_ATTHOLD2 | \
    637                                 FSMC_PATT2_ATTHIZ2));
    638            
    639            /* Set FSMC_NAND device timing parameters */
    640            tmpr |= (uint32_t)(Timing->SetupTime                     |\
    641                                 ((Timing->WaitSetupTime) << 8U)     |\
    642                                 ((Timing->HoldSetupTime) << 16U)    |\
    643                                 ((Timing->HiZSetupTime) << 24U)
    644                                 );
   \                     ??FSMC_NAND_AttributeSpace_Timing_Init_1: (+1)
   \   0000000C   0x680B             LDR      R3,[R1, #+0]
   \   0000000E   0x684C             LDR      R4,[R1, #+4]
   \   00000010   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   00000014   0x688C             LDR      R4,[R1, #+8]
   \   00000016   0xEA43 0x4304      ORR      R3,R3,R4, LSL #+16
   \   0000001A   0x68C9             LDR      R1,[R1, #+12]
   \   0000001C   0xEA43 0x6101      ORR      R1,R3,R1, LSL #+24
    645                                 
    646            if(Bank == FSMC_NAND_BANK2)
   \   00000020   0xD101             BNE.N    ??FSMC_NAND_AttributeSpace_Timing_Init_2
    647            {
    648              /* NAND bank 2 registers configuration */
    649              Device->PATT2 = tmpr;
   \   00000022   0x60C1             STR      R1,[R0, #+12]
   \   00000024   0xE000             B.N      ??FSMC_NAND_AttributeSpace_Timing_Init_3
    650            }
    651            else
    652            {
    653              /* NAND bank 3 registers configuration */
    654              Device->PATT3 = tmpr;
   \                     ??FSMC_NAND_AttributeSpace_Timing_Init_2: (+1)
   \   00000026   0x62C1             STR      R1,[R0, #+44]
    655            }   
    656            
    657            return HAL_OK;
   \                     ??FSMC_NAND_AttributeSpace_Timing_Init_3: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBC10             POP      {R4}
   \   0000002C   0x4770             BX       LR               ;; return
    658          }
    659          
    660          /**
    661            * @brief  DeInitializes the FSMC_NAND device 
    662            * @param  Device: Pointer to NAND device instance
    663            * @param  Bank: NAND bank number
    664            * @retval HAL status
    665            */

   \                                 In section .text, align 2, keep-with-next
    666          HAL_StatusTypeDef FSMC_NAND_DeInit(FSMC_NAND_TypeDef *Device, uint32_t Bank)
    667          {
    668            /* Disable the NAND Bank */
    669            __FSMC_NAND_DISABLE(Device, Bank);
   \                     FSMC_NAND_DeInit: (+1)
   \   00000000   0x2910             CMP      R1,#+16
   \   00000002   0xD104             BNE.N    ??FSMC_NAND_DeInit_0
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0xF022 0x0204      BIC      R2,R2,#0x4
   \   0000000A   0x6002             STR      R2,[R0, #+0]
   \   0000000C   0xE003             B.N      ??FSMC_NAND_DeInit_1
   \                     ??FSMC_NAND_DeInit_0: (+1)
   \   0000000E   0x6A02             LDR      R2,[R0, #+32]
   \   00000010   0xF022 0x0204      BIC      R2,R2,#0x4
   \   00000014   0x6202             STR      R2,[R0, #+32]
    670           
    671            /* De-initialize the NAND Bank */
    672            if(Bank == FSMC_NAND_BANK2)
   \                     ??FSMC_NAND_DeInit_1: (+1)
   \   00000016   0xF04F 0x32FC      MOV      R2,#-50529028
   \   0000001A   0xD106             BNE.N    ??FSMC_NAND_DeInit_2
    673            {
    674              /* Set the FSMC_NAND_BANK2 registers to their reset values */
    675              Device->PCR2  = 0x00000018U;
   \   0000001C   0x2118             MOVS     R1,#+24
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    676              Device->SR2   = 0x00000040U;
   \   00000020   0x2140             MOVS     R1,#+64
   \   00000022   0x6041             STR      R1,[R0, #+4]
    677              Device->PMEM2 = 0xFCFCFCFCU;
   \   00000024   0x6082             STR      R2,[R0, #+8]
    678              Device->PATT2 = 0xFCFCFCFCU;  
   \   00000026   0x60C2             STR      R2,[R0, #+12]
   \   00000028   0xE005             B.N      ??FSMC_NAND_DeInit_3
    679            }
    680            /* FSMC_Bank3_NAND */  
    681            else
    682            {
    683              /* Set the FSMC_NAND_BANK3 registers to their reset values */
    684              Device->PCR3  = 0x00000018U;
   \                     ??FSMC_NAND_DeInit_2: (+1)
   \   0000002A   0x2118             MOVS     R1,#+24
   \   0000002C   0x6201             STR      R1,[R0, #+32]
    685              Device->SR3   = 0x00000040U;
   \   0000002E   0x2140             MOVS     R1,#+64
   \   00000030   0x6241             STR      R1,[R0, #+36]
    686              Device->PMEM3 = 0xFCFCFCFCU;
   \   00000032   0x6282             STR      R2,[R0, #+40]
    687              Device->PATT3 = 0xFCFCFCFCU; 
   \   00000034   0x62C2             STR      R2,[R0, #+44]
    688            }
    689            
    690            return HAL_OK;
   \                     ??FSMC_NAND_DeInit_3: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x4770             BX       LR               ;; return
    691          }
    692          /**
    693            * @}
    694            */
    695            
    696          /** @addtogroup FSMC_LL_NAND_Private_Functions_Group2
    697            *  @brief   management functions 
    698            *
    699          @verbatim   
    700            ==============================================================================
    701                                 ##### FSMC_NAND Control functions #####
    702            ==============================================================================
    703            [..]
    704              This subsection provides a set of functions allowing to control dynamically
    705              the FSMC NAND interface.
    706          
    707          @endverbatim
    708            * @{
    709            */ 
    710              
    711          /**
    712            * @brief  Enables dynamically FSMC_NAND ECC feature.
    713            * @param  Device: Pointer to NAND device instance
    714            * @param  Bank: NAND bank number
    715            * @retval HAL status
    716            */    

   \                                 In section .text, align 2, keep-with-next
    717          HAL_StatusTypeDef  FSMC_NAND_ECC_Enable(FSMC_NAND_TypeDef *Device, uint32_t Bank)
    718          {
    719            /* Enable ECC feature */
    720            if(Bank == FSMC_NAND_BANK2)
   \                     FSMC_NAND_ECC_Enable: (+1)
   \   00000000   0x2910             CMP      R1,#+16
   \   00000002   0xD104             BNE.N    ??FSMC_NAND_ECC_Enable_0
    721            {
    722              Device->PCR2 |= FSMC_PCR2_ECCEN;
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0xE003             B.N      ??FSMC_NAND_ECC_Enable_1
    723            }
    724            else
    725            {
    726              Device->PCR3 |= FSMC_PCR3_ECCEN;
   \                     ??FSMC_NAND_ECC_Enable_0: (+1)
   \   0000000E   0x6A01             LDR      R1,[R0, #+32]
   \   00000010   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000014   0x6201             STR      R1,[R0, #+32]
    727            } 
    728            
    729            return HAL_OK;  
   \                     ??FSMC_NAND_ECC_Enable_1: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
    730          }
    731          
    732          /**
    733            * @brief  Disables dynamically FSMC_NAND ECC feature.
    734            * @param  Device: Pointer to NAND device instance
    735            * @param  Bank: NAND bank number
    736            * @retval HAL status
    737            */  

   \                                 In section .text, align 2, keep-with-next
    738          HAL_StatusTypeDef FSMC_NAND_ECC_Disable(FSMC_NAND_TypeDef *Device, uint32_t Bank)  
    739          {  
    740            /* Disable ECC feature */
    741            if(Bank == FSMC_NAND_BANK2)
   \                     FSMC_NAND_ECC_Disable: (+1)
   \   00000000   0x2910             CMP      R1,#+16
   \   00000002   0xD104             BNE.N    ??FSMC_NAND_ECC_Disable_0
    742            {
    743              Device->PCR2 &= ~FSMC_PCR2_ECCEN;
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0xE003             B.N      ??FSMC_NAND_ECC_Disable_1
    744            }
    745            else
    746            {
    747              Device->PCR3 &= ~FSMC_PCR3_ECCEN;
   \                     ??FSMC_NAND_ECC_Disable_0: (+1)
   \   0000000E   0x6A01             LDR      R1,[R0, #+32]
   \   00000010   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000014   0x6201             STR      R1,[R0, #+32]
    748            } 
    749          
    750            return HAL_OK;  
   \                     ??FSMC_NAND_ECC_Disable_1: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
    751          }
    752          
    753          /**
    754            * @brief  Disables dynamically FSMC_NAND ECC feature.
    755            * @param  Device: Pointer to NAND device instance
    756            * @param  ECCval: Pointer to ECC value
    757            * @param  Bank: NAND bank number
    758            * @param  Timeout: Timeout wait value  
    759            * @retval HAL status
    760            */

   \                                 In section .text, align 2, keep-with-next
    761          HAL_StatusTypeDef FSMC_NAND_GetECC(FSMC_NAND_TypeDef *Device, uint32_t *ECCval, uint32_t Bank, uint32_t Timeout)
    762          {
   \                     FSMC_NAND_GetECC: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    763            uint32_t tickstart = 0U;
    764            
    765            /* Check the parameters */ 
    766            assert_param(IS_FSMC_NAND_DEVICE(Device)); 
    767            assert_param(IS_FSMC_NAND_BANK(Bank));
    768          
    769            /* Get tick */ 
    770            tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   \   00000010   0x4680             MOV      R8,R0
    771          
    772            /* Wait until FIFO is empty */
    773            while(__FSMC_NAND_GET_FLAG(Device, Bank, FSMC_FLAG_FEMPT) == RESET)
   \                     ??FSMC_NAND_GetECC_0: (+1)
   \   00000012   0x2E10             CMP      R6,#+16
   \   00000014   0xD104             BNE.N    ??FSMC_NAND_GetECC_1
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x0980             LSRS     R0,R0,#+6
   \   0000001A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000001E   0xE003             B.N      ??FSMC_NAND_GetECC_2
   \                     ??FSMC_NAND_GetECC_1: (+1)
   \   00000020   0x6A60             LDR      R0,[R4, #+36]
   \   00000022   0x0980             LSRS     R0,R0,#+6
   \   00000024   0xF000 0x0001      AND      R0,R0,#0x1
   \                     ??FSMC_NAND_GetECC_2: (+1)
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD10C             BNE.N    ??FSMC_NAND_GetECC_3
    774            {
    775              /* Check for the Timeout */
    776              if(Timeout != HAL_MAX_DELAY)
   \   0000002C   0xF117 0x0F01      CMN      R7,#+1
   \   00000030   0xD0EF             BEQ.N    ??FSMC_NAND_GetECC_0
    777              {
    778                if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000032   0x2F00             CMP      R7,#+0
   \   00000034   0xD005             BEQ.N    ??FSMC_NAND_GetECC_4
   \   00000036   0x.... 0x....      BL       HAL_GetTick
   \   0000003A   0xEBA0 0x0008      SUB      R0,R0,R8
   \   0000003E   0x4287             CMP      R7,R0
   \   00000040   0xD2E7             BCS.N    ??FSMC_NAND_GetECC_0
    779                {
    780                  return HAL_TIMEOUT;
   \                     ??FSMC_NAND_GetECC_4: (+1)
   \   00000042   0x2003             MOVS     R0,#+3
   \   00000044   0xE007             B.N      ??FSMC_NAND_GetECC_5
    781                }
    782              }   
    783            }
    784               
    785            if(Bank == FSMC_NAND_BANK2)
   \                     ??FSMC_NAND_GetECC_3: (+1)
   \   00000046   0x2E10             CMP      R6,#+16
   \   00000048   0xD102             BNE.N    ??FSMC_NAND_GetECC_6
    786            {    
    787              /* Get the ECCR2 register value */
    788              *ECCval = (uint32_t)Device->ECCR2;
   \   0000004A   0x6960             LDR      R0,[R4, #+20]
   \   0000004C   0x6028             STR      R0,[R5, #+0]
   \   0000004E   0xE001             B.N      ??FSMC_NAND_GetECC_7
    789            }
    790            else
    791            {    
    792              /* Get the ECCR3 register value */
    793              *ECCval = (uint32_t)Device->ECCR3;
   \                     ??FSMC_NAND_GetECC_6: (+1)
   \   00000050   0x6B60             LDR      R0,[R4, #+52]
   \   00000052   0x6028             STR      R0,[R5, #+0]
    794            }
    795          
    796            return HAL_OK;  
   \                     ??FSMC_NAND_GetECC_7: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??FSMC_NAND_GetECC_5: (+1)
   \   00000056   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    797          }
    798          
    799          /**
    800            * @}
    801            */
    802            
    803          /**
    804            * @}
    805            */
    806              
    807          /** @addtogroup FSMC_LL_PCCARD
    808            * @brief    PCCARD Controller functions 
    809            *
    810            @verbatim 
    811            ==============================================================================
    812                              ##### How to use PCCARD device driver #####
    813            ==============================================================================
    814            [..]
    815              This driver contains a set of APIs to interface with the FSMC PCCARD bank in order
    816              to run the PCCARD/compact flash external devices.
    817            
    818              (+) FSMC PCCARD bank reset using the function FSMC_PCCARD_DeInit() 
    819              (+) FSMC PCCARD bank control configuration using the function FSMC_PCCARD_Init()
    820              (+) FSMC PCCARD bank common space timing configuration using the function 
    821                  FSMC_PCCARD_CommonSpace_Timing_Init()
    822              (+) FSMC PCCARD bank attribute space timing configuration using the function 
    823                  FSMC_PCCARD_AttributeSpace_Timing_Init()
    824              (+) FSMC PCCARD bank IO space timing configuration using the function 
    825                  FSMC_PCCARD_IOSpace_Timing_Init()
    826                 
    827          @endverbatim
    828            * @{
    829            */
    830            
    831          /** @addtogroup FSMC_LL_PCCARD_Private_Functions_Group1
    832            *  @brief   Initialization and Configuration functions 
    833            *
    834          @verbatim    
    835            ==============================================================================
    836                        ##### Initialization and de_initialization functions #####
    837            ==============================================================================
    838            [..]  
    839              This section provides functions allowing to:
    840              (+) Initialize and configure the FSMC PCCARD interface
    841              (+) De-initialize the FSMC PCCARD interface 
    842              (+) Configure the FSMC clock and associated GPIOs
    843                  
    844          @endverbatim
    845            * @{
    846            */
    847            
    848          /**
    849            * @brief  Initializes the FSMC_PCCARD device according to the specified
    850            *         control parameters in the FSMC_PCCARD_HandleTypeDef
    851            * @param  Device: Pointer to PCCARD device instance
    852            * @param  Init: Pointer to PCCARD Initialization structure   
    853            * @retval HAL status
    854            */

   \                                 In section .text, align 2, keep-with-next
    855          HAL_StatusTypeDef FSMC_PCCARD_Init(FSMC_PCCARD_TypeDef *Device, FSMC_PCCARD_InitTypeDef *Init)
    856          {
    857            uint32_t tmpr = 0U;
    858            
    859            /* Check the parameters */ 
    860            assert_param(IS_FSMC_WAIT_FEATURE(Init->Waitfeature));
    861            assert_param(IS_FSMC_TCLR_TIME(Init->TCLRSetupTime));
    862            assert_param(IS_FSMC_TAR_TIME(Init->TARSetupTime));     
    863            
    864            /* Get PCCARD control register value */
    865            tmpr = Device->PCR4;
   \                     FSMC_PCCARD_Init: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
    866            
    867            /* Clear TAR, TCLR, PWAITEN and PWID bits */
    868            tmpr &= ((uint32_t)~(FSMC_PCR4_TAR  | FSMC_PCR4_TCLR | FSMC_PCR4_PWAITEN | \
    869                                 FSMC_PCR4_PWID));
    870            
    871            /* Set FSMC_PCCARD device control parameters */
    872            tmpr |= (uint32_t)(Init->Waitfeature               |\
    873                               FSMC_NAND_PCC_MEM_BUS_WIDTH_16  |\
    874                               (Init->TCLRSetupTime << 9U)     |\
    875                               (Init->TARSetupTime << 13U));
    876            
    877            Device->PCR4 = tmpr;
   \   00000002   0x....             LDR.N    R3,??DataTable3_3  ;; 0xfffe01cd
   \   00000004   0x401A             ANDS     R2,R3,R2
   \   00000006   0x680B             LDR      R3,[R1, #+0]
   \   00000008   0x431A             ORRS     R2,R3,R2
   \   0000000A   0x684B             LDR      R3,[R1, #+4]
   \   0000000C   0xEA42 0x2243      ORR      R2,R2,R3, LSL #+9
   \   00000010   0x6889             LDR      R1,[R1, #+8]
   \   00000012   0xEA42 0x3141      ORR      R1,R2,R1, LSL #+13
   \   00000016   0xF041 0x0110      ORR      R1,R1,#0x10
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    878            
    879            return HAL_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x4770             BX       LR               ;; return
    880          }
    881          
    882          /**
    883            * @brief  Initializes the FSMC_PCCARD Common space Timing according to the specified
    884            *         parameters in the FSMC_NAND_PCC_TimingTypeDef
    885            * @param  Device: Pointer to PCCARD device instance
    886            * @param  Timing: Pointer to PCCARD timing structure 
    887            * @retval HAL status
    888            */

   \                                 In section .text, align 2, keep-with-next
    889          HAL_StatusTypeDef FSMC_PCCARD_CommonSpace_Timing_Init(FSMC_PCCARD_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing)
    890          {
    891            uint32_t tmpr = 0U;
    892            
    893            /* Check the parameters */
    894            assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
    895            assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
    896            assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
    897            assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
    898          
    899            /* Get PCCARD common space timing register value */
    900            tmpr = Device->PMEM4;
   \                     FSMC_PCCARD_CommonSpace_Timing_Init: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
    901            
    902            /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
    903            tmpr &= ((uint32_t)~(FSMC_PMEM4_MEMSET4  | FSMC_PMEM4_MEMWAIT4 | FSMC_PMEM4_MEMHOLD4 | \
    904                                 FSMC_PMEM4_MEMHIZ4));
    905            /* Set PCCARD timing parameters */
    906            tmpr |= (uint32_t)((Timing->SetupTime                 |\
    907                              ((Timing->WaitSetupTime) << 8U)     |\
    908                              (Timing->HoldSetupTime) << 16U)     |\
    909                              ((Timing->HiZSetupTime) << 24U));
    910            
    911            Device->PMEM4 = tmpr;
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x684B             LDR      R3,[R1, #+4]
   \   00000006   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   0000000A   0x688B             LDR      R3,[R1, #+8]
   \   0000000C   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   00000010   0x68C9             LDR      R1,[R1, #+12]
   \   00000012   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   00000016   0x6081             STR      R1,[R0, #+8]
    912            
    913            return HAL_OK;  
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    914          }
    915          
    916          /**
    917            * @brief  Initializes the FSMC_PCCARD Attribute space Timing according to the specified
    918            *         parameters in the FSMC_NAND_PCC_TimingTypeDef
    919            * @param  Device: Pointer to PCCARD device instance
    920            * @param  Timing: Pointer to PCCARD timing structure  
    921            * @retval HAL status
    922            */

   \                                 In section .text, align 2, keep-with-next
    923          HAL_StatusTypeDef FSMC_PCCARD_AttributeSpace_Timing_Init(FSMC_PCCARD_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing)
    924          {
    925            uint32_t tmpr = 0U;
    926          
    927            /* Check the parameters */  
    928            assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
    929            assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
    930            assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
    931            assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
    932          
    933            /* Get PCCARD timing parameters */
    934            tmpr = Device->PATT4;
   \                     FSMC_PCCARD_AttributeSpace_Timing_Init: (+1)
   \   00000000   0x68C2             LDR      R2,[R0, #+12]
    935          
    936            /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
    937            tmpr &= ((uint32_t)~(FSMC_PATT4_ATTSET4  | FSMC_PATT4_ATTWAIT4 | FSMC_PATT4_ATTHOLD4 | \
    938                                 FSMC_PATT4_ATTHIZ4));
    939            
    940            /* Set PCCARD timing parameters */
    941            tmpr |= (uint32_t)(Timing->SetupTime                 |\
    942                             ((Timing->WaitSetupTime) << 8U)     |\
    943                             ((Timing->HoldSetupTime) << 16U)    |\
    944                             ((Timing->HiZSetupTime) << 24U));
    945            Device->PATT4 = tmpr; 
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x684B             LDR      R3,[R1, #+4]
   \   00000006   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   0000000A   0x688B             LDR      R3,[R1, #+8]
   \   0000000C   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   00000010   0x68C9             LDR      R1,[R1, #+12]
   \   00000012   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   00000016   0x60C1             STR      R1,[R0, #+12]
    946                                                  
    947            return HAL_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    948          }
    949          
    950          /**
    951            * @brief  Initializes the FSMC_PCCARD IO space Timing according to the specified
    952            *         parameters in the FSMC_NAND_PCC_TimingTypeDef
    953            * @param  Device: Pointer to PCCARD device instance
    954            * @param  Timing: Pointer to PCCARD timing structure  
    955            * @retval HAL status
    956            */

   \                                 In section .text, align 2, keep-with-next
    957          HAL_StatusTypeDef FSMC_PCCARD_IOSpace_Timing_Init(FSMC_PCCARD_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing)
    958          {
    959            uint32_t tmpr = 0U;
    960            
    961            /* Check the parameters */  
    962            assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
    963            assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
    964            assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
    965            assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
    966          
    967            /* Get FSMC_PCCARD device timing parameters */
    968            tmpr = Device->PIO4;
   \                     FSMC_PCCARD_IOSpace_Timing_Init: (+1)
   \   00000000   0x6902             LDR      R2,[R0, #+16]
    969          
    970            /* Clear IOSET4, IOWAIT4, IOHOLD4 and IOHIZ4 bits */
    971            tmpr &= ((uint32_t)~(FSMC_PIO4_IOSET4  | FSMC_PIO4_IOWAIT4 | FSMC_PIO4_IOHOLD4 | \
    972                                 FSMC_PIO4_IOHIZ4));
    973            
    974            /* Set FSMC_PCCARD device timing parameters */
    975            tmpr |= (uint32_t)(Timing->SetupTime                   |\
    976                               ((Timing->WaitSetupTime) << 8U)     |\
    977                               ((Timing->HoldSetupTime) << 16U)    |\
    978                               ((Timing->HiZSetupTime) << 24U));   
    979            
    980            Device->PIO4 = tmpr;
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x684B             LDR      R3,[R1, #+4]
   \   00000006   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   0000000A   0x688B             LDR      R3,[R1, #+8]
   \   0000000C   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   00000010   0x68C9             LDR      R1,[R1, #+12]
   \   00000012   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   00000016   0x6101             STR      R1,[R0, #+16]
    981            
    982            return HAL_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    983          }
    984                                                     
    985          /**
    986            * @brief  DeInitializes the FSMC_PCCARD device 
    987            * @param  Device: Pointer to PCCARD device instance
    988            * @retval HAL status
    989            */

   \                                 In section .text, align 2, keep-with-next
    990          HAL_StatusTypeDef FSMC_PCCARD_DeInit(FSMC_PCCARD_TypeDef *Device)
    991          {
    992            /* Disable the FSMC_PCCARD device */
    993            __FSMC_PCCARD_DISABLE(Device);
   \                     FSMC_PCCARD_DeInit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000006   0x6001             STR      R1,[R0, #+0]
    994            
    995            /* De-initialize the FSMC_PCCARD device */
    996            Device->PCR4    = 0x00000018U; 
   \   00000008   0x2118             MOVS     R1,#+24
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    997            Device->SR4     = 0x00000000U;	
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6041             STR      R1,[R0, #+4]
    998            Device->PMEM4   = 0xFCFCFCFCU;
   \   00000010   0xF04F 0x31FC      MOV      R1,#-50529028
   \   00000014   0x6081             STR      R1,[R0, #+8]
    999            Device->PATT4   = 0xFCFCFCFCU;
   \   00000016   0x60C1             STR      R1,[R0, #+12]
   1000            Device->PIO4    = 0xFCFCFCFCU;
   \   00000018   0x6101             STR      R1,[R0, #+16]
   1001            
   1002            return HAL_OK;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
   1003          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0xFFF00080         DC32     0xfff00080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0xCFF00000         DC32     0xcff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0xFFF00181         DC32     0xfff00181

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0xFFFE01CD         DC32     0xfffe01cd
   1004          /**
   1005            * @}
   1006            */
   1007          
   1008          /**
   1009            * @}
   1010            */
   1011          #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
   1012          
   1013          /**
   1014            * @}
   1015            */
   1016          #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F412Zx || STM32F412Vx */
   1017          #endif /* HAL_SRAM_MODULE_ENABLED || HAL_NOR_MODULE_ENABLED || HAL_NAND_MODULE_ENABLED || HAL_PCCARD_MODULE_ENABLED */
   1018          
   1019          /**
   1020            * @}
   1021            */
   1022          
   1023          /**
   1024            * @}
   1025            */
   1026          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   FSMC_NAND_AttributeSpace_Timing_Init
       4   FSMC_NAND_CommonSpace_Timing_Init
       0   FSMC_NAND_DeInit
       0   FSMC_NAND_ECC_Disable
       0   FSMC_NAND_ECC_Enable
      24   FSMC_NAND_GetECC
        24   -> HAL_GetTick
       4   FSMC_NAND_Init
       0   FSMC_NORSRAM_DeInit
       4   FSMC_NORSRAM_Extended_Timing_Init
       8   FSMC_NORSRAM_Init
       0   FSMC_NORSRAM_Timing_Init
       0   FSMC_NORSRAM_WriteOperation_Disable
       0   FSMC_NORSRAM_WriteOperation_Enable
       0   FSMC_PCCARD_AttributeSpace_Timing_Init
       0   FSMC_PCCARD_CommonSpace_Timing_Init
       0   FSMC_PCCARD_DeInit
       0   FSMC_PCCARD_IOSpace_Timing_Init
       0   FSMC_PCCARD_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
      46  FSMC_NAND_AttributeSpace_Timing_Init
      46  FSMC_NAND_CommonSpace_Timing_Init
      58  FSMC_NAND_DeInit
      26  FSMC_NAND_ECC_Disable
      26  FSMC_NAND_ECC_Enable
      90  FSMC_NAND_GetECC
      66  FSMC_NAND_Init
      50  FSMC_NORSRAM_DeInit
      62  FSMC_NORSRAM_Extended_Timing_Init
      82  FSMC_NORSRAM_Init
      58  FSMC_NORSRAM_Timing_Init
      16  FSMC_NORSRAM_WriteOperation_Disable
      16  FSMC_NORSRAM_WriteOperation_Enable
      28  FSMC_PCCARD_AttributeSpace_Timing_Init
      28  FSMC_PCCARD_CommonSpace_Timing_Init
      30  FSMC_PCCARD_DeInit
      28  FSMC_PCCARD_IOSpace_Timing_Init
      32  FSMC_PCCARD_Init

 
 804 bytes in section .text
 
 804 bytes of CODE memory

Errors: none
Warnings: none
