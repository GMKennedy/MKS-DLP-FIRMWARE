###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  10:19:55
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\GUIDemo\GUIDEMO_Cursor.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\GUIDemo\GUIDEMO_Cursor.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\GUIDEMO_Cursor.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\GUIDEMO_Cursor.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\gui\GUI\GUIDemo\GUIDEMO_Cursor.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/GUI
      4          *                        Universal graphic software for embedded applications
      5          *
      6          *                       (c) Copyright 2002, Micrium Inc., Weston, FL
      7          *                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
      8          *
      9          *              µC/GUI is protected by international copyright laws. Knowledge of the
     10          *              source code may not be used to write a similar product. This file may
     11          *              only be used in accordance with a license and should not be redistributed
     12          *              in any way. We appreciate your understanding and fairness.
     13          *
     14          ----------------------------------------------------------------------
     15          File        : GUIDEMO_Cursor.c
     16          Purpose     : shows Cursor-API
     17          ----------------------------------------------------------------------
     18          */
     19          
     20          #include "GUI.h"
     21          #include "GUIDEMO.h"
     22          
     23          #if (GUI_SUPPORT_CURSOR & GUI_SUPPORT_TOUCH)
     24          
     25          /*********************************************************************
     26          *
     27          *       defines
     28          *
     29          **********************************************************************
     30          */
     31          
     32          #define countof(Obj) (sizeof(Obj)/sizeof(Obj[0]))
     33          
     34          #if GUIDEMO_LARGE
     35            #define NUM_CURSORS   3
     36            #define XMAX  28
     37          #else
     38            #define NUM_CURSORS   2
     39            #define XMAX  24
     40          #endif
     41          
     42          /*********************************************************************
     43          *
     44          *       types
     45          *
     46          **********************************************************************
     47          */
     48          
     49          typedef struct {
     50            const GUI_CURSOR* pCursor;
     51            char              Size;
     52          } CURSOR_INFO;
     53          
     54          typedef struct {
     55            const CURSOR_INFO aCursor[NUM_CURSORS];
     56            const char*       pType;
     57          } CURSORTYPE_INFO;
     58          
     59          /*********************************************************************
     60          *
     61          *       static data
     62          *
     63          **********************************************************************
     64          */
     65          

   \                                 In section .text, align 4, keep-with-next
     66          static const CURSORTYPE_INFO _CursorArrow = {
   \                     _CursorArrow:
   \   00000000   0x........         DC32 GUI_CursorArrowS
   \   00000004   0x53 0x00          DC8 83, 0, 0, 0
   \              0x00 0x00    
   \   00000008   0x........         DC32 GUI_CursorArrowM
   \   0000000C   0x4D 0x00          DC8 77, 0, 0, 0
   \              0x00 0x00    
   \   00000010   0x........         DC32 GUI_CursorArrowL
   \   00000014   0x4C 0x00          DC8 76, 0, 0, 0
   \              0x00 0x00    
   \   00000018   0x........         DC32 `?<Constant "arrow cursors">`
     67            &GUI_CursorArrowS, 'S',
     68            &GUI_CursorArrowM, 'M',
     69            #if (NUM_CURSORS == 3)
     70              &GUI_CursorArrowL, 'L',
     71              "arrow cursors"
     72            #else
     73              "arrow\ncursors"
     74            #endif
     75          };
     76          
     77          #if !(GUIDEMO_TINY)

   \                                 In section .text, align 4, keep-with-next
     78            static const CURSORTYPE_INFO _CursorArrowI = {
   \                     _CursorArrowI:
   \   00000000   0x........         DC32 GUI_CursorArrowSI
   \   00000004   0x53 0x00          DC8 83, 0, 0, 0
   \              0x00 0x00    
   \   00000008   0x........         DC32 GUI_CursorArrowMI
   \   0000000C   0x4D 0x00          DC8 77, 0, 0, 0
   \              0x00 0x00    
   \   00000010   0x........         DC32 GUI_CursorArrowLI
   \   00000014   0x4C 0x00          DC8 76, 0, 0, 0
   \              0x00 0x00    
   \   00000018   0x........         DC32 `?<Constant "inverted arrow cursors">`
     79              &GUI_CursorArrowSI, 'S',
     80              &GUI_CursorArrowMI, 'M',
     81              #if (NUM_CURSORS == 3)
     82                &GUI_CursorArrowLI, 'L',
     83                "inverted arrow cursors"
     84              #else
     85                "inverted\narrow cursors"
     86              #endif
     87            };
     88          #endif
     89          

   \                                 In section .text, align 4, keep-with-next
     90          static const CURSORTYPE_INFO _CursorCross = {
   \                     _CursorCross:
   \   00000000   0x........         DC32 GUI_CursorCrossS
   \   00000004   0x53 0x00          DC8 83, 0, 0, 0
   \              0x00 0x00    
   \   00000008   0x........         DC32 GUI_CursorCrossM
   \   0000000C   0x4D 0x00          DC8 77, 0, 0, 0
   \              0x00 0x00    
   \   00000010   0x........         DC32 GUI_CursorCrossL
   \   00000014   0x4C 0x00          DC8 76, 0, 0, 0
   \              0x00 0x00    
   \   00000018   0x........         DC32 `?<Constant "cross cursors">`
     91            &GUI_CursorCrossS, 'S',
     92            &GUI_CursorCrossM, 'M',
     93            #if (NUM_CURSORS == 3)
     94              &GUI_CursorCrossL, 'L',
     95              "cross cursors"
     96            #else
     97              "cross\ncursors"
     98            #endif
     99          };
    100          
    101          #if !(GUIDEMO_TINY)

   \                                 In section .text, align 4, keep-with-next
    102            static const CURSORTYPE_INFO _CursorCrossI = {
   \                     _CursorCrossI:
   \   00000000   0x........         DC32 GUI_CursorCrossSI
   \   00000004   0x53 0x00          DC8 83, 0, 0, 0
   \              0x00 0x00    
   \   00000008   0x........         DC32 GUI_CursorCrossMI
   \   0000000C   0x4D 0x00          DC8 77, 0, 0, 0
   \              0x00 0x00    
   \   00000010   0x........         DC32 GUI_CursorCrossLI
   \   00000014   0x4C 0x00          DC8 76, 0, 0, 0
   \              0x00 0x00    
   \   00000018   0x........         DC32 `?<Constant "inverted cross cursors">`
    103              &GUI_CursorCrossSI, 'S',
    104              &GUI_CursorCrossMI, 'M',
    105              #if (NUM_CURSORS == 3)
    106                &GUI_CursorCrossLI, 'L',
    107                "inverted cross cursors"
    108              #else
    109                "inverted\ncross cursors"
    110              #endif
    111            };
    112          #endif
    113          

   \                                 In section .data, align 4
    114          static const GUI_CURSOR* _aCursor[] = { 
   \                     _aCursor:
   \   00000000   0x........         DC32 GUI_CursorArrowM, GUI_CursorArrowMI, GUI_CursorCrossM
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 GUI_CursorCrossMI
    115            &GUI_CursorArrowM,
    116            #if !(GUIDEMO_TINY)
    117              &GUI_CursorArrowMI,
    118            #endif
    119            &GUI_CursorCrossM,
    120            #if !(GUIDEMO_TINY)
    121              &GUI_CursorCrossMI,
    122            #endif
    123          };
    124          
    125          /*********************************************************************
    126          *
    127          *       static code
    128          *
    129          **********************************************************************
    130          */
    131          /*********************************************************************
    132          *
    133          *       _ShowCursorType
    134          */

   \                                 In section .text, align 2, keep-with-next
    135          static void _ShowCursorType(const CURSORTYPE_INFO* pCursorType, int x0, int y0) {
   \                     _ShowCursorType: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4690             MOV      R8,R2
    136            const GUI_CURSOR* pCursor;
    137            char Char;
    138            int i, x, y;
    139            int yMax = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
    140            int yHot = 0;
   \   0000000E   0x4637             MOV      R7,R6
    141            /* Calculate height and width of biggest cursor */
    142            for (i = 0; i < NUM_CURSORS; i++) {
   \   00000010   0x4630             MOV      R0,R6
   \   00000012   0xE00A             B.N      ??_ShowCursorType_0
    143              pCursor = pCursorType->aCursor[i].pCursor;
   \                     ??_ShowCursorType_1: (+1)
   \   00000014   0xF854 0x9030      LDR      R9,[R4, R0, LSL #+3]
   \   00000018   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \   0000001C   0x8849             LDRH     R1,[R1, #+2]
   \   0000001E   0x428E             CMP      R6,R1
   \   00000020   0xDA02             BGE.N    ??_ShowCursorType_2
    144              if (pCursor->pBitmap->YSize > yMax) {
    145                yMax = pCursor->pBitmap->YSize;
   \   00000022   0x460E             MOV      R6,R1
    146                yHot = pCursor->yHot;
   \   00000024   0xF8D9 0x7008      LDR      R7,[R9, #+8]
    147              }
    148            }
   \                     ??_ShowCursorType_2: (+1)
   \   00000028   0x1C40             ADDS     R0,R0,#+1
   \                     ??_ShowCursorType_0: (+1)
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xDBF2             BLT.N    ??_ShowCursorType_1
    149            #if ((LCD_YSIZE >= 220) && (LCD_XSIZE >= 300))
    150              GUI_SetFont(&GUI_FontComic18B_ASCII);
   \   0000002E   0x....             LDR.N    R0,??DataTable13
   \   00000030   0x.... 0x....      BL       GUI_SetFont
    151            #else
    152              GUI_SetFont(&GUI_Font13B_ASCII);
    153            #endif
    154            #if (NUM_CURSORS != 3)
    155              GUI_SetLBorder(x0);
    156            #endif
    157            GUI_DispStringAt(pCursorType->pType, x0, y0);
   \   00000034   0x4642             MOV      R2,R8
   \   00000036   0x4629             MOV      R1,R5
   \   00000038   0x69A0             LDR      R0,[R4, #+24]
   \   0000003A   0x.... 0x....      BL       GUI_DispStringAt
    158            #if GUIDEMO_LARGE
    159              y0 += GUI_GetFontDistY() + 1;
   \   0000003E   0x.... 0x....      BL       GUI_GetFontDistY
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0x4440             ADD      R0,R0,R8
   \   00000046   0x9000             STR      R0,[SP, #+0]
    160              GUI_SetFont(&GUI_Font13B_ASCII);
   \   00000048   0x....             LDR.N    R0,??DataTable13_1
   \   0000004A   0x.... 0x....      BL       GUI_SetFont
    161            #else
    162              #if (LCD_YSIZE < 80)
    163                x0 += 50;
    164              #else
    165                y0 += GUI_GetFontDistY() * 2 + 1;
    166              #endif
    167              GUI_SetFont(&GUI_Font10_ASCII);
    168            #endif
    169            for (i = 0; i < NUM_CURSORS; i++) {
   \   0000004E   0xF04F 0x0800      MOV      R8,#+0
   \   00000052   0xE02E             B.N      ??_ShowCursorType_3
    170              pCursor = pCursorType->aCursor[i].pCursor;
   \                     ??_ShowCursorType_4: (+1)
   \   00000054   0xF854 0x9038      LDR      R9,[R4, R8, LSL #+3]
    171              Char    = pCursorType->aCursor[i].Size;
   \   00000058   0xEB04 0x00C8      ADD      R0,R4,R8, LSL #+3
   \   0000005C   0xF990 0xA004      LDRSB    R10,[R0, #+4]
    172              y = y0 + yHot - pCursor->yHot;
   \   00000060   0x9800             LDR      R0,[SP, #+0]
   \   00000062   0x1838             ADDS     R0,R7,R0
   \   00000064   0xF8D9 0x1008      LDR      R1,[R9, #+8]
   \   00000068   0xEBA0 0x0B01      SUB      R11,R0,R1
   \   0000006C   0x4650             MOV      R0,R10
   \   0000006E   0xB280             UXTH     R0,R0
    173              x = ((pCursor->pBitmap->XSize - GUI_GetCharDistX(Char)) >> 1);
   \   00000070   0x.... 0x....      BL       GUI_GetCharDistX
   \   00000074   0x4601             MOV      R1,R0
   \   00000076   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   0000007A   0x8802             LDRH     R2,[R0, #+0]
   \   0000007C   0x1A51             SUBS     R1,R2,R1
   \   0000007E   0x1049             ASRS     R1,R1,#+1
   \   00000080   0x9101             STR      R1,[SP, #+4]
    174              GUI_DrawBitmap(pCursor->pBitmap, x0 + XMAX * i + 5,     y);
   \   00000082   0xF04F 0x091C      MOV      R9,#+28
   \   00000086   0x465A             MOV      R2,R11
   \   00000088   0xFB09 0x5108      MLA      R1,R9,R8,R5
   \   0000008C   0x1D49             ADDS     R1,R1,#+5
   \   0000008E   0x.... 0x....      BL       GUI_DrawBitmap
    175              GUI_DispCharAt(Char,             x0 + XMAX * i + 5 + x, y0 + yMax + 2);
   \   00000092   0x9800             LDR      R0,[SP, #+0]
   \   00000094   0x1830             ADDS     R0,R6,R0
   \   00000096   0x1C82             ADDS     R2,R0,#+2
   \   00000098   0xB212             SXTH     R2,R2
   \   0000009A   0xFB09 0x5008      MLA      R0,R9,R8,R5
   \   0000009E   0x9901             LDR      R1,[SP, #+4]
   \   000000A0   0x1808             ADDS     R0,R1,R0
   \   000000A2   0x1D41             ADDS     R1,R0,#+5
   \   000000A4   0xB209             SXTH     R1,R1
   \   000000A6   0x4650             MOV      R0,R10
   \   000000A8   0xB280             UXTH     R0,R0
   \   000000AA   0x.... 0x....      BL       GUI_DispCharAt
    176            }
   \   000000AE   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??_ShowCursorType_3: (+1)
   \   000000B2   0xF1B8 0x0F03      CMP      R8,#+3
   \   000000B6   0xDBCD             BLT.N    ??_ShowCursorType_4
    177          }
   \   000000B8   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
    178          
    179          /*********************************************************************
    180          *
    181          *       _MoveCursor
    182          */

   \                                 In section .text, align 2, keep-with-next
    183          static void _MoveCursor(const GUI_CURSOR* Cursor){
   \                     _MoveCursor: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    184            int x, y;
    185            int xMax = LCD_XSIZE >> 1;
    186            int yMax = LCD_YSIZE >> 1;
    187            #if !GUIDEMO_LARGE
    188              xMax *= 1.3;
    189              yMax *= 1.3;
    190            #endif
    191            GUI_CURSOR_Select(Cursor);  
   \   00000002   0x.... 0x....      BL       GUI_CURSOR_Select
    192            for(x = y = 0; ((x < xMax) && (y < yMax) && !GUIDEMO_CheckCancel()); x += 6, y += 6) {
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x4625             MOV      R5,R4
   \   0000000A   0xE008             B.N      ??_MoveCursor_0
    193              if ( x == xMax) {
    194                x = xMax;
    195              }
    196              if ( y == yMax) {
    197                y = yMax;
    198              }
    199              GUI_CURSOR_SetPosition(x, y);
   \                     ??_MoveCursor_1: (+1)
   \   0000000C   0x4621             MOV      R1,R4
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       GUI_CURSOR_SetPosition
    200              GUIDEMO_Delay(75);
   \   00000014   0x204B             MOVS     R0,#+75
   \   00000016   0x.... 0x....      BL       GUIDEMO_Delay
    201            }
   \   0000001A   0x1DAD             ADDS     R5,R5,#+6
   \   0000001C   0x1DA4             ADDS     R4,R4,#+6
   \                     ??_MoveCursor_0: (+1)
   \   0000001E   0x2DF0             CMP      R5,#+240
   \   00000020   0xDA05             BGE.N    ??_MoveCursor_2
   \   00000022   0x2CA0             CMP      R4,#+160
   \   00000024   0xDA03             BGE.N    ??_MoveCursor_2
   \   00000026   0x.... 0x....      BL       GUIDEMO_CheckCancel
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD0EE             BEQ.N    ??_MoveCursor_1
    202          }
   \                     ??_MoveCursor_2: (+1)
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    203          
    204          /*********************************************************************
    205          *
    206          *       _DispCursor
    207          */

   \                                 In section .text, align 2, keep-with-next
    208          static void _DispCursor(void) {
   \                     _DispCursor: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    209            #if !(GUIDEMO_LARGE)
    210              int x0 = 0;
    211            #endif
    212            int y0, dx, dy;
    213            GUI_CURSOR_Hide();
   \   00000002   0x.... 0x....      BL       GUI_CURSOR_Hide
    214            GUI_SetTextMode(GUI_TM_TRANS);
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0x.... 0x....      BL       GUI_SetTextMode
    215            #if GUIDEMO_LARGE
    216              GUI_SetFont(&GUI_FontComic24B_ASCII);
   \   0000000C   0x....             LDR.N    R0,??DataTable13_2
   \   0000000E   0x.... 0x....      BL       GUI_SetFont
    217              GUI_DispStringAt("Available\n  cursors:", 18, 12);
   \   00000012   0x220C             MOVS     R2,#+12
   \   00000014   0x2112             MOVS     R1,#+18
   \   00000016   0x.... 0x....      ADR.W    R0,`?<Constant "Available\\n  cursors:">`
   \   0000001A   0x.... 0x....      BL       GUI_DispStringAt
    218            #else
    219              #if GUIDEMO_TINY
    220                GUI_SetFont(&GUI_Font13B_ASCII);
    221              #else
    222                GUI_SetFont(&GUI_FontComic18B_ASCII);
    223              #endif
    224              GUI_DispStringHCenterAt("Available cursors:", LCD_XSIZE >> 1,  LCD_YSIZE >> 5);
    225            #endif
    226            /* Display the cursors */
    227            #if GUIDEMO_LARGE
    228              y0 = 68;
    229              dx = LCD_XSIZE / 2.5;
    230              #if (LCD_YSIZE > 240)
    231                dy = LCD_YSIZE / 3.2;
    232              #else
    233                dy = 75;
    234              #endif
    235              #if ((LCD_YSIZE < 220) || (LCD_XSIZE < 300))
    236                y0 -=  3;
    237                dy -= 12;
    238              #endif
    239              _ShowCursorType(&_CursorArrow,    0, y0);
   \   0000001E   0x2244             MOVS     R2,#+68
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x.... 0x....      ADR.W    R0,_CursorArrow
   \   00000026   0x.... 0x....      BL       _ShowCursorType
    240              _ShowCursorType(&_CursorCross,    0, y0 + dy);
   \   0000002A   0x22A8             MOVS     R2,#+168
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x.... 0x....      ADR.W    R0,_CursorCross
   \   00000032   0x.... 0x....      BL       _ShowCursorType
    241              _ShowCursorType(&_CursorArrowI,  dx, y0);
   \   00000036   0x2244             MOVS     R2,#+68
   \   00000038   0x21C0             MOVS     R1,#+192
   \   0000003A   0x.... 0x....      ADR.W    R0,_CursorArrowI
   \   0000003E   0x.... 0x....      BL       _ShowCursorType
    242              _ShowCursorType(&_CursorCrossI,  dx, y0 + dy);
   \   00000042   0x22A8             MOVS     R2,#+168
   \   00000044   0x21C0             MOVS     R1,#+192
   \   00000046   0x.... 0x....      ADR.W    R0,_CursorCrossI
   \   0000004A   0xE8BD 0x4008      POP      {R3,LR}
   \   0000004E   0x....             B.N      _ShowCursorType
    243            #else
    244              #if GUIDEMO_TINY
    245                y0 = 20;
    246              #else
    247                y0 = 30;
    248              #endif
    249              #if ((LCD_XSIZE < 160) && ((LCD_YSIZE >= 160) || (LCD_YSIZE < 90)))
    250                x0 = 10;
    251              #endif
    252              dx = LCD_XSIZE / 2.2;
    253              dy = LCD_YSIZE / 2.6;
    254              _ShowCursorType(&_CursorArrow,    x0, y0);
    255              #if (LCD_YSIZE >= 160)
    256                _ShowCursorType(&_CursorCross,  x0, y0 + dy);
    257              #elif (LCD_YSIZE < 90)
    258                GUIDEMO_Delay(2000);
    259                GUI_ClearRect(0, 20, LCD_XSIZE - 1, LCD_YSIZE - 1);
    260                _ShowCursorType(&_CursorCross,  x0, y0);
    261              #else
    262                _ShowCursorType(&_CursorCross,  dx, y0);
    263              #endif
    264              #if ((LCD_YSIZE >= 160) && (LCD_XSIZE >= 160))
    265                _ShowCursorType(&_CursorArrowI, dx, y0);
    266                _ShowCursorType(&_CursorCrossI, dx, y0 + dy);
    267              #endif
    268            #endif
    269          }
    270          
    271          /*********************************************************************
    272          *
    273          *       public code
    274          *
    275          **********************************************************************
    276          */
    277          /*********************************************************************
    278          *
    279          *       GUIDEMO_Cursor
    280          */

   \                                 In section .text, align 2, keep-with-next
    281          void GUIDEMO_Cursor(void) {
   \                     GUIDEMO_Cursor: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    282            int i = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    283            GUIDEMO_ShowIntro("Cursor",
    284                              "\nemWin supports"
    285                              "\nsoftware cursor");
   \   00000004   0x.... 0x....      ADR.W    R1,`?<Constant "\\nemWin supports\\nsoftw...">`
   \   00000008   0x.... 0x....      ADR.W    R0,`?<Constant "Cursor">`
   \   0000000C   0x.... 0x....      BL       GUIDEMO_ShowIntro
    286            GUIDEMO_SetBkColor(GUI_BLUE);
   \   00000010   0xF44F 0x007F      MOV      R0,#+16711680
   \   00000014   0x.... 0x....      BL       GUIDEMO_SetBkColor
    287            GUI_Clear();
   \   00000018   0x.... 0x....      BL       GUI_Clear
    288            _DispCursor();
   \   0000001C   0x.... 0x....      BL       _DispCursor
    289            GUIDEMO_Delay(1500);
   \   00000020   0xF240 0x50DC      MOVW     R0,#+1500
   \   00000024   0x.... 0x....      BL       GUIDEMO_Delay
    290            GUIDEMO_NotifyStartNext();
   \   00000028   0x.... 0x....      BL       GUIDEMO_NotifyStartNext
    291            GUI_CURSOR_Show();
   \   0000002C   0x.... 0x....      BL       GUI_CURSOR_Show
    292            for ( i = 0;(i < countof(_aCursor) && !GUIDEMO_CheckCancel()); i++) {
   \   00000030   0xE005             B.N      ??GUIDEMO_Cursor_0
    293                _MoveCursor(_aCursor[i]);
   \                     ??GUIDEMO_Cursor_1: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable13_3
   \   00000034   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000038   0x.... 0x....      BL       _MoveCursor
    294            }
   \   0000003C   0x1C64             ADDS     R4,R4,#+1
   \                     ??GUIDEMO_Cursor_0: (+1)
   \   0000003E   0x2C04             CMP      R4,#+4
   \   00000040   0xD203             BCS.N    ??GUIDEMO_Cursor_2
   \   00000042   0x.... 0x....      BL       GUIDEMO_CheckCancel
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD0F3             BEQ.N    ??GUIDEMO_Cursor_1
    295            GUI_CURSOR_SetPosition(0,0);
   \                     ??GUIDEMO_Cursor_2: (+1)
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x4608             MOV      R0,R1
   \   0000004E   0x.... 0x....      BL       GUI_CURSOR_SetPosition
    296            GUI_CURSOR_Select(&GUI_CursorArrowM);  
   \   00000052   0x....             LDR.N    R0,??DataTable13_4
   \   00000054   0xE8BD 0x4010      POP      {R4,LR}
   \   00000058   0x.... 0x....      B.W      GUI_CURSOR_Select
    297          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     GUI_FontComic18B_ASCII

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     GUI_Font13B_ASCII

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     GUI_FontComic24B_ASCII

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     _aCursor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     GUI_CursorArrowM

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Available\\n  cursors:">`:
   \   00000000   0x41 0x76          DC8 "Available\012  cursors:"
   \              0x61 0x69    
   \              0x6C 0x61    
   \              0x62 0x6C    
   \              0x65 0x0A    
   \              0x20 0x20    
   \              0x63 0x75    
   \              0x72 0x73    
   \              0x6F 0x72    
   \              0x73 0x3A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Cursor">`:
   \   00000000   0x43 0x75          DC8 "Cursor"
   \              0x72 0x73    
   \              0x6F 0x72    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\nemWin supports\\nsoftw...">`:
   \   00000000   0x0A 0x65          DC8 "\012emWin supports\012software cursor"
   \              0x6D 0x57    
   \              0x69 0x6E    
   \              0x20 0x73    
   \              0x75 0x70    
   \              0x70 0x6F    
   \              0x72 0x74    
   \              0x73 0x0A    
   \              0x73 0x6F    
   \              0x66 0x74    
   \              0x77 0x61    
   \              0x72 0x65    
   \              0x20 0x63    
   \              0x75 0x72    
   \              0x73 0x6F    
   \              0x72 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "arrow cursors">`:
   \   00000000   0x61 0x72          DC8 "arrow cursors"
   \              0x72 0x6F    
   \              0x77 0x20    
   \              0x63 0x75    
   \              0x72 0x73    
   \              0x6F 0x72    
   \              0x73 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "inverted arrow cursors">`:
   \   00000000   0x69 0x6E          DC8 "inverted arrow cursors"
   \              0x76 0x65    
   \              0x72 0x74    
   \              0x65 0x64    
   \              0x20 0x61    
   \              0x72 0x72    
   \              0x6F 0x77    
   \              0x20 0x63    
   \              0x75 0x72    
   \              0x73 0x6F    
   \              0x72 0x73    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "cross cursors">`:
   \   00000000   0x63 0x72          DC8 "cross cursors"
   \              0x6F 0x73    
   \              0x73 0x20    
   \              0x63 0x75    
   \              0x72 0x73    
   \              0x6F 0x72    
   \              0x73 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "inverted cross cursors">`:
   \   00000000   0x69 0x6E          DC8 "inverted cross cursors"
   \              0x76 0x65    
   \              0x72 0x74    
   \              0x65 0x64    
   \              0x20 0x63    
   \              0x72 0x6F    
   \              0x73 0x73    
   \              0x20 0x63    
   \              0x75 0x72    
   \              0x73 0x6F    
   \              0x72 0x73    
   \              0x00         
   \   00000017   0x00               DC8 0
    298          
    299          #else
    300          
    301          void GUIDEMO_Cursor(void) {}
    302          
    303          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   GUIDEMO_Cursor
         8   -> GUIDEMO_CheckCancel
         8   -> GUIDEMO_Delay
         8   -> GUIDEMO_NotifyStartNext
         8   -> GUIDEMO_SetBkColor
         8   -> GUIDEMO_ShowIntro
         0   -> GUI_CURSOR_Select
         8   -> GUI_CURSOR_SetPosition
         8   -> GUI_CURSOR_Show
         8   -> GUI_Clear
         8   -> _DispCursor
         8   -> _MoveCursor
       8   _DispCursor
         8   -> GUI_CURSOR_Hide
         8   -> GUI_DispStringAt
         8   -> GUI_SetFont
         8   -> GUI_SetTextMode
         0   -> _ShowCursorType
         8   -> _ShowCursorType
      16   _MoveCursor
        16   -> GUIDEMO_CheckCancel
        16   -> GUIDEMO_Delay
        16   -> GUI_CURSOR_Select
        16   -> GUI_CURSOR_SetPosition
      48   _ShowCursorType
        48   -> GUI_DispCharAt
        48   -> GUI_DispStringAt
        48   -> GUI_DrawBitmap
        48   -> GUI_GetCharDistX
        48   -> GUI_GetFontDistY
        48   -> GUI_SetFont


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  ?<Constant "Available\n  cursors:">
       8  ?<Constant "Cursor">
      32  ?<Constant "\nemWin supports\nsoftw...">
      16  ?<Constant "arrow cursors">
      16  ?<Constant "cross cursors">
      24  ?<Constant "inverted arrow cursors">
      24  ?<Constant "inverted cross cursors">
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
      92  GUIDEMO_Cursor
      28  _CursorArrow
      28  _CursorArrowI
      28  _CursorCross
      28  _CursorCrossI
      80  _DispCursor
      48  _MoveCursor
     188  _ShowCursorType
      16  _aCursor

 
  16 bytes in section .data
  80 bytes in section .rodata
 604 bytes in section .text
 
 604 bytes of CODE  memory
  80 bytes of CONST memory
  16 bytes of DATA  memory

Errors: none
Warnings: none
