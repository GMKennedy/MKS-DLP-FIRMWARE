###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        16/Apr/2020  18:39:35
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\temperature.cpp
#    Command line =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\temperature.cpp
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -D USE_STM32F407VET -lC
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\ -lA
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/Obj\ --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Inc\ -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Src\ -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/variant\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/lcd\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/libstmf4\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/libstmf4/include\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui\ -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui/Multi_language\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui/QRENCODE\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/GUI\
#        -Om --eec++ -I "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\temperature.lst
#    Object file  =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/Obj\temperature.o
#
###############################################################################

D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\temperature.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * temperature.cpp - temperature control
     25           */
     26          
     27          #include "Marlin.h"

    #define MIN_SOFTWARE_ENDSTOPS mksCfg.min_software_endstops	/*--mks cfg--*/
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Configuration.h",824  Warning[Pe047]: 
          incompatible redefinition of macro "MIN_SOFTWARE_ENDSTOPS" (declared
          at line 819)

    #define MAX_SOFTWARE_ENDSTOPS mksCfg.max_software_endstops	/*--mks cfg--*/
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Configuration.h",834  Warning[Pe047]: 
          incompatible redefinition of macro "MAX_SOFTWARE_ENDSTOPS" (declared
          at line 829)

  #define UNUSED(x) ((void)(x))
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Inc\mks_cfg.h",407  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_iwdg.h",80  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_PRESCALER" (declared at
          line 209 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_iwdg.h")

  #define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_iwdg.h",97  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_RELOAD" (declared at
          line 222 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_iwdg.h")

  #define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",272  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NORSRAM_BANK" (declared
          at line 834 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",277  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NAND_BANK" (declared at
          line 855 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",298  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MUX" (declared at line
          839 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",311  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MEMORY" (declared at
          line 842 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",336  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_BURSTMODE" (declared at
          line 894 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",347  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ASYNWAIT" (declared at
          line 915 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",358  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_POLARITY" (declared
          at line 897 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",369  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRAP_MODE" (declared at
          line 900 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",380  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_SIGNAL_ACTIVE"
          (declared at line 903 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",391  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_OPERATION"
          (declared at line 906 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",402  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAITE_SIGNAL" (declared
          at line 909 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",414  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_EXTENDED_MODE" (declared
          at line 912 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",426  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_BURST" (declared
          at line 920 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",435  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_SETUP_TIME"
          (declared at line 923 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_HOLD_TIME"
          (declared at line 925 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",451  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATASETUP_TIME"
          (declared at line 927 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",459  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TURNAROUND_TIME"
          (declared at line 929 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",467  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_CLK_DIV" (declared at
          line 934 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATA_LATENCY" (declared
          at line 918 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",487  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ACCESS_MODE" (declared
          at line 850 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",508  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_FEATURE" (declared
          at line 858 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",520  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECC_STATE" (declared at
          line 864 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",535  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECCPAGE_SIZE" (declared
          at line 867 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",548  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TCLR_TIME" (declared at
          line 874 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",556  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TAR_TIME" (declared at
          line 876 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",564  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_SETUP_TIME" (declared at
          line 878 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",572  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_TIME" (declared at
          line 880 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",580  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HOLD_TIME" (declared at
          line 882 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",588  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HIZ_TIME" (declared at
          line 884 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define FSMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",613  Warning[Pe047]: 
          incompatible redefinition of macro "FSMC_FLAG_FEMPT" (declared at
          line 530 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

    #define assert_param(expr) ((void)0)        
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\stm32f4xx_conf.h",149  Warning[Pe047]: 
          incompatible redefinition of macro "assert_param" (declared at line
          431 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Inc\stm32f4xx_hal_c
          onf.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial6

   \                                 In section .text, align 4
   \   __interwork __softfp bool IsRunning()
   \                     _Z9IsRunningv: (+1)
   \   00000000   0x4801             LDR.N    R0,??IsRunning_0
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??IsRunning_0:
   \   00000008   0x........         DC32     Running
     28          #include "temperature.h"

   \                                 In section .text, align 4
   \   __interwork __vfp float Temperature::degHotend(uint8_t)
   \                     _ZN11Temperature9degHotendEh: (+1)
   \   00000000   0x4801             LDR.N    R0,??degHotend_0
   \   00000002   0xED90 0x0A06      VLDR     S0,[R0, #+24]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??degHotend_0:
   \   00000008   0x........         DC32     _ZN11Temperature15temp_meas_readyE

   \                                 In section .text, align 4
   \   __interwork __vfp float Temperature::degTargetHotend(uint8_t)
   \                     _ZN11Temperature15degTargetHotendEh: (+1)
   \   00000000   0x4802             LDR.N    R0,??degTargetHotend_0
   \   00000002   0xED90 0x0A08      VLDR     S0,[R0, #+32]
   \   00000006   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000000A   0x4770             BX       LR               ;; return
   \                     ??degTargetHotend_0:
   \   0000000C   0x........         DC32     _ZN11Temperature15temp_meas_readyE

   \                                 In section .text, align 4

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\temperature.h",397  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   __interwork __vfp void Temperature::setTargetHotend(float, uint8_t)
   \                     _ZN11Temperature15setTargetHotendEfh: (+1)
   \   00000000   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000004   0x4802             LDR.N    R0,??setTargetHotend_0
   \   00000006   0xED80 0x0A08      VSTR     S0,[R0, #+32]
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      B.W      _ZN11Temperature21start_watching_heaterEh
   \                     ??setTargetHotend_0:
   \   00000010   0x........         DC32     _ZN11Temperature15temp_meas_readyE

   \                                 In section .text, align 2
   \   __interwork __vfp void Temperature::setTargetBed(float)
   \                     _ZN11Temperature12setTargetBedEf: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void Temperature::updatePID()
   \                     _ZN11Temperature9updatePIDEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     29          #include "thermistortables.h"
     30          #include "ultralcd.h"

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_update()
   \                     _Z10lcd_updatev: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_buttons_update()
   \                     _Z18lcd_buttons_updatev: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     31          #include "planner.h"

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\planner.h",582  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\planner.h",583  Warning[Pe815]: 
          type qualifier on return type is meaningless
     32          #include "language.h"
     33          #include "adc.h"
     34          #include "tim.h"
     35          #include "spi.h"
     36          #if ENABLED(HEATER_0_USES_MAX6675)
     37            //#include "MarlinSPI.h"
     38          #endif
     39          
     40          #if ENABLED(BABYSTEPPING)
     41            #include "stepper.h"
     42          #endif
     43          
     44          #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     45            #include "endstops.h"
     46          #endif
     47          
     48          #if ENABLED(USE_WATCHDOG)
     49            #include "watchdog.h"
     50          #endif
     51          
     52          #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     53            static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     54            static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
     55          #else

   \                                 In section .bss, align 4
     56            static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
     57            static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
   \                     heater_ttbllen_map:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \   00000004                      DS8 4
     58          #endif
     59          

   \                                 In section .bss, align 4
     60          Temperature thermalManager;
   \                     thermalManager:
   \   00000000                      DS8 4
     61          
     62          // public:
     63          
     64          float Temperature::current_temperature[HOTENDS] = { 0.0 },

   \                                 In section .bss, align 4
     65                Temperature::current_temperature_bed = 0.0;
   \                     _ZN11Temperature23current_temperature_bedE:
   \   00000000                      DS8 4
     66          int Temperature::current_temperature_raw[HOTENDS] = { 0 },
     67                  Temperature::target_temperature[HOTENDS] = { 0 },
     68                  Temperature::current_temperature_bed_raw = 0;
     69          
     70          #if HAS_HEATER_BED
     71            int16_t Temperature::target_temperature_bed = 0;
     72          #endif
     73          
     74          // Initialized by settings.load()
     75          #if ENABLED(PIDTEMP)
     76            #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
     77              float Temperature::Kp[HOTENDS], Temperature::Ki[HOTENDS], Temperature::Kd[HOTENDS];
     78              #if ENABLED(PID_EXTRUSION_SCALING)
     79                float Temperature::Kc[HOTENDS];
     80              #endif
     81            #else
     82              float Temperature::Kp, Temperature::Ki, Temperature::Kd;
     83              #if ENABLED(PID_EXTRUSION_SCALING)
     84                float Temperature::Kc;
     85              #endif
     86            #endif
     87          #endif
     88          
     89          // Initialized by settings.load()
     90          #if ENABLED(PIDTEMPBED)
     91            float Temperature::bedKp, Temperature::bedKi, Temperature::bedKd;
     92          #endif
     93          
     94          #if ENABLED(BABYSTEPPING)
     95            volatile int Temperature::babystepsTodo[XYZ] = { 0 };
     96          #endif
     97          
     98          #if WATCH_HOTENDS
     99            uint16_t Temperature::watch_target_temp[HOTENDS] = { 0 };
    100            millis_t Temperature::watch_heater_next_ms[HOTENDS] = { 0 };
    101          #endif
    102          
    103          #if WATCH_THE_BED
    104            uint16_t Temperature::watch_target_bed_temp = 0;
    105            millis_t Temperature::watch_bed_next_ms = 0;
    106          #endif
    107          
    108          #if ENABLED(PREVENT_COLD_EXTRUSION)
    109            bool Temperature::allow_cold_extrude = false;
    110            int16_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
    111          #endif
    112          
    113          // private:
    114          
    115          #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    116            uint16_t Temperature::redundant_temperature_raw = 0;
    117            float Temperature::redundant_temperature = 0.0;
    118          #endif
    119          
    120          volatile bool Temperature::temp_meas_ready = false;
    121          
    122          #if ENABLED(PIDTEMP)
    123            float Temperature::temp_iState[HOTENDS] = { 0 },
    124                  Temperature::temp_dState[HOTENDS] = { 0 },
    125                  Temperature::pTerm[HOTENDS],
    126                  Temperature::iTerm[HOTENDS],
    127                  Temperature::dTerm[HOTENDS];
    128          
    129            #if ENABLED(PID_EXTRUSION_SCALING)
    130              float Temperature::cTerm[HOTENDS];
    131              long Temperature::last_e_position;
    132              long Temperature::lpq[LPQ_MAX_LEN];
    133              int Temperature::lpq_ptr = 0;
    134            #endif
    135          
    136            float Temperature::pid_error[HOTENDS];
    137            bool Temperature::pid_reset[HOTENDS];
    138          #endif
    139          #if ENABLED(PIDTEMPBED)
    140            float Temperature::temp_iState_bed = { 0 },
    141                  Temperature::temp_dState_bed = { 0 },
    142                  Temperature::pTerm_bed,
    143                  Temperature::iTerm_bed,
    144                  Temperature::dTerm_bed,
    145                  Temperature::pid_error_bed;
    146          #else
    147            millis_t Temperature::next_bed_check_ms;
    148          #endif
    149          
    150          
    151          uint16_t Temperature::raw_temp_value[MAX_EXTRUDERS] = { 0 },
    152                   Temperature::raw_temp_bed_value = 0;
    153          
    154          // Init min and max temp with extreme values to prevent false errors during startup
    155          int16_t Temperature::minttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP, HEATER_4_RAW_LO_TEMP),
    156                  Temperature::maxttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP, HEATER_4_RAW_HI_TEMP),
    157                  Temperature::minttemp[HOTENDS] = { 0 },
    158                  Temperature::maxttemp[HOTENDS] = ARRAY_BY_HOTENDS1(16383);
    159          
    160          #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
    161            uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
    162          #endif
    163          
    164          #ifdef MILLISECONDS_PREHEAT_TIME
    165            millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
    166          #endif
    167          
    168          #ifdef BED_MINTEMP
    169            int16_t Temperature::bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
    170          #endif
    171          
    172          #ifdef BED_MAXTEMP
    173            int16_t Temperature::bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
    174          #endif
    175          
    176          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    177            int8_t Temperature::meas_shift_index;  // Index of a delayed sample in buffer
    178          #endif
    179          
    180          #if HAS_AUTO_FAN
    181            millis_t Temperature::next_auto_fan_check_ms = 0;
    182          #endif
    183          
    184          uint8_t Temperature::soft_pwm_amount[HOTENDS],
    185                  Temperature::soft_pwm_amount_bed;
    186          
    187          #if ENABLED(FAN_SOFT_PWM)
    188            uint8_t Temperature::soft_pwm_amount_fan[FAN_COUNT],
    189                    Temperature::soft_pwm_count_fan[FAN_COUNT];
    190          #endif
    191          
    192          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    193            uint16_t Temperature::current_raw_filwidth = 0; // Measured filament diameter - one extruder only
    194          #endif
    195          
    196          #if ENABLED(PROBING_HEATERS_OFF)
    197            bool Temperature::paused;
    198          #endif
    199          
    200          #if HEATER_IDLE_HANDLER
    201            millis_t Temperature::heater_idle_timeout_ms[HOTENDS] = { 0 };
    202            bool Temperature::heater_idle_timeout_exceeded[HOTENDS] = { false };
    203            #if HAS_TEMP_BED
    204              millis_t Temperature::bed_idle_timeout_ms = 0;
    205              bool Temperature::bed_idle_timeout_exceeded = false;
    206            #endif
    207          #endif
    208          
    209          #if ENABLED(ADC_KEYPAD)
    210            uint32_t Temperature::current_ADCKey_raw = 0;
    211            uint8_t Temperature::ADCKey_count = 0;
    212          #endif
    213          
    214          #if HAS_PID_HEATING
    215          
    216            /**
    217             * PID Autotuning (M303)
    218             *
    219             * Alternately heat and cool the nozzle, observing its behavior to
    220             * determine the best PID values to achieve a stable temperature.
    221             */

   \                                 In section .text, align 4, keep-with-next
    222            void Temperature::PID_autotune(const float temp, const int8_t hotend, const int8_t ncycles, const bool set_result/*=false*/) {
   \                     _ZN11Temperature12PID_autotuneEfaab: (+1)
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0xED2D 0x8B0A      VPUSH    {D8-D12}
   \   00000008   0xB086             SUB      SP,SP,#+24
   \   0000000A   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000E   0x4604             MOV      R4,R0
    223              float input = 0.0;
   \   00000010   0xEDDF 0x8AD7      VLDR.W   S17,??PID_autotune_0  ;; 0x0
    224              int cycles = 0;
   \   00000014   0xF04F 0x0800      MOV      R8,#+0
    225              bool heating = true;
   \   00000018   0x2501             MOVS     R5,#+1
    226          
    227              millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
   \   0000001A   0x.... 0x....      BL       HAL_GetTick
   \   0000001E   0x9002             STR      R0,[SP, #+8]
   \   00000020   0x9004             STR      R0,[SP, #+16]
   \   00000022   0x9802             LDR      R0,[SP, #+8]
   \   00000024   0x9003             STR      R0,[SP, #+12]
    228              long t_high = 0, t_low = 0;
   \   00000026   0x46C2             MOV      R10,R8
    229          
    230              long bias, d;
    231              float Ku, Tu,
    232                    workKp = 0, workKi = 0, workKd = 0,
   \   00000028   0xEDDF 0xAAD1      VLDR.W   S21,??PID_autotune_0  ;; 0x0
   \   0000002C   0xED9F 0xBAD0      VLDR.W   S22,??PID_autotune_0  ;; 0x0
   \   00000030   0xEDDF 0xBACF      VLDR.W   S23,??PID_autotune_0  ;; 0x0
    233                    max = 0, min = 10000;
   \   00000034   0xED9F 0x9ACE      VLDR.W   S18,??PID_autotune_0  ;; 0x0
   \   00000038   0xED9F 0xCACE      VLDR.W   S24,??PID_autotune_0+0x4  ;; 0x461c4000
    234          
    235              #if WATCH_THE_BED || WATCH_HOTENDS
    236                const float watch_temp_target = temp -
    237                  #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
    238                    (hotend < 0 ? (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1) : (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))
    239                  #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
    240                    (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)
    241                  #else
    242                    (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)
    243                  #endif
    244                ;
   \   0000003C   0xEEB9 0x0A08      VMOV.F32 S0,#-6.0
   \   00000040   0xEE78 0x9A00      VADD.F32 S19,S16,S0
   \   00000044   0x9802             LDR      R0,[SP, #+8]
   \   00000046   0xF500 0x409C      ADD      R0,R0,#+19968
   \   0000004A   0x3020             ADDS     R0,R0,#+32
   \   0000004C   0x9005             STR      R0,[SP, #+20]
    245                const int8_t watch_temp_period =
    246                  #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
    247                    hotend < 0 ? WATCH_BED_TEMP_PERIOD : WATCH_TEMP_PERIOD
    248                  #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
    249                    WATCH_BED_TEMP_PERIOD
    250                  #else
    251                    WATCH_TEMP_PERIOD
    252                  #endif
    253                ;
    254                const int8_t watch_temp_increase =
    255                  #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
    256                    hotend < 0 ? WATCH_BED_TEMP_INCREASE : WATCH_TEMP_INCREASE
    257                  #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
    258                    WATCH_BED_TEMP_INCREASE
    259                  #else
    260                    WATCH_TEMP_INCREASE
    261                  #endif
    262                ;
    263                millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
    264                float next_watch_temp = 0.0;
   \   0000004E   0xED9F 0xAAC8      VLDR.W   S20,??PID_autotune_0  ;; 0x0
    265                bool heated = false;
   \   00000052   0x46C1             MOV      R9,R8
   \   00000054   0xB264             SXTB     R4,R4
   \   00000056   0x2C00             CMP      R4,#+0
   \   00000058   0xD010             BEQ.N    ??PID_autotune_1
    266              #endif
    267          
    268              #if HAS_AUTO_FAN
    269                next_auto_fan_check_ms = next_temp_ms + 2500UL;
    270              #endif
    271          
    272              #if ENABLED(PIDTEMP)
    273                #define _TOP_HOTEND HOTENDS - 1
    274              #else
    275                #define _TOP_HOTEND -1
    276              #endif
    277              #if ENABLED(PIDTEMPBED)
    278                #define _BOT_HOTEND -1
    279              #else
    280                #define _BOT_HOTEND 0
    281              #endif
    282          
    283              if (!WITHIN(hotend, _BOT_HOTEND, _TOP_HOTEND)) {
    284                SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);
   \   0000005A   0x.... 0x....      ADR.W    R1,`?<Constant "PID Autotune failed! ...">`
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable42
   \   00000062   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000066   0x210A             MOVS     R1,#+10
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable42
   \   0000006C   0xB006             ADD      SP,SP,#+24
   \   0000006E   0xECBD 0x8B0A      VPOP     {D8-D12}
   \   00000072   0xB003             ADD      SP,SP,#+12
   \   00000074   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000078   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    285                return;
    286              }
    287          
    288              SERIAL_ECHOLN(MSG_PID_AUTOTUNE_START);
   \                     ??PID_autotune_1: (+1)
   \   0000007C   0x.... 0x....      ADR.W    R1,`?<Constant "PID Autotune start">`
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable42
   \   00000084   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000088   0x210A             MOVS     R1,#+10
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable42
   \   0000008E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    289          
    290              disable_all_heaters(); // switch off all heaters.
   \   00000092   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
    291          
    292              #if HAS_PID_FOR_BOTH
    293                if (hotend < 0)
    294                  soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
    295                else
    296                  soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
    297              #elif ENABLED(PIDTEMP)
    298                soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
   \   00000096   0x277F             MOVS     R7,#+127
   \   00000098   0x463E             MOV      R6,R7
   \   0000009A   0x.... 0x....      LDR.W    R11,??DataTable42_1
   \   0000009E   0x4630             MOV      R0,R6
   \   000000A0   0xF88B 0x0002      STRB     R0,[R11, #+2]
   \   000000A4   0x4628             MOV      R0,R5
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable42_2
   \   000000AA   0x7008             STRB     R0,[R1, #+0]
   \   000000AC   0xE001             B.N      ??PID_autotune_2
    299              #else
    300                soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
    301              #endif
    302          
    303              wait_for_heatup = true;
    304          
    305              // PID Tuning loop
    306              while (wait_for_heatup) {
    307          
    308                const millis_t ms = millis();
    309          
    310                if (temp_meas_ready) { // temp sample ready
    311                  updateTemperaturesFromRawValues();
    312          
    313                  input =
    314                    #if HAS_PID_FOR_BOTH
    315                      hotend < 0 ? current_temperature_bed : current_temperature[hotend]
    316                    #elif ENABLED(PIDTEMP)
    317                      current_temperature[hotend]
    318                    #else
    319                      current_temperature_bed
    320                    #endif
    321                  ;
    322          
    323                  NOLESS(max, input);
    324                  NOMORE(min, input);
    325          
    326                  #if HAS_AUTO_FAN
    327                    if (ELAPSED(ms, next_auto_fan_check_ms)) {
    328                      checkExtruderAutoFans();
    329                      next_auto_fan_check_ms = ms + 2500UL;
    330                    }
    331                  #endif
    332          
    333                  if (heating && input > temp) {
    334                    if (ELAPSED(ms, t2 + 5000UL)) {
    335                      heating = false;
    336                      #if HAS_PID_FOR_BOTH
    337                        if (hotend < 0)
    338                          soft_pwm_amount_bed = (bias - d) >> 1;
    339                        else
    340                          soft_pwm_amount[hotend] = (bias - d) >> 1;
    341                      #elif ENABLED(PIDTEMP)
    342                        soft_pwm_amount[hotend] = (bias - d) >> 1;
    343                      #elif ENABLED(PIDTEMPBED)
    344                        soft_pwm_amount_bed = (bias - d) >> 1;
    345                      #endif
    346                      t1 = ms;
    347                      t_high = t1 - t2;
    348                      max = temp;
    349                    }
    350                  }
    351          
    352                  if (!heating && input < temp) {
    353                    if (ELAPSED(ms, t1 + 5000UL)) {
    354                      heating = true;
    355                      t2 = ms;
    356                      t_low = t2 - t1;
    357                      if (cycles > 0) {
    358                        long max_pow =
    359                          #if HAS_PID_FOR_BOTH
    360                            hotend < 0 ? MAX_BED_POWER : PID_MAX
    361                          #elif ENABLED(PIDTEMP)
    362                            PID_MAX
    363                          #else
    364                            MAX_BED_POWER
    365                          #endif
    366                        ;
    367                        bias += (d * (t_high - t_low)) / (t_low + t_high);
    368                        bias = constrain(bias, 20, max_pow - 20);
    369                        d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
    370          
    371                        SERIAL_PROTOCOLPAIR(MSG_BIAS, bias);
    372                        SERIAL_PROTOCOLPAIR(MSG_D, d);
    373                        SERIAL_PROTOCOLPAIR(MSG_T_MIN, min);
    374                        SERIAL_PROTOCOLPAIR(MSG_T_MAX, max);
    375                        if (cycles > 2) {
    376                          Ku = (4.0 * d) / (M_PI * (max - min) * 0.5);
    377                          Tu = ((float)(t_low + t_high) * 0.001);
    378                          SERIAL_PROTOCOLPAIR(MSG_KU, Ku);
    379                          SERIAL_PROTOCOLPAIR(MSG_TU, Tu);
    380                          workKp = 0.6 * Ku;
    381                          workKi = 2 * workKp / Tu;
    382                          workKd = workKp * Tu * 0.125;
    383                          SERIAL_PROTOCOLLNPGM("\n" MSG_CLASSIC_PID);
    384                          SERIAL_PROTOCOLPAIR(MSG_KP, workKp);
    385                          SERIAL_PROTOCOLPAIR(MSG_KI, workKi);
    386                          SERIAL_PROTOCOLLNPAIR(MSG_KD, workKd);
    387                          /**
    388                          workKp = 0.33*Ku;
    389                          workKi = workKp/Tu;
    390                          workKd = workKp*Tu/3;
    391                          SERIAL_PROTOCOLLNPGM(" Some overshoot");
    392                          SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
    393                          SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
    394                          SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
    395                          workKp = 0.2*Ku;
    396                          workKi = 2*workKp/Tu;
    397                          workKd = workKp*Tu/3;
    398                          SERIAL_PROTOCOLLNPGM(" No overshoot");
    399                          SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
    400                          SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
    401                          SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
    402                          */
    403                        }
    404                      }
    405                      #if HAS_PID_FOR_BOTH
    406                        if (hotend < 0)
    407                          soft_pwm_amount_bed = (bias + d) >> 1;
    408                        else
    409                          soft_pwm_amount[hotend] = (bias + d) >> 1;
    410                      #elif ENABLED(PIDTEMP)
    411                        soft_pwm_amount[hotend] = (bias + d) >> 1;
    412                      #else
    413                        soft_pwm_amount_bed = (bias + d) >> 1;
    414                      #endif
    415                      cycles++;
    416                      min = temp;
    417                    }
    418                  }
    419                }
    420                #define MAX_OVERSHOOT_PID_AUTOTUNE 20
    421                if (input > temp + MAX_OVERSHOOT_PID_AUTOTUNE) {
    422                  SERIAL_PROTOCOLLNPGM(MSG_PID_TEMP_TOO_HIGH);
    423                  break;
    424                }
    425                // Every 2 seconds...
    426                if (ELAPSED(ms, next_temp_ms)) {
    427                  #if HAS_TEMP_HOTEND || HAS_TEMP_BED
    428                    print_heaterstates();
    429                    SERIAL_EOL();
    430                  #endif
    431          
    432                  next_temp_ms = ms + 2000UL;
    433          
    434                  #if WATCH_THE_BED || WATCH_HOTENDS
    435                    if (!heated && input > next_watch_temp) {
    436                      if (input > watch_temp_target) heated = true;
    437                      next_watch_temp = input + watch_temp_increase;
    438                      temp_change_ms = ms + watch_temp_period * 1000UL;
    439                    }
    440                    else if (!heated && ELAPSED(ms, temp_change_ms))
    441                      _temp_error(hotend, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
    442                    else if (heated && input < temp - MAX_OVERSHOOT_PID_AUTOTUNE)
    443                      _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
    444                  #endif
    445                } // every 2 seconds
    446                // Timeout after 20 minutes since the last undershoot/overshoot cycle
    447                if (((ms - t1) + (ms - t2)) > (20L * 60L * 1000L)) {
    448                  SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
    449                  break;
    450                }
    451                if (cycles > ncycles) {
    452                  SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
    453          
    454                  #if HAS_PID_FOR_BOTH
    455                    const char* estring = hotend < 0 ? "bed" : "";
    456                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL();
    457                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL();
    458                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL();
    459                  #elif ENABLED(PIDTEMP)
    460                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kp ", workKp); SERIAL_EOL();
    461                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Ki ", workKi); SERIAL_EOL();
    462                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kd ", workKd); SERIAL_EOL();
    463                  #else
    464                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKp ", workKp); SERIAL_EOL();
    465                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKi ", workKi); SERIAL_EOL();
    466                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKd ", workKd); SERIAL_EOL();
    467                  #endif
    468          
    469                  #define _SET_BED_PID() do { \
    470                    bedKp = workKp; \
    471                    bedKi = scalePID_i(workKi); \
    472                    bedKd = scalePID_d(workKd); \
    473                    }while(0)
    474          
    475                  #define _SET_EXTRUDER_PID() do { \
    476                    PID_PARAM(Kp, hotend) = workKp; \
    477                    PID_PARAM(Ki, hotend) = scalePID_i(workKi); \
    478                    PID_PARAM(Kd, hotend) = scalePID_d(workKd); \
    479                    updatePID(); }while(0)
    480          
    481                  // Use the result? (As with "M303 U1")
    482                  if (set_result) {
    483                    #if HAS_PID_FOR_BOTH
    484                      if (hotend < 0)
    485                        _SET_BED_PID();
    486                      else
    487                        _SET_EXTRUDER_PID();
    488                    #elif ENABLED(PIDTEMP)
    489                      _SET_EXTRUDER_PID();
    490                    #else
    491                      _SET_BED_PID();
    492                    #endif
    493                  }
    494                  return;
    495                }
    496                lcd_update();
   \                     ??PID_autotune_3: (+1)
   \   000000AE   0x.... 0x....      BL       _Z10lcd_updatev
   \                     ??PID_autotune_2: (+1)
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable42_2
   \   000000B6   0x7800             LDRB     R0,[R0, #+0]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xF000 0x8101      BEQ.W    ??PID_autotune_4
   \   000000BE   0x.... 0x....      BL       HAL_GetTick
   \   000000C2   0x4604             MOV      R4,R0
   \   000000C4   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xF000 0x80EC      BEQ.W    ??PID_autotune_5
   \   000000CE   0x.... 0x....      BL       _ZN11Temperature31updateTemperaturesFromRawValuesEv
   \   000000D2   0xEDDB 0x8A06      VLDR     S17,[R11, #+24]
   \   000000D6   0xEEB4 0x9A68      VCMP.F32 S18,S17
   \   000000DA   0xEEF1 0xFA10      FMSTAT   
   \   000000DE   0xD501             BPL.N    ??PID_autotune_6
   \   000000E0   0xEEB0 0x9A68      VMOV.F32 S18,S17
   \                     ??PID_autotune_6: (+1)
   \   000000E4   0xEEF4 0x8A4C      VCMP.F32 S17,S24
   \   000000E8   0xEEF1 0xFA10      FMSTAT   
   \   000000EC   0xD501             BPL.N    ??PID_autotune_7
   \   000000EE   0xEEB0 0xCA68      VMOV.F32 S24,S17
   \                     ??PID_autotune_7: (+1)
   \   000000F2   0x2D00             CMP      R5,#+0
   \   000000F4   0xD013             BEQ.N    ??PID_autotune_8
   \   000000F6   0xEEB4 0x8A68      VCMP.F32 S16,S17
   \   000000FA   0xEEF1 0xFA10      FMSTAT   
   \   000000FE   0xD50E             BPL.N    ??PID_autotune_8
   \   00000100   0x9803             LDR      R0,[SP, #+12]
   \   00000102   0x1A20             SUBS     R0,R4,R0
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable42_3  ;; 0xffffec78
   \   00000108   0x1809             ADDS     R1,R1,R0
   \   0000010A   0xD408             BMI.N    ??PID_autotune_8
   \   0000010C   0x2500             MOVS     R5,#+0
   \   0000010E   0x1BF1             SUBS     R1,R6,R7
   \   00000110   0x1049             ASRS     R1,R1,#+1
   \   00000112   0xF88B 0x1002      STRB     R1,[R11, #+2]
   \   00000116   0x9404             STR      R4,[SP, #+16]
   \   00000118   0x4682             MOV      R10,R0
   \   0000011A   0xEEB0 0x9A48      VMOV.F32 S18,S16
   \                     ??PID_autotune_8: (+1)
   \   0000011E   0x2D00             CMP      R5,#+0
   \   00000120   0xF040 0x80C1      BNE.W    ??PID_autotune_5
   \   00000124   0xEEF4 0x8A48      VCMP.F32 S17,S16
   \   00000128   0xEEF1 0xFA10      FMSTAT   
   \   0000012C   0xF140 0x80BB      BPL.W    ??PID_autotune_5
   \   00000130   0x9804             LDR      R0,[SP, #+16]
   \   00000132   0x1A20             SUBS     R0,R4,R0
   \   00000134   0x.... 0x....      LDR.W    R1,??DataTable42_3  ;; 0xffffec78
   \   00000138   0x1809             ADDS     R1,R1,R0
   \   0000013A   0xF100 0x80B4      BMI.W    ??PID_autotune_5
   \   0000013E   0x2501             MOVS     R5,#+1
   \   00000140   0x9403             STR      R4,[SP, #+12]
   \   00000142   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000146   0xF2C0 0x80A6      BLT.W    ??PID_autotune_9
   \   0000014A   0xEB0A 0x0100      ADD      R1,R10,R0
   \   0000014E   0xEE0C 0x1A90      VMOV     S25,R1
   \   00000152   0xEBAA 0x0000      SUB      R0,R10,R0
   \   00000156   0x4378             MULS     R0,R0,R7
   \   00000158   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000015C   0x1986             ADDS     R6,R0,R6
   \   0000015E   0x2E14             CMP      R6,#+20
   \   00000160   0xDA01             BGE.N    ??PID_autotune_10
   \   00000162   0x2614             MOVS     R6,#+20
   \   00000164   0xE002             B.N      ??PID_autotune_11
   \                     ??PID_autotune_10: (+1)
   \   00000166   0x2EEC             CMP      R6,#+236
   \   00000168   0xDB00             BLT.N    ??PID_autotune_11
   \   0000016A   0x26EB             MOVS     R6,#+235
   \                     ??PID_autotune_11: (+1)
   \   0000016C   0x2E80             CMP      R6,#+128
   \   0000016E   0xDB02             BLT.N    ??PID_autotune_12
   \   00000170   0xF1C6 0x07FE      RSB      R7,R6,#+254
   \   00000174   0xE000             B.N      ??PID_autotune_13
   \                     ??PID_autotune_12: (+1)
   \   00000176   0x4637             MOV      R7,R6
   \                     ??PID_autotune_13: (+1)
   \   00000178   0x4631             MOV      R1,R6
   \   0000017A   0x.... 0x....      ADR.W    R0,`?<Constant " bias: ">`
   \   0000017E   0x.... 0x....      BL       _Z17serial_echopair_PPKcl
   \   00000182   0x4639             MOV      R1,R7
   \   00000184   0x.... 0x....      ADR.W    R0,`?<Constant " d: ">`
   \   00000188   0x.... 0x....      BL       _Z17serial_echopair_PPKcl
   \   0000018C   0xEEB0 0x0A4C      VMOV.F32 S0,S24
   \   00000190   0x.... 0x....      ADR.W    R0,`?<Constant " min: ">`
   \   00000194   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000198   0xEEB0 0x0A49      VMOV.F32 S0,S18
   \   0000019C   0x.... 0x....      ADR.W    R0,`?<Constant " max: ">`
   \   000001A0   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000001A4   0xF1B8 0x0F03      CMP      R8,#+3
   \   000001A8   0xDB75             BLT.N    ??PID_autotune_9
   \   000001AA   0x4638             MOV      R0,R7
   \   000001AC   0x.... 0x....      BL       __aeabi_i2d
   \   000001B0   0x2200             MOVS     R2,#+0
   \   000001B2   0x.... 0x....      LDR.W    R3,??DataTable42_4  ;; 0x40100000
   \   000001B6   0x.... 0x....      BL       __aeabi_dmul
   \   000001BA   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   000001BE   0xEE39 0x0A4C      VSUB.F32 S0,S18,S24
   \   000001C2   0xEE10 0x0A10      VMOV     R0,S0
   \   000001C6   0x.... 0x....      BL       __aeabi_f2d
   \   000001CA   0x.... 0x....      LDR.W    R2,??DataTable42_5  ;; 0x54442d18
   \   000001CE   0x.... 0x....      LDR.W    R3,??DataTable42_6  ;; 0x400921fb
   \   000001D2   0x.... 0x....      BL       __aeabi_dmul
   \   000001D6   0x2200             MOVS     R2,#+0
   \   000001D8   0x.... 0x....      LDR.W    R3,??DataTable42_7  ;; 0x3fe00000
   \   000001DC   0x.... 0x....      BL       __aeabi_dmul
   \   000001E0   0x4602             MOV      R2,R0
   \   000001E2   0x460B             MOV      R3,R1
   \   000001E4   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   000001E8   0x.... 0x....      BL       __aeabi_ddiv
   \   000001EC   0x.... 0x....      BL       __aeabi_d2f
   \   000001F0   0xEE0A 0x0A90      VMOV     S21,R0
   \   000001F4   0xEEB8 0x0AEC      VCVT.F32.S32 S0,S25
   \   000001F8   0xEE10 0x0A10      VMOV     R0,S0
   \   000001FC   0x.... 0x....      BL       __aeabi_f2d
   \   00000200   0x.... 0x....      LDR.W    R2,??DataTable42_8  ;; 0xd2f1a9fc
   \   00000204   0x.... 0x....      LDR.W    R3,??DataTable42_9  ;; 0x3f50624d
   \   00000208   0x.... 0x....      BL       __aeabi_dmul
   \   0000020C   0x.... 0x....      BL       __aeabi_d2f
   \   00000210   0xEE0B 0x0A90      VMOV     S23,R0
   \   00000214   0xEEB0 0x0A6A      VMOV.F32 S0,S21
   \   00000218   0x.... 0x....      ADR.W    R0,`?<Constant " Ku: ">`
   \   0000021C   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000220   0xEEB0 0x0A6B      VMOV.F32 S0,S23
   \   00000224   0x.... 0x....      ADR.W    R0,`?<Constant " Tu: ">`
   \   00000228   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   0000022C   0xEE1A 0x0A90      VMOV     R0,S21
   \   00000230   0x.... 0x....      BL       __aeabi_f2d
   \   00000234   0xF04F 0x3233      MOV      R2,#+858993459
   \   00000238   0x.... 0x....      LDR.W    R3,??DataTable42_10  ;; 0x3fe33333
   \   0000023C   0x.... 0x....      BL       __aeabi_dmul
   \   00000240   0x.... 0x....      BL       __aeabi_d2f
   \   00000244   0xEE0A 0x0A90      VMOV     S21,R0
   \   00000248   0xEEB0 0x0A00      VMOV.F32 S0,#2.0
   \   0000024C   0xEE2A 0x0A80      VMUL.F32 S0,S21,S0
   \   00000250   0xEE80 0xBA2B      VDIV.F32 S22,S0,S23
   \   00000254   0xEE2A 0x0AAB      VMUL.F32 S0,S21,S23
   \   00000258   0xEEF4 0x0A00      VMOV.F32 S1,#0.125
   \   0000025C   0xEE60 0xBA20      VMUL.F32 S23,S0,S1
   \   00000260   0x.... 0x....      ADR.W    R0,`?<Constant "\\n Classic PID \\n">`
   \   00000264   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000268   0xEEB0 0x0A6A      VMOV.F32 S0,S21
   \   0000026C   0x.... 0x....      ADR.W    R0,`?<Constant " Kp: ">`
   \   00000270   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000274   0xEEB0 0x0A4B      VMOV.F32 S0,S22
   \   00000278   0x.... 0x....      ADR.W    R0,`?<Constant " Ki: ">`
   \   0000027C   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000280   0xEEB0 0x0A6B      VMOV.F32 S0,S23
   \   00000284   0x.... 0x....      ADR.W    R0,`?<Constant " Kd: ">`
   \   00000288   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   0000028C   0x210A             MOVS     R1,#+10
   \   0000028E   0x.... 0x....      LDR.W    R0,??DataTable42
   \   00000292   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??PID_autotune_9: (+1)
   \   00000296   0x19B8             ADDS     R0,R7,R6
   \   00000298   0x1040             ASRS     R0,R0,#+1
   \   0000029A   0xF88B 0x0002      STRB     R0,[R11, #+2]
   \   0000029E   0xF108 0x0801      ADD      R8,R8,#+1
   \   000002A2   0xEEB0 0xCA48      VMOV.F32 S24,S16
   \                     ??PID_autotune_5: (+1)
   \   000002A6   0xEEB3 0x0A04      VMOV.F32 S0,#20.0
   \   000002AA   0xEE38 0x0A00      VADD.F32 S0,S16,S0
   \   000002AE   0xEEB4 0x0A68      VCMP.F32 S0,S17
   \   000002B2   0xEEF1 0xFA10      FMSTAT   
   \   000002B6   0xD50E             BPL.N    ??PID_autotune_14
   \   000002B8   0x.... 0x....      ADR.W    R0,`?<Constant "PID Autotune failed! ...">_1`
   \   000002BC   0x.... 0x....      BL       _Z14serialprintPGMPKc
    497              }
    498              disable_all_heaters();
   \                     ??PID_autotune_4: (+1)
   \   000002C0   0xB006             ADD      SP,SP,#+24
   \   000002C2   0xECBD 0x8B0A      VPOP     {D8-D12}
   \   000002C6   0xE8BD 0x4FF7      POP      {R0-R2,R4-R11,LR}
   \   000002CA   0x....             B.N      _ZN11Temperature19disable_all_heatersEv
   \                     ??PID_autotune_15: (+1)
   \   000002CC   0xB006             ADD      SP,SP,#+24
   \   000002CE   0xECBD 0x8B0A      VPOP     {D8-D12}
   \   000002D2   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   \                     ??PID_autotune_14: (+1)
   \   000002D6   0x9802             LDR      R0,[SP, #+8]
   \   000002D8   0x1A20             SUBS     R0,R4,R0
   \   000002DA   0xD43A             BMI.N    ??PID_autotune_16
   \   000002DC   0xF504 0x60FA      ADD      R0,R4,#+2000
   \   000002E0   0x9002             STR      R0,[SP, #+8]
   \   000002E2   0xF1B9 0x0F00      CMP      R9,#+0
   \   000002E6   0xD114             BNE.N    ??PID_autotune_17
   \   000002E8   0xEEB4 0xAA68      VCMP.F32 S20,S17
   \   000002EC   0xEEF1 0xFA10      FMSTAT   
   \   000002F0   0xD50F             BPL.N    ??PID_autotune_17
   \   000002F2   0xEEF4 0x9A68      VCMP.F32 S19,S17
   \   000002F6   0xEEF1 0xFA10      FMSTAT   
   \   000002FA   0xD501             BPL.N    ??PID_autotune_18
   \   000002FC   0xF04F 0x0901      MOV      R9,#+1
   \                     ??PID_autotune_18: (+1)
   \   00000300   0xEEB0 0x0A00      VMOV.F32 S0,#2.0
   \   00000304   0xEE38 0xAA80      VADD.F32 S20,S17,S0
   \   00000308   0xF504 0x409C      ADD      R0,R4,#+19968
   \   0000030C   0x3020             ADDS     R0,R0,#+32
   \   0000030E   0x9005             STR      R0,[SP, #+20]
   \   00000310   0xE01F             B.N      ??PID_autotune_16
   \                     ??PID_autotune_17: (+1)
   \   00000312   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000316   0xD109             BNE.N    ??PID_autotune_19
   \   00000318   0x9805             LDR      R0,[SP, #+20]
   \   0000031A   0x1A20             SUBS     R0,R4,R0
   \   0000031C   0xD406             BMI.N    ??PID_autotune_19
   \   0000031E   0x.... 0x....      ADR.W    R1,`?<Constant "Heating failed">`
   \   00000322   0x460A             MOV      R2,R1
   \   00000324   0x2000             MOVS     R0,#+0
   \   00000326   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \   0000032A   0xE012             B.N      ??PID_autotune_16
   \                     ??PID_autotune_19: (+1)
   \   0000032C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000330   0xD00F             BEQ.N    ??PID_autotune_16
   \   00000332   0xEEBB 0x0A04      VMOV.F32 S0,#-20.0
   \   00000336   0xEE38 0x0A00      VADD.F32 S0,S16,S0
   \   0000033A   0xEEF4 0x8A40      VCMP.F32 S17,S0
   \   0000033E   0xEEF1 0xFA10      FMSTAT   
   \   00000342   0xD506             BPL.N    ??PID_autotune_16
   \   00000344   0x.... 0x....      ADR.W    R2,`?<Constant "THERMAL RUNAWAY">`
   \   00000348   0x.... 0x....      ADR.W    R1,`?<Constant "Thermal Runaway">`
   \   0000034C   0x2000             MOVS     R0,#+0
   \   0000034E   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \                     ??PID_autotune_16: (+1)
   \   00000352   0x9804             LDR      R0,[SP, #+16]
   \   00000354   0xEBC0 0x0044      RSB      R0,R0,R4, LSL #+1
   \   00000358   0x9903             LDR      R1,[SP, #+12]
   \   0000035A   0x1A40             SUBS     R0,R0,R1
   \   0000035C   0x.... 0x....      LDR.W    R1,??DataTable42_11  ;; 0x124f81
   \   00000360   0x4288             CMP      R0,R1
   \   00000362   0xD309             BCC.N    ??PID_autotune_20
   \   00000364   0x.... 0x....      ADR.W    R0,`?<Constant "PID Autotune failed! ...">_2`
   \   00000368   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   0000036C   0xE7A8             B.N      ??PID_autotune_4
   \   0000036E   0xBF00             Nop      
   \                     ??PID_autotune_0:
   \   00000370   0x00000000         DC32     0x0
   \   00000374   0x461C4000         DC32     0x461c4000
   \                     ??PID_autotune_20: (+1)
   \   00000378   0xF99D 0x0044      LDRSB    R0,[SP, #+68]
   \   0000037C   0x4540             CMP      R0,R8
   \   0000037E   0xF6BF 0xAE96      BGE.W    ??PID_autotune_3
   \   00000382   0x.... 0x....      ADR.W    R0,`?<Constant "PID Autotune finished...">`
   \   00000386   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   0000038A   0xEEB0 0x0A6A      VMOV.F32 S0,S21
   \   0000038E   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_Kp ">`
   \   00000392   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000396   0x210A             MOVS     R1,#+10
   \   00000398   0x.... 0x....      LDR.W    R0,??DataTable42
   \   0000039C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000003A0   0xEEB0 0x0A4B      VMOV.F32 S0,S22
   \   000003A4   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_Ki ">`
   \   000003A8   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000003AC   0x210A             MOVS     R1,#+10
   \   000003AE   0x.... 0x....      LDR.W    R0,??DataTable42
   \   000003B2   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000003B6   0xEEB0 0x0A6B      VMOV.F32 S0,S23
   \   000003BA   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_Kd ">`
   \   000003BE   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000003C2   0x210A             MOVS     R1,#+10
   \   000003C4   0x.... 0x....      LDR.W    R0,??DataTable42
   \   000003C8   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000003CC   0xF89D 0x0048      LDRB     R0,[SP, #+72]
   \   000003D0   0x2800             CMP      R0,#+0
   \   000003D2   0xF43F 0xAF7B      BEQ.W    ??PID_autotune_15
   \   000003D6   0xEDCB 0xAA0A      VSTR     S21,[R11, #+40]
   \   000003DA   0xEE1B 0x0A10      VMOV     R0,S22
   \   000003DE   0x.... 0x....      BL       __aeabi_f2d
   \   000003E2   0x.... 0x....      LDR.W    R2,??DataTable42_12  ;; 0x88e368f1
   \   000003E6   0x.... 0x....      LDR.W    R3,??DataTable42_13  ;; 0x3fc4f8b5
   \   000003EA   0x.... 0x....      BL       __aeabi_dmul
   \   000003EE   0x.... 0x....      BL       __aeabi_d2f
   \   000003F2   0xF8CB 0x002C      STR      R0,[R11, #+44]
   \   000003F6   0xEE1B 0x0A90      VMOV     R0,S23
   \   000003FA   0x.... 0x....      BL       __aeabi_f2d
   \   000003FE   0x.... 0x....      LDR.W    R2,??DataTable42_12  ;; 0x88e368f1
   \   00000402   0x.... 0x....      LDR.W    R3,??DataTable42_13  ;; 0x3fc4f8b5
   \   00000406   0x.... 0x....      BL       __aeabi_ddiv
   \   0000040A   0x.... 0x....      BL       __aeabi_d2f
   \   0000040E   0xF8CB 0x0030      STR      R0,[R11, #+48]
   \   00000412   0xB006             ADD      SP,SP,#+24
   \   00000414   0xECBD 0x8B0A      VPOP     {D8-D12}
   \   00000418   0xE8BD 0x4FF7      POP      {R0-R2,R4-R11,LR}
   \   0000041C   0x.... 0x....      B.W      _ZN11Temperature9updatePIDEv
    499            }
    500          
    501          #endif // HAS_PID_HEATING
    502          
    503          /**
    504           * Class and Instance Methods
    505           */
    506          

   \                                 In section .text, align 2, keep-with-next
    507          Temperature::Temperature() { }
   \                     _ZN11TemperatureC1Ev: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    508          

   \                                 In section .text, align 2, keep-with-next
    509          int Temperature::getHeaterPower(int heater) {
    510            return heater < 0 ? soft_pwm_amount_bed : soft_pwm_amount[heater];
   \                     _ZN11Temperature14getHeaterPowerEi: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable42_1
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD501             BPL.N    ??getHeaterPower_0
   \   00000008   0x78C8             LDRB     R0,[R1, #+3]
   \   0000000A   0x4770             BX       LR
   \                     ??getHeaterPower_0: (+1)
   \   0000000C   0x1840             ADDS     R0,R0,R1
   \   0000000E   0x7880             LDRB     R0,[R0, #+2]
   \   00000010   0x4770             BX       LR               ;; return
    511          }
    512          
    513          #if HAS_AUTO_FAN
    514          
    515            void Temperature::checkExtruderAutoFans() {
    516              static const int8_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN };
    517              static const uint8_t fanBit[] PROGMEM = {
    518                              0,
    519                AUTO_1_IS_0 ? 0 :               1,
    520                AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
    521                AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 :               3,
    522                AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4
    523              };
    524              uint8_t fanState = 0;
    525          
    526              HOTEND_LOOP()
    527                if (current_temperature[e] > EXTRUDER_AUTO_FAN_TEMPERATURE)
    528                  SBI(fanState, pgm_read_byte(&fanBit[e]));
    529          
    530              uint8_t fanDone = 0;
    531              for (uint8_t f = 0; f < COUNT(fanPin); f++) {
    532                int8_t pin = pgm_read_byte(&fanPin[f]);
    533                const uint8_t bit = pgm_read_byte(&fanBit[f]);
    534                if (pin >= 0 && !TEST(fanDone, bit)) {
    535                  uint8_t newFanSpeed = TEST(fanState, bit) ? EXTRUDER_AUTO_FAN_SPEED : 0;
    536                  // this idiom allows both digital and PWM fan outputs (see M42 handling).
    537                  digitalWrite(pin, newFanSpeed);
    538                  analogWrite(pin, newFanSpeed);
    539                  SBI(fanDone, bit);
    540                }
    541              }
    542            }
    543          
    544          #endif // HAS_AUTO_FAN
    545          
    546          #if 1
    547          extern void temper_error_kill();
    548          #endif//
    549          //
    550          // Temperature Error Handlers
    551          //

   \                                 In section .text, align 2, keep-with-next
    552          void Temperature::_temp_error(const int8_t e, const char * const serial_msg, const char * const lcd_msg) {
   \                     _ZN11Temperature11_temp_errorEaPKcS1_: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    553            static bool killed = false;
    554            if (IsRunning()) {
   \   00000006   0x.... 0x....      BL       _Z9IsRunningv
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD01C             BEQ.N    ??_temp_error_0
    555              SERIAL_ERROR_START();
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable42_14
   \   00000012   0x.... 0x....      BL       _Z14serialprintPGMPKc
    556              serialprintPGM(serial_msg);
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       _Z14serialprintPGMPKc
    557              SERIAL_ERRORPGM(MSG_STOPPED_HEATER);
   \   0000001C   0x.... 0x....      ADR.W    R0,`?<Constant ", system stopped! Hea...">`
   \   00000020   0x.... 0x....      BL       _Z14serialprintPGMPKc
    558              if (e >= 0) {SERIAL_ERRORLN((int)e);} else {SERIAL_ERRORLNPGM(MSG_HEATER_BED);}
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD40B             BMI.N    ??_temp_error_1
   \   00000028   0x.... 0x....      LDR.W    R5,??DataTable42
   \   0000002C   0x220A             MOVS     R2,#+10
   \   0000002E   0x4621             MOV      R1,R4
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x.... 0x....      BL       _ZN5Print5printEii
   \   00000036   0x210A             MOVS     R1,#+10
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   0000003E   0xE003             B.N      ??_temp_error_0
   \                     ??_temp_error_1: (+1)
   \   00000040   0x.... 0x....      ADR.W    R0,`?<Constant "bed\\n">`
   \   00000044   0x.... 0x....      BL       _Z14serialprintPGMPKc
    559            }
    560            #if DISABLED(BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE)
    561              if (!killed) {
   \                     ??_temp_error_0: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable42_15
   \   0000004C   0x7801             LDRB     R1,[R0, #+0]
   \   0000004E   0x2900             CMP      R1,#+0
   \   00000050   0xD109             BNE.N    ??_temp_error_2
    562                Running = false;
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x.... 0x....      LDR.W    R2,??DataTable42_16
   \   00000058   0x7011             STRB     R1,[R2, #+0]
    563                killed = true;
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0x7001             STRB     R1,[R0, #+0]
    564                //kill(lcd_msg);
    565                #if 1
    566                temper_error_kill();
   \   0000005E   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000062   0x.... 0x....      B.W      _Z17temper_error_killv
    567                #endif
    568              }
    569              else
    570                disable_all_heaters(); // paranoia
   \                     ??_temp_error_2: (+1)
   \   00000066   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000006A   0x....             B.N      _ZN11Temperature19disable_all_heatersEv
    571            #endif
    572          }

   \                                 In section .bss, align 1
   \                     ??killed:
   \   00000000                      DS8 1
    573          

   \                                 In section .text, align 2, keep-with-next
    574          void Temperature::max_temp_error(const int8_t e) {
    575            #if HAS_TEMP_BED
    576              _temp_error(e, PSTR(MSG_T_MAXTEMP), e >= 0 ? PSTR(MSG_ERR_MAXTEMP) : PSTR(MSG_ERR_MAXTEMP_BED));
    577            #else
    578              _temp_error(HOTEND_INDEX, PSTR(MSG_T_MAXTEMP), PSTR(MSG_ERR_MAXTEMP));
   \                     _ZN11Temperature14max_temp_errorEa: (+1)
   \   00000000   0x.... 0x....      ADR.W    R2,`?<Constant "Err: MAXTEMP">`
   \   00000004   0x.... 0x....      ADR.W    R1,`?<Constant "MAXTEMP triggered">`
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             B.N      _ZN11Temperature11_temp_errorEaPKcS1_
    579              #if HOTENDS == 1
    580                UNUSED(e);
    581              #endif
    582            #endif
    583          }

   \                                 In section .text, align 2, keep-with-next
    584          void Temperature::min_temp_error(const int8_t e) {
    585            #if HAS_TEMP_BED
    586              _temp_error(e, PSTR(MSG_T_MINTEMP), e >= 0 ? PSTR(MSG_ERR_MINTEMP) : PSTR(MSG_ERR_MINTEMP_BED));
    587            #else
    588              _temp_error(HOTEND_INDEX, PSTR(MSG_T_MINTEMP), PSTR(MSG_ERR_MINTEMP));
   \                     _ZN11Temperature14min_temp_errorEa: (+1)
   \   00000000   0x.... 0x....      ADR.W    R2,`?<Constant "Err: MINTEMP">`
   \   00000004   0x.... 0x....      ADR.W    R1,`?<Constant "MINTEMP triggered">`
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             B.N      _ZN11Temperature11_temp_errorEaPKcS1_
    589              #if HOTENDS == 1
    590                UNUSED(e);
    591              #endif
    592            #endif
    593          }
    594          

   \                                 In section .text, align 4, keep-with-next
    595          float Temperature::get_pid_output(const int8_t e) {
   \                     _ZN11Temperature14get_pid_outputEa: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
    596            #if HOTENDS == 1
    597              UNUSED(e);
    598              #define _HOTEND_TEST     true
    599            #else
    600              #define _HOTEND_TEST     e == active_extruder
    601            #endif
    602            float pid_output;
    603            #if ENABLED(PIDTEMP)
    604              #if DISABLED(PID_OPENLOOP)
    605                pid_error[HOTEND_INDEX] = target_temperature[HOTEND_INDEX] - current_temperature[HOTEND_INDEX];
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable42_1
   \   0000000A   0xED96 0x8A06      VLDR     S16,[R6, #+24]
   \   0000000E   0x6A37             LDR      R7,[R6, #+32]
   \   00000010   0xEE00 0x7A10      VMOV     S0,R7
   \   00000014   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000018   0xEE70 0x8A48      VSUB.F32 S17,S0,S16
   \   0000001C   0xEDC6 0x8A13      VSTR     S17,[R6, #+76]
    606                dTerm[HOTEND_INDEX] = PID_K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + PID_K1 * dTerm[HOTEND_INDEX];
   \   00000020   0x6B30             LDR      R0,[R6, #+48]
   \   00000022   0x.... 0x....      BL       __aeabi_f2d
   \   00000026   0x.... 0x....      LDR.W    R2,??DataTable42_17  ;; 0x999999a0
   \   0000002A   0x.... 0x....      LDR.W    R3,??DataTable42_18  ;; 0x3fa99999
   \   0000002E   0x.... 0x....      BL       __aeabi_dmul
   \   00000032   0x4604             MOV      R4,R0
   \   00000034   0x460D             MOV      R5,R1
   \   00000036   0xED96 0x0A0F      VLDR     S0,[R6, #+60]
   \   0000003A   0xEE38 0x0A40      VSUB.F32 S0,S16,S0
   \   0000003E   0xEE10 0x0A10      VMOV     R0,S0
   \   00000042   0x.... 0x....      BL       __aeabi_f2d
   \   00000046   0x4622             MOV      R2,R4
   \   00000048   0x462B             MOV      R3,R5
   \   0000004A   0x.... 0x....      BL       __aeabi_dmul
   \   0000004E   0x4604             MOV      R4,R0
   \   00000050   0x460D             MOV      R5,R1
   \   00000052   0x6CB0             LDR      R0,[R6, #+72]
   \   00000054   0x.... 0x....      BL       __aeabi_f2d
   \   00000058   0xF04F 0x3266      MOV      R2,#+1717986918
   \   0000005C   0x.... 0x....      LDR.W    R3,??DataTable42_19  ;; 0x3fee6666
   \   00000060   0x.... 0x....      BL       __aeabi_dmul
   \   00000064   0x4622             MOV      R2,R4
   \   00000066   0x462B             MOV      R3,R5
   \   00000068   0x.... 0x....      BL       __aeabi_dadd
   \   0000006C   0x.... 0x....      BL       __aeabi_d2f
   \   00000070   0xEE00 0x0A10      VMOV     S0,R0
   \   00000074   0xED86 0x0A12      VSTR     S0,[R6, #+72]
    607                temp_dState[HOTEND_INDEX] = current_temperature[HOTEND_INDEX];
   \   00000078   0xED86 0x8A0F      VSTR     S16,[R6, #+60]
    608                #if HEATER_IDLE_HANDLER
    609                  if (heater_idle_timeout_exceeded[HOTEND_INDEX]) {
    610                    pid_output = 0;
    611                    pid_reset[HOTEND_INDEX] = true;
    612                  }
    613                  else
    614                #endif
    615                if (pid_error[HOTEND_INDEX] > PID_FUNCTIONAL_RANGE) {
   \   0000007C   0xEDDF 0x....      VLDR.W   S1,??DataTable38  ;; 0x41200001
   \   00000080   0xEEF4 0x8A60      VCMP.F32 S17,S1
   \   00000084   0xEEF1 0xFA10      FMSTAT   
   \   00000088   0xDB04             BLT.N    ??get_pid_output_0
    616                  pid_output = BANG_MAX;
   \   0000008A   0xED9F 0x....      VLDR.W   S0,??DataTable38_1  ;; 0x437f0000
    617                  pid_reset[HOTEND_INDEX] = true;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x7070             STRB     R0,[R6, #+1]
   \   00000092   0xE04C             B.N      ??get_pid_output_1
    618                }
    619                else if (pid_error[HOTEND_INDEX] < -(PID_FUNCTIONAL_RANGE) || target_temperature[HOTEND_INDEX] == 0
    620                  #if HEATER_IDLE_HANDLER
    621                    || heater_idle_timeout_exceeded[HOTEND_INDEX]
    622                  #endif
    623                  ) {
   \                     ??get_pid_output_0: (+1)
   \   00000094   0xEEFA 0x0A04      VMOV.F32 S1,#-10.0
   \   00000098   0xEEF4 0x8A60      VCMP.F32 S17,S1
   \   0000009C   0xEEF1 0xFA10      FMSTAT   
   \   000000A0   0xD401             BMI.N    ??get_pid_output_2
   \   000000A2   0x2F00             CMP      R7,#+0
   \   000000A4   0xD104             BNE.N    ??get_pid_output_3
    624                  pid_output = 0;
   \                     ??get_pid_output_2: (+1)
   \   000000A6   0xED9F 0x....      VLDR.W   S0,??DataTable38_2  ;; 0x0
    625                  pid_reset[HOTEND_INDEX] = true;
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0x7070             STRB     R0,[R6, #+1]
   \   000000AE   0xE03E             B.N      ??get_pid_output_1
    626                }
    627                else {
    628                  if (pid_reset[HOTEND_INDEX]) {
   \                     ??get_pid_output_3: (+1)
   \   000000B0   0x7870             LDRB     R0,[R6, #+1]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD002             BEQ.N    ??get_pid_output_4
    629                    temp_iState[HOTEND_INDEX] = 0.0;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x63B0             STR      R0,[R6, #+56]
    630                    pid_reset[HOTEND_INDEX] = false;
   \   000000BA   0x7070             STRB     R0,[R6, #+1]
    631                  }
    632                  pTerm[HOTEND_INDEX] = PID_PARAM(Kp, HOTEND_INDEX) * pid_error[HOTEND_INDEX];
   \                     ??get_pid_output_4: (+1)
   \   000000BC   0xEDD6 0x0A0A      VLDR     S1,[R6, #+40]
   \   000000C0   0xEE60 0x0AA8      VMUL.F32 S1,S1,S17
   \   000000C4   0xEDC6 0x0A10      VSTR     S1,[R6, #+64]
    633                  temp_iState[HOTEND_INDEX] += pid_error[HOTEND_INDEX];
   \   000000C8   0xED96 0x1A0E      VLDR     S2,[R6, #+56]
   \   000000CC   0xEE31 0x1A28      VADD.F32 S2,S2,S17
   \   000000D0   0xED86 0x1A0E      VSTR     S2,[R6, #+56]
    634                  iTerm[HOTEND_INDEX] = PID_PARAM(Ki, HOTEND_INDEX) * temp_iState[HOTEND_INDEX];
   \   000000D4   0xEDD6 0x1A0B      VLDR     S3,[R6, #+44]
   \   000000D8   0xEE61 0x1A81      VMUL.F32 S3,S3,S2
   \   000000DC   0xEDC6 0x1A11      VSTR     S3,[R6, #+68]
    635          
    636                  pid_output = pTerm[HOTEND_INDEX] + iTerm[HOTEND_INDEX] - dTerm[HOTEND_INDEX];
   \   000000E0   0xEE70 0x0AA1      VADD.F32 S1,S1,S3
   \   000000E4   0xEE30 0x0AC0      VSUB.F32 S0,S1,S0
    637          
    638                  #if ENABLED(PID_EXTRUSION_SCALING)
    639                    cTerm[HOTEND_INDEX] = 0;
    640                    if (_HOTEND_TEST) {
    641                      long e_position = stepper.position(E_AXIS);
    642                      if (e_position > last_e_position) {
    643                        lpq[lpq_ptr] = e_position - last_e_position;
    644                        last_e_position = e_position;
    645                      }
    646                      else {
    647                        lpq[lpq_ptr] = 0;
    648                      }
    649                      if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
    650                      cTerm[HOTEND_INDEX] = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
    651                      pid_output += cTerm[HOTEND_INDEX];
    652                    }
    653                  #endif // PID_EXTRUSION_SCALING
    654          
    655                  if (pid_output > PID_MAX) {
   \   000000E8   0xEDDF 0x....      VLDR.W   S1,??DataTable38_3  ;; 0x437f0001
   \   000000EC   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000000F0   0xEEF1 0xFA10      FMSTAT   
   \   000000F4   0xDB0B             BLT.N    ??get_pid_output_5
    656                    if (pid_error[HOTEND_INDEX] > 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
   \   000000F6   0xEEF5 0x8A40      VCMP.F32 S17,#0.0
   \   000000FA   0xEEF1 0xFA10      FMSTAT   
   \   000000FE   0xDD03             BLE.N    ??get_pid_output_6
   \   00000100   0xEE31 0x0A68      VSUB.F32 S0,S2,S17
   \   00000104   0xED86 0x0A0E      VSTR     S0,[R6, #+56]
    657                    pid_output = PID_MAX;
   \                     ??get_pid_output_6: (+1)
   \   00000108   0xED9F 0x....      VLDR.W   S0,??DataTable38_1  ;; 0x437f0000
   \   0000010C   0xE00F             B.N      ??get_pid_output_1
    658                  }
    659                  else if (pid_output < 0) {
   \                     ??get_pid_output_5: (+1)
   \   0000010E   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000112   0xEEF1 0xFA10      FMSTAT   
   \   00000116   0xD50A             BPL.N    ??get_pid_output_1
    660                    if (pid_error[HOTEND_INDEX] < 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
   \   00000118   0xEEF5 0x8A40      VCMP.F32 S17,#0.0
   \   0000011C   0xEEF1 0xFA10      FMSTAT   
   \   00000120   0xD503             BPL.N    ??get_pid_output_7
   \   00000122   0xEE31 0x0A68      VSUB.F32 S0,S2,S17
   \   00000126   0xED86 0x0A0E      VSTR     S0,[R6, #+56]
    661                    pid_output = 0;
   \                     ??get_pid_output_7: (+1)
   \   0000012A   0xED9F 0x....      VLDR.W   S0,??DataTable38_2  ;; 0x0
    662                  }
    663                }
    664              #else
    665                pid_output = constrain(target_temperature[HOTEND_INDEX], 0, PID_MAX);
    666              #endif // PID_OPENLOOP
    667          
    668              #if ENABLED(PID_DEBUG)
    669                SERIAL_ECHO_START();
    670                SERIAL_ECHOPAIR(MSG_PID_DEBUG, HOTEND_INDEX);
    671                SERIAL_ECHOPAIR(MSG_PID_DEBUG_INPUT, current_temperature[HOTEND_INDEX]);
    672                SERIAL_ECHOPAIR(MSG_PID_DEBUG_OUTPUT, pid_output);
    673                SERIAL_ECHOPAIR(MSG_PID_DEBUG_PTERM, pTerm[HOTEND_INDEX]);
    674                SERIAL_ECHOPAIR(MSG_PID_DEBUG_ITERM, iTerm[HOTEND_INDEX]);
    675                SERIAL_ECHOPAIR(MSG_PID_DEBUG_DTERM, dTerm[HOTEND_INDEX]);
    676                #if ENABLED(PID_EXTRUSION_SCALING)
    677                  SERIAL_ECHOPAIR(MSG_PID_DEBUG_CTERM, cTerm[HOTEND_INDEX]);
    678                #endif
    679                SERIAL_EOL();
    680              #endif // PID_DEBUG
    681          
    682            #else /* PID off */
    683              #if HEATER_IDLE_HANDLER
    684                if (heater_idle_timeout_exceeded[HOTEND_INDEX])
    685                  pid_output = 0;
    686                else
    687              #endif
    688              pid_output = (current_temperature[HOTEND_INDEX] < target_temperature[HOTEND_INDEX]) ? PID_MAX : 0;
    689            #endif
    690          
    691            return pid_output;
   \                     ??get_pid_output_1: (+1)
   \   0000012E   0xECBD 0x8B02      VPOP     {D8}
   \   00000132   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    692          }
    693          
    694          #if ENABLED(PIDTEMPBED)
    695            float Temperature::get_pid_output_bed() {
    696              float pid_output;
    697              #if DISABLED(PID_OPENLOOP)
    698                pid_error_bed = target_temperature_bed - current_temperature_bed;
    699                pTerm_bed = bedKp * pid_error_bed;
    700                temp_iState_bed += pid_error_bed;
    701                iTerm_bed = bedKi * temp_iState_bed;
    702          
    703                dTerm_bed = PID_K2 * bedKd * (current_temperature_bed - temp_dState_bed) + PID_K1 * dTerm_bed;
    704                temp_dState_bed = current_temperature_bed;
    705          
    706                pid_output = pTerm_bed + iTerm_bed - dTerm_bed;
    707                if (pid_output > MAX_BED_POWER) {
    708                  if (pid_error_bed > 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
    709                  pid_output = MAX_BED_POWER;
    710                }
    711                else if (pid_output < 0) {
    712                  if (pid_error_bed < 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
    713                  pid_output = 0;
    714                }
    715              #else
    716                pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);
    717              #endif // PID_OPENLOOP
    718          
    719              #if ENABLED(PID_BED_DEBUG)
    720                SERIAL_ECHO_START();
    721                SERIAL_ECHOPGM(" PID_BED_DEBUG ");
    722                SERIAL_ECHOPGM(": Input ");
    723                SERIAL_ECHO(current_temperature_bed);
    724                SERIAL_ECHOPGM(" Output ");
    725                SERIAL_ECHO(pid_output);
    726                SERIAL_ECHOPGM(" pTerm ");
    727                SERIAL_ECHO(pTerm_bed);
    728                SERIAL_ECHOPGM(" iTerm ");
    729                SERIAL_ECHO(iTerm_bed);
    730                SERIAL_ECHOPGM(" dTerm ");
    731                SERIAL_ECHOLN(dTerm_bed);
    732              #endif // PID_BED_DEBUG
    733          
    734              return pid_output;
    735            }
    736          #endif // PIDTEMPBED
    737          
    738          /**
    739           * Manage heating activities for extruder hot-ends and a heated bed
    740           *  - Acquire updated temperature readings
    741           *    - Also resets the watchdog timer
    742           *  - Invoke thermal runaway protection
    743           *  - Manage extruder auto-fan
    744           *  - Apply filament width to the extrusion rate (may move)
    745           *  - Update the heated bed PID output value
    746           */
    747          static float current_temper_bak;
    748          

   \                                 In section .text, align 2, keep-with-next
    749          void Temperature::manage_heater() {
   \                     _ZN11Temperature13manage_heaterEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0xB082             SUB      SP,SP,#+8
    750          
    751            if (!temp_meas_ready) return;
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable42_1
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD068             BEQ.N    ??manage_heater_0
    752          
    753            updateTemperaturesFromRawValues(); // also resets the watchdog
   \   00000014   0x.... 0x....      BL       _ZN11Temperature31updateTemperaturesFromRawValuesEv
    754          
    755            #if ENABLED(HEATER_0_USES_MAX6675)
    756              if (current_temperature[0] > min(HEATER_0_MAXTEMP, MAX6675_TMAX - 1.0)) max_temp_error(0);
    757              if (current_temperature[0] < max(HEATER_0_MINTEMP, MAX6675_TMIN + .01)) min_temp_error(0);
    758            #endif
    759          
    760            #if WATCH_HOTENDS || WATCH_THE_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
    761              millis_t ms = millis();
   \   00000018   0x.... 0x....      BL       HAL_GetTick
   \   0000001C   0x4605             MOV      R5,R0
    762            #endif
    763          
    764            HOTEND_LOOP() {
   \   0000001E   0x2600             MOVS     R6,#+0
   \   00000020   0xE005             B.N      ??manage_heater_1
    765          
    766              #if HEATER_IDLE_HANDLER
    767                if (!heater_idle_timeout_exceeded[e] && heater_idle_timeout_ms[e] && ELAPSED(ms, heater_idle_timeout_ms[e]))
    768                  heater_idle_timeout_exceeded[e] = true;
    769              #endif
    770          
    771              #if ENABLED(THERMAL_PROTECTION_HOTENDS)
    772                // Check for thermal runaway
    773                thermal_runaway_protection(&thermal_runaway_state_machine[e], &thermal_runaway_timer[e], current_temperature[e], target_temperature[e], e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
    774              #endif
    775          
    776              soft_pwm_amount[e] = (current_temperature[e] > minttemp[e] || is_preheating(e)) && current_temperature[e] < maxttemp[e] ? (int)get_pid_output(e) >> 1 : 0;
    777          
    778              #if WATCH_HOTENDS
    779                // Make sure temperature is increasing
    780                if (watch_heater_next_ms[e] && ELAPSED(ms, watch_heater_next_ms[e])) { // Time to check this extruder?
    781                  if (degHotend(e) < watch_target_temp[e])                             // Failed to increase enough?
    782                    _temp_error(e, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
    783                  else                                                                 // Start again if the target is still far off
    784                    start_watching_heater(e);
   \                     ??manage_heater_2: (+1)
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x.... 0x....      BL       _ZN11Temperature21start_watching_heaterEh
   \                     ??manage_heater_3: (+1)
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
   \   0000002C   0xB276             SXTB     R6,R6
   \                     ??manage_heater_1: (+1)
   \   0000002E   0x2E01             CMP      R6,#+1
   \   00000030   0xDA52             BGE.N    ??manage_heater_4
   \   00000032   0xEB04 0x0786      ADD      R7,R4,R6, LSL #+2
   \   00000036   0x2004             MOVS     R0,#+4
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x2328             MOVS     R3,#+40
   \   0000003C   0x4632             MOV      R2,R6
   \   0000003E   0xED97 0x0A08      VLDR     S0,[R7, #+32]
   \   00000042   0xEEF8 0x0AC0      VCVT.F32.S32 S1,S0
   \   00000046   0xED97 0x0A06      VLDR     S0,[R7, #+24]
   \   0000004A   0xF107 0x0158      ADD      R1,R7,#+88
   \   0000004E   0x1930             ADDS     R0,R6,R4
   \   00000050   0x3054             ADDS     R0,R0,#+84
   \   00000052   0x.... 0x....      BL       _ZN11Temperature26thermal_runaway_protectionEPNS_7TRStateEPmffatt
   \   00000056   0xED97 0x0A06      VLDR     S0,[R7, #+24]
   \   0000005A   0xEB04 0x0846      ADD      R8,R4,R6, LSL #+1
   \   0000005E   0xF9B8 0x0016      LDRSH    R0,[R8, #+22]
   \   00000062   0xEE00 0x0A90      VMOV     S1,R0
   \   00000066   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000006A   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   0000006E   0xEEF1 0xFA10      FMSTAT   
   \   00000072   0xD513             BPL.N    ??manage_heater_5
   \   00000074   0xF9B8 0x0010      LDRSH    R0,[R8, #+16]
   \   00000078   0xEE00 0x0A90      VMOV     S1,R0
   \   0000007C   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000080   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000084   0xEEF1 0xFA10      FMSTAT   
   \   00000088   0xD508             BPL.N    ??manage_heater_5
   \   0000008A   0x4630             MOV      R0,R6
   \   0000008C   0x.... 0x....      BL       _ZN11Temperature14get_pid_outputEa
   \   00000090   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000094   0xEE10 0x0A10      VMOV     R0,S0
   \   00000098   0x1040             ASRS     R0,R0,#+1
   \   0000009A   0xE000             B.N      ??manage_heater_6
   \                     ??manage_heater_5: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \                     ??manage_heater_6: (+1)
   \   0000009E   0x1931             ADDS     R1,R6,R4
   \   000000A0   0x7088             STRB     R0,[R1, #+2]
   \   000000A2   0x6B78             LDR      R0,[R7, #+52]
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD0C0             BEQ.N    ??manage_heater_3
   \   000000A8   0x1A28             SUBS     R0,R5,R0
   \   000000AA   0xD4BE             BMI.N    ??manage_heater_3
   \   000000AC   0xF8B8 0x000C      LDRH     R0,[R8, #+12]
   \   000000B0   0xEE00 0x0A10      VMOV     S0,R0
   \   000000B4   0xEEB8 0x8A40      VCVT.F32.U32 S16,S0
   \   000000B8   0x4630             MOV      R0,R6
   \   000000BA   0xB2C0             UXTB     R0,R0
   \   000000BC   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   000000C0   0xEEB4 0x0A48      VCMP.F32 S0,S16
   \   000000C4   0xEEF1 0xFA10      FMSTAT   
   \   000000C8   0xD5AB             BPL.N    ??manage_heater_2
   \   000000CA   0x.... 0x....      ADR.W    R1,`?<Constant "Heating failed">`
   \   000000CE   0x460A             MOV      R2,R1
   \   000000D0   0x4630             MOV      R0,R6
   \   000000D2   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \   000000D6   0xE7A8             B.N      ??manage_heater_3
    785                }
    786              #endif
    787          
    788              #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    789                // Make sure measured temperatures are close together
    790                if (FABS(current_temperature[0] - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
    791                  _temp_error(0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
    792              #endif
    793          
    794            } // HOTEND_LOOP
    795          
    796            #if HAS_AUTO_FAN
    797              if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
    798                checkExtruderAutoFans();
    799                next_auto_fan_check_ms = ms + 2500UL;
    800              }
    801            #endif
    802          
    803            #if ENABLED(FILAMENT_WIDTH_SENSOR)
    804              /**
    805               * Filament Width Sensor dynamically sets the volumetric multiplier
    806               * based on a delayed measurement of the filament diameter.
    807               */
    808              if (filament_sensor) {
    809                meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
    810                if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
    811                meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
    812                planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
    813              }
    814            #endif // FILAMENT_WIDTH_SENSOR
    815          
    816            #if WATCH_THE_BED
    817              // Make sure temperature is increasing
    818              if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
    819                if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
    820                  _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
    821                else                                                            // Start again if the target is still far off
    822                  start_watching_bed();
    823              }
    824            #endif // WATCH_THE_BED
    825          
    826            #if DISABLED(PIDTEMPBED)
    827              if (PENDING(ms, next_bed_check_ms)) return;
   \                     ??manage_heater_4: (+1)
   \   000000D8   0x6D20             LDR      R0,[R4, #+80]
   \   000000DA   0x1A28             SUBS     R0,R5,R0
   \   000000DC   0xD403             BMI.N    ??manage_heater_0
    828              next_bed_check_ms = ms + BED_CHECK_INTERVAL;
   \   000000DE   0xF505 0x5098      ADD      R0,R5,#+4864
   \   000000E2   0x3088             ADDS     R0,R0,#+136
   \   000000E4   0x6520             STR      R0,[R4, #+80]
    829            #endif
    830          
    831            #if HAS_TEMP_BED
    832          
    833              #if HEATER_IDLE_HANDLER
    834                if (!bed_idle_timeout_exceeded && bed_idle_timeout_ms && ELAPSED(ms, bed_idle_timeout_ms))
    835                  bed_idle_timeout_exceeded = true;
    836              #endif
    837          
    838              #if HAS_THERMALLY_PROTECTED_BED
    839                thermal_runaway_protection(&thermal_runaway_bed_state_machine, &thermal_runaway_bed_timer, current_temperature_bed, target_temperature_bed, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
    840              #endif
    841          
    842              #if HEATER_IDLE_HANDLER
    843                if (bed_idle_timeout_exceeded)
    844                {
    845                  soft_pwm_amount_bed = 0;
    846          
    847                  #if DISABLED(PIDTEMPBED)
    848                    WRITE_HEATER_BED(LOW);
    849                  #endif
    850                }
    851                else
    852              #endif
    853              {
    854                #if ENABLED(PIDTEMPBED)
    855                  soft_pwm_amount_bed = WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
    856          
    857                #elif ENABLED(BED_LIMIT_SWITCHING)
    858                  // Check if temperature is within the correct band
    859                  if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
    860                    if (current_temperature_bed >= target_temperature_bed + BED_HYSTERESIS)
    861                      soft_pwm_amount_bed = 0;
    862                    else if (current_temperature_bed <= target_temperature_bed - (BED_HYSTERESIS))
    863                      soft_pwm_amount_bed = MAX_BED_POWER >> 1;
    864                  }
    865                  else {
    866                    soft_pwm_amount_bed = 0;
    867                    WRITE_HEATER_BED(LOW);
    868                  }
    869                #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
    870                  // Check if temperature is within the correct range
    871                  if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
    872                    soft_pwm_amount_bed = current_temperature_bed < target_temperature_bed ? MAX_BED_POWER >> 1 : 0;
    873                  }
    874                  else {
    875                    soft_pwm_amount_bed = 0;
    876                    WRITE_HEATER_BED(LOW);
    877                  }
    878                #endif
    879              }
    880            #endif // HAS_TEMP_BED
    881          }
   \                     ??manage_heater_0: (+1)
   \   000000E6   0xB002             ADD      SP,SP,#+8
   \   000000E8   0xECBD 0x8B02      VPOP     {D8}
   \   000000EC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    882          
    883          //#define PGM_RD_W(x)   (short)pgm_read_word(&x)
    884          #define PGM_RD_W(x)   (short)(x)
    885          
    886          // Derived from RepRap FiveD extruder::getTemperature()
    887          // For hot end temperature measurement.

   \                                 In section .text, align 4, keep-with-next
    888          float Temperature::analog2temp(const int raw, const uint8_t e) {
   \                     _ZN11Temperature11analog2tempEih: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x000C             MOVS     R4,R1
    889            #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    890              if (e > HOTENDS)
    891            #else
    892              if (e >= HOTENDS)
   \   00000004   0xD014             BEQ.N    ??analog2temp_0
    893            #endif
    894              {
    895                SERIAL_ERROR_START();
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable42_14
   \   0000000A   0x.... 0x....      BL       _Z14serialprintPGMPKc
    896                SERIAL_ERROR((int)e);
   \   0000000E   0x220A             MOVS     R2,#+10
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable42
   \   00000016   0x.... 0x....      BL       _ZN5Print5printEii
    897                SERIAL_ERRORLNPGM(MSG_INVALID_EXTRUDER_NUM);
   \   0000001A   0x.... 0x....      ADR.W    R0,`?<Constant " - Invalid extruder n...">`
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
    898                kill(PSTR(MSG_KILLED));
   \   00000022   0x.... 0x....      ADR.W    R0,`?<Constant "KILLED. ">`
   \   00000026   0x.... 0x....      BL       _Z4killPKc
    899                return 0.0;
   \   0000002A   0xED9F 0x....      VLDR.W   S0,??DataTable38_2  ;; 0x0
   \   0000002E   0xBDF1             POP      {R0,R4-R7,PC}
    900              }
    901          
    902            #if ENABLED(HEATER_0_USES_MAX6675)
    903              if (e == 0) return 0.25 * raw;
    904            #endif
    905          
    906            if (heater_ttbl_map[e] != NULL) {
   \                     ??analog2temp_0: (+1)
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable42_20
   \   00000034   0x684A             LDR      R2,[R1, #+4]
   \   00000036   0x2A00             CMP      R2,#+0
   \   00000038   0xD03A             BEQ.N    ??analog2temp_1
    907              float celsius = 0;
   \   0000003A   0xED9F 0x....      VLDR.W   S0,??DataTable38_2  ;; 0x0
    908              uint8_t i;
    909              short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
    910          
    911              for (i = 1; i < heater_ttbllen_map[e]; i++) {
   \   0000003E   0x2301             MOVS     R3,#+1
   \   00000040   0x780C             LDRB     R4,[R1, #+0]
   \   00000042   0xE001             B.N      ??analog2temp_2
   \                     ??analog2temp_3: (+1)
   \   00000044   0x1C5B             ADDS     R3,R3,#+1
   \   00000046   0xB2DB             UXTB     R3,R3
   \                     ??analog2temp_2: (+1)
   \   00000048   0x42A3             CMP      R3,R4
   \   0000004A   0xDA25             BGE.N    ??analog2temp_4
   \   0000004C   0xF932 0x5023      LDRSH    R5,[R2, R3, LSL #+2]
   \   00000050   0x42A8             CMP      R0,R5
   \   00000052   0xDAF7             BGE.N    ??analog2temp_3
    912                if (PGM_RD_W((*tt)[i][0]) > raw) {
    913                  celsius = PGM_RD_W((*tt)[i - 1][1]) +
    914                            (raw - PGM_RD_W((*tt)[i - 1][0])) *
    915                            (float)(PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i - 1][1])) /
    916                            (float)(PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i - 1][0]));
   \   00000054   0xEB02 0x0183      ADD      R1,R2,R3, LSL #+2
   \   00000058   0xF931 0x6C04      LDRSH    R6,[R1, #-4]
   \   0000005C   0x1F0F             SUBS     R7,R1,#+4
   \   0000005E   0xF9B7 0x7002      LDRSH    R7,[R7, #+2]
   \   00000062   0xEE00 0x7A10      VMOV     S0,R7
   \   00000066   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000006A   0x1B80             SUBS     R0,R0,R6
   \   0000006C   0xEE00 0x0A90      VMOV     S1,R0
   \   00000070   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000074   0xF9B1 0x0002      LDRSH    R0,[R1, #+2]
   \   00000078   0x1BC0             SUBS     R0,R0,R7
   \   0000007A   0xEE01 0x0A10      VMOV     S2,R0
   \   0000007E   0xEEB8 0x1AC1      VCVT.F32.S32 S2,S2
   \   00000082   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   00000086   0x1BA8             SUBS     R0,R5,R6
   \   00000088   0xEE01 0x0A10      VMOV     S2,R0
   \   0000008C   0xEEB8 0x1AC1      VCVT.F32.S32 S2,S2
   \   00000090   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   00000094   0xEE30 0x0A20      VADD.F32 S0,S0,S1
    917                  break;
    918                }
    919              }
    920          
    921              // Overflow: Set to last value in the table
    922              if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i - 1][1]);
   \                     ??analog2temp_4: (+1)
   \   00000098   0x42A3             CMP      R3,R4
   \   0000009A   0xD113             BNE.N    ??analog2temp_5
   \   0000009C   0xEB02 0x0083      ADD      R0,R2,R3, LSL #+2
   \   000000A0   0x1F00             SUBS     R0,R0,#+4
   \   000000A2   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   000000A6   0xEE00 0x0A10      VMOV     S0,R0
   \   000000AA   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
    923          
    924              return celsius;
   \   000000AE   0xBDF1             POP      {R0,R4-R7,PC}
    925            }
    926            return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
   \                     ??analog2temp_1: (+1)
   \   000000B0   0x.... 0x....      BL       __aeabi_i2d
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0x....             LDR.N    R3,??DataTable42_21  ;; 0x3f9f4000
   \   000000B8   0x.... 0x....      BL       __aeabi_dmul
   \   000000BC   0x.... 0x....      BL       __aeabi_d2f
   \   000000C0   0xEE00 0x0A10      VMOV     S0,R0
   \                     ??analog2temp_5: (+1)
   \   000000C4   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    927          }
    928          
    929          #if HAS_TEMP_BED
    930            // Derived from RepRap FiveD extruder::getTemperature()
    931            // For bed temperature measurement.
    932            float Temperature::analog2tempBed(const int raw) {
    933              #if ENABLED(BED_USES_THERMISTOR)
    934                float celsius = 0;
    935                byte i;
    936          
    937                for (i = 1; i < BEDTEMPTABLE_LEN; i++) {
    938                  if (PGM_RD_W(BEDTEMPTABLE[i][0]) > raw) {
    939                    celsius  = PGM_RD_W(BEDTEMPTABLE[i - 1][1]) +
    940                               (raw - PGM_RD_W(BEDTEMPTABLE[i - 1][0])) *
    941                               (float)(PGM_RD_W(BEDTEMPTABLE[i][1]) - PGM_RD_W(BEDTEMPTABLE[i - 1][1])) /
    942                               (float)(PGM_RD_W(BEDTEMPTABLE[i][0]) - PGM_RD_W(BEDTEMPTABLE[i - 1][0]));
    943                    break;
    944                  }
    945                }
    946          
    947                // Overflow: Set to last value in the table
    948                if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i - 1][1]);
    949          
    950                return celsius;
    951          
    952              #elif defined(BED_USES_AD595)
    953          
    954                return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
    955          
    956              #else
    957          
    958                UNUSED(raw);
    959                return 0;
    960          
    961              #endif
    962            }
    963          #endif // HAS_TEMP_BED
    964          
    965          /**
    966           * Get the raw values into the actual temperatures.
    967           * The raw values are created in interrupt context,
    968           * and this function is called from normal context
    969           * as it would block the stepper routine.
    970           */

   \                                 In section .text, align 4, keep-with-next
    971          void Temperature::updateTemperaturesFromRawValues() {
   \                     _ZN11Temperature31updateTemperaturesFromRawValuesEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    972            #if ENABLED(HEATER_0_USES_MAX6675)
    973              current_temperature_raw[0] = read_max6675();
    974            #endif
    975            HOTEND_LOOP()
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE00A             B.N      ??updateTemperaturesFromRawValues_0
    976              current_temperature[e] = Temperature::analog2temp(current_temperature_raw[e], e);
   \                     ??updateTemperaturesFromRawValues_1: (+1)
   \   00000006   0xEB00 0x0584      ADD      R5,R0,R4, LSL #+2
   \   0000000A   0x4621             MOV      R1,R4
   \   0000000C   0xB2C9             UXTB     R1,R1
   \   0000000E   0x69E8             LDR      R0,[R5, #+28]
   \   00000010   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \   00000014   0xED85 0x0A06      VSTR     S0,[R5, #+24]
   \   00000018   0x1C64             ADDS     R4,R4,#+1
   \   0000001A   0xB264             SXTB     R4,R4
   \                     ??updateTemperaturesFromRawValues_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable42_1
   \   0000001E   0x2C01             CMP      R4,#+1
   \   00000020   0xDBF1             BLT.N    ??updateTemperaturesFromRawValues_1
    977            #if HAS_TEMP_BED
    978              current_temperature_bed = Temperature::analog2tempBed(current_temperature_bed_raw);
    979            #endif
    980            #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    981              redundant_temperature = Temperature::analog2temp(redundant_temperature_raw, 1);
    982            #endif
    983            #if ENABLED(FILAMENT_WIDTH_SENSOR)
    984              filament_width_meas = analog2widthFil();
    985            #endif
    986          
    987            #if ENABLED(USE_WATCHDOG)
    988              // Reset the watchdog after we know we have a temperature measurement.
    989              watchdog_reset();
    990            #endif
    991          
    992            CRITICAL_SECTION_START;
   \   00000022   0xB672             cpsid i
    993            temp_meas_ready = false;
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x7001             STRB     R1,[R0, #+0]
    994            CRITICAL_SECTION_END;
   \   00000028   0xB662             cpsie i
    995          }
   \   0000002A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    996          
    997          
    998          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    999          
   1000            // Convert raw Filament Width to millimeters
   1001            float Temperature::analog2widthFil() {
   1002              return current_raw_filwidth * 5.0 * (1.0 / 16383.0);
   1003            }
   1004          
   1005            /**
   1006             * Convert Filament Width (mm) to a simple ratio
   1007             * and reduce to an 8 bit value.
   1008             *
   1009             * A nominal width of 1.75 and measured width of 1.73
   1010             * gives (100 * 1.75 / 1.73) for a ratio of 101 and
   1011             * a return value of 1.
   1012             */
   1013            int8_t Temperature::widthFil_to_size_ratio() {
   1014              if (FABS(filament_width_nominal - filament_width_meas) <= FILWIDTH_ERROR_MARGIN)
   1015                return int(100.0 * filament_width_nominal / filament_width_meas) - 100;
   1016              return 0;
   1017            }
   1018          
   1019          #endif
   1020          
   1021          #if ENABLED(HEATER_0_USES_MAX6675)
   1022            #ifndef MAX6675_SCK_PIN
   1023              #define MAX6675_SCK_PIN SCK_PIN
   1024            #endif
   1025            #ifndef MAX6675_DO_PIN
   1026              #define MAX6675_DO_PIN MISO_PIN
   1027            #endif
   1028            SPI<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
   1029          #endif
   1030          
   1031          /**
   1032           * Initialize the temperature manager
   1033           * The manager is implemented by periodic calls to manage_heater()
   1034           */

   \                                 In section .text, align 2, keep-with-next
   1035          void Temperature::init() {
   1036          
   1037            #if MB(RUMBA) && (TEMP_SENSOR_0 == -1 || TEMP_SENSOR_1 == -1 || TEMP_SENSOR_2 == -1 || TEMP_SENSOR_BED == -1)
   1038              // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
   1039              MCUCR = _BV(JTD);
   1040              MCUCR = _BV(JTD);
   1041            #endif
   1042          
   1043            // Finish init of mult hotend arrays
   1044            HOTEND_LOOP() maxttemp[e] = maxttemp[0];
   \                     _ZN11Temperature4initEv: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE005             B.N      ??init_0
   \                     ??init_1: (+1)
   \   00000004   0x....             LDR.N    R1,??DataTable42_1
   \   00000006   0x8A0B             LDRH     R3,[R1, #+16]
   \   00000008   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \   0000000C   0x820B             STRH     R3,[R1, #+16]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \                     ??init_0: (+1)
   \   00000010   0xB240             SXTB     R0,R0
   \   00000012   0x4602             MOV      R2,R0
   \   00000014   0x2A01             CMP      R2,#+1
   \   00000016   0xDBF5             BLT.N    ??init_1
   1045          
   1046            #if ENABLED(PIDTEMP) && ENABLED(PID_EXTRUSION_SCALING)
   1047              last_e_position = 0;
   1048            #endif
   1049          
   1050            #if HAS_HEATER_0
   1051              SET_OUTPUT(HEATER_0_PIN);
   1052            #endif
   1053            #if HAS_HEATER_1
   1054              SET_OUTPUT(HEATER_1_PIN);
   1055            #endif
   1056            #if HAS_HEATER_2
   1057              SET_OUTPUT(HEATER_2_PIN);
   1058            #endif
   1059            #if HAS_HEATER_3
   1060              SET_OUTPUT(HEATER_3_PIN);
   1061            #endif
   1062            #if HAS_HEATER_4
   1063              SET_OUTPUT(HEATER_3_PIN);
   1064            #endif
   1065            #if HAS_HEATER_BED
   1066              SET_OUTPUT(HEATER_BED_PIN);
   1067            #endif
   1068          
   1069            #if HAS_FAN0
   1070              SET_OUTPUT(FAN_PIN);
   1071              #if ENABLED(FAST_PWM_FAN)
   1072                setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1073              #endif
   1074            #endif
   1075          
   1076            #if HAS_FAN1
   1077              SET_OUTPUT(FAN1_PIN);
   1078              #if ENABLED(FAST_PWM_FAN)
   1079                setPwmFrequency(FAN1_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1080              #endif
   1081            #endif
   1082          
   1083            #if HAS_FAN2
   1084              SET_OUTPUT(FAN2_PIN);
   1085              #if ENABLED(FAST_PWM_FAN)
   1086                setPwmFrequency(FAN2_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1087              #endif
   1088            #endif
   1089          
   1090            #if ENABLED(HEATER_0_USES_MAX6675)
   1091          
   1092              OUT_WRITE(SCK_PIN, LOW);
   1093              OUT_WRITE(MOSI_PIN, HIGH);
   1094              SET_INPUT_PULLUP(MISO_PIN);
   1095          
   1096              max6675_spi.init();
   1097          
   1098              OUT_WRITE(SS_PIN, HIGH);
   1099              OUT_WRITE(MAX6675_SS, HIGH);
   1100          
   1101            #endif // HEATER_0_USES_MAX6675
   1102          
   1103            #ifdef DIDR2
   1104              #define ANALOG_SELECT(pin) do{ if (pin < 8) SBI(DIDR0, pin); else SBI(DIDR2, pin - 8); }while(0)
   1105            #else
   1106              #define ANALOG_SELECT(pin) do{ SBI(DIDR0, pin); }while(0)
   1107            #endif
   1108          #if 0
   1109            // Set analog inputs
   1110            ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADIF) | 0x07;
   1111            DIDR0 = 0;
   1112            #ifdef DIDR2
   1113              DIDR2 = 0;
   1114            #endif
   1115            #if HAS_TEMP_0
   1116              ANALOG_SELECT(TEMP_0_PIN);
   1117            #endif
   1118            #if HAS_TEMP_1
   1119              ANALOG_SELECT(TEMP_1_PIN);
   1120            #endif
   1121            #if HAS_TEMP_2
   1122              ANALOG_SELECT(TEMP_2_PIN);
   1123            #endif
   1124            #if HAS_TEMP_3
   1125              ANALOG_SELECT(TEMP_3_PIN);
   1126            #endif
   1127            #if HAS_TEMP_4
   1128              ANALOG_SELECT(TEMP_4_PIN);
   1129            #endif
   1130            #if HAS_TEMP_BED
   1131              ANALOG_SELECT(TEMP_BED_PIN);
   1132            #endif
   1133            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1134              ANALOG_SELECT(FILWIDTH_PIN);
   1135            #endif
   1136          
   1137            #if HAS_AUTO_FAN_0
   1138              #if E0_AUTO_FAN_PIN == FAN1_PIN
   1139                SET_OUTPUT(E0_AUTO_FAN_PIN);
   1140                #if ENABLED(FAST_PWM_FAN)
   1141                  setPwmFrequency(E0_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1142                #endif
   1143              #else
   1144                SET_OUTPUT(E0_AUTO_FAN_PIN);
   1145              #endif
   1146            #endif
   1147            #if HAS_AUTO_FAN_1 && !AUTO_1_IS_0
   1148              #if E1_AUTO_FAN_PIN == FAN1_PIN
   1149                SET_OUTPUT(E1_AUTO_FAN_PIN);
   1150                #if ENABLED(FAST_PWM_FAN)
   1151                  setPwmFrequency(E1_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1152                #endif
   1153              #else
   1154                SET_OUTPUT(E1_AUTO_FAN_PIN);
   1155              #endif
   1156            #endif
   1157            #if HAS_AUTO_FAN_2 && !AUTO_2_IS_0 && !AUTO_2_IS_1
   1158              #if E2_AUTO_FAN_PIN == FAN1_PIN
   1159                SET_OUTPUT(E2_AUTO_FAN_PIN);
   1160                #if ENABLED(FAST_PWM_FAN)
   1161                  setPwmFrequency(E2_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1162                #endif
   1163              #else
   1164                SET_OUTPUT(E2_AUTO_FAN_PIN);
   1165              #endif
   1166            #endif
   1167            #if HAS_AUTO_FAN_3 && !AUTO_3_IS_0 && !AUTO_3_IS_1 && !AUTO_3_IS_2
   1168              #if E3_AUTO_FAN_PIN == FAN1_PIN
   1169                SET_OUTPUT(E3_AUTO_FAN_PIN);
   1170                #if ENABLED(FAST_PWM_FAN)
   1171                  setPwmFrequency(E3_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1172                #endif
   1173              #else
   1174                SET_OUTPUT(E3_AUTO_FAN_PIN);
   1175              #endif
   1176            #endif
   1177            #if HAS_AUTO_FAN_4 && !AUTO_4_IS_0 && !AUTO_4_IS_1 && !AUTO_4_IS_2 && !AUTO_4_IS_3
   1178              #if E4_AUTO_FAN_PIN == FAN1_PIN
   1179                SET_OUTPUT(E4_AUTO_FAN_PIN);
   1180                #if ENABLED(FAST_PWM_FAN)
   1181                  setPwmFrequency(E4_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1182                #endif
   1183              #else
   1184                SET_OUTPUT(E4_AUTO_FAN_PIN);
   1185              #endif
   1186            #endif
   1187          
   1188            // Use timer0 for temperature measurement
   1189            // Interleave temperature interrupt with millies interrupt
   1190            OCR0B = 128;
   1191            SBI(TIMSK0, OCIE0B);
   1192          
   1193            // Wait for temperature measurement to settle
   1194            delay(250);
   1195          #endif
   1196            #define TEMP_MIN_ROUTINE(NR) \
   1197              minttemp[NR] = HEATER_ ##NR## _MINTEMP; \
   1198              while (analog2temp(minttemp_raw[NR], NR) < HEATER_ ##NR## _MINTEMP) { \
   1199                if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
   1200                  minttemp_raw[NR] += OVERSAMPLENR; \
   1201                else \
   1202                  minttemp_raw[NR] -= OVERSAMPLENR; \
   1203              }
   1204            #define TEMP_MAX_ROUTINE(NR) \
   1205              maxttemp[NR] = HEATER_ ##NR## _MAXTEMP; \
   1206              while (analog2temp(maxttemp_raw[NR], NR) > HEATER_ ##NR## _MAXTEMP) { \
   1207                if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
   1208                  maxttemp_raw[NR] -= OVERSAMPLENR; \
   1209                else \
   1210                  maxttemp_raw[NR] += OVERSAMPLENR; \
   1211              }
   1212          
   1213            #ifdef HEATER_0_MINTEMP
   1214              TEMP_MIN_ROUTINE(0);
   1215            #endif
   1216            #ifdef HEATER_0_MAXTEMP
   1217              TEMP_MAX_ROUTINE(0);
   1218            #endif
   1219            #if HOTENDS > 1
   1220              #ifdef HEATER_1_MINTEMP
   1221                TEMP_MIN_ROUTINE(1);
   1222              #endif
   1223              #ifdef HEATER_1_MAXTEMP
   1224                TEMP_MAX_ROUTINE(1);
   1225              #endif
   1226              #if HOTENDS > 2
   1227                #ifdef HEATER_2_MINTEMP
   1228                  TEMP_MIN_ROUTINE(2);
   1229                #endif
   1230                #ifdef HEATER_2_MAXTEMP
   1231                  TEMP_MAX_ROUTINE(2);
   1232                #endif
   1233                #if HOTENDS > 3
   1234                  #ifdef HEATER_3_MINTEMP
   1235                    TEMP_MIN_ROUTINE(3);
   1236                  #endif
   1237                  #ifdef HEATER_3_MAXTEMP
   1238                    TEMP_MAX_ROUTINE(3);
   1239                  #endif
   1240                  #if HOTENDS > 4
   1241                    #ifdef HEATER_4_MINTEMP
   1242                      TEMP_MIN_ROUTINE(4);
   1243                    #endif
   1244                    #ifdef HEATER_4_MAXTEMP
   1245                      TEMP_MAX_ROUTINE(4);
   1246                    #endif
   1247                  #endif // HOTENDS > 4
   1248                #endif // HOTENDS > 3
   1249              #endif // HOTENDS > 2
   1250            #endif // HOTENDS > 1
   1251          
   1252            #if HAS_TEMP_BED
   1253              #ifdef BED_MINTEMP
   1254                while (analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
   1255                  #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
   1256                    bed_minttemp_raw += OVERSAMPLENR;
   1257                  #else
   1258                    bed_minttemp_raw -= OVERSAMPLENR;
   1259                  #endif
   1260                }
   1261              #endif // BED_MINTEMP
   1262              #ifdef BED_MAXTEMP
   1263                while (analog2tempBed(bed_maxttemp_raw) > BED_MAXTEMP) {
   1264                  #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
   1265                    bed_maxttemp_raw -= OVERSAMPLENR;
   1266                  #else
   1267                    bed_maxttemp_raw += OVERSAMPLENR;
   1268                  #endif
   1269                }
   1270              #endif // BED_MAXTEMP
   1271            #endif //HAS_TEMP_BED
   1272          
   1273            #if ENABLED(PROBING_HEATERS_OFF)
   1274              paused = false;
   1275            #endif
   1276          }
   \   00000018   0x4770             BX       LR               ;; return
   1277          
   1278          #if WATCH_HOTENDS
   1279            /**
   1280             * Start Heating Sanity Check for hotends that are below
   1281             * their target temperature by a configurable margin.
   1282             * This is called when the temperature is set. (M104, M109)
   1283             */

   \                                 In section .text, align 2, keep-with-next
   1284            void Temperature::start_watching_heater(const uint8_t e) {
   \                     _ZN11Temperature21start_watching_heaterEh: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   1285              #if HOTENDS == 1
   1286                UNUSED(e);
   1287              #endif
   1288              if (degHotend(HOTEND_INDEX) < degTargetHotend(HOTEND_INDEX) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   0000000C   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   00000010   0x....             LDR.N    R4,??DataTable42_1
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \   00000018   0xEEF9 0x0A08      VMOV.F32 S1,#-6.0
   \   0000001C   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000020   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   00000024   0xEEF1 0xFA10      FMSTAT   
   \   00000028   0xD512             BPL.N    ??start_watching_heater_0
   1289                watch_target_temp[HOTEND_INDEX] = degHotend(HOTEND_INDEX) + WATCH_TEMP_INCREASE;
                                                       ^
Warning[Pa093]: implicit conversion from floating point to integer

  static float current_temper_bak;
               ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\temperature.cpp",747  Warning[Pe177]: 
          variable "current_temper_bak" was declared but never referenced
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   00000030   0xEEF0 0x0A00      VMOV.F32 S1,#2.0
   \   00000034   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000038   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000003C   0xEE10 0x0A10      VMOV     R0,S0
   \   00000040   0x81A0             STRH     R0,[R4, #+12]
   1290                watch_heater_next_ms[HOTEND_INDEX] = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
   \   00000042   0x.... 0x....      BL       HAL_GetTick
   \   00000046   0xF500 0x409C      ADD      R0,R0,#+19968
   \   0000004A   0x3020             ADDS     R0,R0,#+32
   \   0000004C   0x6360             STR      R0,[R4, #+52]
   \   0000004E   0xE001             B.N      ??start_watching_heater_1
   1291              }
   1292              else
   1293                watch_heater_next_ms[HOTEND_INDEX] = 0;
   \                     ??start_watching_heater_0: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6360             STR      R0,[R4, #+52]
   1294            }
   \                     ??start_watching_heater_1: (+1)
   \   00000054   0xECBD 0x8B02      VPOP     {D8}
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
   1295          #endif
   1296          
   1297          #if WATCH_THE_BED
   1298            /**
   1299             * Start Heating Sanity Check for hotends that are below
   1300             * their target temperature by a configurable margin.
   1301             * This is called when the temperature is set. (M140, M190)
   1302             */
   1303            void Temperature::start_watching_bed() {
   1304              if (degBed() < degTargetBed() - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
   1305                watch_target_bed_temp = degBed() + WATCH_BED_TEMP_INCREASE;
   1306                watch_bed_next_ms = millis() + (WATCH_BED_TEMP_PERIOD) * 1000UL;
   1307              }
   1308              else
   1309                watch_bed_next_ms = 0;
   1310            }
   1311          #endif
   1312          
   1313          #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
   1314          
   1315            #if ENABLED(THERMAL_PROTECTION_HOTENDS)
   1316              Temperature::TRState Temperature::thermal_runaway_state_machine[HOTENDS] = { TRInactive };
   1317              millis_t Temperature::thermal_runaway_timer[HOTENDS] = { 0 };
   1318            #endif
   1319          
   1320            #if HAS_THERMALLY_PROTECTED_BED
   1321              Temperature::TRState Temperature::thermal_runaway_bed_state_machine = TRInactive;
   1322              millis_t Temperature::thermal_runaway_bed_timer;
   1323            #endif
   1324          

   \                                 In section .text, align 2, keep-with-next
   1325            void Temperature::thermal_runaway_protection(Temperature::TRState * const state, millis_t * const timer, const float current, const float target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
   \                     _ZN11Temperature26thermal_runaway_protectionEPNS_7TRStateEPmffatt: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
   1326          
   1327              static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
   1328          
   1329              /**
   1330                  SERIAL_ECHO_START();
   1331                  SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");
   1332                  if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
   1333                  SERIAL_ECHOPAIR(" ;  State:", *state);
   1334                  SERIAL_ECHOPAIR(" ;  Timer:", *timer);
   1335                  SERIAL_ECHOPAIR(" ;  Temperature:", current);
   1336                  SERIAL_ECHOPAIR(" ;  Target Temp:", target);
   1337                  if (heater_id >= 0)
   1338                    SERIAL_ECHOPAIR(" ;  Idle Timeout:", heater_idle_timeout_exceeded[heater_id]);
   1339                  else
   1340                    SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle_timeout_exceeded);
   1341                  SERIAL_EOL();
   1342              */
   1343          
   1344              const int heater_index = heater_id >= 0 ? heater_id : HOTENDS;
   \   0000000A   0xB276             SXTB     R6,R6
   \   0000000C   0x0031             MOVS     R1,R6
   \   0000000E   0xD500             BPL.N    ??thermal_runaway_protection_0
   \   00000010   0x2101             MOVS     R1,#+1
   1345          
   1346              #if HEATER_IDLE_HANDLER
   1347                // If the heater idle timeout expires, restart
   1348                if (heater_id >= 0 && heater_idle_timeout_exceeded[heater_id]) {
   1349                  *state = TRInactive;
   1350                  tr_target_temperature[heater_index] = 0;
   1351                }
   1352                #if HAS_TEMP_BED
   1353                  else if (heater_id < 0 && bed_idle_timeout_exceeded) {
   1354                    *state = TRInactive;
   1355                    tr_target_temperature[heater_index] = 0;
   1356                  }
   1357                #endif
   1358                else
   1359              #endif
   1360              // If the target temperature changes, restart
   1361              if (tr_target_temperature[heater_index] != target) {
   \                     ??thermal_runaway_protection_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable42_22
   \   00000014   0xEB02 0x0081      ADD      R0,R2,R1, LSL #+2
   \   00000018   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   0000001C   0xEEB4 0x1A60      VCMP.F32 S2,S1
   \   00000020   0xEEF1 0xFA10      FMSTAT   
   \   00000024   0xD00A             BEQ.N    ??thermal_runaway_protection_1
   1362                tr_target_temperature[heater_index] = target;
   \   00000026   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   1363                *state = target > 0 ? TRFirstHeating : TRInactive;
   \   0000002A   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   0000002E   0xEEF1 0xFA10      FMSTAT   
   \   00000032   0xDD01             BLE.N    ??thermal_runaway_protection_2
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE000             B.N      ??thermal_runaway_protection_3
   \                     ??thermal_runaway_protection_2: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??thermal_runaway_protection_3: (+1)
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
   1364              }
   1365          
   1366              switch (*state) {
   \                     ??thermal_runaway_protection_1: (+1)
   \   0000003C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD004             BEQ.N    ??thermal_runaway_protection_4
   \   00000044   0xD336             BCC.N    ??thermal_runaway_protection_5
   \   00000046   0x2803             CMP      R0,#+3
   \   00000048   0xD02C             BEQ.N    ??thermal_runaway_protection_6
   \   0000004A   0xD30B             BCC.N    ??thermal_runaway_protection_7
   \   0000004C   0xBDF1             POP      {R0,R4-R7,PC}
   1367                // Inactive state waits for a target temperature to be set
   1368                case TRInactive: break;
   1369                // When first heating, wait for the temperature to be reached then go to Stable state
   1370                case TRFirstHeating:
   1371                  if (current < tr_target_temperature[heater_index]) break;
   \                     ??thermal_runaway_protection_4: (+1)
   \   0000004E   0xEB02 0x0081      ADD      R0,R2,R1, LSL #+2
   \   00000052   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000056   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000005A   0xEEF1 0xFA10      FMSTAT   
   \   0000005E   0xD429             BMI.N    ??thermal_runaway_protection_5
   1372                  *state = TRStable;
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x7020             STRB     R0,[R4, #+0]
   1373                // While the temperature is stable watch for a bad temperature
   1374                case TRStable:
   1375                  if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
   \                     ??thermal_runaway_protection_7: (+1)
   \   00000064   0x9806             LDR      R0,[SP, #+24]
   \   00000066   0xEE00 0x0A90      VMOV     S1,R0
   \   0000006A   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   0000006E   0xEB02 0x0081      ADD      R0,R2,R1, LSL #+2
   \   00000072   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   00000076   0xEE71 0x0A60      VSUB.F32 S1,S2,S1
   \   0000007A   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000007E   0xEEF1 0xFA10      FMSTAT   
   \   00000082   0xDB08             BLT.N    ??thermal_runaway_protection_8
   1376                    *timer = millis() + period_seconds * 1000UL;
   \   00000084   0x.... 0x....      BL       HAL_GetTick
   \   00000088   0xB2BF             UXTH     R7,R7
   \   0000008A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000008E   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   00000092   0x6028             STR      R0,[R5, #+0]
   1377                    break;
   \   00000094   0xBDF1             POP      {R0,R4-R7,PC}
   1378                  }
   1379                  else if (PENDING(millis(), *timer)) break;
   \                     ??thermal_runaway_protection_8: (+1)
   \   00000096   0x.... 0x....      BL       HAL_GetTick
   \   0000009A   0x6829             LDR      R1,[R5, #+0]
   \   0000009C   0x1A40             SUBS     R0,R0,R1
   \   0000009E   0xD409             BMI.N    ??thermal_runaway_protection_5
   1380                  *state = TRRunaway;
   \   000000A0   0x2003             MOVS     R0,#+3
   \   000000A2   0x7020             STRB     R0,[R4, #+0]
   1381                case TRRunaway:
   1382                  _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
   \                     ??thermal_runaway_protection_6: (+1)
   \   000000A4   0x.... 0x....      ADR.W    R2,`?<Constant "THERMAL RUNAWAY">`
   \   000000A8   0x.... 0x....      ADR.W    R1,`?<Constant "Thermal Runaway">`
   \   000000AC   0x4630             MOV      R0,R6
   \   000000AE   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   000000B2   0x....             B.N      _ZN11Temperature11_temp_errorEaPKcS1_
   1383              }
   1384            }
   \                     ??thermal_runaway_protection_5: (+1)
   \   000000B4   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .bss, align 4
   \                     ??tr_target_temperature:
   \   00000000                      DS8 8
   1385          
   1386          #endif // THERMAL_PROTECTION_HOTENDS || THERMAL_PROTECTION_BED
   1387          

   \                                 In section .text, align 4, keep-with-next
   1388          void Temperature::disable_all_heaters() {
   \                     _ZN11Temperature19disable_all_heatersEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1389          
   1390            #if ENABLED(AUTOTEMP)
   1391              planner.autotemp_enabled = false;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable42_23
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   1392            #endif
   1393          
   1394            HOTEND_LOOP() setTargetHotend(0, e);
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0xE006             B.N      ??disable_all_heaters_0
   \                     ??disable_all_heaters_1: (+1)
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0xED9F 0x....      VLDR.W   S0,??DataTable41  ;; 0x0
   \   00000014   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   \   00000018   0x1C64             ADDS     R4,R4,#+1
   \                     ??disable_all_heaters_0: (+1)
   \   0000001A   0xB264             SXTB     R4,R4
   \   0000001C   0x2C01             CMP      R4,#+1
   \   0000001E   0xDBF5             BLT.N    ??disable_all_heaters_1
   1395            setTargetBed(0);
   \   00000020   0xED9F 0x....      VLDR.W   S0,??DataTable41  ;; 0x0
   \   00000024   0x.... 0x....      BL       _ZN11Temperature12setTargetBedEf
   1396          
   1397            // Unpause and reset everything
   1398            #if ENABLED(PROBING_HEATERS_OFF)
   1399              pause(false);
   1400            #endif
   1401          
   1402            // If all heaters go down then for sure our print job has stopped
   1403            print_job_timer.stop();
   \   00000028   0x....             LDR.N    R0,??DataTable42_24
   \   0000002A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002E   0x.... 0x....      B.W      _ZN9Stopwatch4stopEv
   1404          
   1405            #define DISABLE_HEATER(NR) { \
   1406              setTargetHotend(0, NR); \
   1407              soft_pwm_amount[NR] = 0; \
   1408              WRITE_HEATER_ ##NR (LOW); \
   1409            }
   1410          
   1411            #if HAS_TEMP_HOTEND
   1412              DISABLE_HEATER(0);
   1413              #if HOTENDS > 1
   1414                DISABLE_HEATER(1);
   1415                #if HOTENDS > 2
   1416                  DISABLE_HEATER(2);
   1417                  #if HOTENDS > 3
   1418                    DISABLE_HEATER(3);
   1419                    #if HOTENDS > 4
   1420                      DISABLE_HEATER(4);
   1421                    #endif // HOTENDS > 4
   1422                  #endif // HOTENDS > 3
   1423                #endif // HOTENDS > 2
   1424              #endif // HOTENDS > 1
   1425            #endif
   1426          
   1427            #if HAS_TEMP_BED
   1428              target_temperature_bed = 0;
   1429              soft_pwm_amount_bed = 0;
   1430              #if HAS_HEATER_BED
   1431                WRITE_HEATER_BED(LOW);
   1432              #endif
   1433            #endif
   1434          }
   1435          
   1436          #if ENABLED(PROBING_HEATERS_OFF)
   1437          
   1438            void Temperature::pause(const bool p) {
   1439              if (p != paused) {
   1440                paused = p;
   1441                if (p) {
   1442                  HOTEND_LOOP() start_heater_idle_timer(e, 0); // timeout immediately
   1443                  #if HAS_TEMP_BED
   1444                    start_bed_idle_timer(0); // timeout immediately
   1445                  #endif
   1446                }
   1447                else {
   1448                  HOTEND_LOOP() reset_heater_idle_timer(e);
   1449                  #if HAS_TEMP_BED
   1450                    reset_bed_idle_timer();
   1451                  #endif
   1452                }
   1453              }
   1454            }
   1455          
   1456          #endif // PROBING_HEATERS_OFF
   1457          
   1458          #if ENABLED(HEATER_0_USES_MAX6675)
   1459          
   1460            #define MAX6675_HEAT_INTERVAL 250u
   1461          
   1462            #if ENABLED(MAX6675_IS_MAX31855)
   1463              uint32_t max6675_temp = 2000;
   1464              #define MAX6675_ERROR_MASK 7
   1465              #define MAX6675_DISCARD_BITS 18
   1466              #define MAX6675_SPEED_BITS (_BV(SPR1)) // clock ÷ 64
   1467            #else
   1468              uint16_t max6675_temp = 2000;
   1469              #define MAX6675_ERROR_MASK 4
   1470              #define MAX6675_DISCARD_BITS 3
   1471              #define MAX6675_SPEED_BITS (_BV(SPR0)) // clock ÷ 16
   1472            #endif
   1473          
   1474            int Temperature::read_max6675() {
   1475          
   1476              static millis_t next_max6675_ms = 0;
   1477          
   1478              millis_t ms = millis();
   1479          
   1480              if (PENDING(ms, next_max6675_ms)) return (int)max6675_temp;
   1481          
   1482              next_max6675_ms = ms + MAX6675_HEAT_INTERVAL;
   1483          
   1484              CBI(
   1485                #ifdef PRR
   1486                  PRR
   1487                #elif defined(PRR0)
   1488                  PRR0
   1489                #endif
   1490                  , PRSPI);
   1491              SPCR = _BV(MSTR) | _BV(SPE) | MAX6675_SPEED_BITS;
   1492          
   1493              WRITE(MAX6675_SS, 0); // enable TT_MAX6675
   1494          
   1495              // ensure 100ns delay - a bit extra is fine
   1496              asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
   1497              asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
   1498          
   1499              // Read a big-endian temperature value
   1500              max6675_temp = 0;
   1501              for (uint8_t i = sizeof(max6675_temp); i--;) {
   1502                max6675_temp |= max6675_spi.receive();
   1503                if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
   1504              }
   1505          
   1506              WRITE(MAX6675_SS, 1); // disable TT_MAX6675
   1507          
   1508              if (max6675_temp & MAX6675_ERROR_MASK) {
   1509                SERIAL_ERROR_START();
   1510                SERIAL_ERRORPGM("Temp measurement error! ");
   1511                #if MAX6675_ERROR_MASK == 7
   1512                  SERIAL_ERRORPGM("MAX31855 ");
   1513                  if (max6675_temp & 1)
   1514                    SERIAL_ERRORLNPGM("Open Circuit");
   1515                  else if (max6675_temp & 2)
   1516                    SERIAL_ERRORLNPGM("Short to GND");
   1517                  else if (max6675_temp & 4)
   1518                    SERIAL_ERRORLNPGM("Short to VCC");
   1519                #else
   1520                  SERIAL_ERRORLNPGM("MAX6675");
   1521                #endif
   1522                max6675_temp = MAX6675_TMAX * 4; // thermocouple open
   1523              }
   1524              else
   1525                max6675_temp >>= MAX6675_DISCARD_BITS;
   1526                #if ENABLED(MAX6675_IS_MAX31855)
   1527                  // Support negative temperature
   1528                  if (max6675_temp & 0x00002000) max6675_temp |= 0xFFFFC000;
   1529                #endif
   1530          
   1531              return (int)max6675_temp;
   1532            }
   1533          
   1534          #endif // HEATER_0_USES_MAX6675
   1535          
   1536          /**
   1537           * Get raw temperatures
   1538           */

   \                                 In section .text, align 2, keep-with-next
   1539          void Temperature::set_current_temp_raw() {
   1540            #if HAS_TEMP_0 && DISABLED(HEATER_0_USES_MAX6675)
   1541              current_temperature_raw[0] = raw_temp_value[0];	//mks 2018-08
   1542            #endif
   1543            #if HAS_TEMP_1
   1544              #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   1545                redundant_temperature_raw = raw_temp_value[1];
   1546              #else
   1547                current_temperature_raw[1] = raw_temp_value[1];
   1548              #endif
   1549              #if HAS_TEMP_2
   1550                current_temperature_raw[2] = raw_temp_value[2];
   1551                #if HAS_TEMP_3
   1552                  current_temperature_raw[3] = raw_temp_value[3];
   1553                  #if HAS_TEMP_4
   1554                    current_temperature_raw[4] = raw_temp_value[4];
   1555                  #endif
   1556                #endif
   1557              #endif
   1558            #endif
   1559            current_temperature_bed_raw = raw_temp_bed_value;
   \                     _ZN11Temperature20set_current_temp_rawEv: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable42_1
   \   00000002   0x89C1             LDRH     R1,[R0, #+14]
   \   00000004   0x6241             STR      R1,[R0, #+36]
   1560            temp_meas_ready = true;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x7001             STRB     R1,[R0, #+0]
   1561          }
   \   0000000A   0x4770             BX       LR               ;; return
   1562          
   1563          #if ENABLED(PINS_DEBUGGING)
   1564            /**
   1565             * monitors endstops & Z probe for changes
   1566             *
   1567             * If a change is detected then the LED is toggled and
   1568             * a message is sent out the serial port
   1569             *
   1570             * Yes, we could miss a rapid back & forth change but
   1571             * that won't matter because this is all manual.
   1572             *
   1573             */
   1574            void endstop_monitor() {
   1575              static uint16_t old_endstop_bits_local = 0;
   1576              static uint8_t local_LED_status = 0;
   1577              uint16_t current_endstop_bits_local = 0;
   1578              #if HAS_X_MIN
   1579                if (READ(X_MIN_PIN)) SBI(current_endstop_bits_local, X_MIN);
   1580              #endif
   1581              #if HAS_X_MAX
   1582                if (READ(X_MAX_PIN)) SBI(current_endstop_bits_local, X_MAX);
   1583              #endif
   1584              #if HAS_Y_MIN
   1585                if (READ(Y_MIN_PIN)) SBI(current_endstop_bits_local, Y_MIN);
   1586              #endif
   1587              #if HAS_Y_MAX
   1588                if (READ(Y_MAX_PIN)) SBI(current_endstop_bits_local, Y_MAX);
   1589              #endif
   1590              #if HAS_Z_MIN
   1591                if (READ(Z_MIN_PIN)) SBI(current_endstop_bits_local, Z_MIN);
   1592              #endif
   1593              #if HAS_Z_MAX
   1594                if (READ(Z_MAX_PIN)) SBI(current_endstop_bits_local, Z_MAX);
   1595              #endif
   1596              #if HAS_Z_MIN_PROBE_PIN
   1597                if (READ(Z_MIN_PROBE_PIN)) SBI(current_endstop_bits_local, Z_MIN_PROBE);
   1598              #endif
   1599              #if HAS_Z2_MIN
   1600                if (READ(Z2_MIN_PIN)) SBI(current_endstop_bits_local, Z2_MIN);
   1601              #endif
   1602              #if HAS_Z2_MAX
   1603                if (READ(Z2_MAX_PIN)) SBI(current_endstop_bits_local, Z2_MAX);
   1604              #endif
   1605          
   1606              uint16_t endstop_change = current_endstop_bits_local ^ old_endstop_bits_local;
   1607          
   1608              if (endstop_change) {
   1609                #if HAS_X_MIN
   1610                  if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", !!TEST(current_endstop_bits_local, X_MIN));
   1611                #endif
   1612                #if HAS_X_MAX
   1613                  if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", !!TEST(current_endstop_bits_local, X_MAX));
   1614                #endif
   1615                #if HAS_Y_MIN
   1616                  if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", !!TEST(current_endstop_bits_local, Y_MIN));
   1617                #endif
   1618                #if HAS_Y_MAX
   1619                  if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", !!TEST(current_endstop_bits_local, Y_MAX));
   1620                #endif
   1621                #if HAS_Z_MIN
   1622                  if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", !!TEST(current_endstop_bits_local, Z_MIN));
   1623                #endif
   1624                #if HAS_Z_MAX
   1625                  if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", !!TEST(current_endstop_bits_local, Z_MAX));
   1626                #endif
   1627                #if HAS_Z_MIN_PROBE_PIN
   1628                  if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", !!TEST(current_endstop_bits_local, Z_MIN_PROBE));
   1629                #endif
   1630                #if HAS_Z2_MIN
   1631                  if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", !!TEST(current_endstop_bits_local, Z2_MIN));
   1632                #endif
   1633                #if HAS_Z2_MAX
   1634                  if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", !!TEST(current_endstop_bits_local, Z2_MAX));
   1635                #endif
   1636                SERIAL_PROTOCOLPGM("\n\n");
   1637                analogWrite(LED_PIN, local_LED_status);
   1638                local_LED_status ^= 255;
   1639                old_endstop_bits_local = current_endstop_bits_local;
   1640              }
   1641            }
   1642          #endif // PINS_DEBUGGING
   1643          
   1644          /**
   1645           * Timer 0 is shared with millies so don't change the prescaler.
   1646           *
   1647           * This ISR uses the compare method so it runs at the base
   1648           * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
   1649           * in OCR0B above (128 or halfway between OVFs).
   1650           *
   1651           *  - Manage PWM to all the heaters and fan
   1652           *  - Prepare or Measure one of the raw ADC sensor values
   1653           *  - Check new temperature values for MIN/MAX errors (kill on error)
   1654           *  - Step the babysteps value for each axis towards 0
   1655           *  - For PINS_DEBUGGING, monitor and report endstop pins
   1656           *  - For ENDSTOP_INTERRUPTS_FEATURE check endstops if flagged
   1657           */
   1658          //ISR(TIMER0_COMPB_vect) { Temperature::isr(); }
   1659          
   1660          volatile bool Temperature::in_temp_isr = false;
   1661          
   1662          //void Temperature::isr() {

   \                                 In section .text, align 2, keep-with-next
   1663            void IsrTemperatureHandler() { Temperature::TemperatureHandler(); }
   \                     IsrTemperatureHandler: (+1)
   \   00000000   0xBF00             Nop      
   \   00000002                      REQUIRE _ZN11Temperature18TemperatureHandlerEv
   \   00000002                      ;; // Fall through to label Temperature::TemperatureHandler()

   \                                 In section .text, align 2, keep-with-next
   1664            void Temperature::TemperatureHandler(void)  {
   \                     _ZN11Temperature18TemperatureHandlerEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   1665          
   1666            // The stepper ISR can interrupt this ISR. When it does it re-enables this ISR
   1667            // at the end of its run, potentially causing re-entry. This flag prevents it.
   1668            if (in_temp_isr) return;
   \   00000006   0x....             LDR.N    R4,??DataTable42_1
   \   00000008   0x7920             LDRB     R0,[R4, #+4]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xF040 0x8099      BNE.W    ??TemperatureHandler_0
   1669            in_temp_isr = true;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x7120             STRB     R0,[R4, #+4]
   1670          
   1671            // Allow UART and stepper ISRs
   1672            //CBI(TIMSK0, OCIE0B); //Disable Temperature ISR
   1673            //sei();
   1674            HAL_TIM_Base_Stop_IT(&htim4);
   \   00000014   0x....             LDR.N    R5,??DataTable42_25
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   1675          
   1676            static int8_t temp_count = -1;
   1677            static ADCSensorState adc_sensor_state = StartupDelay;
   1678            static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
   1679            // avoid multiple loads of pwm_count
   1680            uint8_t pwm_count_tmp = pwm_count;
   \   0000001C   0x79E6             LDRB     R6,[R4, #+7]
   1681            #if ENABLED(ADC_KEYPAD)
   1682              static unsigned int raw_ADCKey_value = 0;
   1683            #endif
   1684          
   1685            // Static members for each heater
   1686            #if ENABLED(SLOW_PWM_HEATERS)
   1687              static uint8_t slow_pwm_count = 0;
   1688              #define ISR_STATICS(n) \
   1689                static uint8_t soft_pwm_count_ ## n, \
   1690                               state_heater_ ## n = 0, \
   1691                               state_timer_heater_ ## n = 0
   1692            #else
   1693              #define ISR_STATICS(n) static uint8_t soft_pwm_count_ ## n = 0
   1694            #endif
   1695          
   1696            // Statics per heater
   1697            ISR_STATICS(0);
   1698            #if HOTENDS > 1
   1699              ISR_STATICS(1);
   1700              #if HOTENDS > 2
   1701                ISR_STATICS(2);
   1702                #if HOTENDS > 3
   1703                  ISR_STATICS(3);
   1704                  #if HOTENDS > 4
   1705                    ISR_STATICS(4);
   1706                  #endif // HOTENDS > 4
   1707                #endif // HOTENDS > 3
   1708              #endif // HOTENDS > 2
   1709            #endif // HOTENDS > 1
   1710            #if HAS_HEATER_BED
   1711              ISR_STATICS(BED);
   1712            #endif
   1713          
   1714            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1715              static unsigned long raw_filwidth_value = 0;
   1716            #endif
   1717          
   1718            #if DISABLED(SLOW_PWM_HEATERS)
   1719              constexpr uint8_t pwm_mask =
   1720                #if ENABLED(SOFT_PWM_DITHER)
   1721                  _BV(SOFT_PWM_SCALE) - 1
   1722                #else
   1723                  0
   1724                #endif
   1725              ;
   1726          
   1727              /**
   1728               * Standard PWM modulation
   1729               */
   1730              if (pwm_count_tmp >= 127) {
   \   0000001E   0x2E7F             CMP      R6,#+127
   \   00000020   0xDB0F             BLT.N    ??TemperatureHandler_1
   1731                pwm_count_tmp -= 127;
   \   00000022   0x3E7F             SUBS     R6,R6,#+127
   \   00000024   0xB2F6             UXTB     R6,R6
   1732                soft_pwm_count_0 = (soft_pwm_count_0 & pwm_mask) + soft_pwm_amount[0];
   \   00000026   0x78A0             LDRB     R0,[R4, #+2]
   \   00000028   0x7220             STRB     R0,[R4, #+8]
   1733                //WRITE_HEATER_0(soft_pwm_count_0 > pwm_mask ? HIGH : LOW);
   1734          	  if(soft_pwm_count_0 > pwm_mask) WRITE_HEATER_0(HIGH);
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD00C             BEQ.N    ??TemperatureHandler_2
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0x....             LDR.N    R0,??DataTable42_26
   \   00000032   0xF830 0x1C02      LDRH     R1,[R0, #-2]
   \   00000036   0x....             LDR.N    R0,??DataTable42_27
   \   00000038   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \   0000003C   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000040   0xE00B             B.N      ??TemperatureHandler_3
   1735          	  else WRITE_HEATER_0(LOW);      
   1736                #if HOTENDS > 1
   1737                  soft_pwm_count_1 = (soft_pwm_count_1 & pwm_mask) + soft_pwm_amount[1];
   1738                  WRITE_HEATER_1(soft_pwm_count_1 > pwm_mask ? HIGH : LOW);
   1739                  #if HOTENDS > 2
   1740                    soft_pwm_count_2 = (soft_pwm_count_2 & pwm_mask) + soft_pwm_amount[2];
   1741                    WRITE_HEATER_2(soft_pwm_count_2 > pwm_mask ? HIGH : LOW);
   1742                    #if HOTENDS > 3
   1743                      soft_pwm_count_3 = (soft_pwm_count_3 & pwm_mask) + soft_pwm_amount[3];
   1744                      WRITE_HEATER_3(soft_pwm_count_3 > pwm_mask ? HIGH : LOW);
   1745                      #if HOTENDS > 4
   1746                        soft_pwm_count_4 = (soft_pwm_count_4 & pwm_mask) + soft_pwm_amount[4];
   1747                        WRITE_HEATER_4(soft_pwm_count_4 > pwm_mask ? HIGH : LOW);
   1748                      #endif // HOTENDS > 4
   1749                    #endif // HOTENDS > 3
   1750                  #endif // HOTENDS > 2
   1751                #endif // HOTENDS > 1
   1752          
   1753                #if HAS_HEATER_BED
   1754                  soft_pwm_count_BED = (soft_pwm_count_BED & pwm_mask) + soft_pwm_amount_bed;
   1755                  //WRITE_HEATER_BED(soft_pwm_count_BED > pwm_mask ? HIGH : LOW);
   1756          		if(soft_pwm_count_BED > pwm_mask) WRITE_HEATER_BED(HIGH);
   1757          		else WRITE_HEATER_BED(LOW);        
   1758                #endif
   1759          
   1760                #if ENABLED(FAN_SOFT_PWM)
   1761                  #if HAS_FAN0
   1762                    soft_pwm_count_fan[0] = (soft_pwm_count_fan[0] & pwm_mask) + (soft_pwm_amount_fan[0] >> 1);
   1763                    WRITE_FAN(soft_pwm_count_fan[0] > pwm_mask ? HIGH : LOW);
   1764                  #endif
   1765                  #if HAS_FAN1
   1766                    soft_pwm_count_fan[1] = (soft_pwm_count_fan[1] & pwm_mask) + (soft_pwm_amount_fan[1] >> 1);
   1767                    WRITE_FAN1(soft_pwm_count_fan[1] > pwm_mask ? HIGH : LOW);
   1768                  #endif
   1769                  #if HAS_FAN2
   1770                    soft_pwm_count_fan[2] = (soft_pwm_count_fan[2] & pwm_mask) + (soft_pwm_amount_fan[2] >> 1);
   1771                    WRITE_FAN2(soft_pwm_count_fan[2] > pwm_mask ? HIGH : LOW);
   1772                  #endif
   1773                #endif
   1774              }
   1775              else {
   1776                if (soft_pwm_count_0 <= pwm_count_tmp) WRITE_HEATER_0(LOW);
   \                     ??TemperatureHandler_1: (+1)
   \   00000042   0x7A20             LDRB     R0,[R4, #+8]
   \   00000044   0x4286             CMP      R6,R0
   \   00000046   0xDB08             BLT.N    ??TemperatureHandler_3
   \                     ??TemperatureHandler_2: (+1)
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x....             LDR.N    R0,??DataTable42_26
   \   0000004C   0xF830 0x1C02      LDRH     R1,[R0, #-2]
   \   00000050   0x....             LDR.N    R0,??DataTable42_27
   \   00000052   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \   00000056   0x.... 0x....      BL       HAL_GPIO_WritePin
   1777                #if HOTENDS > 1
   1778                  if (soft_pwm_count_1 <= pwm_count_tmp) WRITE_HEATER_1(LOW);
   1779                  #if HOTENDS > 2
   1780                    if (soft_pwm_count_2 <= pwm_count_tmp) WRITE_HEATER_2(LOW);
   1781                    #if HOTENDS > 3
   1782                      if (soft_pwm_count_3 <= pwm_count_tmp) WRITE_HEATER_3(LOW);
   1783                      #if HOTENDS > 4
   1784                        if (soft_pwm_count_4 <= pwm_count_tmp) WRITE_HEATER_4(LOW);
   1785                      #endif // HOTENDS > 4
   1786                    #endif // HOTENDS > 3
   1787                  #endif // HOTENDS > 2
   1788                #endif // HOTENDS > 1
   1789          
   1790                #if HAS_HEATER_BED
   1791                  if (soft_pwm_count_BED <= pwm_count_tmp) WRITE_HEATER_BED(LOW);
   1792                #endif
   1793          
   1794                #if ENABLED(FAN_SOFT_PWM)
   1795                  #if HAS_FAN0
   1796                    if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
   1797                  #endif
   1798                  #if HAS_FAN1
   1799                    if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
   1800                  #endif
   1801                  #if HAS_FAN2
   1802                    if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN2(LOW);
   1803                  #endif
   1804                #endif
   1805              }
   1806          
   1807              // SOFT_PWM_SCALE to frequency:
   1808              //
   1809              // 0: 16000000/64/256/128 =   7.6294 Hz
   1810              // 1:                / 64 =  15.2588 Hz
   1811              // 2:                / 32 =  30.5176 Hz
   1812              // 3:                / 16 =  61.0352 Hz
   1813              // 4:                /  8 = 122.0703 Hz
   1814              // 5:                /  4 = 244.1406 Hz
   1815              pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
   \                     ??TemperatureHandler_3: (+1)
   \   0000005A   0x1C70             ADDS     R0,R6,#+1
   \   0000005C   0x71E0             STRB     R0,[R4, #+7]
   1816          
   1817            #else // SLOW_PWM_HEATERS
   1818          
   1819              /**
   1820               * SLOW PWM HEATERS
   1821               *
   1822               * For relay-driven heaters
   1823               */
   1824              #ifndef MIN_STATE_TIME
   1825                #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
   1826              #endif
   1827          
   1828              // Macros for Slow PWM timer logic
   1829              #define _SLOW_PWM_ROUTINE(NR, src) \
   1830                soft_pwm_count_ ##NR = src; \
   1831                if (soft_pwm_count_ ##NR > 0) { \
   1832                  if (state_timer_heater_ ##NR == 0) { \
   1833                    if (state_heater_ ##NR == 0) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   1834                    state_heater_ ##NR = 1; \
   1835                    WRITE_HEATER_ ##NR(1); \
   1836                  } \
   1837                } \
   1838                else { \
   1839                  if (state_timer_heater_ ##NR == 0) { \
   1840                    if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   1841                    state_heater_ ##NR = 0; \
   1842                    WRITE_HEATER_ ##NR(0); \
   1843                  } \
   1844                }
   1845              #define SLOW_PWM_ROUTINE(n) _SLOW_PWM_ROUTINE(n, soft_pwm_amount[n])
   1846          
   1847              #define PWM_OFF_ROUTINE(NR) \
   1848                if (soft_pwm_count_ ##NR < slow_pwm_count) { \
   1849                  if (state_timer_heater_ ##NR == 0) { \
   1850                    if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   1851                    state_heater_ ##NR = 0; \
   1852                    WRITE_HEATER_ ##NR (0); \
   1853                  } \
   1854                }
   1855          
   1856              if (slow_pwm_count == 0) {
   1857          
   1858                SLOW_PWM_ROUTINE(0);
   1859                #if HOTENDS > 1
   1860                  SLOW_PWM_ROUTINE(1);
   1861                  #if HOTENDS > 2
   1862                    SLOW_PWM_ROUTINE(2);
   1863                    #if HOTENDS > 3
   1864                      SLOW_PWM_ROUTINE(3);
   1865                      #if HOTENDS > 4
   1866                        SLOW_PWM_ROUTINE(4);
   1867                      #endif // HOTENDS > 4
   1868                    #endif // HOTENDS > 3
   1869                  #endif // HOTENDS > 2
   1870                #endif // HOTENDS > 1
   1871                #if HAS_HEATER_BED
   1872                  _SLOW_PWM_ROUTINE(BED, soft_pwm_amount_bed); // BED
   1873                #endif
   1874          
   1875              } // slow_pwm_count == 0
   1876          
   1877              PWM_OFF_ROUTINE(0);
   1878              #if HOTENDS > 1
   1879                PWM_OFF_ROUTINE(1);
   1880                #if HOTENDS > 2
   1881                  PWM_OFF_ROUTINE(2);
   1882                  #if HOTENDS > 3
   1883                    PWM_OFF_ROUTINE(3);
   1884                    #if HOTENDS > 4
   1885                      PWM_OFF_ROUTINE(4);
   1886                    #endif // HOTENDS > 4
   1887                  #endif // HOTENDS > 3
   1888                #endif // HOTENDS > 2
   1889              #endif // HOTENDS > 1
   1890              #if HAS_HEATER_BED
   1891                PWM_OFF_ROUTINE(BED); // BED
   1892              #endif
   1893          
   1894              #if ENABLED(FAN_SOFT_PWM)
   1895                if (pwm_count_tmp >= 127) {
   1896                  pwm_count_tmp = 0;
   1897                  #if HAS_FAN0
   1898                    soft_pwm_count_fan[0] = soft_pwm_amount_fan[0] >> 1;
   1899                    WRITE_FAN(soft_pwm_count_fan[0] > 0 ? HIGH : LOW);
   1900                  #endif
   1901                  #if HAS_FAN1
   1902                    soft_pwm_count_fan[1] = soft_pwm_amount_fan[1] >> 1;
   1903                    WRITE_FAN1(soft_pwm_count_fan[1] > 0 ? HIGH : LOW);
   1904                  #endif
   1905                  #if HAS_FAN2
   1906                    soft_pwm_count_fan[2] = soft_pwm_amount_fan[2] >> 1;
   1907                    WRITE_FAN2(soft_pwm_count_fan[2] > 0 ? HIGH : LOW);
   1908                  #endif
   1909                }
   1910                #if HAS_FAN0
   1911                  if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
   1912                #endif
   1913                #if HAS_FAN1
   1914                  if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
   1915                #endif
   1916                #if HAS_FAN2
   1917                  if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN2(LOW);
   1918                #endif
   1919              #endif // FAN_SOFT_PWM
   1920          
   1921              // SOFT_PWM_SCALE to frequency:
   1922              //
   1923              // 0: 16000000/64/256/128 =   7.6294 Hz
   1924              // 1:                / 64 =  15.2588 Hz
   1925              // 2:                / 32 =  30.5176 Hz
   1926              // 3:                / 16 =  61.0352 Hz
   1927              // 4:                /  8 = 122.0703 Hz
   1928              // 5:                /  4 = 244.1406 Hz
   1929              pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
   1930          
   1931              // increment slow_pwm_count only every 64th pwm_count,
   1932              // i.e. yielding a PWM frequency of 16/128 Hz (8s).
   1933              if (((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0) {
   1934                slow_pwm_count++;
   1935                slow_pwm_count &= 0x7F;
   1936          
   1937                if (state_timer_heater_0 > 0) state_timer_heater_0--;
   1938                #if HOTENDS > 1
   1939                  if (state_timer_heater_1 > 0) state_timer_heater_1--;
   1940                  #if HOTENDS > 2
   1941                    if (state_timer_heater_2 > 0) state_timer_heater_2--;
   1942                    #if HOTENDS > 3
   1943                      if (state_timer_heater_3 > 0) state_timer_heater_3--;
   1944                      #if HOTENDS > 4
   1945                        if (state_timer_heater_4 > 0) state_timer_heater_4--;
   1946                      #endif // HOTENDS > 4
   1947                    #endif // HOTENDS > 3
   1948                  #endif // HOTENDS > 2
   1949                #endif // HOTENDS > 1
   1950                #if HAS_HEATER_BED
   1951                  if (state_timer_heater_BED > 0) state_timer_heater_BED--;
   1952                #endif
   1953              } // ((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0
   1954          
   1955            #endif // SLOW_PWM_HEATERS
   1956          
   1957            //
   1958            // Update lcd buttons 488 times per second
   1959            //
   1960            static bool do_buttons;
   1961            if ((do_buttons ^= true)) lcd_buttons_update();
   \   0000005E   0x7A60             LDRB     R0,[R4, #+9]
   \   00000060   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000064   0x1E40             SUBS     R0,R0,#+1
   \   00000066   0x4180             SBCS     R0,R0,R0
   \   00000068   0x43C0             MVNS     R0,R0
   \   0000006A   0x0FC0             LSRS     R0,R0,#+31
   \   0000006C   0x7260             STRB     R0,[R4, #+9]
   \   0000006E   0x7A60             LDRB     R0,[R4, #+9]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD001             BEQ.N    ??TemperatureHandler_4
   \   00000074   0x.... 0x....      BL       _Z18lcd_buttons_updatev
   1962          
   1963            /**
   1964             * One sensor is sampled on every other call of the ISR.
   1965             * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
   1966             *
   1967             * On each Prepare pass, ADC is started for a sensor pin.
   1968             * On the next pass, the ADC value is read and accumulated.
   1969             *
   1970             * This gives each ADC 0.9765ms to charge up.
   1971             */
   1972          #if 0
   1973            #define SET_ADMUX_ADCSRA(pin) ADMUX = _BV(REFS0) | (pin & 0x07); SBI(ADCSRA, ADSC)
   1974            #ifdef MUX5
   1975              #define START_ADC(pin) if (pin > 7) ADCSRB = _BV(MUX5); else ADCSRB = 0; SET_ADMUX_ADCSRA(pin)
   1976            #else
   1977              #define START_ADC(pin) ADCSRB = 0; SET_ADMUX_ADCSRA(pin)
   1978            #endif
   1979          #endif
   1980            switch (adc_sensor_state) {
   \                     ??TemperatureHandler_4: (+1)
   \   00000078   0xF994 0x0006      LDRSB    R0,[R4, #+6]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD10D             BNE.N    ??TemperatureHandler_5
   1981          
   1982              case SensorsReady: {
   1983                // All sensors have been read. Stay in this state for a few
   1984                // ISRs to save on calls to temp update/checking code below.
   1985                constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;
   1986                static uint8_t delay_count = 0;
   1987                if (extra_loops > 0) {
   1988                  if (delay_count == 0) delay_count = extra_loops;   // Init this delay
   \   00000080   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD101             BNE.N    ??TemperatureHandler_6
   \   00000086   0x200A             MOVS     R0,#+10
   \   00000088   0x72A0             STRB     R0,[R4, #+10]
   1989                  if (--delay_count)                                 // While delaying...
   \                     ??TemperatureHandler_6: (+1)
   \   0000008A   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000008C   0x1E40             SUBS     R0,R0,#+1
   \   0000008E   0x72A0             STRB     R0,[R4, #+10]
   \   00000090   0xB2C0             UXTB     R0,R0
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD002             BEQ.N    ??TemperatureHandler_5
   1990                    adc_sensor_state = (ADCSensorState)(int(SensorsReady) - 1); // retain this state (else, next state will be 0)
   \   00000096   0xF04F 0x30FF      MOV      R0,#-1
   \   0000009A   0x71A0             STRB     R0,[R4, #+6]
   1991                  break;
   1992                }
   1993                else
   1994                  adc_sensor_state = (ADCSensorState)0; // Fall-through to start first sensor now
   1995              }
   1996          
   1997              #if HAS_TEMP_0
   1998                case PrepareTemp_0:
   1999                  //START_ADC(TEMP_0_PIN);
   2000                  break;
   2001                case MeasureTemp_0:
   2002          		#if defined(MKS_ROBIN_LITE) || defined(MKS_ROBIN) || defined(MKS_ROBINMINI)
   2003          			raw_temp_value[0] += uhADCxConvertedValue[1]>>2;	//TH1
   2004          		#elif defined(MKS_ROBINPRO) || defined(MKS_ROBIN2) || defined(MKS_ROBIN2MINI)
   2005          			raw_temp_value[0] += uhADCxConvertedValue[1];   	//TH1
   2006          		#endif 
   2007          
   2008                  break;
   2009              #endif
   2010          
   2011              #if HAS_TEMP_BED
   2012                case PrepareTemp_BED:
   2013                  //START_ADC(TEMP_BED_PIN);
   2014                  break;
   2015                case MeasureTemp_BED:
   2016          			#if defined(MKS_ROBIN_LITE) || defined(MKS_ROBIN) || defined(MKS_ROBINMINI)
   2017          				raw_temp_bed_value += uhADCxConvertedValue[0]>>2;	//TB
   2018          			#elif defined(MKS_ROBINPRO) || defined(MKS_ROBIN2) || defined(MKS_ROBIN2MINI)
   2019          				raw_temp_bed_value += uhADCxConvertedValue[0];	//TB
   2020          			#endif 		
   2021                  break;
   2022              #endif
   2023          
   2024              #if HAS_TEMP_1
   2025                case PrepareTemp_1:
   2026                  //START_ADC(TEMP_1_PIN);
   2027                  break;
   2028                case MeasureTemp_1:
   2029          		#if defined(MKS_ROBIN_LITE) || defined(MKS_ROBIN) || defined(MKS_ROBINMINI)
   2030          			raw_temp_value[1] += uhADCxConvertedValue[2]>>2;		//TH2
   2031          		#elif defined(MKS_ROBINPRO) || defined(MKS_ROBIN2) || defined(MKS_ROBIN2MINI)
   2032          			raw_temp_value[1] += uhADCxConvertedValue[2];   //TH2
   2033          		#endif 
   2034          
   2035                  break;
   2036              #endif
   2037          
   2038              #if HAS_TEMP_2
   2039                case PrepareTemp_2:
   2040                  START_ADC(TEMP_2_PIN);
   2041                  break;
   2042                case MeasureTemp_2:
   2043                  raw_temp_value[2] += ADC;
   2044                  break;
   2045              #endif
   2046          
   2047              #if HAS_TEMP_3
   2048                case PrepareTemp_3:
   2049                  START_ADC(TEMP_3_PIN);
   2050                  break;
   2051                case MeasureTemp_3:
   2052                  raw_temp_value[3] += ADC;
   2053                  break;
   2054              #endif
   2055          
   2056              #if HAS_TEMP_4
   2057                case PrepareTemp_4:
   2058                  START_ADC(TEMP_4_PIN);
   2059                  break;
   2060                case MeasureTemp_4:
   2061                  raw_temp_value[4] += ADC;
   2062                  break;
   2063              #endif
   2064          
   2065              #if ENABLED(FILAMENT_WIDTH_SENSOR)
   2066                case Prepare_FILWIDTH:
   2067                  START_ADC(FILWIDTH_PIN);
   2068                break;
   2069                case Measure_FILWIDTH:
   2070                  if (ADC > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
   2071                    raw_filwidth_value -= (raw_filwidth_value >> 7); // Subtract 1/128th of the raw_filwidth_value
   2072                    raw_filwidth_value += ((unsigned long)ADC << 7); // Add new ADC reading, scaled by 128
   2073                  }
   2074                break;
   2075              #endif
   2076          
   2077              #if ENABLED(ADC_KEYPAD)
   2078                case Prepare_ADC_KEY:
   2079                  START_ADC(ADC_KEYPAD_PIN);
   2080                  break;
   2081                case Measure_ADC_KEY:
   2082                  if (ADCKey_count < 16) {
   2083                    raw_ADCKey_value = ADC;
   2084                    if (raw_ADCKey_value > 900) {
   2085                      //ADC Key release
   2086                      ADCKey_count = 0;
   2087                      current_ADCKey_raw = 0;
   2088                    }
   2089                    else {
   2090                      current_ADCKey_raw += raw_ADCKey_value;
   2091                      ADCKey_count++;
   2092                    }
   2093                  }
   2094                  break;
   2095              #endif // ADC_KEYPAD
   2096          
   2097              case StartupDelay: break;
   2098          
   2099            } // switch(adc_sensor_state)
   2100          
   2101            if (!adc_sensor_state && ++temp_count >= OVERSAMPLENR) { // 10 * 16 * 1/(16000000/64/256)  = 164ms.
   \                     ??TemperatureHandler_5: (+1)
   \   0000009C   0xF994 0x0006      LDRSB    R0,[R4, #+6]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD141             BNE.N    ??TemperatureHandler_7
   \   000000A4   0x7960             LDRB     R0,[R4, #+5]
   \   000000A6   0x1C40             ADDS     R0,R0,#+1
   \   000000A8   0x7160             STRB     R0,[R4, #+5]
   \   000000AA   0xB240             SXTB     R0,R0
   \   000000AC   0x2810             CMP      R0,#+16
   \   000000AE   0xDB3B             BLT.N    ??TemperatureHandler_7
   2102          
   2103              temp_count = 0;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x7160             STRB     R0,[R4, #+5]
   2104          
   2105              // Update the raw values if they've been read. Else we could be updating them during reading.
   2106              if (!temp_meas_ready) set_current_temp_raw();
   \   000000B4   0x7820             LDRB     R0,[R4, #+0]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD101             BNE.N    ??TemperatureHandler_8
   \   000000BA   0x.... 0x....      BL       _ZN11Temperature20set_current_temp_rawEv
   2107          
   2108              // Filament Sensor - can be read any time since IIR filtering is used
   2109              #if ENABLED(FILAMENT_WIDTH_SENSOR)
   2110                current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
   2111              #endif
   2112          
   2113              ZERO(raw_temp_value);
   \                     ??TemperatureHandler_8: (+1)
   \   000000BE   0x2202             MOVS     R2,#+2
   \   000000C0   0x2100             MOVS     R1,#+0
   \   000000C2   0xF104 0x0056      ADD      R0,R4,#+86
   \   000000C6   0x.... 0x....      BL       memset
   2114              raw_temp_bed_value = 0;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x81E0             STRH     R0,[R4, #+14]
   2115          
   2116              #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) > (HEATER_##N##_RAW_HI_TEMP) ? -1 : 1)
   2117          
   2118              int constexpr temp_dir[] = {
   2119                #if ENABLED(HEATER_0_USES_MAX6675)
   2120                   0
   2121                #else
   2122                  TEMPDIR(0)
   2123                #endif
   2124                #if HOTENDS > 1
   2125                  , TEMPDIR(1)
   2126                  #if HOTENDS > 2
   2127                    , TEMPDIR(2)
   2128                    #if HOTENDS > 3
   2129                      , TEMPDIR(3)
   2130                      #if HOTENDS > 4
   2131                        , TEMPDIR(4)
   2132                      #endif // HOTENDS > 4
   2133                    #endif // HOTENDS > 3
   2134                  #endif // HOTENDS > 2
   2135                #endif // HOTENDS > 1
   2136              };
   \   000000CE   0xA800             ADD      R0,SP,#+0
   \   000000D0   0x.... 0x....      ADR.W    R1,`?<Constant {1}>`
   \   000000D4   0x680A             LDR      R2,[R1, #0]
   \   000000D6   0x6002             STR      R2,[R0, #+0]
   2137          
   2138              for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xE023             B.N      ??TemperatureHandler_9
   2139                const int16_t tdir = temp_dir[e], rawtemp = current_temperature_raw[e] * tdir;
   \                     ??TemperatureHandler_10: (+1)
   \   000000DC   0xA800             ADD      R0,SP,#+0
   \   000000DE   0xF9B0 0x6000      LDRSH    R6,[R0, #+0]
   \   000000E2   0x69E0             LDR      R0,[R4, #+28]
   \   000000E4   0xFB06 0xF800      MUL      R8,R6,R0
   \   000000E8   0xFA0F 0xF888      SXTH     R8,R8
   2140                const bool heater_on = 0 <
   2141                  #if ENABLED(PIDTEMP)
   2142                    soft_pwm_amount[e]
   2143                  #else
   2144                    target_temperature[e]
   2145                  #endif
   2146                ;
   \   000000EC   0x78A0             LDRB     R0,[R4, #+2]
   \   000000EE   0x1E47             SUBS     R7,R0,#+1
   \   000000F0   0x41BF             SBCS     R7,R7,R7
   \   000000F2   0x43FF             MVNS     R7,R7
   \   000000F4   0x0FFF             LSRS     R7,R7,#+31
   2147                if (rawtemp > maxttemp_raw[e] * tdir && heater_on) max_temp_error(e);
   \   000000F6   0xF9B4 0x0014      LDRSH    R0,[R4, #+20]
   \   000000FA   0xFB16 0xF000      SMULBB   R0,R6,R0
   \   000000FE   0x4540             CMP      R0,R8
   \   00000100   0xDA04             BGE.N    ??TemperatureHandler_11
   \   00000102   0x2F00             CMP      R7,#+0
   \   00000104   0xD002             BEQ.N    ??TemperatureHandler_11
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x.... 0x....      BL       _ZN11Temperature14max_temp_errorEa
   2148                if (rawtemp < minttemp_raw[e] * tdir && !is_preheating(e) && heater_on) {
   \                     ??TemperatureHandler_11: (+1)
   \   0000010C   0xF9B4 0x0012      LDRSH    R0,[R4, #+18]
   \   00000110   0xFB16 0xF000      SMULBB   R0,R6,R0
   \   00000114   0x4580             CMP      R8,R0
   \   00000116   0xDA04             BGE.N    ??TemperatureHandler_12
   \   00000118   0x2F00             CMP      R7,#+0
   \   0000011A   0xD002             BEQ.N    ??TemperatureHandler_12
   2149                  #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   2150                    if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
   2151                  #endif
   2152                      min_temp_error(e);
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0x.... 0x....      BL       _ZN11Temperature14min_temp_errorEa
   2153                }
   2154                #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   2155                  else
   2156                    consecutive_low_temperature_error[e] = 0;
   2157                #endif
   2158              }
   \                     ??TemperatureHandler_12: (+1)
   \   00000122   0x2001             MOVS     R0,#+1
   \                     ??TemperatureHandler_9: (+1)
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD0D9             BEQ.N    ??TemperatureHandler_10
   2159          
   2160              #if HAS_TEMP_BED
   2161                #if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
   2162                  #define GEBED <=
   2163                #else
   2164                  #define GEBED >=
   2165                #endif
   2166                const bool bed_on = 0 <
   2167                  #if ENABLED(PIDTEMPBED)
   2168                    soft_pwm_amount_bed
   2169                  #else
   2170                    target_temperature_bed
   2171                  #endif
   2172                ;
   2173                if (current_temperature_bed_raw GEBED bed_maxttemp_raw && bed_on) max_temp_error(-1);
   2174                if (bed_minttemp_raw GEBED current_temperature_bed_raw && bed_on) min_temp_error(-1);
   2175              #endif
   2176          
   2177            } // temp_count >= OVERSAMPLENR
   2178          
   2179            // Go to the next state, up to SensorsReady
   2180            adc_sensor_state = (ADCSensorState)(int(adc_sensor_state) + 1);
   \                     ??TemperatureHandler_7: (+1)
   \   00000128   0x79A0             LDRB     R0,[R4, #+6]
   \   0000012A   0x1C40             ADDS     R0,R0,#+1
   \   0000012C   0x71A0             STRB     R0,[R4, #+6]
   2181            if (adc_sensor_state > SensorsReady) adc_sensor_state = (ADCSensorState)0;
   \   0000012E   0xB240             SXTB     R0,R0
   \   00000130   0x2801             CMP      R0,#+1
   \   00000132   0xDB01             BLT.N    ??TemperatureHandler_13
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0x71A0             STRB     R0,[R4, #+6]
   2182          
   2183            #if ENABLED(BABYSTEPPING)
   2184              LOOP_XYZ(axis) {
   2185                const int curTodo = babystepsTodo[axis]; // get rid of volatile for performance
   2186                if (curTodo) {
   2187                  stepper.babystep((AxisEnum)axis, curTodo > 0);
   2188                  if (curTodo > 0) babystepsTodo[axis]--;
   2189                              else babystepsTodo[axis]++;
   2190                }
   2191              }
   2192            #endif // BABYSTEPPING
   2193          
   2194            #if ENABLED(PINS_DEBUGGING)
   2195              extern bool endstop_monitor_flag;
   2196              // run the endstop monitor at 15Hz
   2197              static uint8_t endstop_monitor_count = 16;  // offset this check from the others
   2198              if (endstop_monitor_flag) {
   2199                endstop_monitor_count += _BV(1);  //  15 Hz
   2200                endstop_monitor_count &= 0x7F;
   2201                if (!endstop_monitor_count) endstop_monitor();  // report changes in endstop status
   2202              }
   2203            #endif
   2204          
   2205            #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   2206          
   2207              extern volatile uint8_t e_hit;
   2208          
   2209              if (e_hit && ENDSTOPS_ENABLED) {
   2210                endstops.update();  // call endstop update routine
   2211                e_hit--;
   2212              }
   2213            #endif
   2214          
   2215            //cli();
   2216            in_temp_isr = false;
   \                     ??TemperatureHandler_13: (+1)
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x7120             STRB     R0,[R4, #+4]
   2217            //SBI(TIMSK0, OCIE0B); //re-enable Temperature ISR
   2218            HAL_TIM_Base_Start_IT(&htim4);
   \   0000013C   0x4628             MOV      R0,R5
   \   0000013E   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   2219          }
   \                     ??TemperatureHandler_0: (+1)
   \   00000142   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return

   \                                 In section .data, align 4
   \                     _ZN11Temperature15temp_meas_readyE:
   \   00000000   0x00               DC8 0
   \                     _ZN11Temperature9pid_resetE:
   \   00000001   0x00               DC8 0
   \                     _ZN11Temperature15soft_pwm_amountE:
   \   00000002   0x00               DC8 0
   \                     _ZN11Temperature19soft_pwm_amount_bedE:
   \   00000003   0x00               DC8 0
   \                     _ZN11Temperature11in_temp_isrE:
   \   00000004   0x00               DC8 0
   \   00000005   0xFF               DC8 -1
   \   00000006   0x01               DC8 1
   \   00000007   0x01               DC8 1
   \   00000008   0x00               DC8 0
   \   00000009   0x00               DC8 0
   \   0000000A   0x00               DC8 0
   \   0000000B   0x00               DC8 0
   \                     _ZN11Temperature17watch_target_tempE:
   \   0000000C   0x0000             DC16 0
   \                     _ZN11Temperature18raw_temp_bed_valueE:
   \   0000000E   0x0000             DC16 0
   \                     _ZN11Temperature8maxttempE:
   \   00000010   0x3FFF             DC16 16383
   \                     _ZN11Temperature12minttemp_rawE:
   \   00000012   0x0000             DC16 0
   \                     _ZN11Temperature12maxttemp_rawE:
   \   00000014   0x3FFF             DC16 16383
   \                     _ZN11Temperature8minttempE:
   \   00000016   0x0000             DC16 0
   \                     _ZN11Temperature19current_temperatureE:
   \   00000018   0x00000000         DC32 0H
   \                     _ZN11Temperature23current_temperature_rawE:
   \   0000001C   0x00000000         DC32 0
   \                     _ZN11Temperature18target_temperatureE:
   \   00000020   0x00000000         DC32 0
   \                     _ZN11Temperature27current_temperature_bed_rawE:
   \   00000024   0x00000000         DC32 0
   \                     _ZN11Temperature2KpE:
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature2KiE:
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature2KdE:
   \   00000030   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature20watch_heater_next_msE:
   \   00000034   0x00000000         DC32 0
   \                     _ZN11Temperature11temp_iStateE:
   \   00000038   0x00000000         DC32 0H
   \                     _ZN11Temperature11temp_dStateE:
   \   0000003C   0x00000000         DC32 0H
   \                     _ZN11Temperature5pTermE:
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature5iTermE:
   \   00000044   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature5dTermE:
   \   00000048   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature9pid_errorE:
   \   0000004C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature17next_bed_check_msE:
   \   00000050   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature29thermal_runaway_state_machineE:
   \   00000054   0x00               DC8 0
   \   00000055   0x00               DC8 0
   \                     _ZN11Temperature14raw_temp_valueE:
   \   00000056   0x0000             DC16 0
   \                     _ZN11Temperature21thermal_runaway_timerE:
   \   00000058   0x00000000         DC32 0

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp Temperature::subobject Temperature()
   \                     _ZN11TemperatureC2Ev: (+1)
   \   00000000   0x....             B.N      _ZN11TemperatureC1Ev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   0x41200001         DC32     0x41200001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \   00000000   0x437F0000         DC32     0x437f0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_2:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_3:
   \   00000000   0x437F0001         DC32     0x437f0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \   00000000   0x........         DC32     Serial6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_1:
   \   00000000   0x........         DC32     _ZN11Temperature15temp_meas_readyE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_2:
   \   00000000   0x........         DC32     wait_for_heatup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_3:
   \   00000000   0xFFFFEC78         DC32     0xffffec78

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_4:
   \   00000000   0x40100000         DC32     0x40100000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_5:
   \   00000000   0x54442D18         DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_6:
   \   00000000   0x400921FB         DC32     0x400921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_7:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_8:
   \   00000000   0xD2F1A9FC         DC32     0xd2f1a9fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_9:
   \   00000000   0x3F50624D         DC32     0x3f50624d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_10:
   \   00000000   0x3FE33333         DC32     0x3fe33333

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_11:
   \   00000000   0x00124F81         DC32     0x124f81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_12:
   \   00000000   0x88E368F1         DC32     0x88e368f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_13:
   \   00000000   0x3FC4F8B5         DC32     0x3fc4f8b5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_14:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_15:
   \   00000000   0x........         DC32     ??killed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_16:
   \   00000000   0x........         DC32     Running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_17:
   \   00000000   0x999999A0         DC32     0x999999a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_18:
   \   00000000   0x3FA99999         DC32     0x3fa99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_19:
   \   00000000   0x3FEE6666         DC32     0x3fee6666

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_20:
   \   00000000   0x........         DC32     heater_ttbllen_map

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_21:
   \   00000000   0x3F9F4000         DC32     0x3f9f4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_22:
   \   00000000   0x........         DC32     ??tr_target_temperature

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_23:
   \   00000000   0x........         DC32     _ZN7Planner16autotemp_enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_24:
   \   00000000   0x........         DC32     print_job_timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_25:
   \   00000000   0x........         DC32     htim4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_26:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_27:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " - Invalid extruder n...">`:
   \   00000000   0x20 0x2D          DC8 " - Invalid extruder number !\012"
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x65    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x20 0x21    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "KILLED. ">`:
   \   00000000   0x4B 0x49          DC8 "KILLED. "
   \              0x4C 0x4C    
   \              0x45 0x44    
   \              0x2E 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {1}>`:
   \   00000000   0x00000001         DC32 1

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Heating failed">`:
   \   00000000   0x48 0x65          DC8 "Heating failed"
   \              0x61 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune failed! ...">`:
   \   00000000   0x50 0x49          DC8 "PID Autotune failed! Bad extruder number"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x42    
   \              0x61 0x64    
   \              0x20 0x65    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune start">`:
   \   00000000   0x50 0x49          DC8 "PID Autotune start"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " bias: ">`:
   \   00000000   0x20 0x62          DC8 " bias: "
   \              0x69 0x61    
   \              0x73 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " d: ">`:
   \   00000000   0x20 0x64          DC8 " d: "
   \              0x3A 0x20    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " min: ">`:
   \   00000000   0x20 0x6D          DC8 " min: "
   \              0x69 0x6E    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " max: ">`:
   \   00000000   0x20 0x6D          DC8 " max: "
   \              0x61 0x78    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Ku: ">`:
   \   00000000   0x20 0x4B          DC8 " Ku: "
   \              0x75 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Tu: ">`:
   \   00000000   0x20 0x54          DC8 " Tu: "
   \              0x75 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\n Classic PID \\n">`:
   \   00000000   0x0A 0x20          DC8 "\012 Classic PID \012"
   \              0x43 0x6C    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x63 0x20    
   \              0x50 0x49    
   \              0x44 0x20    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Kp: ">`:
   \   00000000   0x20 0x4B          DC8 " Kp: "
   \              0x70 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Ki: ">`:
   \   00000000   0x20 0x4B          DC8 " Ki: "
   \              0x69 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Kd: ">`:
   \   00000000   0x20 0x4B          DC8 " Kd: "
   \              0x64 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune failed! ...">_1`:
   \   00000000   0x50 0x49          DC8 "PID Autotune failed! Temperature too high\012"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x54    
   \              0x65 0x6D    
   \              0x70 0x65    
   \              0x72 0x61    
   \              0x74 0x75    
   \              0x72 0x65    
   \              0x20 0x74    
   \              0x6F 0x6F    
   \              0x20 0x68    
   \              0x69 0x67    
   \              0x68 0x0A    
   \              0x00         
   \   0000002B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Thermal Runaway">`:
   \   00000000   0x54 0x68          DC8 "Thermal Runaway"
   \              0x65 0x72    
   \              0x6D 0x61    
   \              0x6C 0x20    
   \              0x52 0x75    
   \              0x6E 0x61    
   \              0x77 0x61    
   \              0x79 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "THERMAL RUNAWAY">`:
   \   00000000   0x54 0x48          DC8 "THERMAL RUNAWAY"
   \              0x45 0x52    
   \              0x4D 0x41    
   \              0x4C 0x20    
   \              0x52 0x55    
   \              0x4E 0x41    
   \              0x57 0x41    
   \              0x59 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune failed! ...">_2`:
   \   00000000   0x50 0x49          DC8 "PID Autotune failed! timeout\012"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune finished...">`:
   \   00000000   0x50 0x49          DC8 50H, 49H, 44H, 20H, 41H, 75H, 74H, 6FH
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \   00000008   0x74 0x75          DC8 74H, 75H, 6EH, 65H, 20H, 66H, 69H, 6EH
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x69 0x6E    
   \   00000010   0x69 0x73          DC8 69H, 73H, 68H, 65H, 64H, 21H, 20H, 50H
   \              0x68 0x65    
   \              0x64 0x21    
   \              0x20 0x50    
   \   00000018   0x75 0x74          DC8 75H, 74H, 20H, 74H, 68H, 65H, 20H, 6CH
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x6C    
   \   00000020   0x61 0x73          DC8 61H, 73H, 74H, 20H, 4BH, 70H, 2CH, 20H
   \              0x74 0x20    
   \              0x4B 0x70    
   \              0x2C 0x20    
   \   00000028   0x4B 0x69          DC8 4BH, 69H, 20H, 61H, 6EH, 64H, 20H, 4BH
   \              0x20 0x61    
   \              0x6E 0x64    
   \              0x20 0x4B    
   \   00000030   0x64 0x20          DC8 64H, 20H, 63H, 6FH, 6EH, 73H, 74H, 61H
   \              0x63 0x6F    
   \              0x6E 0x73    
   \              0x74 0x61    
   \   00000038   0x6E 0x74          DC8 6EH, 74H, 73H, 20H, 66H, 72H, 6FH, 6DH
   \              0x73 0x20    
   \              0x66 0x72    
   \              0x6F 0x6D    
   \   00000040   0x20 0x62          DC8 20H, 62H, 65H, 6CH, 6FH, 77H, 20H, 69H
   \              0x65 0x6C    
   \              0x6F 0x77    
   \              0x20 0x69    
   \   00000048   0x6E 0x74          DC8 6EH, 74H, 6FH, 20H, 43H, 6FH, 6EH, 66H
   \              0x6F 0x20    
   \              0x43 0x6F    
   \              0x6E 0x66    
   \   00000050   0x69 0x67          DC8 69H, 67H, 75H, 72H, 61H, 74H, 69H, 6FH
   \              0x75 0x72    
   \              0x61 0x74    
   \              0x69 0x6F    
   \   00000058   0x6E 0x2E          DC8 6EH, 2EH, 68H, 0AH, 0
   \              0x68 0x0A    
   \              0x00         
   \   0000005D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_Kp ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_Kp "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x70 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_Ki ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_Ki "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x69 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_Kd ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_Kd "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x64 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ", system stopped! Hea...">`:
   \   00000000   0x2C 0x20          DC8 ", system stopped! Heater_ID: "
   \              0x73 0x79    
   \              0x73 0x74    
   \              0x65 0x6D    
   \              0x20 0x73    
   \              0x74 0x6F    
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x21 0x20    
   \              0x48 0x65    
   \              0x61 0x74    
   \              0x65 0x72    
   \              0x5F 0x49    
   \              0x44 0x3A    
   \              0x20 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "bed\\n">`:
   \   00000000   0x62 0x65          DC8 "bed\012"
   \              0x64 0x0A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MINTEMP triggered">`:
   \   00000000   0x4D 0x49          DC8 "MINTEMP triggered"
   \              0x4E 0x54    
   \              0x45 0x4D    
   \              0x50 0x20    
   \              0x74 0x72    
   \              0x69 0x67    
   \              0x67 0x65    
   \              0x72 0x65    
   \              0x64 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Err: MINTEMP">`:
   \   00000000   0x45 0x72          DC8 "Err: MINTEMP"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x49 0x4E    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MAXTEMP triggered">`:
   \   00000000   0x4D 0x41          DC8 "MAXTEMP triggered"
   \              0x58 0x54    
   \              0x45 0x4D    
   \              0x50 0x20    
   \              0x74 0x72    
   \              0x69 0x67    
   \              0x67 0x65    
   \              0x72 0x65    
   \              0x64 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Err: MAXTEMP">`:
   \   00000000   0x45 0x72          DC8 "Err: MAXTEMP"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x41 0x58    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   2220          
   2221          #if HAS_TEMP_HOTEND || HAS_TEMP_BED
   2222          
   2223            void print_heater_state(const float &c, const float &t,
   2224              #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2225                const float r,
   2226              #endif
   2227              const int8_t e=-2
   2228            ) {
   2229              #if !(HAS_TEMP_BED && HAS_TEMP_HOTEND) && HOTENDS <= 1
   2230                UNUSED(e);
   2231              #endif
   2232          
   2233              SERIAL_PROTOCOLCHAR(' ');
   2234              SERIAL_PROTOCOLCHAR(
   2235                #if HAS_TEMP_BED && HAS_TEMP_HOTEND
   2236                  e == -1 ? 'B' : 'T'
   2237                #elif HAS_TEMP_HOTEND
   2238                  'T'
   2239                #else
   2240                  'B'
   2241                #endif
   2242              );
   2243              #if HOTENDS > 1
   2244                if (e >= 0) SERIAL_PROTOCOLCHAR('0' + e);
   2245              #endif
   2246              SERIAL_PROTOCOLCHAR(':');
   2247              SERIAL_PROTOCOL(c);
   2248              SERIAL_PROTOCOLPAIR(" /" , t);
   2249              #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2250                SERIAL_PROTOCOLPAIR(" (", r / OVERSAMPLENR);
   2251                SERIAL_PROTOCOLCHAR(')');
   2252              #endif
   2253            }
   2254          
   2255            extern uint8_t target_extruder;
   2256          
   2257            void Temperature::print_heaterstates() {
   2258              #if HAS_TEMP_HOTEND
   2259                print_heater_state(degHotend(target_extruder), degTargetHotend(target_extruder)
   2260                  #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2261                    , rawHotendTemp(target_extruder)
   2262                  #endif
   2263                );
   2264              #endif
   2265              #if HAS_TEMP_BED
   2266                print_heater_state(degBed(), degTargetBed()
   2267                  #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2268                    , rawBedTemp()
   2269                  #endif
   2270                  , -1 // BED
   2271                );
   2272              #endif
   2273              #if HOTENDS > 1
   2274                HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
   2275                  #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2276                    , rawHotendTemp(e)
   2277                  #endif
   2278                  , e
   2279                );
   2280              #endif
   2281              SERIAL_PROTOCOLPGM(" @:");
   2282              SERIAL_PROTOCOL(getHeaterPower(target_extruder));
   2283              #if HAS_TEMP_BED
   2284                SERIAL_PROTOCOLPGM(" B@:");
   2285                SERIAL_PROTOCOL(getHeaterPower(-1));
   2286              #endif
   2287              #if HOTENDS > 1
   2288                HOTEND_LOOP() {
   2289                  SERIAL_PROTOCOLPAIR(" @", e);
   2290                  SERIAL_PROTOCOLCHAR(':');
   2291                  SERIAL_PROTOCOL(getHeaterPower(e));
   2292                }
   2293              #endif
   2294            }
   2295          
   2296            #if ENABLED(AUTO_REPORT_TEMPERATURES)
   2297          
   2298              uint8_t Temperature::auto_report_temp_interval;
   2299              millis_t Temperature::next_temp_report_ms;
   2300          
   2301              void Temperature::auto_report_temperatures() {
   2302                if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
   2303                  next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
   2304                  print_heaterstates();
   2305                  SERIAL_EOL();
   2306                }
   2307              }
   2308          
   2309            #endif // AUTO_REPORT_TEMPERATURES
   2310          
   2311          #endif // HAS_TEMP_HOTEND || HAS_TEMP_BED

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   IsRunning()
       0   IsrTemperatureHandler
         0   -> Temperature::TemperatureHandler()
     112   Temperature::PID_autotune(float, int8_t, int8_t, bool)
       112   -> HAL_GetTick
       112   -> Print::print(char const *)
       112   -> Temperature::_temp_error(int8_t, char const *, char const *)
         0   -> Temperature::disable_all_heaters()
       112   -> Temperature::disable_all_heaters()
         0   -> Temperature::updatePID()
       112   -> Temperature::updateTemperaturesFromRawValues()
         0   -> USARTClass::write(uint8_t)
       112   -> USARTClass::write(uint8_t)
       112   -> __aeabi_d2f
       112   -> __aeabi_ddiv
       112   -> __aeabi_dmul
       112   -> __aeabi_f2d
       112   -> __aeabi_i2d
       112   -> lcd_update()
       112   -> serial_echopair_P(char const *, float)
       112   -> serial_echopair_P(char const *, long)
       112   -> serialprintPGM(char const *)
       0   Temperature::Temperature()
      32   Temperature::TemperatureHandler()
        32   -> HAL_GPIO_WritePin
        32   -> HAL_TIM_Base_Start_IT
        32   -> HAL_TIM_Base_Stop_IT
        32   -> Temperature::max_temp_error(int8_t)
        32   -> Temperature::min_temp_error(int8_t)
        32   -> Temperature::set_current_temp_raw()
        32   -> lcd_buttons_update()
        32   -> memset
      16   Temperature::_temp_error(int8_t, char const *, char const *)
        16   -> IsRunning()
        16   -> Print::print(int, int)
         0   -> Temperature::disable_all_heaters()
        16   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
         0   -> temper_error_kill()
      24   Temperature::analog2temp(int, uint8_t)
        24   -> Print::print(int, int)
        24   -> __aeabi_d2f
        24   -> __aeabi_dmul
        24   -> __aeabi_i2d
        24   -> kill(char const *)
        24   -> serialprintPGM(char const *)
       0   Temperature::degHotend(uint8_t)
       0   Temperature::degTargetHotend(uint8_t)
       8   Temperature::disable_all_heaters()
         0   -> Stopwatch::stop()
         8   -> Temperature::setTargetBed(float)
         8   -> Temperature::setTargetHotend(float, uint8_t)
       0   Temperature::getHeaterPower(int)
      32   Temperature::get_pid_output(int8_t)
        32   -> __aeabi_d2f
        32   -> __aeabi_dadd
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
       0   Temperature::init()
      40   Temperature::manage_heater()
        40   -> HAL_GetTick
        40   -> Temperature::_temp_error(int8_t, char const *, char const *)
        40   -> Temperature::degHotend(uint8_t)
        40   -> Temperature::get_pid_output(int8_t)
        40   -> Temperature::start_watching_heater(uint8_t)
        40   -> Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int8_t, uint16_t, uint16_t)
        40   -> Temperature::updateTemperaturesFromRawValues()
       0   Temperature::max_temp_error(int8_t)
         0   -> Temperature::_temp_error(int8_t, char const *, char const *)
       0   Temperature::min_temp_error(int8_t)
         0   -> Temperature::_temp_error(int8_t, char const *, char const *)
       0   Temperature::setTargetBed(float)
       0   Temperature::setTargetHotend(float, uint8_t)
         0   -> Temperature::start_watching_heater(uint8_t)
       0   Temperature::set_current_temp_raw()
      16   Temperature::start_watching_heater(uint8_t)
        16   -> HAL_GetTick
        16   -> Temperature::degHotend(uint8_t)
        16   -> Temperature::degTargetHotend(uint8_t)
       0   Temperature::subobject Temperature()
         0   -> Temperature::Temperature()
      24   Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int8_t, uint16_t, uint16_t)
        24   -> HAL_GetTick
         0   -> Temperature::_temp_error(int8_t, char const *, char const *)
       0   Temperature::updatePID()
      16   Temperature::updateTemperaturesFromRawValues()
        16   -> Temperature::analog2temp(int, uint8_t)
       0   lcd_buttons_update()
       0   lcd_update()
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant " - Invalid extruder n...">
       8  ?<Constant " Kd: ">
       8  ?<Constant " Ki: ">
       8  ?<Constant " Kp: ">
       8  ?<Constant " Ku: ">
       8  ?<Constant " Tu: ">
       8  ?<Constant " bias: ">
       8  ?<Constant " d: ">
       8  ?<Constant " max: ">
       8  ?<Constant " min: ">
      24  ?<Constant "#define  DEFAULT_Kd ">
      24  ?<Constant "#define  DEFAULT_Ki ">
      24  ?<Constant "#define  DEFAULT_Kp ">
      32  ?<Constant ", system stopped! Hea...">
      16  ?<Constant "Err: MAXTEMP">
      16  ?<Constant "Err: MINTEMP">
      16  ?<Constant "Heating failed">
      12  ?<Constant "KILLED. ">
      20  ?<Constant "MAXTEMP triggered">
      20  ?<Constant "MINTEMP triggered">
      44  ?<Constant "PID Autotune failed! ...">
      44  ?<Constant "PID Autotune failed! ...">_1
      32  ?<Constant "PID Autotune failed! ...">_2
      96  ?<Constant "PID Autotune finished...">
      20  ?<Constant "PID Autotune start">
      16  ?<Constant "THERMAL RUNAWAY">
      16  ?<Constant "Thermal Runaway">
      16  ?<Constant "\n Classic PID \n">
       8  ?<Constant "bed\n">
       4  ?<Constant {1}>
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable41
       4  ??DataTable42
       4  ??DataTable42_1
       4  ??DataTable42_10
       4  ??DataTable42_11
       4  ??DataTable42_12
       4  ??DataTable42_13
       4  ??DataTable42_14
       4  ??DataTable42_15
       4  ??DataTable42_16
       4  ??DataTable42_17
       4  ??DataTable42_18
       4  ??DataTable42_19
       4  ??DataTable42_2
       4  ??DataTable42_20
       4  ??DataTable42_21
       4  ??DataTable42_22
       4  ??DataTable42_23
       4  ??DataTable42_24
       4  ??DataTable42_25
       4  ??DataTable42_26
       4  ??DataTable42_27
       4  ??DataTable42_3
       4  ??DataTable42_4
       4  ??DataTable42_5
       4  ??DataTable42_6
       4  ??DataTable42_7
       4  ??DataTable42_8
       4  ??DataTable42_9
      12  IsRunning()
       2  IsrTemperatureHandler
    1056  Temperature::PID_autotune(float, int8_t, int8_t, bool)
       2  Temperature::Temperature()
     326  Temperature::TemperatureHandler()
     108  Temperature::_temp_error(int8_t, char const *, char const *)
     198  Temperature::analog2temp(int, uint8_t)
       4  Temperature::current_temperature_bed
      12  Temperature::degHotend(uint8_t)
      16  Temperature::degTargetHotend(uint8_t)
      50  Temperature::disable_all_heaters()
      18  Temperature::getHeaterPower(int)
     308  Temperature::get_pid_output(int8_t)
      26  Temperature::init()
     240  Temperature::manage_heater()
      12  Temperature::max_temp_error(int8_t)
      12  Temperature::min_temp_error(int8_t)
       2  Temperature::setTargetBed(float)
      20  Temperature::setTargetHotend(float, uint8_t)
      12  Temperature::set_current_temp_raw()
      90  Temperature::start_watching_heater(uint8_t)
       2  Temperature::subobject Temperature()
      92  Temperature::temp_meas_ready
          Temperature::pid_reset
          Temperature::soft_pwm_amount
          Temperature::soft_pwm_amount_bed
          Temperature::in_temp_isr
          temp_count
          adc_sensor_state
          pwm_count
          soft_pwm_count_0
          do_buttons
          delay_count
          Temperature::watch_target_temp
          Temperature::raw_temp_bed_value
          Temperature::maxttemp
          Temperature::minttemp_raw
          Temperature::maxttemp_raw
          Temperature::minttemp
          Temperature::current_temperature
          Temperature::current_temperature_raw
          Temperature::target_temperature
          Temperature::current_temperature_bed_raw
          Temperature::Kp
          Temperature::Ki
          Temperature::Kd
          Temperature::watch_heater_next_ms
          Temperature::temp_iState
          Temperature::temp_dState
          Temperature::pTerm
          Temperature::iTerm
          Temperature::dTerm
          Temperature::pid_error
          Temperature::next_bed_check_ms
          Temperature::thermal_runaway_state_machine
          Temperature::raw_temp_value
          Temperature::thermal_runaway_timer
     182  Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int8_t, uint16_t, uint16_t)
       2  Temperature::updatePID()
      44  Temperature::updateTemperaturesFromRawValues()
       8  heater_ttbllen_map
          heater_ttbl_map
       1  killed
       2  lcd_buttons_update()
       2  lcd_update()
      28  serialprintPGM(char const *)
       4  thermalManager
       8  tr_target_temperature
       1  -- Other

 
    25 bytes in section .bss
    92 bytes in section .data
     1 byte  in section .rodata
 3 520 bytes in section .text
 
 3 424 bytes of CODE  memory (+ 96 bytes shared)
     0 bytes of CONST memory (+  1 byte  shared)
   117 bytes of DATA  memory

Errors: none
Warnings: 46
