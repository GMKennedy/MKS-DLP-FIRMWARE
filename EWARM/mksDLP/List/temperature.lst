###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:57:00
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\temperature.cpp
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\temperature.cpp
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\temperature.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\temperature.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\temperature.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * temperature.cpp - temperature control
     25           */
     26          
     27          #include "Marlin.h"

    #define MIN_SOFTWARE_ENDSTOPS mksCfg.min_software_endstops	/*--mks cfg--*/
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\Configuration.h",824  Warning[Pe047]: 
          incompatible redefinition of macro "MIN_SOFTWARE_ENDSTOPS" (declared
          at line 819)

    #define MAX_SOFTWARE_ENDSTOPS mksCfg.max_software_endstops	/*--mks cfg--*/
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\Configuration.h",834  Warning[Pe047]: 
          incompatible redefinition of macro "MAX_SOFTWARE_ENDSTOPS" (declared
          at line 829)

  #define UNUSED(x) ((void)(x))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Inc\mks_cfg.h",351  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Par
          ty\Marlin\Marlin_export.h")

  #define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_iwdg.h",80  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_PRESCALER" (declared at
          line 209 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_iwdg.h")

  #define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_iwdg.h",97  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_RELOAD" (declared at
          line 222 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_hal_iwdg.h")

  #define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",272  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NORSRAM_BANK" (declared
          at line 834 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",277  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NAND_BANK" (declared at
          line 855 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",298  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MUX" (declared at line
          839 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",311  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MEMORY" (declared at
          line 842 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",336  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_BURSTMODE" (declared at
          line 894 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",347  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ASYNWAIT" (declared at
          line 915 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",358  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_POLARITY" (declared
          at line 897 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",369  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRAP_MODE" (declared at
          line 900 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",380  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_SIGNAL_ACTIVE"
          (declared at line 903 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",391  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_OPERATION"
          (declared at line 906 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",402  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAITE_SIGNAL" (declared
          at line 909 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",414  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_EXTENDED_MODE" (declared
          at line 912 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",426  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_BURST" (declared
          at line 920 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",435  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_SETUP_TIME"
          (declared at line 923 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_HOLD_TIME"
          (declared at line 925 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",451  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATASETUP_TIME"
          (declared at line 927 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",459  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TURNAROUND_TIME"
          (declared at line 929 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",467  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_CLK_DIV" (declared at
          line 934 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATA_LATENCY" (declared
          at line 918 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",487  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ACCESS_MODE" (declared
          at line 850 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",508  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_FEATURE" (declared
          at line 858 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",520  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECC_STATE" (declared at
          line 864 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",535  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECCPAGE_SIZE" (declared
          at line 867 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",548  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TCLR_TIME" (declared at
          line 874 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",556  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TAR_TIME" (declared at
          line 876 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",564  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_SETUP_TIME" (declared at
          line 878 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",572  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_TIME" (declared at
          line 880 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",580  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HOLD_TIME" (declared at
          line 882 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",588  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HIZ_TIME" (declared at
          line 884 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

  #define FSMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
          ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\include\stm32f4xx_fsmc.h",613  Warning[Pe047]: 
          incompatible redefinition of macro "FSMC_FLAG_FEMPT" (declared at
          line 530 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL
          _Driver\Inc\stm32f4xx_ll_fsmc.h")

    #define assert_param(expr) ((void)0)        
            ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\libstmf4\stm32f4xx_conf.h",149  Warning[Pe047]: 
          incompatible redefinition of macro "assert_param" (declared at line
          431 of
          "E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\stm32f4x
          x_hal_conf.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial6

   \                                 In section .text, align 4
   \   __interwork __softfp bool IsRunning()
   \                     _Z9IsRunningv: (+1)
   \   00000000   0x4801             LDR.N    R0,??IsRunning_0
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??IsRunning_0:
   \   00000008   0x........         DC32     Running
     28          #include "temperature.h"

   \                                 In section .text, align 4
   \   __interwork __vfp float Temperature::degHotend(uint8_t)
   \                     _ZN11Temperature9degHotendEh: (+1)
   \   00000000   0x4801             LDR.N    R0,??degHotend_0
   \   00000002   0xED90 0x0A06      VLDR     S0,[R0, #+24]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??degHotend_0:
   \   00000008   0x........         DC32     _ZN11Temperature15temp_meas_readyE

   \                                 In section .text, align 4
   \   __interwork __vfp float Temperature::degTargetHotend(uint8_t)
   \                     _ZN11Temperature15degTargetHotendEh: (+1)
   \   00000000   0x4802             LDR.N    R0,??degTargetHotend_0
   \   00000002   0xED90 0x0A08      VLDR     S0,[R0, #+32]
   \   00000006   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000000A   0x4770             BX       LR               ;; return
   \                     ??degTargetHotend_0:
   \   0000000C   0x........         DC32     _ZN11Temperature15temp_meas_readyE

   \                                 In section .text, align 4

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\temperature.h",397  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   __interwork __vfp void Temperature::setTargetHotend(float, uint8_t)
   \                     _ZN11Temperature15setTargetHotendEfh: (+1)
   \   00000000   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000004   0x4802             LDR.N    R0,??setTargetHotend_0
   \   00000006   0xED80 0x0A08      VSTR     S0,[R0, #+32]
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      B.W      _ZN11Temperature21start_watching_heaterEh
   \                     ??setTargetHotend_0:
   \   00000010   0x........         DC32     _ZN11Temperature15temp_meas_readyE

   \                                 In section .text, align 2
   \   __interwork __vfp void Temperature::setTargetBed(float)
   \                     _ZN11Temperature12setTargetBedEf: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void Temperature::updatePID()
   \                     _ZN11Temperature9updatePIDEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     29          #include "thermistortables.h"
     30          #include "ultralcd.h"

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_update()
   \                     _Z10lcd_updatev: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_buttons_update()
   \                     _Z18lcd_buttons_updatev: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     31          #include "planner.h"

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.h",582  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\planner.h",583  Warning[Pe815]: 
          type qualifier on return type is meaningless
     32          #include "language.h"
     33          #include "adc.h"
     34          #include "tim.h"
     35          #include "spi.h"
     36          #if ENABLED(HEATER_0_USES_MAX6675)
     37            //#include "MarlinSPI.h"
     38          #endif
     39          
     40          #if ENABLED(BABYSTEPPING)
     41            #include "stepper.h"
     42          #endif
     43          
     44          #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     45            #include "endstops.h"
     46          #endif
     47          
     48          #if ENABLED(USE_WATCHDOG)
     49            #include "watchdog.h"
     50          #endif
     51          
     52          #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     53            static void* heater_ttbl_map[2] = { (void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     54            static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
     55          #else

   \                                 In section .bss, align 4
     56            static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
     57            static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
   \                     heater_ttbllen_map:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \   00000004                      DS8 4
     58          #endif
     59          

   \                                 In section .bss, align 4
     60          Temperature thermalManager;
   \                     thermalManager:
   \   00000000                      DS8 4
     61          
     62          // public:
     63          
     64          float Temperature::current_temperature[HOTENDS] = { 0.0 },

   \                                 In section .bss, align 4
     65                Temperature::current_temperature_bed = 0.0;
   \                     _ZN11Temperature23current_temperature_bedE:
   \   00000000                      DS8 4
     66          int Temperature::current_temperature_raw[HOTENDS] = { 0 },
     67                  Temperature::target_temperature[HOTENDS] = { 0 },
     68                  Temperature::current_temperature_bed_raw = 0;
     69          
     70          #if HAS_HEATER_BED
     71            int16_t Temperature::target_temperature_bed = 0;
     72          #endif
     73          
     74          // Initialized by settings.load()
     75          #if ENABLED(PIDTEMP)
     76            #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
     77              float Temperature::Kp[HOTENDS], Temperature::Ki[HOTENDS], Temperature::Kd[HOTENDS];
     78              #if ENABLED(PID_EXTRUSION_SCALING)
     79                float Temperature::Kc[HOTENDS];
     80              #endif
     81            #else
     82              float Temperature::Kp, Temperature::Ki, Temperature::Kd;
     83              #if ENABLED(PID_EXTRUSION_SCALING)
     84                float Temperature::Kc;
     85              #endif
     86            #endif
     87          #endif
     88          
     89          // Initialized by settings.load()
     90          #if ENABLED(PIDTEMPBED)
     91            float Temperature::bedKp, Temperature::bedKi, Temperature::bedKd;
     92          #endif
     93          
     94          #if ENABLED(BABYSTEPPING)
     95            volatile int Temperature::babystepsTodo[XYZ] = { 0 };
     96          #endif
     97          
     98          #if WATCH_HOTENDS
     99            uint16_t Temperature::watch_target_temp[HOTENDS] = { 0 };
    100            millis_t Temperature::watch_heater_next_ms[HOTENDS] = { 0 };
    101          #endif
    102          
    103          #if WATCH_THE_BED
    104            uint16_t Temperature::watch_target_bed_temp = 0;
    105            millis_t Temperature::watch_bed_next_ms = 0;
    106          #endif
    107          
    108          #if ENABLED(PREVENT_COLD_EXTRUSION)
    109            bool Temperature::allow_cold_extrude = false;
    110            int16_t Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
    111          #endif
    112          
    113          // private:
    114          
    115          #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    116            uint16_t Temperature::redundant_temperature_raw = 0;
    117            float Temperature::redundant_temperature = 0.0;
    118          #endif
    119          
    120          volatile bool Temperature::temp_meas_ready = false;
    121          
    122          #if ENABLED(PIDTEMP)
    123            float Temperature::temp_iState[HOTENDS] = { 0 },
    124                  Temperature::temp_dState[HOTENDS] = { 0 },
    125                  Temperature::pTerm[HOTENDS],
    126                  Temperature::iTerm[HOTENDS],
    127                  Temperature::dTerm[HOTENDS];
    128          
    129            #if ENABLED(PID_EXTRUSION_SCALING)
    130              float Temperature::cTerm[HOTENDS];
    131              long Temperature::last_e_position;
    132              long Temperature::lpq[LPQ_MAX_LEN];
    133              int Temperature::lpq_ptr = 0;
    134            #endif
    135          
    136            float Temperature::pid_error[HOTENDS];
    137            bool Temperature::pid_reset[HOTENDS];
    138          #endif
    139          #if ENABLED(PIDTEMPBED)
    140            float Temperature::temp_iState_bed = { 0 },
    141                  Temperature::temp_dState_bed = { 0 },
    142                  Temperature::pTerm_bed,
    143                  Temperature::iTerm_bed,
    144                  Temperature::dTerm_bed,
    145                  Temperature::pid_error_bed;
    146          #else
    147            millis_t Temperature::next_bed_check_ms;
    148          #endif
    149          
    150          
    151          uint16_t Temperature::raw_temp_value[MAX_EXTRUDERS] = { 0 },
    152                   Temperature::raw_temp_bed_value = 0;
    153          
    154          // Init min and max temp with extreme values to prevent false errors during startup
    155          int16_t Temperature::minttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP, HEATER_4_RAW_LO_TEMP),
    156                  Temperature::maxttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP, HEATER_4_RAW_HI_TEMP),
    157                  Temperature::minttemp[HOTENDS] = { 0 },
    158                  Temperature::maxttemp[HOTENDS] = ARRAY_BY_HOTENDS1(16383);
    159          
    160          #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
    161            uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
    162          #endif
    163          
    164          #ifdef MILLISECONDS_PREHEAT_TIME
    165            millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
    166          #endif
    167          
    168          #ifdef BED_MINTEMP
    169            int16_t Temperature::bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
    170          #endif
    171          
    172          #ifdef BED_MAXTEMP
    173            int16_t Temperature::bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
    174          #endif
    175          
    176          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    177            int8_t Temperature::meas_shift_index;  // Index of a delayed sample in buffer
    178          #endif
    179          
    180          #if HAS_AUTO_FAN
    181            millis_t Temperature::next_auto_fan_check_ms = 0;
    182          #endif
    183          
    184          uint8_t Temperature::soft_pwm_amount[HOTENDS],
    185                  Temperature::soft_pwm_amount_bed;
    186          
    187          #if ENABLED(FAN_SOFT_PWM)
    188            uint8_t Temperature::soft_pwm_amount_fan[FAN_COUNT],
    189                    Temperature::soft_pwm_count_fan[FAN_COUNT];
    190          #endif
    191          
    192          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    193            uint16_t Temperature::current_raw_filwidth = 0; // Measured filament diameter - one extruder only
    194          #endif
    195          
    196          #if ENABLED(PROBING_HEATERS_OFF)
    197            bool Temperature::paused;
    198          #endif
    199          
    200          #if HEATER_IDLE_HANDLER
    201            millis_t Temperature::heater_idle_timeout_ms[HOTENDS] = { 0 };
    202            bool Temperature::heater_idle_timeout_exceeded[HOTENDS] = { false };
    203            #if HAS_TEMP_BED
    204              millis_t Temperature::bed_idle_timeout_ms = 0;
    205              bool Temperature::bed_idle_timeout_exceeded = false;
    206            #endif
    207          #endif
    208          
    209          #if ENABLED(ADC_KEYPAD)
    210            uint32_t Temperature::current_ADCKey_raw = 0;
    211            uint8_t Temperature::ADCKey_count = 0;
    212          #endif
    213          
    214          #if HAS_PID_HEATING
    215          
    216            /**
    217             * PID Autotuning (M303)
    218             *
    219             * Alternately heat and cool the nozzle, observing its behavior to
    220             * determine the best PID values to achieve a stable temperature.
    221             */

   \                                 In section .text, align 4, keep-with-next
    222            void Temperature::PID_autotune(const float temp, const int8_t hotend, const int8_t ncycles, const bool set_result/*=false*/) {
   \                     _ZN11Temperature12PID_autotuneEfaab: (+1)
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0xED2D 0x8B0A      VPUSH    {D8-D12}
   \   00000008   0xB086             SUB      SP,SP,#+24
   \   0000000A   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000E   0x4604             MOV      R4,R0
    223              float input = 0.0;
   \   00000010   0xEDDF 0x8AD7      VLDR.W   S17,??PID_autotune_0  ;; 0x0
    224              int cycles = 0;
   \   00000014   0xF04F 0x0800      MOV      R8,#+0
    225              bool heating = true;
   \   00000018   0x2501             MOVS     R5,#+1
    226          
    227              millis_t next_temp_ms = millis(), t1 = next_temp_ms, t2 = next_temp_ms;
   \   0000001A   0x.... 0x....      BL       HAL_GetTick
   \   0000001E   0x9002             STR      R0,[SP, #+8]
   \   00000020   0x9004             STR      R0,[SP, #+16]
   \   00000022   0x9802             LDR      R0,[SP, #+8]
   \   00000024   0x9003             STR      R0,[SP, #+12]
    228              long t_high = 0, t_low = 0;
   \   00000026   0x46C2             MOV      R10,R8
    229          
    230              long bias, d;
    231              float Ku, Tu,
    232                    workKp = 0, workKi = 0, workKd = 0,
   \   00000028   0xEDDF 0xAAD1      VLDR.W   S21,??PID_autotune_0  ;; 0x0
   \   0000002C   0xED9F 0xBAD0      VLDR.W   S22,??PID_autotune_0  ;; 0x0
   \   00000030   0xEDDF 0xBACF      VLDR.W   S23,??PID_autotune_0  ;; 0x0
    233                    max = 0, min = 10000;
   \   00000034   0xED9F 0x9ACE      VLDR.W   S18,??PID_autotune_0  ;; 0x0
   \   00000038   0xED9F 0xCACE      VLDR.W   S24,??PID_autotune_0+0x4  ;; 0x461c4000
    234          
    235              #if WATCH_THE_BED || WATCH_HOTENDS
    236                const float watch_temp_target = temp -
    237                  #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
    238                    (hotend < 0 ? (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1) : (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))
    239                  #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
    240                    (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)
    241                  #else
    242                    (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)
    243                  #endif
    244                ;
   \   0000003C   0xEEB9 0x0A08      VMOV.F32 S0,#-6.0
   \   00000040   0xEE78 0x9A00      VADD.F32 S19,S16,S0
   \   00000044   0x9802             LDR      R0,[SP, #+8]
   \   00000046   0xF500 0x409C      ADD      R0,R0,#+19968
   \   0000004A   0x3020             ADDS     R0,R0,#+32
   \   0000004C   0x9005             STR      R0,[SP, #+20]
    245                const int8_t watch_temp_period =
    246                  #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
    247                    hotend < 0 ? WATCH_BED_TEMP_PERIOD : WATCH_TEMP_PERIOD
    248                  #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
    249                    WATCH_BED_TEMP_PERIOD
    250                  #else
    251                    WATCH_TEMP_PERIOD
    252                  #endif
    253                ;
    254                const int8_t watch_temp_increase =
    255                  #if ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED) && ENABLED(THERMAL_PROTECTION_HOTENDS) && ENABLED(PIDTEMP)
    256                    hotend < 0 ? WATCH_BED_TEMP_INCREASE : WATCH_TEMP_INCREASE
    257                  #elif ENABLED(THERMAL_PROTECTION_BED) && ENABLED(PIDTEMPBED)
    258                    WATCH_BED_TEMP_INCREASE
    259                  #else
    260                    WATCH_TEMP_INCREASE
    261                  #endif
    262                ;
    263                millis_t temp_change_ms = next_temp_ms + watch_temp_period * 1000UL;
    264                float next_watch_temp = 0.0;
   \   0000004E   0xED9F 0xAAC8      VLDR.W   S20,??PID_autotune_0  ;; 0x0
    265                bool heated = false;
   \   00000052   0x46C1             MOV      R9,R8
   \   00000054   0xB264             SXTB     R4,R4
   \   00000056   0x2C00             CMP      R4,#+0
   \   00000058   0xD010             BEQ.N    ??PID_autotune_1
    266              #endif
    267          
    268              #if HAS_AUTO_FAN
    269                next_auto_fan_check_ms = next_temp_ms + 2500UL;
    270              #endif
    271          
    272              #if ENABLED(PIDTEMP)
    273                #define _TOP_HOTEND HOTENDS - 1
    274              #else
    275                #define _TOP_HOTEND -1
    276              #endif
    277              #if ENABLED(PIDTEMPBED)
    278                #define _BOT_HOTEND -1
    279              #else
    280                #define _BOT_HOTEND 0
    281              #endif
    282          
    283              if (!WITHIN(hotend, _BOT_HOTEND, _TOP_HOTEND)) {
    284                SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);
   \   0000005A   0x.... 0x....      ADR.W    R1,`?<Constant "PID Autotune failed! ...">`
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable42
   \   00000062   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000066   0x210A             MOVS     R1,#+10
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable42
   \   0000006C   0xB006             ADD      SP,SP,#+24
   \   0000006E   0xECBD 0x8B0A      VPOP     {D8-D12}
   \   00000072   0xB003             ADD      SP,SP,#+12
   \   00000074   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000078   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    285                return;
    286              }
    287          
    288              SERIAL_ECHOLN(MSG_PID_AUTOTUNE_START);
   \                     ??PID_autotune_1: (+1)
   \   0000007C   0x.... 0x....      ADR.W    R1,`?<Constant "PID Autotune start">`
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable42
   \   00000084   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000088   0x210A             MOVS     R1,#+10
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable42
   \   0000008E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    289          
    290              disable_all_heaters(); // switch off all heaters.
   \   00000092   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
    291          
    292              #if HAS_PID_FOR_BOTH
    293                if (hotend < 0)
    294                  soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
    295                else
    296                  soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
    297              #elif ENABLED(PIDTEMP)
    298                soft_pwm_amount[hotend] = bias = d = (PID_MAX) >> 1;
   \   00000096   0x277F             MOVS     R7,#+127
   \   00000098   0x463E             MOV      R6,R7
   \   0000009A   0x.... 0x....      LDR.W    R11,??DataTable42_1
   \   0000009E   0x4630             MOV      R0,R6
   \   000000A0   0xF88B 0x0002      STRB     R0,[R11, #+2]
   \   000000A4   0x4628             MOV      R0,R5
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable42_2
   \   000000AA   0x7008             STRB     R0,[R1, #+0]
   \   000000AC   0xE001             B.N      ??PID_autotune_2
    299              #else
    300                soft_pwm_amount_bed = bias = d = (MAX_BED_POWER) >> 1;
    301              #endif
    302          
    303              wait_for_heatup = true;
    304          
    305              // PID Tuning loop
    306              while (wait_for_heatup) {
    307          
    308                const millis_t ms = millis();
    309          
    310                if (temp_meas_ready) { // temp sample ready
    311                  updateTemperaturesFromRawValues();
    312          
    313                  input =
    314                    #if HAS_PID_FOR_BOTH
    315                      hotend < 0 ? current_temperature_bed : current_temperature[hotend]
    316                    #elif ENABLED(PIDTEMP)
    317                      current_temperature[hotend]
    318                    #else
    319                      current_temperature_bed
    320                    #endif
    321                  ;
    322          
    323                  NOLESS(max, input);
    324                  NOMORE(min, input);
    325          
    326                  #if HAS_AUTO_FAN
    327                    if (ELAPSED(ms, next_auto_fan_check_ms)) {
    328                      checkExtruderAutoFans();
    329                      next_auto_fan_check_ms = ms + 2500UL;
    330                    }
    331                  #endif
    332          
    333                  if (heating && input > temp) {
    334                    if (ELAPSED(ms, t2 + 5000UL)) {
    335                      heating = false;
    336                      #if HAS_PID_FOR_BOTH
    337                        if (hotend < 0)
    338                          soft_pwm_amount_bed = (bias - d) >> 1;
    339                        else
    340                          soft_pwm_amount[hotend] = (bias - d) >> 1;
    341                      #elif ENABLED(PIDTEMP)
    342                        soft_pwm_amount[hotend] = (bias - d) >> 1;
    343                      #elif ENABLED(PIDTEMPBED)
    344                        soft_pwm_amount_bed = (bias - d) >> 1;
    345                      #endif
    346                      t1 = ms;
    347                      t_high = t1 - t2;
    348                      max = temp;
    349                    }
    350                  }
    351          
    352                  if (!heating && input < temp) {
    353                    if (ELAPSED(ms, t1 + 5000UL)) {
    354                      heating = true;
    355                      t2 = ms;
    356                      t_low = t2 - t1;
    357                      if (cycles > 0) {
    358                        long max_pow =
    359                          #if HAS_PID_FOR_BOTH
    360                            hotend < 0 ? MAX_BED_POWER : PID_MAX
    361                          #elif ENABLED(PIDTEMP)
    362                            PID_MAX
    363                          #else
    364                            MAX_BED_POWER
    365                          #endif
    366                        ;
    367                        bias += (d * (t_high - t_low)) / (t_low + t_high);
    368                        bias = constrain(bias, 20, max_pow - 20);
    369                        d = (bias > max_pow >> 1) ? max_pow - 1 - bias : bias;
    370          
    371                        SERIAL_PROTOCOLPAIR(MSG_BIAS, bias);
    372                        SERIAL_PROTOCOLPAIR(MSG_D, d);
    373                        SERIAL_PROTOCOLPAIR(MSG_T_MIN, min);
    374                        SERIAL_PROTOCOLPAIR(MSG_T_MAX, max);
    375                        if (cycles > 2) {
    376                          Ku = (4.0 * d) / (M_PI * (max - min) * 0.5);
    377                          Tu = ((float)(t_low + t_high) * 0.001);
    378                          SERIAL_PROTOCOLPAIR(MSG_KU, Ku);
    379                          SERIAL_PROTOCOLPAIR(MSG_TU, Tu);
    380                          workKp = 0.6 * Ku;
    381                          workKi = 2 * workKp / Tu;
    382                          workKd = workKp * Tu * 0.125;
    383                          SERIAL_PROTOCOLLNPGM("\n" MSG_CLASSIC_PID);
    384                          SERIAL_PROTOCOLPAIR(MSG_KP, workKp);
    385                          SERIAL_PROTOCOLPAIR(MSG_KI, workKi);
    386                          SERIAL_PROTOCOLLNPAIR(MSG_KD, workKd);
    387                          /**
    388                          workKp = 0.33*Ku;
    389                          workKi = workKp/Tu;
    390                          workKd = workKp*Tu/3;
    391                          SERIAL_PROTOCOLLNPGM(" Some overshoot");
    392                          SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
    393                          SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
    394                          SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
    395                          workKp = 0.2*Ku;
    396                          workKi = 2*workKp/Tu;
    397                          workKd = workKp*Tu/3;
    398                          SERIAL_PROTOCOLLNPGM(" No overshoot");
    399                          SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
    400                          SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
    401                          SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
    402                          */
    403                        }
    404                      }
    405                      #if HAS_PID_FOR_BOTH
    406                        if (hotend < 0)
    407                          soft_pwm_amount_bed = (bias + d) >> 1;
    408                        else
    409                          soft_pwm_amount[hotend] = (bias + d) >> 1;
    410                      #elif ENABLED(PIDTEMP)
    411                        soft_pwm_amount[hotend] = (bias + d) >> 1;
    412                      #else
    413                        soft_pwm_amount_bed = (bias + d) >> 1;
    414                      #endif
    415                      cycles++;
    416                      min = temp;
    417                    }
    418                  }
    419                }
    420                #define MAX_OVERSHOOT_PID_AUTOTUNE 20
    421                if (input > temp + MAX_OVERSHOOT_PID_AUTOTUNE) {
    422                  SERIAL_PROTOCOLLNPGM(MSG_PID_TEMP_TOO_HIGH);
    423                  break;
    424                }
    425                // Every 2 seconds...
    426                if (ELAPSED(ms, next_temp_ms)) {
    427                  #if HAS_TEMP_HOTEND || HAS_TEMP_BED
    428                    print_heaterstates();
    429                    SERIAL_EOL();
    430                  #endif
    431          
    432                  next_temp_ms = ms + 2000UL;
    433          
    434                  #if WATCH_THE_BED || WATCH_HOTENDS
    435                    if (!heated && input > next_watch_temp) {
    436                      if (input > watch_temp_target) heated = true;
    437                      next_watch_temp = input + watch_temp_increase;
    438                      temp_change_ms = ms + watch_temp_period * 1000UL;
    439                    }
    440                    else if (!heated && ELAPSED(ms, temp_change_ms))
    441                      _temp_error(hotend, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
    442                    else if (heated && input < temp - MAX_OVERSHOOT_PID_AUTOTUNE)
    443                      _temp_error(hotend, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
    444                  #endif
    445                } // every 2 seconds
    446                // Timeout after 20 minutes since the last undershoot/overshoot cycle
    447                if (((ms - t1) + (ms - t2)) > (20L * 60L * 1000L)) {
    448                  SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
    449                  break;
    450                }
    451                if (cycles > ncycles) {
    452                  SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
    453          
    454                  #if HAS_PID_FOR_BOTH
    455                    const char* estring = hotend < 0 ? "bed" : "";
    456                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL();
    457                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL();
    458                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL();
    459                  #elif ENABLED(PIDTEMP)
    460                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kp ", workKp); SERIAL_EOL();
    461                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Ki ", workKi); SERIAL_EOL();
    462                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kd ", workKd); SERIAL_EOL();
    463                  #else
    464                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKp ", workKp); SERIAL_EOL();
    465                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKi ", workKi); SERIAL_EOL();
    466                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKd ", workKd); SERIAL_EOL();
    467                  #endif
    468          
    469                  #define _SET_BED_PID() do { \
    470                    bedKp = workKp; \
    471                    bedKi = scalePID_i(workKi); \
    472                    bedKd = scalePID_d(workKd); \
    473                    }while(0)
    474          
    475                  #define _SET_EXTRUDER_PID() do { \
    476                    PID_PARAM(Kp, hotend) = workKp; \
    477                    PID_PARAM(Ki, hotend) = scalePID_i(workKi); \
    478                    PID_PARAM(Kd, hotend) = scalePID_d(workKd); \
    479                    updatePID(); }while(0)
    480          
    481                  // Use the result? (As with "M303 U1")
    482                  if (set_result) {
    483                    #if HAS_PID_FOR_BOTH
    484                      if (hotend < 0)
    485                        _SET_BED_PID();
    486                      else
    487                        _SET_EXTRUDER_PID();
    488                    #elif ENABLED(PIDTEMP)
    489                      _SET_EXTRUDER_PID();
    490                    #else
    491                      _SET_BED_PID();
    492                    #endif
    493                  }
    494                  return;
    495                }
    496                lcd_update();
   \                     ??PID_autotune_3: (+1)
   \   000000AE   0x.... 0x....      BL       _Z10lcd_updatev
   \                     ??PID_autotune_2: (+1)
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable42_2
   \   000000B6   0x7800             LDRB     R0,[R0, #+0]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xF000 0x8101      BEQ.W    ??PID_autotune_4
   \   000000BE   0x.... 0x....      BL       HAL_GetTick
   \   000000C2   0x4604             MOV      R4,R0
   \   000000C4   0xF89B 0x0000      LDRB     R0,[R11, #+0]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xF000 0x80EC      BEQ.W    ??PID_autotune_5
   \   000000CE   0x.... 0x....      BL       _ZN11Temperature31updateTemperaturesFromRawValuesEv
   \   000000D2   0xEDDB 0x8A06      VLDR     S17,[R11, #+24]
   \   000000D6   0xEEB4 0x9A68      VCMP.F32 S18,S17
   \   000000DA   0xEEF1 0xFA10      FMSTAT   
   \   000000DE   0xD501             BPL.N    ??PID_autotune_6
   \   000000E0   0xEEB0 0x9A68      VMOV.F32 S18,S17
   \                     ??PID_autotune_6: (+1)
   \   000000E4   0xEEF4 0x8A4C      VCMP.F32 S17,S24
   \   000000E8   0xEEF1 0xFA10      FMSTAT   
   \   000000EC   0xD501             BPL.N    ??PID_autotune_7
   \   000000EE   0xEEB0 0xCA68      VMOV.F32 S24,S17
   \                     ??PID_autotune_7: (+1)
   \   000000F2   0x2D00             CMP      R5,#+0
   \   000000F4   0xD013             BEQ.N    ??PID_autotune_8
   \   000000F6   0xEEB4 0x8A68      VCMP.F32 S16,S17
   \   000000FA   0xEEF1 0xFA10      FMSTAT   
   \   000000FE   0xD50E             BPL.N    ??PID_autotune_8
   \   00000100   0x9803             LDR      R0,[SP, #+12]
   \   00000102   0x1A20             SUBS     R0,R4,R0
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable42_3  ;; 0xffffec78
   \   00000108   0x1809             ADDS     R1,R1,R0
   \   0000010A   0xD408             BMI.N    ??PID_autotune_8
   \   0000010C   0x2500             MOVS     R5,#+0
   \   0000010E   0x1BF1             SUBS     R1,R6,R7
   \   00000110   0x1049             ASRS     R1,R1,#+1
   \   00000112   0xF88B 0x1002      STRB     R1,[R11, #+2]
   \   00000116   0x9404             STR      R4,[SP, #+16]
   \   00000118   0x4682             MOV      R10,R0
   \   0000011A   0xEEB0 0x9A48      VMOV.F32 S18,S16
   \                     ??PID_autotune_8: (+1)
   \   0000011E   0x2D00             CMP      R5,#+0
   \   00000120   0xF040 0x80C1      BNE.W    ??PID_autotune_5
   \   00000124   0xEEF4 0x8A48      VCMP.F32 S17,S16
   \   00000128   0xEEF1 0xFA10      FMSTAT   
   \   0000012C   0xF140 0x80BB      BPL.W    ??PID_autotune_5
   \   00000130   0x9804             LDR      R0,[SP, #+16]
   \   00000132   0x1A20             SUBS     R0,R4,R0
   \   00000134   0x.... 0x....      LDR.W    R1,??DataTable42_3  ;; 0xffffec78
   \   00000138   0x1809             ADDS     R1,R1,R0
   \   0000013A   0xF100 0x80B4      BMI.W    ??PID_autotune_5
   \   0000013E   0x2501             MOVS     R5,#+1
   \   00000140   0x9403             STR      R4,[SP, #+12]
   \   00000142   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000146   0xF2C0 0x80A6      BLT.W    ??PID_autotune_9
   \   0000014A   0xEB0A 0x0100      ADD      R1,R10,R0
   \   0000014E   0xEE0C 0x1A90      VMOV     S25,R1
   \   00000152   0xEBAA 0x0000      SUB      R0,R10,R0
   \   00000156   0x4378             MULS     R0,R0,R7
   \   00000158   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000015C   0x1986             ADDS     R6,R0,R6
   \   0000015E   0x2E14             CMP      R6,#+20
   \   00000160   0xDA01             BGE.N    ??PID_autotune_10
   \   00000162   0x2614             MOVS     R6,#+20
   \   00000164   0xE002             B.N      ??PID_autotune_11
   \                     ??PID_autotune_10: (+1)
   \   00000166   0x2EEC             CMP      R6,#+236
   \   00000168   0xDB00             BLT.N    ??PID_autotune_11
   \   0000016A   0x26EB             MOVS     R6,#+235
   \                     ??PID_autotune_11: (+1)
   \   0000016C   0x2E80             CMP      R6,#+128
   \   0000016E   0xDB02             BLT.N    ??PID_autotune_12
   \   00000170   0xF1C6 0x07FE      RSB      R7,R6,#+254
   \   00000174   0xE000             B.N      ??PID_autotune_13
   \                     ??PID_autotune_12: (+1)
   \   00000176   0x4637             MOV      R7,R6
   \                     ??PID_autotune_13: (+1)
   \   00000178   0x4631             MOV      R1,R6
   \   0000017A   0x.... 0x....      ADR.W    R0,`?<Constant " bias: ">`
   \   0000017E   0x.... 0x....      BL       _Z17serial_echopair_PPKcl
   \   00000182   0x4639             MOV      R1,R7
   \   00000184   0x.... 0x....      ADR.W    R0,`?<Constant " d: ">`
   \   00000188   0x.... 0x....      BL       _Z17serial_echopair_PPKcl
   \   0000018C   0xEEB0 0x0A4C      VMOV.F32 S0,S24
   \   00000190   0x.... 0x....      ADR.W    R0,`?<Constant " min: ">`
   \   00000194   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000198   0xEEB0 0x0A49      VMOV.F32 S0,S18
   \   0000019C   0x.... 0x....      ADR.W    R0,`?<Constant " max: ">`
   \   000001A0   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000001A4   0xF1B8 0x0F03      CMP      R8,#+3
   \   000001A8   0xDB75             BLT.N    ??PID_autotune_9
   \   000001AA   0x4638             MOV      R0,R7
   \   000001AC   0x.... 0x....      BL       __aeabi_i2d
   \   000001B0   0x2200             MOVS     R2,#+0
   \   000001B2   0x.... 0x....      LDR.W    R3,??DataTable42_4  ;; 0x40100000
   \   000001B6   0x.... 0x....      BL       __aeabi_dmul
   \   000001BA   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   000001BE   0xEE39 0x0A4C      VSUB.F32 S0,S18,S24
   \   000001C2   0xEE10 0x0A10      VMOV     R0,S0
   \   000001C6   0x.... 0x....      BL       __aeabi_f2d
   \   000001CA   0x.... 0x....      LDR.W    R2,??DataTable42_5  ;; 0x54442d18
   \   000001CE   0x.... 0x....      LDR.W    R3,??DataTable42_6  ;; 0x400921fb
   \   000001D2   0x.... 0x....      BL       __aeabi_dmul
   \   000001D6   0x2200             MOVS     R2,#+0
   \   000001D8   0x.... 0x....      LDR.W    R3,??DataTable42_7  ;; 0x3fe00000
   \   000001DC   0x.... 0x....      BL       __aeabi_dmul
   \   000001E0   0x4602             MOV      R2,R0
   \   000001E2   0x460B             MOV      R3,R1
   \   000001E4   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   000001E8   0x.... 0x....      BL       __aeabi_ddiv
   \   000001EC   0x.... 0x....      BL       __aeabi_d2f
   \   000001F0   0xEE0A 0x0A90      VMOV     S21,R0
   \   000001F4   0xEEB8 0x0AEC      VCVT.F32.S32 S0,S25
   \   000001F8   0xEE10 0x0A10      VMOV     R0,S0
   \   000001FC   0x.... 0x....      BL       __aeabi_f2d
   \   00000200   0x.... 0x....      LDR.W    R2,??DataTable42_8  ;; 0xd2f1a9fc
   \   00000204   0x.... 0x....      LDR.W    R3,??DataTable42_9  ;; 0x3f50624d
   \   00000208   0x.... 0x....      BL       __aeabi_dmul
   \   0000020C   0x.... 0x....      BL       __aeabi_d2f
   \   00000210   0xEE0B 0x0A90      VMOV     S23,R0
   \   00000214   0xEEB0 0x0A6A      VMOV.F32 S0,S21
   \   00000218   0x.... 0x....      ADR.W    R0,`?<Constant " Ku: ">`
   \   0000021C   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000220   0xEEB0 0x0A6B      VMOV.F32 S0,S23
   \   00000224   0x.... 0x....      ADR.W    R0,`?<Constant " Tu: ">`
   \   00000228   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   0000022C   0xEE1A 0x0A90      VMOV     R0,S21
   \   00000230   0x.... 0x....      BL       __aeabi_f2d
   \   00000234   0xF04F 0x3233      MOV      R2,#+858993459
   \   00000238   0x.... 0x....      LDR.W    R3,??DataTable42_10  ;; 0x3fe33333
   \   0000023C   0x.... 0x....      BL       __aeabi_dmul
   \   00000240   0x.... 0x....      BL       __aeabi_d2f
   \   00000244   0xEE0A 0x0A90      VMOV     S21,R0
   \   00000248   0xEEB0 0x0A00      VMOV.F32 S0,#2.0
   \   0000024C   0xEE2A 0x0A80      VMUL.F32 S0,S21,S0
   \   00000250   0xEE80 0xBA2B      VDIV.F32 S22,S0,S23
   \   00000254   0xEE2A 0x0AAB      VMUL.F32 S0,S21,S23
   \   00000258   0xEEF4 0x0A00      VMOV.F32 S1,#0.125
   \   0000025C   0xEE60 0xBA20      VMUL.F32 S23,S0,S1
   \   00000260   0x.... 0x....      ADR.W    R0,`?<Constant "\\n Classic PID \\n">`
   \   00000264   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000268   0xEEB0 0x0A6A      VMOV.F32 S0,S21
   \   0000026C   0x.... 0x....      ADR.W    R0,`?<Constant " Kp: ">`
   \   00000270   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000274   0xEEB0 0x0A4B      VMOV.F32 S0,S22
   \   00000278   0x.... 0x....      ADR.W    R0,`?<Constant " Ki: ">`
   \   0000027C   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000280   0xEEB0 0x0A6B      VMOV.F32 S0,S23
   \   00000284   0x.... 0x....      ADR.W    R0,`?<Constant " Kd: ">`
   \   00000288   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   0000028C   0x210A             MOVS     R1,#+10
   \   0000028E   0x.... 0x....      LDR.W    R0,??DataTable42
   \   00000292   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??PID_autotune_9: (+1)
   \   00000296   0x19B8             ADDS     R0,R7,R6
   \   00000298   0x1040             ASRS     R0,R0,#+1
   \   0000029A   0xF88B 0x0002      STRB     R0,[R11, #+2]
   \   0000029E   0xF108 0x0801      ADD      R8,R8,#+1
   \   000002A2   0xEEB0 0xCA48      VMOV.F32 S24,S16
   \                     ??PID_autotune_5: (+1)
   \   000002A6   0xEEB3 0x0A04      VMOV.F32 S0,#20.0
   \   000002AA   0xEE38 0x0A00      VADD.F32 S0,S16,S0
   \   000002AE   0xEEB4 0x0A68      VCMP.F32 S0,S17
   \   000002B2   0xEEF1 0xFA10      FMSTAT   
   \   000002B6   0xD50E             BPL.N    ??PID_autotune_14
   \   000002B8   0x.... 0x....      ADR.W    R0,`?<Constant "PID Autotune failed! ...">_1`
   \   000002BC   0x.... 0x....      BL       _Z14serialprintPGMPKc
    497              }
    498              disable_all_heaters();
   \                     ??PID_autotune_4: (+1)
   \   000002C0   0xB006             ADD      SP,SP,#+24
   \   000002C2   0xECBD 0x8B0A      VPOP     {D8-D12}
   \   000002C6   0xE8BD 0x4FF7      POP      {R0-R2,R4-R11,LR}
   \   000002CA   0x....             B.N      _ZN11Temperature19disable_all_heatersEv
   \                     ??PID_autotune_15: (+1)
   \   000002CC   0xB006             ADD      SP,SP,#+24
   \   000002CE   0xECBD 0x8B0A      VPOP     {D8-D12}
   \   000002D2   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   \                     ??PID_autotune_14: (+1)
   \   000002D6   0x9802             LDR      R0,[SP, #+8]
   \   000002D8   0x1A20             SUBS     R0,R4,R0
   \   000002DA   0xD43A             BMI.N    ??PID_autotune_16
   \   000002DC   0xF504 0x60FA      ADD      R0,R4,#+2000
   \   000002E0   0x9002             STR      R0,[SP, #+8]
   \   000002E2   0xF1B9 0x0F00      CMP      R9,#+0
   \   000002E6   0xD114             BNE.N    ??PID_autotune_17
   \   000002E8   0xEEB4 0xAA68      VCMP.F32 S20,S17
   \   000002EC   0xEEF1 0xFA10      FMSTAT   
   \   000002F0   0xD50F             BPL.N    ??PID_autotune_17
   \   000002F2   0xEEF4 0x9A68      VCMP.F32 S19,S17
   \   000002F6   0xEEF1 0xFA10      FMSTAT   
   \   000002FA   0xD501             BPL.N    ??PID_autotune_18
   \   000002FC   0xF04F 0x0901      MOV      R9,#+1
   \                     ??PID_autotune_18: (+1)
   \   00000300   0xEEB0 0x0A00      VMOV.F32 S0,#2.0
   \   00000304   0xEE38 0xAA80      VADD.F32 S20,S17,S0
   \   00000308   0xF504 0x409C      ADD      R0,R4,#+19968
   \   0000030C   0x3020             ADDS     R0,R0,#+32
   \   0000030E   0x9005             STR      R0,[SP, #+20]
   \   00000310   0xE01F             B.N      ??PID_autotune_16
   \                     ??PID_autotune_17: (+1)
   \   00000312   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000316   0xD109             BNE.N    ??PID_autotune_19
   \   00000318   0x9805             LDR      R0,[SP, #+20]
   \   0000031A   0x1A20             SUBS     R0,R4,R0
   \   0000031C   0xD406             BMI.N    ??PID_autotune_19
   \   0000031E   0x.... 0x....      ADR.W    R1,`?<Constant "Heating failed">`
   \   00000322   0x460A             MOV      R2,R1
   \   00000324   0x2000             MOVS     R0,#+0
   \   00000326   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \   0000032A   0xE012             B.N      ??PID_autotune_16
   \                     ??PID_autotune_19: (+1)
   \   0000032C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000330   0xD00F             BEQ.N    ??PID_autotune_16
   \   00000332   0xEEBB 0x0A04      VMOV.F32 S0,#-20.0
   \   00000336   0xEE38 0x0A00      VADD.F32 S0,S16,S0
   \   0000033A   0xEEF4 0x8A40      VCMP.F32 S17,S0
   \   0000033E   0xEEF1 0xFA10      FMSTAT   
   \   00000342   0xD506             BPL.N    ??PID_autotune_16
   \   00000344   0x.... 0x....      ADR.W    R2,`?<Constant "THERMAL RUNAWAY">`
   \   00000348   0x.... 0x....      ADR.W    R1,`?<Constant "Thermal Runaway">`
   \   0000034C   0x2000             MOVS     R0,#+0
   \   0000034E   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \                     ??PID_autotune_16: (+1)
   \   00000352   0x9804             LDR      R0,[SP, #+16]
   \   00000354   0xEBC0 0x0044      RSB      R0,R0,R4, LSL #+1
   \   00000358   0x9903             LDR      R1,[SP, #+12]
   \   0000035A   0x1A40             SUBS     R0,R0,R1
   \   0000035C   0x.... 0x....      LDR.W    R1,??DataTable42_11  ;; 0x124f81
   \   00000360   0x4288             CMP      R0,R1
   \   00000362   0xD309             BCC.N    ??PID_autotune_20
   \   00000364   0x.... 0x....      ADR.W    R0,`?<Constant "PID Autotune failed! ...">_2`
   \   00000368   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   0000036C   0xE7A8             B.N      ??PID_autotune_4
   \   0000036E   0xBF00             Nop      
   \                     ??PID_autotune_0:
   \   00000370   0x00000000         DC32     0x0
   \   00000374   0x461C4000         DC32     0x461c4000
   \                     ??PID_autotune_20: (+1)
   \   00000378   0xF99D 0x0044      LDRSB    R0,[SP, #+68]
   \   0000037C   0x4540             CMP      R0,R8
   \   0000037E   0xF6BF 0xAE96      BGE.W    ??PID_autotune_3
   \   00000382   0x.... 0x....      ADR.W    R0,`?<Constant "PID Autotune finished...">`
   \   00000386   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   0000038A   0xEEB0 0x0A6A      VMOV.F32 S0,S21
   \   0000038E   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_Kp ">`
   \   00000392   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000396   0x210A             MOVS     R1,#+10
   \   00000398   0x.... 0x....      LDR.W    R0,??DataTable42
   \   0000039C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000003A0   0xEEB0 0x0A4B      VMOV.F32 S0,S22
   \   000003A4   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_Ki ">`
   \   000003A8   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000003AC   0x210A             MOVS     R1,#+10
   \   000003AE   0x.... 0x....      LDR.W    R0,??DataTable42
   \   000003B2   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000003B6   0xEEB0 0x0A6B      VMOV.F32 S0,S23
   \   000003BA   0x.... 0x....      ADR.W    R0,`?<Constant "#define  DEFAULT_Kd ">`
   \   000003BE   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000003C2   0x210A             MOVS     R1,#+10
   \   000003C4   0x.... 0x....      LDR.W    R0,??DataTable42
   \   000003C8   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000003CC   0xF89D 0x0048      LDRB     R0,[SP, #+72]
   \   000003D0   0x2800             CMP      R0,#+0
   \   000003D2   0xF43F 0xAF7B      BEQ.W    ??PID_autotune_15
   \   000003D6   0xEDCB 0xAA0A      VSTR     S21,[R11, #+40]
   \   000003DA   0xEE1B 0x0A10      VMOV     R0,S22
   \   000003DE   0x.... 0x....      BL       __aeabi_f2d
   \   000003E2   0x.... 0x....      LDR.W    R2,??DataTable42_12  ;; 0x88e368f1
   \   000003E6   0x.... 0x....      LDR.W    R3,??DataTable42_13  ;; 0x3fc4f8b5
   \   000003EA   0x.... 0x....      BL       __aeabi_dmul
   \   000003EE   0x.... 0x....      BL       __aeabi_d2f
   \   000003F2   0xF8CB 0x002C      STR      R0,[R11, #+44]
   \   000003F6   0xEE1B 0x0A90      VMOV     R0,S23
   \   000003FA   0x.... 0x....      BL       __aeabi_f2d
   \   000003FE   0x.... 0x....      LDR.W    R2,??DataTable42_12  ;; 0x88e368f1
   \   00000402   0x.... 0x....      LDR.W    R3,??DataTable42_13  ;; 0x3fc4f8b5
   \   00000406   0x.... 0x....      BL       __aeabi_ddiv
   \   0000040A   0x.... 0x....      BL       __aeabi_d2f
   \   0000040E   0xF8CB 0x0030      STR      R0,[R11, #+48]
   \   00000412   0xB006             ADD      SP,SP,#+24
   \   00000414   0xECBD 0x8B0A      VPOP     {D8-D12}
   \   00000418   0xE8BD 0x4FF7      POP      {R0-R2,R4-R11,LR}
   \   0000041C   0x.... 0x....      B.W      _ZN11Temperature9updatePIDEv
    499            }
    500          
    501          #endif // HAS_PID_HEATING
    502          
    503          /**
    504           * Class and Instance Methods
    505           */
    506          

   \                                 In section .text, align 2, keep-with-next
    507          Temperature::Temperature() { }
   \                     _ZN11TemperatureC1Ev: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    508          

   \                                 In section .text, align 2, keep-with-next
    509          int Temperature::getHeaterPower(int heater) {
    510            return heater < 0 ? soft_pwm_amount_bed : soft_pwm_amount[heater];
   \                     _ZN11Temperature14getHeaterPowerEi: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable42_1
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD501             BPL.N    ??getHeaterPower_0
   \   00000008   0x78C8             LDRB     R0,[R1, #+3]
   \   0000000A   0x4770             BX       LR
   \                     ??getHeaterPower_0: (+1)
   \   0000000C   0x1840             ADDS     R0,R0,R1
   \   0000000E   0x7880             LDRB     R0,[R0, #+2]
   \   00000010   0x4770             BX       LR               ;; return
    511          }
    512          
    513          #if HAS_AUTO_FAN
    514          
    515            void Temperature::checkExtruderAutoFans() {
    516              static const int8_t fanPin[] PROGMEM = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN };
    517              static const uint8_t fanBit[] PROGMEM = {
    518                              0,
    519                AUTO_1_IS_0 ? 0 :               1,
    520                AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
    521                AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 :               3,
    522                AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4
    523              };
    524              uint8_t fanState = 0;
    525          
    526              HOTEND_LOOP()
    527                if (current_temperature[e] > EXTRUDER_AUTO_FAN_TEMPERATURE)
    528                  SBI(fanState, pgm_read_byte(&fanBit[e]));
    529          
    530              uint8_t fanDone = 0;
    531              for (uint8_t f = 0; f < COUNT(fanPin); f++) {
    532                int8_t pin = pgm_read_byte(&fanPin[f]);
    533                const uint8_t bit = pgm_read_byte(&fanBit[f]);
    534                if (pin >= 0 && !TEST(fanDone, bit)) {
    535                  uint8_t newFanSpeed = TEST(fanState, bit) ? EXTRUDER_AUTO_FAN_SPEED : 0;
    536                  // this idiom allows both digital and PWM fan outputs (see M42 handling).
    537                  digitalWrite(pin, newFanSpeed);
    538                  analogWrite(pin, newFanSpeed);
    539                  SBI(fanDone, bit);
    540                }
    541              }
    542            }
    543          
    544          #endif // HAS_AUTO_FAN
    545          
    546          //
    547          // Temperature Error Handlers
    548          //

   \                                 In section .text, align 2, keep-with-next
    549          void Temperature::_temp_error(const int8_t e, const char * const serial_msg, const char * const lcd_msg) {
   \                     _ZN11Temperature11_temp_errorEaPKcS1_: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    550            static bool killed = false;
    551            if (IsRunning()) {
   \   00000006   0x.... 0x....      BL       _Z9IsRunningv
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD01C             BEQ.N    ??_temp_error_0
    552              SERIAL_ERROR_START();
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable42_14
   \   00000012   0x.... 0x....      BL       _Z14serialprintPGMPKc
    553              serialprintPGM(serial_msg);
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       _Z14serialprintPGMPKc
    554              SERIAL_ERRORPGM(MSG_STOPPED_HEATER);
   \   0000001C   0x.... 0x....      ADR.W    R0,`?<Constant ", system stopped! Hea...">`
   \   00000020   0x.... 0x....      BL       _Z14serialprintPGMPKc
    555              if (e >= 0) {SERIAL_ERRORLN((int)e);} else {SERIAL_ERRORLNPGM(MSG_HEATER_BED);}
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD40B             BMI.N    ??_temp_error_1
   \   00000028   0x.... 0x....      LDR.W    R5,??DataTable42
   \   0000002C   0x220A             MOVS     R2,#+10
   \   0000002E   0x4621             MOV      R1,R4
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x.... 0x....      BL       _ZN5Print5printEii
   \   00000036   0x210A             MOVS     R1,#+10
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   0000003E   0xE003             B.N      ??_temp_error_0
   \                     ??_temp_error_1: (+1)
   \   00000040   0x.... 0x....      ADR.W    R0,`?<Constant "bed\\n">`
   \   00000044   0x.... 0x....      BL       _Z14serialprintPGMPKc
    556            }
    557            #if DISABLED(BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE)
    558              if (!killed) {
   \                     ??_temp_error_0: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable42_15
   \   0000004C   0x7801             LDRB     R1,[R0, #+0]
   \   0000004E   0x2900             CMP      R1,#+0
   \   00000050   0xD106             BNE.N    ??_temp_error_2
    559                Running = false;
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x.... 0x....      LDR.W    R2,??DataTable42_16
   \   00000058   0x7011             STRB     R1,[R2, #+0]
    560                killed = true;
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0x7001             STRB     R1,[R0, #+0]
   \   0000005E   0xBD31             POP      {R0,R4,R5,PC}
    561                //kill(lcd_msg);
    562              }
    563              else
    564                disable_all_heaters(); // paranoia
   \                     ??_temp_error_2: (+1)
   \   00000060   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000064   0x....             B.N      _ZN11Temperature19disable_all_heatersEv
    565            #endif
    566          }

   \                                 In section .bss, align 1
   \                     ??killed:
   \   00000000                      DS8 1
    567          

   \                                 In section .text, align 2, keep-with-next
    568          void Temperature::max_temp_error(const int8_t e) {
    569            #if HAS_TEMP_BED
    570              _temp_error(e, PSTR(MSG_T_MAXTEMP), e >= 0 ? PSTR(MSG_ERR_MAXTEMP) : PSTR(MSG_ERR_MAXTEMP_BED));
    571            #else
    572              _temp_error(HOTEND_INDEX, PSTR(MSG_T_MAXTEMP), PSTR(MSG_ERR_MAXTEMP));
   \                     _ZN11Temperature14max_temp_errorEa: (+1)
   \   00000000   0x.... 0x....      ADR.W    R2,`?<Constant "Err: MAXTEMP">`
   \   00000004   0x.... 0x....      ADR.W    R1,`?<Constant "MAXTEMP triggered">`
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             B.N      _ZN11Temperature11_temp_errorEaPKcS1_
    573              #if HOTENDS == 1
    574                UNUSED(e);
    575              #endif
    576            #endif
    577          }

   \                                 In section .text, align 2, keep-with-next
    578          void Temperature::min_temp_error(const int8_t e) {
    579            #if HAS_TEMP_BED
    580              _temp_error(e, PSTR(MSG_T_MINTEMP), e >= 0 ? PSTR(MSG_ERR_MINTEMP) : PSTR(MSG_ERR_MINTEMP_BED));
    581            #else
    582              _temp_error(HOTEND_INDEX, PSTR(MSG_T_MINTEMP), PSTR(MSG_ERR_MINTEMP));
   \                     _ZN11Temperature14min_temp_errorEa: (+1)
   \   00000000   0x.... 0x....      ADR.W    R2,`?<Constant "Err: MINTEMP">`
   \   00000004   0x.... 0x....      ADR.W    R1,`?<Constant "MINTEMP triggered">`
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             B.N      _ZN11Temperature11_temp_errorEaPKcS1_
    583              #if HOTENDS == 1
    584                UNUSED(e);
    585              #endif
    586            #endif
    587          }
    588          

   \                                 In section .text, align 4, keep-with-next
    589          float Temperature::get_pid_output(const int8_t e) {
   \                     _ZN11Temperature14get_pid_outputEa: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
    590            #if HOTENDS == 1
    591              UNUSED(e);
    592              #define _HOTEND_TEST     true
    593            #else
    594              #define _HOTEND_TEST     e == active_extruder
    595            #endif
    596            float pid_output;
    597            #if ENABLED(PIDTEMP)
    598              #if DISABLED(PID_OPENLOOP)
    599                pid_error[HOTEND_INDEX] = target_temperature[HOTEND_INDEX] - current_temperature[HOTEND_INDEX];
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable42_1
   \   0000000A   0xED96 0x8A06      VLDR     S16,[R6, #+24]
   \   0000000E   0x6A37             LDR      R7,[R6, #+32]
   \   00000010   0xEE00 0x7A10      VMOV     S0,R7
   \   00000014   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000018   0xEE70 0x8A48      VSUB.F32 S17,S0,S16
   \   0000001C   0xEDC6 0x8A13      VSTR     S17,[R6, #+76]
    600                dTerm[HOTEND_INDEX] = PID_K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + PID_K1 * dTerm[HOTEND_INDEX];
   \   00000020   0x6B30             LDR      R0,[R6, #+48]
   \   00000022   0x.... 0x....      BL       __aeabi_f2d
   \   00000026   0x.... 0x....      LDR.W    R2,??DataTable42_17  ;; 0x999999a0
   \   0000002A   0x.... 0x....      LDR.W    R3,??DataTable42_18  ;; 0x3fa99999
   \   0000002E   0x.... 0x....      BL       __aeabi_dmul
   \   00000032   0x4604             MOV      R4,R0
   \   00000034   0x460D             MOV      R5,R1
   \   00000036   0xED96 0x0A0F      VLDR     S0,[R6, #+60]
   \   0000003A   0xEE38 0x0A40      VSUB.F32 S0,S16,S0
   \   0000003E   0xEE10 0x0A10      VMOV     R0,S0
   \   00000042   0x.... 0x....      BL       __aeabi_f2d
   \   00000046   0x4622             MOV      R2,R4
   \   00000048   0x462B             MOV      R3,R5
   \   0000004A   0x.... 0x....      BL       __aeabi_dmul
   \   0000004E   0x4604             MOV      R4,R0
   \   00000050   0x460D             MOV      R5,R1
   \   00000052   0x6CB0             LDR      R0,[R6, #+72]
   \   00000054   0x.... 0x....      BL       __aeabi_f2d
   \   00000058   0xF04F 0x3266      MOV      R2,#+1717986918
   \   0000005C   0x.... 0x....      LDR.W    R3,??DataTable42_19  ;; 0x3fee6666
   \   00000060   0x.... 0x....      BL       __aeabi_dmul
   \   00000064   0x4622             MOV      R2,R4
   \   00000066   0x462B             MOV      R3,R5
   \   00000068   0x.... 0x....      BL       __aeabi_dadd
   \   0000006C   0x.... 0x....      BL       __aeabi_d2f
   \   00000070   0xEE00 0x0A10      VMOV     S0,R0
   \   00000074   0xED86 0x0A12      VSTR     S0,[R6, #+72]
    601                temp_dState[HOTEND_INDEX] = current_temperature[HOTEND_INDEX];
   \   00000078   0xED86 0x8A0F      VSTR     S16,[R6, #+60]
    602                #if HEATER_IDLE_HANDLER
    603                  if (heater_idle_timeout_exceeded[HOTEND_INDEX]) {
    604                    pid_output = 0;
    605                    pid_reset[HOTEND_INDEX] = true;
    606                  }
    607                  else
    608                #endif
    609                if (pid_error[HOTEND_INDEX] > PID_FUNCTIONAL_RANGE) {
   \   0000007C   0xEDDF 0x....      VLDR.W   S1,??DataTable38  ;; 0x41200001
   \   00000080   0xEEF4 0x8A60      VCMP.F32 S17,S1
   \   00000084   0xEEF1 0xFA10      FMSTAT   
   \   00000088   0xDB04             BLT.N    ??get_pid_output_0
    610                  pid_output = BANG_MAX;
   \   0000008A   0xED9F 0x....      VLDR.W   S0,??DataTable38_1  ;; 0x437f0000
    611                  pid_reset[HOTEND_INDEX] = true;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x7070             STRB     R0,[R6, #+1]
   \   00000092   0xE04C             B.N      ??get_pid_output_1
    612                }
    613                else if (pid_error[HOTEND_INDEX] < -(PID_FUNCTIONAL_RANGE) || target_temperature[HOTEND_INDEX] == 0
    614                  #if HEATER_IDLE_HANDLER
    615                    || heater_idle_timeout_exceeded[HOTEND_INDEX]
    616                  #endif
    617                  ) {
   \                     ??get_pid_output_0: (+1)
   \   00000094   0xEEFA 0x0A04      VMOV.F32 S1,#-10.0
   \   00000098   0xEEF4 0x8A60      VCMP.F32 S17,S1
   \   0000009C   0xEEF1 0xFA10      FMSTAT   
   \   000000A0   0xD401             BMI.N    ??get_pid_output_2
   \   000000A2   0x2F00             CMP      R7,#+0
   \   000000A4   0xD104             BNE.N    ??get_pid_output_3
    618                  pid_output = 0;
   \                     ??get_pid_output_2: (+1)
   \   000000A6   0xED9F 0x....      VLDR.W   S0,??DataTable38_2  ;; 0x0
    619                  pid_reset[HOTEND_INDEX] = true;
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0x7070             STRB     R0,[R6, #+1]
   \   000000AE   0xE03E             B.N      ??get_pid_output_1
    620                }
    621                else {
    622                  if (pid_reset[HOTEND_INDEX]) {
   \                     ??get_pid_output_3: (+1)
   \   000000B0   0x7870             LDRB     R0,[R6, #+1]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD002             BEQ.N    ??get_pid_output_4
    623                    temp_iState[HOTEND_INDEX] = 0.0;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x63B0             STR      R0,[R6, #+56]
    624                    pid_reset[HOTEND_INDEX] = false;
   \   000000BA   0x7070             STRB     R0,[R6, #+1]
    625                  }
    626                  pTerm[HOTEND_INDEX] = PID_PARAM(Kp, HOTEND_INDEX) * pid_error[HOTEND_INDEX];
   \                     ??get_pid_output_4: (+1)
   \   000000BC   0xEDD6 0x0A0A      VLDR     S1,[R6, #+40]
   \   000000C0   0xEE60 0x0AA8      VMUL.F32 S1,S1,S17
   \   000000C4   0xEDC6 0x0A10      VSTR     S1,[R6, #+64]
    627                  temp_iState[HOTEND_INDEX] += pid_error[HOTEND_INDEX];
   \   000000C8   0xED96 0x1A0E      VLDR     S2,[R6, #+56]
   \   000000CC   0xEE31 0x1A28      VADD.F32 S2,S2,S17
   \   000000D0   0xED86 0x1A0E      VSTR     S2,[R6, #+56]
    628                  iTerm[HOTEND_INDEX] = PID_PARAM(Ki, HOTEND_INDEX) * temp_iState[HOTEND_INDEX];
   \   000000D4   0xEDD6 0x1A0B      VLDR     S3,[R6, #+44]
   \   000000D8   0xEE61 0x1A81      VMUL.F32 S3,S3,S2
   \   000000DC   0xEDC6 0x1A11      VSTR     S3,[R6, #+68]
    629          
    630                  pid_output = pTerm[HOTEND_INDEX] + iTerm[HOTEND_INDEX] - dTerm[HOTEND_INDEX];
   \   000000E0   0xEE70 0x0AA1      VADD.F32 S1,S1,S3
   \   000000E4   0xEE30 0x0AC0      VSUB.F32 S0,S1,S0
    631          
    632                  #if ENABLED(PID_EXTRUSION_SCALING)
    633                    cTerm[HOTEND_INDEX] = 0;
    634                    if (_HOTEND_TEST) {
    635                      long e_position = stepper.position(E_AXIS);
    636                      if (e_position > last_e_position) {
    637                        lpq[lpq_ptr] = e_position - last_e_position;
    638                        last_e_position = e_position;
    639                      }
    640                      else {
    641                        lpq[lpq_ptr] = 0;
    642                      }
    643                      if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
    644                      cTerm[HOTEND_INDEX] = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
    645                      pid_output += cTerm[HOTEND_INDEX];
    646                    }
    647                  #endif // PID_EXTRUSION_SCALING
    648          
    649                  if (pid_output > PID_MAX) {
   \   000000E8   0xEDDF 0x....      VLDR.W   S1,??DataTable38_3  ;; 0x437f0001
   \   000000EC   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000000F0   0xEEF1 0xFA10      FMSTAT   
   \   000000F4   0xDB0B             BLT.N    ??get_pid_output_5
    650                    if (pid_error[HOTEND_INDEX] > 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
   \   000000F6   0xEEF5 0x8A40      VCMP.F32 S17,#0.0
   \   000000FA   0xEEF1 0xFA10      FMSTAT   
   \   000000FE   0xDD03             BLE.N    ??get_pid_output_6
   \   00000100   0xEE31 0x0A68      VSUB.F32 S0,S2,S17
   \   00000104   0xED86 0x0A0E      VSTR     S0,[R6, #+56]
    651                    pid_output = PID_MAX;
   \                     ??get_pid_output_6: (+1)
   \   00000108   0xED9F 0x....      VLDR.W   S0,??DataTable38_1  ;; 0x437f0000
   \   0000010C   0xE00F             B.N      ??get_pid_output_1
    652                  }
    653                  else if (pid_output < 0) {
   \                     ??get_pid_output_5: (+1)
   \   0000010E   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000112   0xEEF1 0xFA10      FMSTAT   
   \   00000116   0xD50A             BPL.N    ??get_pid_output_1
    654                    if (pid_error[HOTEND_INDEX] < 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
   \   00000118   0xEEF5 0x8A40      VCMP.F32 S17,#0.0
   \   0000011C   0xEEF1 0xFA10      FMSTAT   
   \   00000120   0xD503             BPL.N    ??get_pid_output_7
   \   00000122   0xEE31 0x0A68      VSUB.F32 S0,S2,S17
   \   00000126   0xED86 0x0A0E      VSTR     S0,[R6, #+56]
    655                    pid_output = 0;
   \                     ??get_pid_output_7: (+1)
   \   0000012A   0xED9F 0x....      VLDR.W   S0,??DataTable38_2  ;; 0x0
    656                  }
    657                }
    658              #else
    659                pid_output = constrain(target_temperature[HOTEND_INDEX], 0, PID_MAX);
    660              #endif // PID_OPENLOOP
    661          
    662              #if ENABLED(PID_DEBUG)
    663                SERIAL_ECHO_START();
    664                SERIAL_ECHOPAIR(MSG_PID_DEBUG, HOTEND_INDEX);
    665                SERIAL_ECHOPAIR(MSG_PID_DEBUG_INPUT, current_temperature[HOTEND_INDEX]);
    666                SERIAL_ECHOPAIR(MSG_PID_DEBUG_OUTPUT, pid_output);
    667                SERIAL_ECHOPAIR(MSG_PID_DEBUG_PTERM, pTerm[HOTEND_INDEX]);
    668                SERIAL_ECHOPAIR(MSG_PID_DEBUG_ITERM, iTerm[HOTEND_INDEX]);
    669                SERIAL_ECHOPAIR(MSG_PID_DEBUG_DTERM, dTerm[HOTEND_INDEX]);
    670                #if ENABLED(PID_EXTRUSION_SCALING)
    671                  SERIAL_ECHOPAIR(MSG_PID_DEBUG_CTERM, cTerm[HOTEND_INDEX]);
    672                #endif
    673                SERIAL_EOL();
    674              #endif // PID_DEBUG
    675          
    676            #else /* PID off */
    677              #if HEATER_IDLE_HANDLER
    678                if (heater_idle_timeout_exceeded[HOTEND_INDEX])
    679                  pid_output = 0;
    680                else
    681              #endif
    682              pid_output = (current_temperature[HOTEND_INDEX] < target_temperature[HOTEND_INDEX]) ? PID_MAX : 0;
    683            #endif
    684          
    685            return pid_output;
   \                     ??get_pid_output_1: (+1)
   \   0000012E   0xECBD 0x8B02      VPOP     {D8}
   \   00000132   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    686          }
    687          
    688          #if ENABLED(PIDTEMPBED)
    689            float Temperature::get_pid_output_bed() {
    690              float pid_output;
    691              #if DISABLED(PID_OPENLOOP)
    692                pid_error_bed = target_temperature_bed - current_temperature_bed;
    693                pTerm_bed = bedKp * pid_error_bed;
    694                temp_iState_bed += pid_error_bed;
    695                iTerm_bed = bedKi * temp_iState_bed;
    696          
    697                dTerm_bed = PID_K2 * bedKd * (current_temperature_bed - temp_dState_bed) + PID_K1 * dTerm_bed;
    698                temp_dState_bed = current_temperature_bed;
    699          
    700                pid_output = pTerm_bed + iTerm_bed - dTerm_bed;
    701                if (pid_output > MAX_BED_POWER) {
    702                  if (pid_error_bed > 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
    703                  pid_output = MAX_BED_POWER;
    704                }
    705                else if (pid_output < 0) {
    706                  if (pid_error_bed < 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
    707                  pid_output = 0;
    708                }
    709              #else
    710                pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);
    711              #endif // PID_OPENLOOP
    712          
    713              #if ENABLED(PID_BED_DEBUG)
    714                SERIAL_ECHO_START();
    715                SERIAL_ECHOPGM(" PID_BED_DEBUG ");
    716                SERIAL_ECHOPGM(": Input ");
    717                SERIAL_ECHO(current_temperature_bed);
    718                SERIAL_ECHOPGM(" Output ");
    719                SERIAL_ECHO(pid_output);
    720                SERIAL_ECHOPGM(" pTerm ");
    721                SERIAL_ECHO(pTerm_bed);
    722                SERIAL_ECHOPGM(" iTerm ");
    723                SERIAL_ECHO(iTerm_bed);
    724                SERIAL_ECHOPGM(" dTerm ");
    725                SERIAL_ECHOLN(dTerm_bed);
    726              #endif // PID_BED_DEBUG
    727          
    728              return pid_output;
    729            }
    730          #endif // PIDTEMPBED
    731          
    732          /**
    733           * Manage heating activities for extruder hot-ends and a heated bed
    734           *  - Acquire updated temperature readings
    735           *    - Also resets the watchdog timer
    736           *  - Invoke thermal runaway protection
    737           *  - Manage extruder auto-fan
    738           *  - Apply filament width to the extrusion rate (may move)
    739           *  - Update the heated bed PID output value
    740           */
    741          static float current_temper_bak;
    742          

   \                                 In section .text, align 2, keep-with-next
    743          void Temperature::manage_heater() {
   \                     _ZN11Temperature13manage_heaterEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0xB082             SUB      SP,SP,#+8
    744          
    745            if (!temp_meas_ready) return;
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable42_1
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD068             BEQ.N    ??manage_heater_0
    746          
    747            updateTemperaturesFromRawValues(); // also resets the watchdog
   \   00000014   0x.... 0x....      BL       _ZN11Temperature31updateTemperaturesFromRawValuesEv
    748          
    749            #if ENABLED(HEATER_0_USES_MAX6675)
    750              if (current_temperature[0] > min(HEATER_0_MAXTEMP, MAX6675_TMAX - 1.0)) max_temp_error(0);
    751              if (current_temperature[0] < max(HEATER_0_MINTEMP, MAX6675_TMIN + .01)) min_temp_error(0);
    752            #endif
    753          
    754            #if WATCH_HOTENDS || WATCH_THE_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN || HEATER_IDLE_HANDLER
    755              millis_t ms = millis();
   \   00000018   0x.... 0x....      BL       HAL_GetTick
   \   0000001C   0x4605             MOV      R5,R0
    756            #endif
    757          
    758            HOTEND_LOOP() {
   \   0000001E   0x2600             MOVS     R6,#+0
   \   00000020   0xE005             B.N      ??manage_heater_1
    759          
    760              #if HEATER_IDLE_HANDLER
    761                if (!heater_idle_timeout_exceeded[e] && heater_idle_timeout_ms[e] && ELAPSED(ms, heater_idle_timeout_ms[e]))
    762                  heater_idle_timeout_exceeded[e] = true;
    763              #endif
    764          
    765              #if ENABLED(THERMAL_PROTECTION_HOTENDS)
    766                // Check for thermal runaway
    767                thermal_runaway_protection(&thermal_runaway_state_machine[e], &thermal_runaway_timer[e], current_temperature[e], target_temperature[e], e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
    768              #endif
    769          
    770              soft_pwm_amount[e] = (current_temperature[e] > minttemp[e] || is_preheating(e)) && current_temperature[e] < maxttemp[e] ? (int)get_pid_output(e) >> 1 : 0;
    771          
    772              #if WATCH_HOTENDS
    773                // Make sure temperature is increasing
    774                if (watch_heater_next_ms[e] && ELAPSED(ms, watch_heater_next_ms[e])) { // Time to check this extruder?
    775                  if (degHotend(e) < watch_target_temp[e])                             // Failed to increase enough?
    776                    _temp_error(e, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
    777                  else                                                                 // Start again if the target is still far off
    778                    start_watching_heater(e);
   \                     ??manage_heater_2: (+1)
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x.... 0x....      BL       _ZN11Temperature21start_watching_heaterEh
   \                     ??manage_heater_3: (+1)
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
   \   0000002C   0xB276             SXTB     R6,R6
   \                     ??manage_heater_1: (+1)
   \   0000002E   0x2E01             CMP      R6,#+1
   \   00000030   0xDA52             BGE.N    ??manage_heater_4
   \   00000032   0xEB04 0x0786      ADD      R7,R4,R6, LSL #+2
   \   00000036   0x2004             MOVS     R0,#+4
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x2328             MOVS     R3,#+40
   \   0000003C   0x4632             MOV      R2,R6
   \   0000003E   0xED97 0x0A08      VLDR     S0,[R7, #+32]
   \   00000042   0xEEF8 0x0AC0      VCVT.F32.S32 S1,S0
   \   00000046   0xED97 0x0A06      VLDR     S0,[R7, #+24]
   \   0000004A   0xF107 0x0158      ADD      R1,R7,#+88
   \   0000004E   0x1930             ADDS     R0,R6,R4
   \   00000050   0x3054             ADDS     R0,R0,#+84
   \   00000052   0x.... 0x....      BL       _ZN11Temperature26thermal_runaway_protectionEPNS_7TRStateEPmffatt
   \   00000056   0xED97 0x0A06      VLDR     S0,[R7, #+24]
   \   0000005A   0xEB04 0x0846      ADD      R8,R4,R6, LSL #+1
   \   0000005E   0xF9B8 0x0016      LDRSH    R0,[R8, #+22]
   \   00000062   0xEE00 0x0A90      VMOV     S1,R0
   \   00000066   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000006A   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   0000006E   0xEEF1 0xFA10      FMSTAT   
   \   00000072   0xD513             BPL.N    ??manage_heater_5
   \   00000074   0xF9B8 0x0010      LDRSH    R0,[R8, #+16]
   \   00000078   0xEE00 0x0A90      VMOV     S1,R0
   \   0000007C   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000080   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000084   0xEEF1 0xFA10      FMSTAT   
   \   00000088   0xD508             BPL.N    ??manage_heater_5
   \   0000008A   0x4630             MOV      R0,R6
   \   0000008C   0x.... 0x....      BL       _ZN11Temperature14get_pid_outputEa
   \   00000090   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000094   0xEE10 0x0A10      VMOV     R0,S0
   \   00000098   0x1040             ASRS     R0,R0,#+1
   \   0000009A   0xE000             B.N      ??manage_heater_6
   \                     ??manage_heater_5: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \                     ??manage_heater_6: (+1)
   \   0000009E   0x1931             ADDS     R1,R6,R4
   \   000000A0   0x7088             STRB     R0,[R1, #+2]
   \   000000A2   0x6B78             LDR      R0,[R7, #+52]
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD0C0             BEQ.N    ??manage_heater_3
   \   000000A8   0x1A28             SUBS     R0,R5,R0
   \   000000AA   0xD4BE             BMI.N    ??manage_heater_3
   \   000000AC   0xF8B8 0x000C      LDRH     R0,[R8, #+12]
   \   000000B0   0xEE00 0x0A10      VMOV     S0,R0
   \   000000B4   0xEEB8 0x8A40      VCVT.F32.U32 S16,S0
   \   000000B8   0x4630             MOV      R0,R6
   \   000000BA   0xB2C0             UXTB     R0,R0
   \   000000BC   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   000000C0   0xEEB4 0x0A48      VCMP.F32 S0,S16
   \   000000C4   0xEEF1 0xFA10      FMSTAT   
   \   000000C8   0xD5AB             BPL.N    ??manage_heater_2
   \   000000CA   0x.... 0x....      ADR.W    R1,`?<Constant "Heating failed">`
   \   000000CE   0x460A             MOV      R2,R1
   \   000000D0   0x4630             MOV      R0,R6
   \   000000D2   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEaPKcS1_
   \   000000D6   0xE7A8             B.N      ??manage_heater_3
    779                }
    780              #endif
    781          
    782              #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    783                // Make sure measured temperatures are close together
    784                if (FABS(current_temperature[0] - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF)
    785                  _temp_error(0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
    786              #endif
    787          
    788            } // HOTEND_LOOP
    789          
    790            #if HAS_AUTO_FAN
    791              if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
    792                checkExtruderAutoFans();
    793                next_auto_fan_check_ms = ms + 2500UL;
    794              }
    795            #endif
    796          
    797            #if ENABLED(FILAMENT_WIDTH_SENSOR)
    798              /**
    799               * Filament Width Sensor dynamically sets the volumetric multiplier
    800               * based on a delayed measurement of the filament diameter.
    801               */
    802              if (filament_sensor) {
    803                meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
    804                if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
    805                meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
    806                planner.calculate_volumetric_for_width_sensor(measurement_delay[meas_shift_index]);
    807              }
    808            #endif // FILAMENT_WIDTH_SENSOR
    809          
    810            #if WATCH_THE_BED
    811              // Make sure temperature is increasing
    812              if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {        // Time to check the bed?
    813                if (degBed() < watch_target_bed_temp)                           // Failed to increase enough?
    814                  _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
    815                else                                                            // Start again if the target is still far off
    816                  start_watching_bed();
    817              }
    818            #endif // WATCH_THE_BED
    819          
    820            #if DISABLED(PIDTEMPBED)
    821              if (PENDING(ms, next_bed_check_ms)) return;
   \                     ??manage_heater_4: (+1)
   \   000000D8   0x6D20             LDR      R0,[R4, #+80]
   \   000000DA   0x1A28             SUBS     R0,R5,R0
   \   000000DC   0xD403             BMI.N    ??manage_heater_0
    822              next_bed_check_ms = ms + BED_CHECK_INTERVAL;
   \   000000DE   0xF505 0x5098      ADD      R0,R5,#+4864
   \   000000E2   0x3088             ADDS     R0,R0,#+136
   \   000000E4   0x6520             STR      R0,[R4, #+80]
    823            #endif
    824          
    825            #if HAS_TEMP_BED
    826          
    827              #if HEATER_IDLE_HANDLER
    828                if (!bed_idle_timeout_exceeded && bed_idle_timeout_ms && ELAPSED(ms, bed_idle_timeout_ms))
    829                  bed_idle_timeout_exceeded = true;
    830              #endif
    831          
    832              #if HAS_THERMALLY_PROTECTED_BED
    833                thermal_runaway_protection(&thermal_runaway_bed_state_machine, &thermal_runaway_bed_timer, current_temperature_bed, target_temperature_bed, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
    834              #endif
    835          
    836              #if HEATER_IDLE_HANDLER
    837                if (bed_idle_timeout_exceeded)
    838                {
    839                  soft_pwm_amount_bed = 0;
    840          
    841                  #if DISABLED(PIDTEMPBED)
    842                    WRITE_HEATER_BED(LOW);
    843                  #endif
    844                }
    845                else
    846              #endif
    847              {
    848                #if ENABLED(PIDTEMPBED)
    849                  soft_pwm_amount_bed = WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP) ? (int)get_pid_output_bed() >> 1 : 0;
    850          
    851                #elif ENABLED(BED_LIMIT_SWITCHING)
    852                  // Check if temperature is within the correct band
    853                  if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
    854                    if (current_temperature_bed >= target_temperature_bed + BED_HYSTERESIS)
    855                      soft_pwm_amount_bed = 0;
    856                    else if (current_temperature_bed <= target_temperature_bed - (BED_HYSTERESIS))
    857                      soft_pwm_amount_bed = MAX_BED_POWER >> 1;
    858                  }
    859                  else {
    860                    soft_pwm_amount_bed = 0;
    861                    WRITE_HEATER_BED(LOW);
    862                  }
    863                #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
    864                  // Check if temperature is within the correct range
    865                  if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
    866                    soft_pwm_amount_bed = current_temperature_bed < target_temperature_bed ? MAX_BED_POWER >> 1 : 0;
    867                  }
    868                  else {
    869                    soft_pwm_amount_bed = 0;
    870                    WRITE_HEATER_BED(LOW);
    871                  }
    872                #endif
    873              }
    874            #endif // HAS_TEMP_BED
    875          }
   \                     ??manage_heater_0: (+1)
   \   000000E6   0xB002             ADD      SP,SP,#+8
   \   000000E8   0xECBD 0x8B02      VPOP     {D8}
   \   000000EC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    876          
    877          //#define PGM_RD_W(x)   (short)pgm_read_word(&x)
    878          #define PGM_RD_W(x)   (short)(x)
    879          
    880          // Derived from RepRap FiveD extruder::getTemperature()
    881          // For hot end temperature measurement.

   \                                 In section .text, align 4, keep-with-next
    882          float Temperature::analog2temp(const int raw, const uint8_t e) {
   \                     _ZN11Temperature11analog2tempEih: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x000C             MOVS     R4,R1
    883            #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    884              if (e > HOTENDS)
    885            #else
    886              if (e >= HOTENDS)
   \   00000004   0xD014             BEQ.N    ??analog2temp_0
    887            #endif
    888              {
    889                SERIAL_ERROR_START();
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable42_14
   \   0000000A   0x.... 0x....      BL       _Z14serialprintPGMPKc
    890                SERIAL_ERROR((int)e);
   \   0000000E   0x220A             MOVS     R2,#+10
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable42
   \   00000016   0x.... 0x....      BL       _ZN5Print5printEii
    891                SERIAL_ERRORLNPGM(MSG_INVALID_EXTRUDER_NUM);
   \   0000001A   0x.... 0x....      ADR.W    R0,`?<Constant " - Invalid extruder n...">`
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
    892                kill(PSTR(MSG_KILLED));
   \   00000022   0x.... 0x....      ADR.W    R0,`?<Constant "KILLED. ">`
   \   00000026   0x.... 0x....      BL       _Z4killPKc
    893                return 0.0;
   \   0000002A   0xED9F 0x....      VLDR.W   S0,??DataTable38_2  ;; 0x0
   \   0000002E   0xBDF1             POP      {R0,R4-R7,PC}
    894              }
    895          
    896            #if ENABLED(HEATER_0_USES_MAX6675)
    897              if (e == 0) return 0.25 * raw;
    898            #endif
    899          
    900            if (heater_ttbl_map[e] != NULL) {
   \                     ??analog2temp_0: (+1)
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable42_20
   \   00000034   0x684A             LDR      R2,[R1, #+4]
   \   00000036   0x2A00             CMP      R2,#+0
   \   00000038   0xD03A             BEQ.N    ??analog2temp_1
    901              float celsius = 0;
   \   0000003A   0xED9F 0x....      VLDR.W   S0,??DataTable38_2  ;; 0x0
    902              uint8_t i;
    903              short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
    904          
    905              for (i = 1; i < heater_ttbllen_map[e]; i++) {
   \   0000003E   0x2301             MOVS     R3,#+1
   \   00000040   0x780C             LDRB     R4,[R1, #+0]
   \   00000042   0xE001             B.N      ??analog2temp_2
   \                     ??analog2temp_3: (+1)
   \   00000044   0x1C5B             ADDS     R3,R3,#+1
   \   00000046   0xB2DB             UXTB     R3,R3
   \                     ??analog2temp_2: (+1)
   \   00000048   0x42A3             CMP      R3,R4
   \   0000004A   0xDA25             BGE.N    ??analog2temp_4
   \   0000004C   0xF932 0x5023      LDRSH    R5,[R2, R3, LSL #+2]
   \   00000050   0x42A8             CMP      R0,R5
   \   00000052   0xDAF7             BGE.N    ??analog2temp_3
    906                if (PGM_RD_W((*tt)[i][0]) > raw) {
    907                  celsius = PGM_RD_W((*tt)[i - 1][1]) +
    908                            (raw - PGM_RD_W((*tt)[i - 1][0])) *
    909                            (float)(PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i - 1][1])) /
    910                            (float)(PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i - 1][0]));
   \   00000054   0xEB02 0x0183      ADD      R1,R2,R3, LSL #+2
   \   00000058   0xF931 0x6C04      LDRSH    R6,[R1, #-4]
   \   0000005C   0x1F0F             SUBS     R7,R1,#+4
   \   0000005E   0xF9B7 0x7002      LDRSH    R7,[R7, #+2]
   \   00000062   0xEE00 0x7A10      VMOV     S0,R7
   \   00000066   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000006A   0x1B80             SUBS     R0,R0,R6
   \   0000006C   0xEE00 0x0A90      VMOV     S1,R0
   \   00000070   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000074   0xF9B1 0x0002      LDRSH    R0,[R1, #+2]
   \   00000078   0x1BC0             SUBS     R0,R0,R7
   \   0000007A   0xEE01 0x0A10      VMOV     S2,R0
   \   0000007E   0xEEB8 0x1AC1      VCVT.F32.S32 S2,S2
   \   00000082   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   00000086   0x1BA8             SUBS     R0,R5,R6
   \   00000088   0xEE01 0x0A10      VMOV     S2,R0
   \   0000008C   0xEEB8 0x1AC1      VCVT.F32.S32 S2,S2
   \   00000090   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   00000094   0xEE30 0x0A20      VADD.F32 S0,S0,S1
    911                  break;
    912                }
    913              }
    914          
    915              // Overflow: Set to last value in the table
    916              if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i - 1][1]);
   \                     ??analog2temp_4: (+1)
   \   00000098   0x42A3             CMP      R3,R4
   \   0000009A   0xD113             BNE.N    ??analog2temp_5
   \   0000009C   0xEB02 0x0083      ADD      R0,R2,R3, LSL #+2
   \   000000A0   0x1F00             SUBS     R0,R0,#+4
   \   000000A2   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   000000A6   0xEE00 0x0A10      VMOV     S0,R0
   \   000000AA   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
    917          
    918              return celsius;
   \   000000AE   0xBDF1             POP      {R0,R4-R7,PC}
    919            }
    920            return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
   \                     ??analog2temp_1: (+1)
   \   000000B0   0x.... 0x....      BL       __aeabi_i2d
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0x....             LDR.N    R3,??DataTable42_21  ;; 0x3f9f4000
   \   000000B8   0x.... 0x....      BL       __aeabi_dmul
   \   000000BC   0x.... 0x....      BL       __aeabi_d2f
   \   000000C0   0xEE00 0x0A10      VMOV     S0,R0
   \                     ??analog2temp_5: (+1)
   \   000000C4   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    921          }
    922          
    923          #if HAS_TEMP_BED
    924            // Derived from RepRap FiveD extruder::getTemperature()
    925            // For bed temperature measurement.
    926            float Temperature::analog2tempBed(const int raw) {
    927              #if ENABLED(BED_USES_THERMISTOR)
    928                float celsius = 0;
    929                byte i;
    930          
    931                for (i = 1; i < BEDTEMPTABLE_LEN; i++) {
    932                  if (PGM_RD_W(BEDTEMPTABLE[i][0]) > raw) {
    933                    celsius  = PGM_RD_W(BEDTEMPTABLE[i - 1][1]) +
    934                               (raw - PGM_RD_W(BEDTEMPTABLE[i - 1][0])) *
    935                               (float)(PGM_RD_W(BEDTEMPTABLE[i][1]) - PGM_RD_W(BEDTEMPTABLE[i - 1][1])) /
    936                               (float)(PGM_RD_W(BEDTEMPTABLE[i][0]) - PGM_RD_W(BEDTEMPTABLE[i - 1][0]));
    937                    break;
    938                  }
    939                }
    940          
    941                // Overflow: Set to last value in the table
    942                if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i - 1][1]);
    943          
    944                return celsius;
    945          
    946              #elif defined(BED_USES_AD595)
    947          
    948                return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
    949          
    950              #else
    951          
    952                UNUSED(raw);
    953                return 0;
    954          
    955              #endif
    956            }
    957          #endif // HAS_TEMP_BED
    958          
    959          /**
    960           * Get the raw values into the actual temperatures.
    961           * The raw values are created in interrupt context,
    962           * and this function is called from normal context
    963           * as it would block the stepper routine.
    964           */

   \                                 In section .text, align 4, keep-with-next
    965          void Temperature::updateTemperaturesFromRawValues() {
   \                     _ZN11Temperature31updateTemperaturesFromRawValuesEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    966            #if ENABLED(HEATER_0_USES_MAX6675)
    967              current_temperature_raw[0] = read_max6675();
    968            #endif
    969            HOTEND_LOOP()
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE00A             B.N      ??updateTemperaturesFromRawValues_0
    970              current_temperature[e] = Temperature::analog2temp(current_temperature_raw[e], e);
   \                     ??updateTemperaturesFromRawValues_1: (+1)
   \   00000006   0xEB00 0x0584      ADD      R5,R0,R4, LSL #+2
   \   0000000A   0x4621             MOV      R1,R4
   \   0000000C   0xB2C9             UXTB     R1,R1
   \   0000000E   0x69E8             LDR      R0,[R5, #+28]
   \   00000010   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \   00000014   0xED85 0x0A06      VSTR     S0,[R5, #+24]
   \   00000018   0x1C64             ADDS     R4,R4,#+1
   \   0000001A   0xB264             SXTB     R4,R4
   \                     ??updateTemperaturesFromRawValues_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable42_1
   \   0000001E   0x2C01             CMP      R4,#+1
   \   00000020   0xDBF1             BLT.N    ??updateTemperaturesFromRawValues_1
    971            #if HAS_TEMP_BED
    972              current_temperature_bed = Temperature::analog2tempBed(current_temperature_bed_raw);
    973            #endif
    974            #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    975              redundant_temperature = Temperature::analog2temp(redundant_temperature_raw, 1);
    976            #endif
    977            #if ENABLED(FILAMENT_WIDTH_SENSOR)
    978              filament_width_meas = analog2widthFil();
    979            #endif
    980          
    981            #if ENABLED(USE_WATCHDOG)
    982              // Reset the watchdog after we know we have a temperature measurement.
    983              watchdog_reset();
    984            #endif
    985          
    986            CRITICAL_SECTION_START;
   \   00000022   0xB672             cpsid i
    987            temp_meas_ready = false;
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x7001             STRB     R1,[R0, #+0]
    988            CRITICAL_SECTION_END;
   \   00000028   0xB662             cpsie i
    989          }
   \   0000002A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    990          
    991          
    992          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    993          
    994            // Convert raw Filament Width to millimeters
    995            float Temperature::analog2widthFil() {
    996              return current_raw_filwidth * 5.0 * (1.0 / 16383.0);
    997            }
    998          
    999            /**
   1000             * Convert Filament Width (mm) to a simple ratio
   1001             * and reduce to an 8 bit value.
   1002             *
   1003             * A nominal width of 1.75 and measured width of 1.73
   1004             * gives (100 * 1.75 / 1.73) for a ratio of 101 and
   1005             * a return value of 1.
   1006             */
   1007            int8_t Temperature::widthFil_to_size_ratio() {
   1008              if (FABS(filament_width_nominal - filament_width_meas) <= FILWIDTH_ERROR_MARGIN)
   1009                return int(100.0 * filament_width_nominal / filament_width_meas) - 100;
   1010              return 0;
   1011            }
   1012          
   1013          #endif
   1014          
   1015          #if ENABLED(HEATER_0_USES_MAX6675)
   1016            #ifndef MAX6675_SCK_PIN
   1017              #define MAX6675_SCK_PIN SCK_PIN
   1018            #endif
   1019            #ifndef MAX6675_DO_PIN
   1020              #define MAX6675_DO_PIN MISO_PIN
   1021            #endif
   1022            SPI<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
   1023          #endif
   1024          
   1025          /**
   1026           * Initialize the temperature manager
   1027           * The manager is implemented by periodic calls to manage_heater()
   1028           */

   \                                 In section .text, align 2, keep-with-next
   1029          void Temperature::init() {
   1030          
   1031            #if MB(RUMBA) && (TEMP_SENSOR_0 == -1 || TEMP_SENSOR_1 == -1 || TEMP_SENSOR_2 == -1 || TEMP_SENSOR_BED == -1)
   1032              // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
   1033              MCUCR = _BV(JTD);
   1034              MCUCR = _BV(JTD);
   1035            #endif
   1036          
   1037            // Finish init of mult hotend arrays
   1038            HOTEND_LOOP() maxttemp[e] = maxttemp[0];
   \                     _ZN11Temperature4initEv: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE005             B.N      ??init_0
   \                     ??init_1: (+1)
   \   00000004   0x....             LDR.N    R1,??DataTable42_1
   \   00000006   0x8A0B             LDRH     R3,[R1, #+16]
   \   00000008   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \   0000000C   0x820B             STRH     R3,[R1, #+16]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \                     ??init_0: (+1)
   \   00000010   0xB240             SXTB     R0,R0
   \   00000012   0x4602             MOV      R2,R0
   \   00000014   0x2A01             CMP      R2,#+1
   \   00000016   0xDBF5             BLT.N    ??init_1
   1039          
   1040            #if ENABLED(PIDTEMP) && ENABLED(PID_EXTRUSION_SCALING)
   1041              last_e_position = 0;
   1042            #endif
   1043          
   1044            #if HAS_HEATER_0
   1045              SET_OUTPUT(HEATER_0_PIN);
   1046            #endif
   1047            #if HAS_HEATER_1
   1048              SET_OUTPUT(HEATER_1_PIN);
   1049            #endif
   1050            #if HAS_HEATER_2
   1051              SET_OUTPUT(HEATER_2_PIN);
   1052            #endif
   1053            #if HAS_HEATER_3
   1054              SET_OUTPUT(HEATER_3_PIN);
   1055            #endif
   1056            #if HAS_HEATER_4
   1057              SET_OUTPUT(HEATER_3_PIN);
   1058            #endif
   1059            #if HAS_HEATER_BED
   1060              SET_OUTPUT(HEATER_BED_PIN);
   1061            #endif
   1062          
   1063            #if HAS_FAN0
   1064              SET_OUTPUT(FAN_PIN);
   1065              #if ENABLED(FAST_PWM_FAN)
   1066                setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1067              #endif
   1068            #endif
   1069          
   1070            #if HAS_FAN1
   1071              SET_OUTPUT(FAN1_PIN);
   1072              #if ENABLED(FAST_PWM_FAN)
   1073                setPwmFrequency(FAN1_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1074              #endif
   1075            #endif
   1076          
   1077            #if HAS_FAN2
   1078              SET_OUTPUT(FAN2_PIN);
   1079              #if ENABLED(FAST_PWM_FAN)
   1080                setPwmFrequency(FAN2_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1081              #endif
   1082            #endif
   1083          
   1084            #if ENABLED(HEATER_0_USES_MAX6675)
   1085          
   1086              OUT_WRITE(SCK_PIN, LOW);
   1087              OUT_WRITE(MOSI_PIN, HIGH);
   1088              SET_INPUT_PULLUP(MISO_PIN);
   1089          
   1090              max6675_spi.init();
   1091          
   1092              OUT_WRITE(SS_PIN, HIGH);
   1093              OUT_WRITE(MAX6675_SS, HIGH);
   1094          
   1095            #endif // HEATER_0_USES_MAX6675
   1096          
   1097            #ifdef DIDR2
   1098              #define ANALOG_SELECT(pin) do{ if (pin < 8) SBI(DIDR0, pin); else SBI(DIDR2, pin - 8); }while(0)
   1099            #else
   1100              #define ANALOG_SELECT(pin) do{ SBI(DIDR0, pin); }while(0)
   1101            #endif
   1102          #if 0
   1103            // Set analog inputs
   1104            ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADIF) | 0x07;
   1105            DIDR0 = 0;
   1106            #ifdef DIDR2
   1107              DIDR2 = 0;
   1108            #endif
   1109            #if HAS_TEMP_0
   1110              ANALOG_SELECT(TEMP_0_PIN);
   1111            #endif
   1112            #if HAS_TEMP_1
   1113              ANALOG_SELECT(TEMP_1_PIN);
   1114            #endif
   1115            #if HAS_TEMP_2
   1116              ANALOG_SELECT(TEMP_2_PIN);
   1117            #endif
   1118            #if HAS_TEMP_3
   1119              ANALOG_SELECT(TEMP_3_PIN);
   1120            #endif
   1121            #if HAS_TEMP_4
   1122              ANALOG_SELECT(TEMP_4_PIN);
   1123            #endif
   1124            #if HAS_TEMP_BED
   1125              ANALOG_SELECT(TEMP_BED_PIN);
   1126            #endif
   1127            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1128              ANALOG_SELECT(FILWIDTH_PIN);
   1129            #endif
   1130          
   1131            #if HAS_AUTO_FAN_0
   1132              #if E0_AUTO_FAN_PIN == FAN1_PIN
   1133                SET_OUTPUT(E0_AUTO_FAN_PIN);
   1134                #if ENABLED(FAST_PWM_FAN)
   1135                  setPwmFrequency(E0_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1136                #endif
   1137              #else
   1138                SET_OUTPUT(E0_AUTO_FAN_PIN);
   1139              #endif
   1140            #endif
   1141            #if HAS_AUTO_FAN_1 && !AUTO_1_IS_0
   1142              #if E1_AUTO_FAN_PIN == FAN1_PIN
   1143                SET_OUTPUT(E1_AUTO_FAN_PIN);
   1144                #if ENABLED(FAST_PWM_FAN)
   1145                  setPwmFrequency(E1_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1146                #endif
   1147              #else
   1148                SET_OUTPUT(E1_AUTO_FAN_PIN);
   1149              #endif
   1150            #endif
   1151            #if HAS_AUTO_FAN_2 && !AUTO_2_IS_0 && !AUTO_2_IS_1
   1152              #if E2_AUTO_FAN_PIN == FAN1_PIN
   1153                SET_OUTPUT(E2_AUTO_FAN_PIN);
   1154                #if ENABLED(FAST_PWM_FAN)
   1155                  setPwmFrequency(E2_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1156                #endif
   1157              #else
   1158                SET_OUTPUT(E2_AUTO_FAN_PIN);
   1159              #endif
   1160            #endif
   1161            #if HAS_AUTO_FAN_3 && !AUTO_3_IS_0 && !AUTO_3_IS_1 && !AUTO_3_IS_2
   1162              #if E3_AUTO_FAN_PIN == FAN1_PIN
   1163                SET_OUTPUT(E3_AUTO_FAN_PIN);
   1164                #if ENABLED(FAST_PWM_FAN)
   1165                  setPwmFrequency(E3_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1166                #endif
   1167              #else
   1168                SET_OUTPUT(E3_AUTO_FAN_PIN);
   1169              #endif
   1170            #endif
   1171            #if HAS_AUTO_FAN_4 && !AUTO_4_IS_0 && !AUTO_4_IS_1 && !AUTO_4_IS_2 && !AUTO_4_IS_3
   1172              #if E4_AUTO_FAN_PIN == FAN1_PIN
   1173                SET_OUTPUT(E4_AUTO_FAN_PIN);
   1174                #if ENABLED(FAST_PWM_FAN)
   1175                  setPwmFrequency(E4_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1176                #endif
   1177              #else
   1178                SET_OUTPUT(E4_AUTO_FAN_PIN);
   1179              #endif
   1180            #endif
   1181          
   1182            // Use timer0 for temperature measurement
   1183            // Interleave temperature interrupt with millies interrupt
   1184            OCR0B = 128;
   1185            SBI(TIMSK0, OCIE0B);
   1186          
   1187            // Wait for temperature measurement to settle
   1188            delay(250);
   1189          #endif
   1190            #define TEMP_MIN_ROUTINE(NR) \
   1191              minttemp[NR] = HEATER_ ##NR## _MINTEMP; \
   1192              while (analog2temp(minttemp_raw[NR], NR) < HEATER_ ##NR## _MINTEMP) { \
   1193                if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
   1194                  minttemp_raw[NR] += OVERSAMPLENR; \
   1195                else \
   1196                  minttemp_raw[NR] -= OVERSAMPLENR; \
   1197              }
   1198            #define TEMP_MAX_ROUTINE(NR) \
   1199              maxttemp[NR] = HEATER_ ##NR## _MAXTEMP; \
   1200              while (analog2temp(maxttemp_raw[NR], NR) > HEATER_ ##NR## _MAXTEMP) { \
   1201                if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
   1202                  maxttemp_raw[NR] -= OVERSAMPLENR; \
   1203                else \
   1204                  maxttemp_raw[NR] += OVERSAMPLENR; \
   1205              }
   1206          
   1207            #ifdef HEATER_0_MINTEMP
   1208              TEMP_MIN_ROUTINE(0);
   1209            #endif
   1210            #ifdef HEATER_0_MAXTEMP
   1211              TEMP_MAX_ROUTINE(0);
   1212            #endif
   1213            #if HOTENDS > 1
   1214              #ifdef HEATER_1_MINTEMP
   1215                TEMP_MIN_ROUTINE(1);
   1216              #endif
   1217              #ifdef HEATER_1_MAXTEMP
   1218                TEMP_MAX_ROUTINE(1);
   1219              #endif
   1220              #if HOTENDS > 2
   1221                #ifdef HEATER_2_MINTEMP
   1222                  TEMP_MIN_ROUTINE(2);
   1223                #endif
   1224                #ifdef HEATER_2_MAXTEMP
   1225                  TEMP_MAX_ROUTINE(2);
   1226                #endif
   1227                #if HOTENDS > 3
   1228                  #ifdef HEATER_3_MINTEMP
   1229                    TEMP_MIN_ROUTINE(3);
   1230                  #endif
   1231                  #ifdef HEATER_3_MAXTEMP
   1232                    TEMP_MAX_ROUTINE(3);
   1233                  #endif
   1234                  #if HOTENDS > 4
   1235                    #ifdef HEATER_4_MINTEMP
   1236                      TEMP_MIN_ROUTINE(4);
   1237                    #endif
   1238                    #ifdef HEATER_4_MAXTEMP
   1239                      TEMP_MAX_ROUTINE(4);
   1240                    #endif
   1241                  #endif // HOTENDS > 4
   1242                #endif // HOTENDS > 3
   1243              #endif // HOTENDS > 2
   1244            #endif // HOTENDS > 1
   1245          
   1246            #if HAS_TEMP_BED
   1247              #ifdef BED_MINTEMP
   1248                while (analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
   1249                  #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
   1250                    bed_minttemp_raw += OVERSAMPLENR;
   1251                  #else
   1252                    bed_minttemp_raw -= OVERSAMPLENR;
   1253                  #endif
   1254                }
   1255              #endif // BED_MINTEMP
   1256              #ifdef BED_MAXTEMP
   1257                while (analog2tempBed(bed_maxttemp_raw) > BED_MAXTEMP) {
   1258                  #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
   1259                    bed_maxttemp_raw -= OVERSAMPLENR;
   1260                  #else
   1261                    bed_maxttemp_raw += OVERSAMPLENR;
   1262                  #endif
   1263                }
   1264              #endif // BED_MAXTEMP
   1265            #endif //HAS_TEMP_BED
   1266          
   1267            #if ENABLED(PROBING_HEATERS_OFF)
   1268              paused = false;
   1269            #endif
   1270          }
   \   00000018   0x4770             BX       LR               ;; return
   1271          
   1272          #if WATCH_HOTENDS
   1273            /**
   1274             * Start Heating Sanity Check for hotends that are below
   1275             * their target temperature by a configurable margin.
   1276             * This is called when the temperature is set. (M104, M109)
   1277             */

   \                                 In section .text, align 2, keep-with-next
   1278            void Temperature::start_watching_heater(const uint8_t e) {
   \                     _ZN11Temperature21start_watching_heaterEh: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   1279              #if HOTENDS == 1
   1280                UNUSED(e);
   1281              #endif
   1282              if (degHotend(HOTEND_INDEX) < degTargetHotend(HOTEND_INDEX) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   0000000C   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   00000010   0x....             LDR.N    R4,??DataTable42_1
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \   00000018   0xEEF9 0x0A08      VMOV.F32 S1,#-6.0
   \   0000001C   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000020   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   00000024   0xEEF1 0xFA10      FMSTAT   
   \   00000028   0xD512             BPL.N    ??start_watching_heater_0
   1283                watch_target_temp[HOTEND_INDEX] = degHotend(HOTEND_INDEX) + WATCH_TEMP_INCREASE;
                                                       ^
Warning[Pa093]: implicit conversion from floating point to integer

  static float current_temper_bak;
               ^
"E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\Marlin\temperature.cpp",741  Warning[Pe177]: 
          variable "current_temper_bak" was declared but never referenced
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   00000030   0xEEF0 0x0A00      VMOV.F32 S1,#2.0
   \   00000034   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000038   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000003C   0xEE10 0x0A10      VMOV     R0,S0
   \   00000040   0x81A0             STRH     R0,[R4, #+12]
   1284                watch_heater_next_ms[HOTEND_INDEX] = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
   \   00000042   0x.... 0x....      BL       HAL_GetTick
   \   00000046   0xF500 0x409C      ADD      R0,R0,#+19968
   \   0000004A   0x3020             ADDS     R0,R0,#+32
   \   0000004C   0x6360             STR      R0,[R4, #+52]
   \   0000004E   0xE001             B.N      ??start_watching_heater_1
   1285              }
   1286              else
   1287                watch_heater_next_ms[HOTEND_INDEX] = 0;
   \                     ??start_watching_heater_0: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6360             STR      R0,[R4, #+52]
   1288            }
   \                     ??start_watching_heater_1: (+1)
   \   00000054   0xECBD 0x8B02      VPOP     {D8}
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
   1289          #endif
   1290          
   1291          #if WATCH_THE_BED
   1292            /**
   1293             * Start Heating Sanity Check for hotends that are below
   1294             * their target temperature by a configurable margin.
   1295             * This is called when the temperature is set. (M140, M190)
   1296             */
   1297            void Temperature::start_watching_bed() {
   1298              if (degBed() < degTargetBed() - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
   1299                watch_target_bed_temp = degBed() + WATCH_BED_TEMP_INCREASE;
   1300                watch_bed_next_ms = millis() + (WATCH_BED_TEMP_PERIOD) * 1000UL;
   1301              }
   1302              else
   1303                watch_bed_next_ms = 0;
   1304            }
   1305          #endif
   1306          
   1307          #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
   1308          
   1309            #if ENABLED(THERMAL_PROTECTION_HOTENDS)
   1310              Temperature::TRState Temperature::thermal_runaway_state_machine[HOTENDS] = { TRInactive };
   1311              millis_t Temperature::thermal_runaway_timer[HOTENDS] = { 0 };
   1312            #endif
   1313          
   1314            #if HAS_THERMALLY_PROTECTED_BED
   1315              Temperature::TRState Temperature::thermal_runaway_bed_state_machine = TRInactive;
   1316              millis_t Temperature::thermal_runaway_bed_timer;
   1317            #endif
   1318          

   \                                 In section .text, align 2, keep-with-next
   1319            void Temperature::thermal_runaway_protection(Temperature::TRState * const state, millis_t * const timer, const float current, const float target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc) {
   \                     _ZN11Temperature26thermal_runaway_protectionEPNS_7TRStateEPmffatt: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
   1320          
   1321              static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
   1322          
   1323              /**
   1324                  SERIAL_ECHO_START();
   1325                  SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");
   1326                  if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
   1327                  SERIAL_ECHOPAIR(" ;  State:", *state);
   1328                  SERIAL_ECHOPAIR(" ;  Timer:", *timer);
   1329                  SERIAL_ECHOPAIR(" ;  Temperature:", current);
   1330                  SERIAL_ECHOPAIR(" ;  Target Temp:", target);
   1331                  if (heater_id >= 0)
   1332                    SERIAL_ECHOPAIR(" ;  Idle Timeout:", heater_idle_timeout_exceeded[heater_id]);
   1333                  else
   1334                    SERIAL_ECHOPAIR(" ;  Idle Timeout:", bed_idle_timeout_exceeded);
   1335                  SERIAL_EOL();
   1336              */
   1337          
   1338              const int heater_index = heater_id >= 0 ? heater_id : HOTENDS;
   \   0000000A   0xB276             SXTB     R6,R6
   \   0000000C   0x0031             MOVS     R1,R6
   \   0000000E   0xD500             BPL.N    ??thermal_runaway_protection_0
   \   00000010   0x2101             MOVS     R1,#+1
   1339          
   1340              #if HEATER_IDLE_HANDLER
   1341                // If the heater idle timeout expires, restart
   1342                if (heater_id >= 0 && heater_idle_timeout_exceeded[heater_id]) {
   1343                  *state = TRInactive;
   1344                  tr_target_temperature[heater_index] = 0;
   1345                }
   1346                #if HAS_TEMP_BED
   1347                  else if (heater_id < 0 && bed_idle_timeout_exceeded) {
   1348                    *state = TRInactive;
   1349                    tr_target_temperature[heater_index] = 0;
   1350                  }
   1351                #endif
   1352                else
   1353              #endif
   1354              // If the target temperature changes, restart
   1355              if (tr_target_temperature[heater_index] != target) {
   \                     ??thermal_runaway_protection_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable42_22
   \   00000014   0xEB02 0x0081      ADD      R0,R2,R1, LSL #+2
   \   00000018   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   0000001C   0xEEB4 0x1A60      VCMP.F32 S2,S1
   \   00000020   0xEEF1 0xFA10      FMSTAT   
   \   00000024   0xD00A             BEQ.N    ??thermal_runaway_protection_1
   1356                tr_target_temperature[heater_index] = target;
   \   00000026   0xEDC0 0x0A00      VSTR     S1,[R0, #0]
   1357                *state = target > 0 ? TRFirstHeating : TRInactive;
   \   0000002A   0xEEF5 0x0A40      VCMP.F32 S1,#0.0
   \   0000002E   0xEEF1 0xFA10      FMSTAT   
   \   00000032   0xDD01             BLE.N    ??thermal_runaway_protection_2
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE000             B.N      ??thermal_runaway_protection_3
   \                     ??thermal_runaway_protection_2: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??thermal_runaway_protection_3: (+1)
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
   1358              }
   1359          
   1360              switch (*state) {
   \                     ??thermal_runaway_protection_1: (+1)
   \   0000003C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD004             BEQ.N    ??thermal_runaway_protection_4
   \   00000044   0xD336             BCC.N    ??thermal_runaway_protection_5
   \   00000046   0x2803             CMP      R0,#+3
   \   00000048   0xD02C             BEQ.N    ??thermal_runaway_protection_6
   \   0000004A   0xD30B             BCC.N    ??thermal_runaway_protection_7
   \   0000004C   0xBDF1             POP      {R0,R4-R7,PC}
   1361                // Inactive state waits for a target temperature to be set
   1362                case TRInactive: break;
   1363                // When first heating, wait for the temperature to be reached then go to Stable state
   1364                case TRFirstHeating:
   1365                  if (current < tr_target_temperature[heater_index]) break;
   \                     ??thermal_runaway_protection_4: (+1)
   \   0000004E   0xEB02 0x0081      ADD      R0,R2,R1, LSL #+2
   \   00000052   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000056   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000005A   0xEEF1 0xFA10      FMSTAT   
   \   0000005E   0xD429             BMI.N    ??thermal_runaway_protection_5
   1366                  *state = TRStable;
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x7020             STRB     R0,[R4, #+0]
   1367                // While the temperature is stable watch for a bad temperature
   1368                case TRStable:
   1369                  if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
   \                     ??thermal_runaway_protection_7: (+1)
   \   00000064   0x9806             LDR      R0,[SP, #+24]
   \   00000066   0xEE00 0x0A90      VMOV     S1,R0
   \   0000006A   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   0000006E   0xEB02 0x0081      ADD      R0,R2,R1, LSL #+2
   \   00000072   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   00000076   0xEE71 0x0A60      VSUB.F32 S1,S2,S1
   \   0000007A   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000007E   0xEEF1 0xFA10      FMSTAT   
   \   00000082   0xDB08             BLT.N    ??thermal_runaway_protection_8
   1370                    *timer = millis() + period_seconds * 1000UL;
   \   00000084   0x.... 0x....      BL       HAL_GetTick
   \   00000088   0xB2BF             UXTH     R7,R7
   \   0000008A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000008E   0xFB01 0x0007      MLA      R0,R1,R7,R0
   \   00000092   0x6028             STR      R0,[R5, #+0]
   1371                    break;
   \   00000094   0xBDF1             POP      {R0,R4-R7,PC}
   1372                  }
   1373                  else if (PENDING(millis(), *timer)) break;
   \                     ??thermal_runaway_protection_8: (+1)
   \   00000096   0x.... 0x....      BL       HAL_GetTick
   \   0000009A   0x6829             LDR      R1,[R5, #+0]
   \   0000009C   0x1A40             SUBS     R0,R0,R1
   \   0000009E   0xD409             BMI.N    ??thermal_runaway_protection_5
   1374                  *state = TRRunaway;
   \   000000A0   0x2003             MOVS     R0,#+3
   \   000000A2   0x7020             STRB     R0,[R4, #+0]
   1375                case TRRunaway:
   1376                  _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
   \                     ??thermal_runaway_protection_6: (+1)
   \   000000A4   0x.... 0x....      ADR.W    R2,`?<Constant "THERMAL RUNAWAY">`
   \   000000A8   0x.... 0x....      ADR.W    R1,`?<Constant "Thermal Runaway">`
   \   000000AC   0x4630             MOV      R0,R6
   \   000000AE   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   000000B2   0x....             B.N      _ZN11Temperature11_temp_errorEaPKcS1_
   1377              }
   1378            }
   \                     ??thermal_runaway_protection_5: (+1)
   \   000000B4   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .bss, align 4
   \                     ??tr_target_temperature:
   \   00000000                      DS8 8
   1379          
   1380          #endif // THERMAL_PROTECTION_HOTENDS || THERMAL_PROTECTION_BED
   1381          

   \                                 In section .text, align 4, keep-with-next
   1382          void Temperature::disable_all_heaters() {
   \                     _ZN11Temperature19disable_all_heatersEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1383          
   1384            #if ENABLED(AUTOTEMP)
   1385              planner.autotemp_enabled = false;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable42_23
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   1386            #endif
   1387          
   1388            HOTEND_LOOP() setTargetHotend(0, e);
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0xE006             B.N      ??disable_all_heaters_0
   \                     ??disable_all_heaters_1: (+1)
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0xED9F 0x....      VLDR.W   S0,??DataTable41  ;; 0x0
   \   00000014   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   \   00000018   0x1C64             ADDS     R4,R4,#+1
   \                     ??disable_all_heaters_0: (+1)
   \   0000001A   0xB264             SXTB     R4,R4
   \   0000001C   0x2C01             CMP      R4,#+1
   \   0000001E   0xDBF5             BLT.N    ??disable_all_heaters_1
   1389            setTargetBed(0);
   \   00000020   0xED9F 0x....      VLDR.W   S0,??DataTable41  ;; 0x0
   \   00000024   0x.... 0x....      BL       _ZN11Temperature12setTargetBedEf
   1390          
   1391            // Unpause and reset everything
   1392            #if ENABLED(PROBING_HEATERS_OFF)
   1393              pause(false);
   1394            #endif
   1395          
   1396            // If all heaters go down then for sure our print job has stopped
   1397            print_job_timer.stop();
   \   00000028   0x....             LDR.N    R0,??DataTable42_24
   \   0000002A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002E   0x.... 0x....      B.W      _ZN9Stopwatch4stopEv
   1398          
   1399            #define DISABLE_HEATER(NR) { \
   1400              setTargetHotend(0, NR); \
   1401              soft_pwm_amount[NR] = 0; \
   1402              WRITE_HEATER_ ##NR (LOW); \
   1403            }
   1404          
   1405            #if HAS_TEMP_HOTEND
   1406              DISABLE_HEATER(0);
   1407              #if HOTENDS > 1
   1408                DISABLE_HEATER(1);
   1409                #if HOTENDS > 2
   1410                  DISABLE_HEATER(2);
   1411                  #if HOTENDS > 3
   1412                    DISABLE_HEATER(3);
   1413                    #if HOTENDS > 4
   1414                      DISABLE_HEATER(4);
   1415                    #endif // HOTENDS > 4
   1416                  #endif // HOTENDS > 3
   1417                #endif // HOTENDS > 2
   1418              #endif // HOTENDS > 1
   1419            #endif
   1420          
   1421            #if HAS_TEMP_BED
   1422              target_temperature_bed = 0;
   1423              soft_pwm_amount_bed = 0;
   1424              #if HAS_HEATER_BED
   1425                WRITE_HEATER_BED(LOW);
   1426              #endif
   1427            #endif
   1428          }
   1429          
   1430          #if ENABLED(PROBING_HEATERS_OFF)
   1431          
   1432            void Temperature::pause(const bool p) {
   1433              if (p != paused) {
   1434                paused = p;
   1435                if (p) {
   1436                  HOTEND_LOOP() start_heater_idle_timer(e, 0); // timeout immediately
   1437                  #if HAS_TEMP_BED
   1438                    start_bed_idle_timer(0); // timeout immediately
   1439                  #endif
   1440                }
   1441                else {
   1442                  HOTEND_LOOP() reset_heater_idle_timer(e);
   1443                  #if HAS_TEMP_BED
   1444                    reset_bed_idle_timer();
   1445                  #endif
   1446                }
   1447              }
   1448            }
   1449          
   1450          #endif // PROBING_HEATERS_OFF
   1451          
   1452          #if ENABLED(HEATER_0_USES_MAX6675)
   1453          
   1454            #define MAX6675_HEAT_INTERVAL 250u
   1455          
   1456            #if ENABLED(MAX6675_IS_MAX31855)
   1457              uint32_t max6675_temp = 2000;
   1458              #define MAX6675_ERROR_MASK 7
   1459              #define MAX6675_DISCARD_BITS 18
   1460              #define MAX6675_SPEED_BITS (_BV(SPR1)) // clock ÷ 64
   1461            #else
   1462              uint16_t max6675_temp = 2000;
   1463              #define MAX6675_ERROR_MASK 4
   1464              #define MAX6675_DISCARD_BITS 3
   1465              #define MAX6675_SPEED_BITS (_BV(SPR0)) // clock ÷ 16
   1466            #endif
   1467          
   1468            int Temperature::read_max6675() {
   1469          
   1470              static millis_t next_max6675_ms = 0;
   1471          
   1472              millis_t ms = millis();
   1473          
   1474              if (PENDING(ms, next_max6675_ms)) return (int)max6675_temp;
   1475          
   1476              next_max6675_ms = ms + MAX6675_HEAT_INTERVAL;
   1477          
   1478              CBI(
   1479                #ifdef PRR
   1480                  PRR
   1481                #elif defined(PRR0)
   1482                  PRR0
   1483                #endif
   1484                  , PRSPI);
   1485              SPCR = _BV(MSTR) | _BV(SPE) | MAX6675_SPEED_BITS;
   1486          
   1487              WRITE(MAX6675_SS, 0); // enable TT_MAX6675
   1488          
   1489              // ensure 100ns delay - a bit extra is fine
   1490              asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
   1491              asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
   1492          
   1493              // Read a big-endian temperature value
   1494              max6675_temp = 0;
   1495              for (uint8_t i = sizeof(max6675_temp); i--;) {
   1496                max6675_temp |= max6675_spi.receive();
   1497                if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
   1498              }
   1499          
   1500              WRITE(MAX6675_SS, 1); // disable TT_MAX6675
   1501          
   1502              if (max6675_temp & MAX6675_ERROR_MASK) {
   1503                SERIAL_ERROR_START();
   1504                SERIAL_ERRORPGM("Temp measurement error! ");
   1505                #if MAX6675_ERROR_MASK == 7
   1506                  SERIAL_ERRORPGM("MAX31855 ");
   1507                  if (max6675_temp & 1)
   1508                    SERIAL_ERRORLNPGM("Open Circuit");
   1509                  else if (max6675_temp & 2)
   1510                    SERIAL_ERRORLNPGM("Short to GND");
   1511                  else if (max6675_temp & 4)
   1512                    SERIAL_ERRORLNPGM("Short to VCC");
   1513                #else
   1514                  SERIAL_ERRORLNPGM("MAX6675");
   1515                #endif
   1516                max6675_temp = MAX6675_TMAX * 4; // thermocouple open
   1517              }
   1518              else
   1519                max6675_temp >>= MAX6675_DISCARD_BITS;
   1520                #if ENABLED(MAX6675_IS_MAX31855)
   1521                  // Support negative temperature
   1522                  if (max6675_temp & 0x00002000) max6675_temp |= 0xFFFFC000;
   1523                #endif
   1524          
   1525              return (int)max6675_temp;
   1526            }
   1527          
   1528          #endif // HEATER_0_USES_MAX6675
   1529          
   1530          /**
   1531           * Get raw temperatures
   1532           */

   \                                 In section .text, align 2, keep-with-next
   1533          void Temperature::set_current_temp_raw() {
   1534            #if HAS_TEMP_0 && DISABLED(HEATER_0_USES_MAX6675)
   1535              current_temperature_raw[0] = raw_temp_value[0];	//mks 2018-08
   1536            #endif
   1537            #if HAS_TEMP_1
   1538              #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   1539                redundant_temperature_raw = raw_temp_value[1];
   1540              #else
   1541                current_temperature_raw[1] = raw_temp_value[1];
   1542              #endif
   1543              #if HAS_TEMP_2
   1544                current_temperature_raw[2] = raw_temp_value[2];
   1545                #if HAS_TEMP_3
   1546                  current_temperature_raw[3] = raw_temp_value[3];
   1547                  #if HAS_TEMP_4
   1548                    current_temperature_raw[4] = raw_temp_value[4];
   1549                  #endif
   1550                #endif
   1551              #endif
   1552            #endif
   1553            current_temperature_bed_raw = raw_temp_bed_value;
   \                     _ZN11Temperature20set_current_temp_rawEv: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable42_1
   \   00000002   0x89C1             LDRH     R1,[R0, #+14]
   \   00000004   0x6241             STR      R1,[R0, #+36]
   1554            temp_meas_ready = true;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x7001             STRB     R1,[R0, #+0]
   1555          }
   \   0000000A   0x4770             BX       LR               ;; return
   1556          
   1557          #if ENABLED(PINS_DEBUGGING)
   1558            /**
   1559             * monitors endstops & Z probe for changes
   1560             *
   1561             * If a change is detected then the LED is toggled and
   1562             * a message is sent out the serial port
   1563             *
   1564             * Yes, we could miss a rapid back & forth change but
   1565             * that won't matter because this is all manual.
   1566             *
   1567             */
   1568            void endstop_monitor() {
   1569              static uint16_t old_endstop_bits_local = 0;
   1570              static uint8_t local_LED_status = 0;
   1571              uint16_t current_endstop_bits_local = 0;
   1572              #if HAS_X_MIN
   1573                if (READ(X_MIN_PIN)) SBI(current_endstop_bits_local, X_MIN);
   1574              #endif
   1575              #if HAS_X_MAX
   1576                if (READ(X_MAX_PIN)) SBI(current_endstop_bits_local, X_MAX);
   1577              #endif
   1578              #if HAS_Y_MIN
   1579                if (READ(Y_MIN_PIN)) SBI(current_endstop_bits_local, Y_MIN);
   1580              #endif
   1581              #if HAS_Y_MAX
   1582                if (READ(Y_MAX_PIN)) SBI(current_endstop_bits_local, Y_MAX);
   1583              #endif
   1584              #if HAS_Z_MIN
   1585                if (READ(Z_MIN_PIN)) SBI(current_endstop_bits_local, Z_MIN);
   1586              #endif
   1587              #if HAS_Z_MAX
   1588                if (READ(Z_MAX_PIN)) SBI(current_endstop_bits_local, Z_MAX);
   1589              #endif
   1590              #if HAS_Z_MIN_PROBE_PIN
   1591                if (READ(Z_MIN_PROBE_PIN)) SBI(current_endstop_bits_local, Z_MIN_PROBE);
   1592              #endif
   1593              #if HAS_Z2_MIN
   1594                if (READ(Z2_MIN_PIN)) SBI(current_endstop_bits_local, Z2_MIN);
   1595              #endif
   1596              #if HAS_Z2_MAX
   1597                if (READ(Z2_MAX_PIN)) SBI(current_endstop_bits_local, Z2_MAX);
   1598              #endif
   1599          
   1600              uint16_t endstop_change = current_endstop_bits_local ^ old_endstop_bits_local;
   1601          
   1602              if (endstop_change) {
   1603                #if HAS_X_MIN
   1604                  if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", !!TEST(current_endstop_bits_local, X_MIN));
   1605                #endif
   1606                #if HAS_X_MAX
   1607                  if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", !!TEST(current_endstop_bits_local, X_MAX));
   1608                #endif
   1609                #if HAS_Y_MIN
   1610                  if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", !!TEST(current_endstop_bits_local, Y_MIN));
   1611                #endif
   1612                #if HAS_Y_MAX
   1613                  if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", !!TEST(current_endstop_bits_local, Y_MAX));
   1614                #endif
   1615                #if HAS_Z_MIN
   1616                  if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", !!TEST(current_endstop_bits_local, Z_MIN));
   1617                #endif
   1618                #if HAS_Z_MAX
   1619                  if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", !!TEST(current_endstop_bits_local, Z_MAX));
   1620                #endif
   1621                #if HAS_Z_MIN_PROBE_PIN
   1622                  if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", !!TEST(current_endstop_bits_local, Z_MIN_PROBE));
   1623                #endif
   1624                #if HAS_Z2_MIN
   1625                  if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", !!TEST(current_endstop_bits_local, Z2_MIN));
   1626                #endif
   1627                #if HAS_Z2_MAX
   1628                  if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", !!TEST(current_endstop_bits_local, Z2_MAX));
   1629                #endif
   1630                SERIAL_PROTOCOLPGM("\n\n");
   1631                analogWrite(LED_PIN, local_LED_status);
   1632                local_LED_status ^= 255;
   1633                old_endstop_bits_local = current_endstop_bits_local;
   1634              }
   1635            }
   1636          #endif // PINS_DEBUGGING
   1637          
   1638          /**
   1639           * Timer 0 is shared with millies so don't change the prescaler.
   1640           *
   1641           * This ISR uses the compare method so it runs at the base
   1642           * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
   1643           * in OCR0B above (128 or halfway between OVFs).
   1644           *
   1645           *  - Manage PWM to all the heaters and fan
   1646           *  - Prepare or Measure one of the raw ADC sensor values
   1647           *  - Check new temperature values for MIN/MAX errors (kill on error)
   1648           *  - Step the babysteps value for each axis towards 0
   1649           *  - For PINS_DEBUGGING, monitor and report endstop pins
   1650           *  - For ENDSTOP_INTERRUPTS_FEATURE check endstops if flagged
   1651           */
   1652          //ISR(TIMER0_COMPB_vect) { Temperature::isr(); }
   1653          
   1654          volatile bool Temperature::in_temp_isr = false;
   1655          
   1656          //void Temperature::isr() {

   \                                 In section .text, align 2, keep-with-next
   1657            void IsrTemperatureHandler() { Temperature::TemperatureHandler(); }
   \                     IsrTemperatureHandler: (+1)
   \   00000000   0xBF00             Nop      
   \   00000002                      REQUIRE _ZN11Temperature18TemperatureHandlerEv
   \   00000002                      ;; // Fall through to label Temperature::TemperatureHandler()

   \                                 In section .text, align 2, keep-with-next
   1658            void Temperature::TemperatureHandler(void)  {
   \                     _ZN11Temperature18TemperatureHandlerEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   1659          
   1660            // The stepper ISR can interrupt this ISR. When it does it re-enables this ISR
   1661            // at the end of its run, potentially causing re-entry. This flag prevents it.
   1662            if (in_temp_isr) return;
   \   00000006   0x....             LDR.N    R4,??DataTable42_1
   \   00000008   0x7920             LDRB     R0,[R4, #+4]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xF040 0x8099      BNE.W    ??TemperatureHandler_0
   1663            in_temp_isr = true;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x7120             STRB     R0,[R4, #+4]
   1664          
   1665            // Allow UART and stepper ISRs
   1666            //CBI(TIMSK0, OCIE0B); //Disable Temperature ISR
   1667            //sei();
   1668            HAL_TIM_Base_Stop_IT(&htim4);
   \   00000014   0x....             LDR.N    R5,??DataTable42_25
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   1669          
   1670            static int8_t temp_count = -1;
   1671            static ADCSensorState adc_sensor_state = StartupDelay;
   1672            static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
   1673            // avoid multiple loads of pwm_count
   1674            uint8_t pwm_count_tmp = pwm_count;
   \   0000001C   0x79E6             LDRB     R6,[R4, #+7]
   1675            #if ENABLED(ADC_KEYPAD)
   1676              static unsigned int raw_ADCKey_value = 0;
   1677            #endif
   1678          
   1679            // Static members for each heater
   1680            #if ENABLED(SLOW_PWM_HEATERS)
   1681              static uint8_t slow_pwm_count = 0;
   1682              #define ISR_STATICS(n) \
   1683                static uint8_t soft_pwm_count_ ## n, \
   1684                               state_heater_ ## n = 0, \
   1685                               state_timer_heater_ ## n = 0
   1686            #else
   1687              #define ISR_STATICS(n) static uint8_t soft_pwm_count_ ## n = 0
   1688            #endif
   1689          
   1690            // Statics per heater
   1691            ISR_STATICS(0);
   1692            #if HOTENDS > 1
   1693              ISR_STATICS(1);
   1694              #if HOTENDS > 2
   1695                ISR_STATICS(2);
   1696                #if HOTENDS > 3
   1697                  ISR_STATICS(3);
   1698                  #if HOTENDS > 4
   1699                    ISR_STATICS(4);
   1700                  #endif // HOTENDS > 4
   1701                #endif // HOTENDS > 3
   1702              #endif // HOTENDS > 2
   1703            #endif // HOTENDS > 1
   1704            #if HAS_HEATER_BED
   1705              ISR_STATICS(BED);
   1706            #endif
   1707          
   1708            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1709              static unsigned long raw_filwidth_value = 0;
   1710            #endif
   1711          
   1712            #if DISABLED(SLOW_PWM_HEATERS)
   1713              constexpr uint8_t pwm_mask =
   1714                #if ENABLED(SOFT_PWM_DITHER)
   1715                  _BV(SOFT_PWM_SCALE) - 1
   1716                #else
   1717                  0
   1718                #endif
   1719              ;
   1720          
   1721              /**
   1722               * Standard PWM modulation
   1723               */
   1724              if (pwm_count_tmp >= 127) {
   \   0000001E   0x2E7F             CMP      R6,#+127
   \   00000020   0xDB0F             BLT.N    ??TemperatureHandler_1
   1725                pwm_count_tmp -= 127;
   \   00000022   0x3E7F             SUBS     R6,R6,#+127
   \   00000024   0xB2F6             UXTB     R6,R6
   1726                soft_pwm_count_0 = (soft_pwm_count_0 & pwm_mask) + soft_pwm_amount[0];
   \   00000026   0x78A0             LDRB     R0,[R4, #+2]
   \   00000028   0x7220             STRB     R0,[R4, #+8]
   1727                //WRITE_HEATER_0(soft_pwm_count_0 > pwm_mask ? HIGH : LOW);
   1728          	  if(soft_pwm_count_0 > pwm_mask) WRITE_HEATER_0(HIGH);
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD00C             BEQ.N    ??TemperatureHandler_2
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0x....             LDR.N    R0,??DataTable42_26
   \   00000032   0xF830 0x1C02      LDRH     R1,[R0, #-2]
   \   00000036   0x....             LDR.N    R0,??DataTable42_27
   \   00000038   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \   0000003C   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000040   0xE00B             B.N      ??TemperatureHandler_3
   1729          	  else WRITE_HEATER_0(LOW);      
   1730                #if HOTENDS > 1
   1731                  soft_pwm_count_1 = (soft_pwm_count_1 & pwm_mask) + soft_pwm_amount[1];
   1732                  WRITE_HEATER_1(soft_pwm_count_1 > pwm_mask ? HIGH : LOW);
   1733                  #if HOTENDS > 2
   1734                    soft_pwm_count_2 = (soft_pwm_count_2 & pwm_mask) + soft_pwm_amount[2];
   1735                    WRITE_HEATER_2(soft_pwm_count_2 > pwm_mask ? HIGH : LOW);
   1736                    #if HOTENDS > 3
   1737                      soft_pwm_count_3 = (soft_pwm_count_3 & pwm_mask) + soft_pwm_amount[3];
   1738                      WRITE_HEATER_3(soft_pwm_count_3 > pwm_mask ? HIGH : LOW);
   1739                      #if HOTENDS > 4
   1740                        soft_pwm_count_4 = (soft_pwm_count_4 & pwm_mask) + soft_pwm_amount[4];
   1741                        WRITE_HEATER_4(soft_pwm_count_4 > pwm_mask ? HIGH : LOW);
   1742                      #endif // HOTENDS > 4
   1743                    #endif // HOTENDS > 3
   1744                  #endif // HOTENDS > 2
   1745                #endif // HOTENDS > 1
   1746          
   1747                #if HAS_HEATER_BED
   1748                  soft_pwm_count_BED = (soft_pwm_count_BED & pwm_mask) + soft_pwm_amount_bed;
   1749                  //WRITE_HEATER_BED(soft_pwm_count_BED > pwm_mask ? HIGH : LOW);
   1750          		if(soft_pwm_count_BED > pwm_mask) WRITE_HEATER_BED(HIGH);
   1751          		else WRITE_HEATER_BED(LOW);        
   1752                #endif
   1753          
   1754                #if ENABLED(FAN_SOFT_PWM)
   1755                  #if HAS_FAN0
   1756                    soft_pwm_count_fan[0] = (soft_pwm_count_fan[0] & pwm_mask) + (soft_pwm_amount_fan[0] >> 1);
   1757                    WRITE_FAN(soft_pwm_count_fan[0] > pwm_mask ? HIGH : LOW);
   1758                  #endif
   1759                  #if HAS_FAN1
   1760                    soft_pwm_count_fan[1] = (soft_pwm_count_fan[1] & pwm_mask) + (soft_pwm_amount_fan[1] >> 1);
   1761                    WRITE_FAN1(soft_pwm_count_fan[1] > pwm_mask ? HIGH : LOW);
   1762                  #endif
   1763                  #if HAS_FAN2
   1764                    soft_pwm_count_fan[2] = (soft_pwm_count_fan[2] & pwm_mask) + (soft_pwm_amount_fan[2] >> 1);
   1765                    WRITE_FAN2(soft_pwm_count_fan[2] > pwm_mask ? HIGH : LOW);
   1766                  #endif
   1767                #endif
   1768              }
   1769              else {
   1770                if (soft_pwm_count_0 <= pwm_count_tmp) WRITE_HEATER_0(LOW);
   \                     ??TemperatureHandler_1: (+1)
   \   00000042   0x7A20             LDRB     R0,[R4, #+8]
   \   00000044   0x4286             CMP      R6,R0
   \   00000046   0xDB08             BLT.N    ??TemperatureHandler_3
   \                     ??TemperatureHandler_2: (+1)
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x....             LDR.N    R0,??DataTable42_26
   \   0000004C   0xF830 0x1C02      LDRH     R1,[R0, #-2]
   \   00000050   0x....             LDR.N    R0,??DataTable42_27
   \   00000052   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \   00000056   0x.... 0x....      BL       HAL_GPIO_WritePin
   1771                #if HOTENDS > 1
   1772                  if (soft_pwm_count_1 <= pwm_count_tmp) WRITE_HEATER_1(LOW);
   1773                  #if HOTENDS > 2
   1774                    if (soft_pwm_count_2 <= pwm_count_tmp) WRITE_HEATER_2(LOW);
   1775                    #if HOTENDS > 3
   1776                      if (soft_pwm_count_3 <= pwm_count_tmp) WRITE_HEATER_3(LOW);
   1777                      #if HOTENDS > 4
   1778                        if (soft_pwm_count_4 <= pwm_count_tmp) WRITE_HEATER_4(LOW);
   1779                      #endif // HOTENDS > 4
   1780                    #endif // HOTENDS > 3
   1781                  #endif // HOTENDS > 2
   1782                #endif // HOTENDS > 1
   1783          
   1784                #if HAS_HEATER_BED
   1785                  if (soft_pwm_count_BED <= pwm_count_tmp) WRITE_HEATER_BED(LOW);
   1786                #endif
   1787          
   1788                #if ENABLED(FAN_SOFT_PWM)
   1789                  #if HAS_FAN0
   1790                    if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
   1791                  #endif
   1792                  #if HAS_FAN1
   1793                    if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
   1794                  #endif
   1795                  #if HAS_FAN2
   1796                    if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN2(LOW);
   1797                  #endif
   1798                #endif
   1799              }
   1800          
   1801              // SOFT_PWM_SCALE to frequency:
   1802              //
   1803              // 0: 16000000/64/256/128 =   7.6294 Hz
   1804              // 1:                / 64 =  15.2588 Hz
   1805              // 2:                / 32 =  30.5176 Hz
   1806              // 3:                / 16 =  61.0352 Hz
   1807              // 4:                /  8 = 122.0703 Hz
   1808              // 5:                /  4 = 244.1406 Hz
   1809              pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
   \                     ??TemperatureHandler_3: (+1)
   \   0000005A   0x1C70             ADDS     R0,R6,#+1
   \   0000005C   0x71E0             STRB     R0,[R4, #+7]
   1810          
   1811            #else // SLOW_PWM_HEATERS
   1812          
   1813              /**
   1814               * SLOW PWM HEATERS
   1815               *
   1816               * For relay-driven heaters
   1817               */
   1818              #ifndef MIN_STATE_TIME
   1819                #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
   1820              #endif
   1821          
   1822              // Macros for Slow PWM timer logic
   1823              #define _SLOW_PWM_ROUTINE(NR, src) \
   1824                soft_pwm_count_ ##NR = src; \
   1825                if (soft_pwm_count_ ##NR > 0) { \
   1826                  if (state_timer_heater_ ##NR == 0) { \
   1827                    if (state_heater_ ##NR == 0) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   1828                    state_heater_ ##NR = 1; \
   1829                    WRITE_HEATER_ ##NR(1); \
   1830                  } \
   1831                } \
   1832                else { \
   1833                  if (state_timer_heater_ ##NR == 0) { \
   1834                    if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   1835                    state_heater_ ##NR = 0; \
   1836                    WRITE_HEATER_ ##NR(0); \
   1837                  } \
   1838                }
   1839              #define SLOW_PWM_ROUTINE(n) _SLOW_PWM_ROUTINE(n, soft_pwm_amount[n])
   1840          
   1841              #define PWM_OFF_ROUTINE(NR) \
   1842                if (soft_pwm_count_ ##NR < slow_pwm_count) { \
   1843                  if (state_timer_heater_ ##NR == 0) { \
   1844                    if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   1845                    state_heater_ ##NR = 0; \
   1846                    WRITE_HEATER_ ##NR (0); \
   1847                  } \
   1848                }
   1849          
   1850              if (slow_pwm_count == 0) {
   1851          
   1852                SLOW_PWM_ROUTINE(0);
   1853                #if HOTENDS > 1
   1854                  SLOW_PWM_ROUTINE(1);
   1855                  #if HOTENDS > 2
   1856                    SLOW_PWM_ROUTINE(2);
   1857                    #if HOTENDS > 3
   1858                      SLOW_PWM_ROUTINE(3);
   1859                      #if HOTENDS > 4
   1860                        SLOW_PWM_ROUTINE(4);
   1861                      #endif // HOTENDS > 4
   1862                    #endif // HOTENDS > 3
   1863                  #endif // HOTENDS > 2
   1864                #endif // HOTENDS > 1
   1865                #if HAS_HEATER_BED
   1866                  _SLOW_PWM_ROUTINE(BED, soft_pwm_amount_bed); // BED
   1867                #endif
   1868          
   1869              } // slow_pwm_count == 0
   1870          
   1871              PWM_OFF_ROUTINE(0);
   1872              #if HOTENDS > 1
   1873                PWM_OFF_ROUTINE(1);
   1874                #if HOTENDS > 2
   1875                  PWM_OFF_ROUTINE(2);
   1876                  #if HOTENDS > 3
   1877                    PWM_OFF_ROUTINE(3);
   1878                    #if HOTENDS > 4
   1879                      PWM_OFF_ROUTINE(4);
   1880                    #endif // HOTENDS > 4
   1881                  #endif // HOTENDS > 3
   1882                #endif // HOTENDS > 2
   1883              #endif // HOTENDS > 1
   1884              #if HAS_HEATER_BED
   1885                PWM_OFF_ROUTINE(BED); // BED
   1886              #endif
   1887          
   1888              #if ENABLED(FAN_SOFT_PWM)
   1889                if (pwm_count_tmp >= 127) {
   1890                  pwm_count_tmp = 0;
   1891                  #if HAS_FAN0
   1892                    soft_pwm_count_fan[0] = soft_pwm_amount_fan[0] >> 1;
   1893                    WRITE_FAN(soft_pwm_count_fan[0] > 0 ? HIGH : LOW);
   1894                  #endif
   1895                  #if HAS_FAN1
   1896                    soft_pwm_count_fan[1] = soft_pwm_amount_fan[1] >> 1;
   1897                    WRITE_FAN1(soft_pwm_count_fan[1] > 0 ? HIGH : LOW);
   1898                  #endif
   1899                  #if HAS_FAN2
   1900                    soft_pwm_count_fan[2] = soft_pwm_amount_fan[2] >> 1;
   1901                    WRITE_FAN2(soft_pwm_count_fan[2] > 0 ? HIGH : LOW);
   1902                  #endif
   1903                }
   1904                #if HAS_FAN0
   1905                  if (soft_pwm_count_fan[0] <= pwm_count_tmp) WRITE_FAN(LOW);
   1906                #endif
   1907                #if HAS_FAN1
   1908                  if (soft_pwm_count_fan[1] <= pwm_count_tmp) WRITE_FAN1(LOW);
   1909                #endif
   1910                #if HAS_FAN2
   1911                  if (soft_pwm_count_fan[2] <= pwm_count_tmp) WRITE_FAN2(LOW);
   1912                #endif
   1913              #endif // FAN_SOFT_PWM
   1914          
   1915              // SOFT_PWM_SCALE to frequency:
   1916              //
   1917              // 0: 16000000/64/256/128 =   7.6294 Hz
   1918              // 1:                / 64 =  15.2588 Hz
   1919              // 2:                / 32 =  30.5176 Hz
   1920              // 3:                / 16 =  61.0352 Hz
   1921              // 4:                /  8 = 122.0703 Hz
   1922              // 5:                /  4 = 244.1406 Hz
   1923              pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
   1924          
   1925              // increment slow_pwm_count only every 64th pwm_count,
   1926              // i.e. yielding a PWM frequency of 16/128 Hz (8s).
   1927              if (((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0) {
   1928                slow_pwm_count++;
   1929                slow_pwm_count &= 0x7F;
   1930          
   1931                if (state_timer_heater_0 > 0) state_timer_heater_0--;
   1932                #if HOTENDS > 1
   1933                  if (state_timer_heater_1 > 0) state_timer_heater_1--;
   1934                  #if HOTENDS > 2
   1935                    if (state_timer_heater_2 > 0) state_timer_heater_2--;
   1936                    #if HOTENDS > 3
   1937                      if (state_timer_heater_3 > 0) state_timer_heater_3--;
   1938                      #if HOTENDS > 4
   1939                        if (state_timer_heater_4 > 0) state_timer_heater_4--;
   1940                      #endif // HOTENDS > 4
   1941                    #endif // HOTENDS > 3
   1942                  #endif // HOTENDS > 2
   1943                #endif // HOTENDS > 1
   1944                #if HAS_HEATER_BED
   1945                  if (state_timer_heater_BED > 0) state_timer_heater_BED--;
   1946                #endif
   1947              } // ((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0
   1948          
   1949            #endif // SLOW_PWM_HEATERS
   1950          
   1951            //
   1952            // Update lcd buttons 488 times per second
   1953            //
   1954            static bool do_buttons;
   1955            if ((do_buttons ^= true)) lcd_buttons_update();
   \   0000005E   0x7A60             LDRB     R0,[R4, #+9]
   \   00000060   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000064   0x1E40             SUBS     R0,R0,#+1
   \   00000066   0x4180             SBCS     R0,R0,R0
   \   00000068   0x43C0             MVNS     R0,R0
   \   0000006A   0x0FC0             LSRS     R0,R0,#+31
   \   0000006C   0x7260             STRB     R0,[R4, #+9]
   \   0000006E   0x7A60             LDRB     R0,[R4, #+9]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD001             BEQ.N    ??TemperatureHandler_4
   \   00000074   0x.... 0x....      BL       _Z18lcd_buttons_updatev
   1956          
   1957            /**
   1958             * One sensor is sampled on every other call of the ISR.
   1959             * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
   1960             *
   1961             * On each Prepare pass, ADC is started for a sensor pin.
   1962             * On the next pass, the ADC value is read and accumulated.
   1963             *
   1964             * This gives each ADC 0.9765ms to charge up.
   1965             */
   1966          #if 0
   1967            #define SET_ADMUX_ADCSRA(pin) ADMUX = _BV(REFS0) | (pin & 0x07); SBI(ADCSRA, ADSC)
   1968            #ifdef MUX5
   1969              #define START_ADC(pin) if (pin > 7) ADCSRB = _BV(MUX5); else ADCSRB = 0; SET_ADMUX_ADCSRA(pin)
   1970            #else
   1971              #define START_ADC(pin) ADCSRB = 0; SET_ADMUX_ADCSRA(pin)
   1972            #endif
   1973          #endif
   1974            switch (adc_sensor_state) {
   \                     ??TemperatureHandler_4: (+1)
   \   00000078   0xF994 0x0006      LDRSB    R0,[R4, #+6]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD10D             BNE.N    ??TemperatureHandler_5
   1975          
   1976              case SensorsReady: {
   1977                // All sensors have been read. Stay in this state for a few
   1978                // ISRs to save on calls to temp update/checking code below.
   1979                constexpr int8_t extra_loops = MIN_ADC_ISR_LOOPS - (int8_t)SensorsReady;
   1980                static uint8_t delay_count = 0;
   1981                if (extra_loops > 0) {
   1982                  if (delay_count == 0) delay_count = extra_loops;   // Init this delay
   \   00000080   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD101             BNE.N    ??TemperatureHandler_6
   \   00000086   0x200A             MOVS     R0,#+10
   \   00000088   0x72A0             STRB     R0,[R4, #+10]
   1983                  if (--delay_count)                                 // While delaying...
   \                     ??TemperatureHandler_6: (+1)
   \   0000008A   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000008C   0x1E40             SUBS     R0,R0,#+1
   \   0000008E   0x72A0             STRB     R0,[R4, #+10]
   \   00000090   0xB2C0             UXTB     R0,R0
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD002             BEQ.N    ??TemperatureHandler_5
   1984                    adc_sensor_state = (ADCSensorState)(int(SensorsReady) - 1); // retain this state (else, next state will be 0)
   \   00000096   0xF04F 0x30FF      MOV      R0,#-1
   \   0000009A   0x71A0             STRB     R0,[R4, #+6]
   1985                  break;
   1986                }
   1987                else
   1988                  adc_sensor_state = (ADCSensorState)0; // Fall-through to start first sensor now
   1989              }
   1990          
   1991              #if HAS_TEMP_0
   1992                case PrepareTemp_0:
   1993                  //START_ADC(TEMP_0_PIN);
   1994                  break;
   1995                case MeasureTemp_0:
   1996          		#if defined(MKS_ROBIN_LITE) || defined(MKS_ROBIN) || defined(MKS_ROBINMINI)
   1997          			raw_temp_value[0] += uhADCxConvertedValue[1]>>2;	//TH1
   1998          		#elif defined(MKS_ROBINPRO) || defined(MKS_ROBIN2) || defined(MKS_ROBIN2MINI)
   1999          			raw_temp_value[0] += uhADCxConvertedValue[1];   	//TH1
   2000          		#endif 
   2001          
   2002                  break;
   2003              #endif
   2004          
   2005              #if HAS_TEMP_BED
   2006                case PrepareTemp_BED:
   2007                  //START_ADC(TEMP_BED_PIN);
   2008                  break;
   2009                case MeasureTemp_BED:
   2010          			#if defined(MKS_ROBIN_LITE) || defined(MKS_ROBIN) || defined(MKS_ROBINMINI)
   2011          				raw_temp_bed_value += uhADCxConvertedValue[0]>>2;	//TB
   2012          			#elif defined(MKS_ROBINPRO) || defined(MKS_ROBIN2) || defined(MKS_ROBIN2MINI)
   2013          				raw_temp_bed_value += uhADCxConvertedValue[0];	//TB
   2014          			#endif 		
   2015                  break;
   2016              #endif
   2017          
   2018              #if HAS_TEMP_1
   2019                case PrepareTemp_1:
   2020                  //START_ADC(TEMP_1_PIN);
   2021                  break;
   2022                case MeasureTemp_1:
   2023          		#if defined(MKS_ROBIN_LITE) || defined(MKS_ROBIN) || defined(MKS_ROBINMINI)
   2024          			raw_temp_value[1] += uhADCxConvertedValue[2]>>2;		//TH2
   2025          		#elif defined(MKS_ROBINPRO) || defined(MKS_ROBIN2) || defined(MKS_ROBIN2MINI)
   2026          			raw_temp_value[1] += uhADCxConvertedValue[2];   //TH2
   2027          		#endif 
   2028          
   2029                  break;
   2030              #endif
   2031          
   2032              #if HAS_TEMP_2
   2033                case PrepareTemp_2:
   2034                  START_ADC(TEMP_2_PIN);
   2035                  break;
   2036                case MeasureTemp_2:
   2037                  raw_temp_value[2] += ADC;
   2038                  break;
   2039              #endif
   2040          
   2041              #if HAS_TEMP_3
   2042                case PrepareTemp_3:
   2043                  START_ADC(TEMP_3_PIN);
   2044                  break;
   2045                case MeasureTemp_3:
   2046                  raw_temp_value[3] += ADC;
   2047                  break;
   2048              #endif
   2049          
   2050              #if HAS_TEMP_4
   2051                case PrepareTemp_4:
   2052                  START_ADC(TEMP_4_PIN);
   2053                  break;
   2054                case MeasureTemp_4:
   2055                  raw_temp_value[4] += ADC;
   2056                  break;
   2057              #endif
   2058          
   2059              #if ENABLED(FILAMENT_WIDTH_SENSOR)
   2060                case Prepare_FILWIDTH:
   2061                  START_ADC(FILWIDTH_PIN);
   2062                break;
   2063                case Measure_FILWIDTH:
   2064                  if (ADC > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
   2065                    raw_filwidth_value -= (raw_filwidth_value >> 7); // Subtract 1/128th of the raw_filwidth_value
   2066                    raw_filwidth_value += ((unsigned long)ADC << 7); // Add new ADC reading, scaled by 128
   2067                  }
   2068                break;
   2069              #endif
   2070          
   2071              #if ENABLED(ADC_KEYPAD)
   2072                case Prepare_ADC_KEY:
   2073                  START_ADC(ADC_KEYPAD_PIN);
   2074                  break;
   2075                case Measure_ADC_KEY:
   2076                  if (ADCKey_count < 16) {
   2077                    raw_ADCKey_value = ADC;
   2078                    if (raw_ADCKey_value > 900) {
   2079                      //ADC Key release
   2080                      ADCKey_count = 0;
   2081                      current_ADCKey_raw = 0;
   2082                    }
   2083                    else {
   2084                      current_ADCKey_raw += raw_ADCKey_value;
   2085                      ADCKey_count++;
   2086                    }
   2087                  }
   2088                  break;
   2089              #endif // ADC_KEYPAD
   2090          
   2091              case StartupDelay: break;
   2092          
   2093            } // switch(adc_sensor_state)
   2094          
   2095            if (!adc_sensor_state && ++temp_count >= OVERSAMPLENR) { // 10 * 16 * 1/(16000000/64/256)  = 164ms.
   \                     ??TemperatureHandler_5: (+1)
   \   0000009C   0xF994 0x0006      LDRSB    R0,[R4, #+6]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD141             BNE.N    ??TemperatureHandler_7
   \   000000A4   0x7960             LDRB     R0,[R4, #+5]
   \   000000A6   0x1C40             ADDS     R0,R0,#+1
   \   000000A8   0x7160             STRB     R0,[R4, #+5]
   \   000000AA   0xB240             SXTB     R0,R0
   \   000000AC   0x2810             CMP      R0,#+16
   \   000000AE   0xDB3B             BLT.N    ??TemperatureHandler_7
   2096          
   2097              temp_count = 0;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x7160             STRB     R0,[R4, #+5]
   2098          
   2099              // Update the raw values if they've been read. Else we could be updating them during reading.
   2100              if (!temp_meas_ready) set_current_temp_raw();
   \   000000B4   0x7820             LDRB     R0,[R4, #+0]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD101             BNE.N    ??TemperatureHandler_8
   \   000000BA   0x.... 0x....      BL       _ZN11Temperature20set_current_temp_rawEv
   2101          
   2102              // Filament Sensor - can be read any time since IIR filtering is used
   2103              #if ENABLED(FILAMENT_WIDTH_SENSOR)
   2104                current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
   2105              #endif
   2106          
   2107              ZERO(raw_temp_value);
   \                     ??TemperatureHandler_8: (+1)
   \   000000BE   0x2202             MOVS     R2,#+2
   \   000000C0   0x2100             MOVS     R1,#+0
   \   000000C2   0xF104 0x0056      ADD      R0,R4,#+86
   \   000000C6   0x.... 0x....      BL       memset
   2108              raw_temp_bed_value = 0;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x81E0             STRH     R0,[R4, #+14]
   2109          
   2110              #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) > (HEATER_##N##_RAW_HI_TEMP) ? -1 : 1)
   2111          
   2112              int constexpr temp_dir[] = {
   2113                #if ENABLED(HEATER_0_USES_MAX6675)
   2114                   0
   2115                #else
   2116                  TEMPDIR(0)
   2117                #endif
   2118                #if HOTENDS > 1
   2119                  , TEMPDIR(1)
   2120                  #if HOTENDS > 2
   2121                    , TEMPDIR(2)
   2122                    #if HOTENDS > 3
   2123                      , TEMPDIR(3)
   2124                      #if HOTENDS > 4
   2125                        , TEMPDIR(4)
   2126                      #endif // HOTENDS > 4
   2127                    #endif // HOTENDS > 3
   2128                  #endif // HOTENDS > 2
   2129                #endif // HOTENDS > 1
   2130              };
   \   000000CE   0xA800             ADD      R0,SP,#+0
   \   000000D0   0x.... 0x....      ADR.W    R1,`?<Constant {1}>`
   \   000000D4   0x680A             LDR      R2,[R1, #0]
   \   000000D6   0x6002             STR      R2,[R0, #+0]
   2131          
   2132              for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xE023             B.N      ??TemperatureHandler_9
   2133                const int16_t tdir = temp_dir[e], rawtemp = current_temperature_raw[e] * tdir;
   \                     ??TemperatureHandler_10: (+1)
   \   000000DC   0xA800             ADD      R0,SP,#+0
   \   000000DE   0xF9B0 0x6000      LDRSH    R6,[R0, #+0]
   \   000000E2   0x69E0             LDR      R0,[R4, #+28]
   \   000000E4   0xFB06 0xF800      MUL      R8,R6,R0
   \   000000E8   0xFA0F 0xF888      SXTH     R8,R8
   2134                const bool heater_on = 0 <
   2135                  #if ENABLED(PIDTEMP)
   2136                    soft_pwm_amount[e]
   2137                  #else
   2138                    target_temperature[e]
   2139                  #endif
   2140                ;
   \   000000EC   0x78A0             LDRB     R0,[R4, #+2]
   \   000000EE   0x1E47             SUBS     R7,R0,#+1
   \   000000F0   0x41BF             SBCS     R7,R7,R7
   \   000000F2   0x43FF             MVNS     R7,R7
   \   000000F4   0x0FFF             LSRS     R7,R7,#+31
   2141                if (rawtemp > maxttemp_raw[e] * tdir && heater_on) max_temp_error(e);
   \   000000F6   0xF9B4 0x0014      LDRSH    R0,[R4, #+20]
   \   000000FA   0xFB16 0xF000      SMULBB   R0,R6,R0
   \   000000FE   0x4540             CMP      R0,R8
   \   00000100   0xDA04             BGE.N    ??TemperatureHandler_11
   \   00000102   0x2F00             CMP      R7,#+0
   \   00000104   0xD002             BEQ.N    ??TemperatureHandler_11
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x.... 0x....      BL       _ZN11Temperature14max_temp_errorEa
   2142                if (rawtemp < minttemp_raw[e] * tdir && !is_preheating(e) && heater_on) {
   \                     ??TemperatureHandler_11: (+1)
   \   0000010C   0xF9B4 0x0012      LDRSH    R0,[R4, #+18]
   \   00000110   0xFB16 0xF000      SMULBB   R0,R6,R0
   \   00000114   0x4580             CMP      R8,R0
   \   00000116   0xDA04             BGE.N    ??TemperatureHandler_12
   \   00000118   0x2F00             CMP      R7,#+0
   \   0000011A   0xD002             BEQ.N    ??TemperatureHandler_12
   2143                  #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   2144                    if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
   2145                  #endif
   2146                      min_temp_error(e);
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0x.... 0x....      BL       _ZN11Temperature14min_temp_errorEa
   2147                }
   2148                #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   2149                  else
   2150                    consecutive_low_temperature_error[e] = 0;
   2151                #endif
   2152              }
   \                     ??TemperatureHandler_12: (+1)
   \   00000122   0x2001             MOVS     R0,#+1
   \                     ??TemperatureHandler_9: (+1)
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD0D9             BEQ.N    ??TemperatureHandler_10
   2153          
   2154              #if HAS_TEMP_BED
   2155                #if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
   2156                  #define GEBED <=
   2157                #else
   2158                  #define GEBED >=
   2159                #endif
   2160                const bool bed_on = 0 <
   2161                  #if ENABLED(PIDTEMPBED)
   2162                    soft_pwm_amount_bed
   2163                  #else
   2164                    target_temperature_bed
   2165                  #endif
   2166                ;
   2167                if (current_temperature_bed_raw GEBED bed_maxttemp_raw && bed_on) max_temp_error(-1);
   2168                if (bed_minttemp_raw GEBED current_temperature_bed_raw && bed_on) min_temp_error(-1);
   2169              #endif
   2170          
   2171            } // temp_count >= OVERSAMPLENR
   2172          
   2173            // Go to the next state, up to SensorsReady
   2174            adc_sensor_state = (ADCSensorState)(int(adc_sensor_state) + 1);
   \                     ??TemperatureHandler_7: (+1)
   \   00000128   0x79A0             LDRB     R0,[R4, #+6]
   \   0000012A   0x1C40             ADDS     R0,R0,#+1
   \   0000012C   0x71A0             STRB     R0,[R4, #+6]
   2175            if (adc_sensor_state > SensorsReady) adc_sensor_state = (ADCSensorState)0;
   \   0000012E   0xB240             SXTB     R0,R0
   \   00000130   0x2801             CMP      R0,#+1
   \   00000132   0xDB01             BLT.N    ??TemperatureHandler_13
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0x71A0             STRB     R0,[R4, #+6]
   2176          
   2177            #if ENABLED(BABYSTEPPING)
   2178              LOOP_XYZ(axis) {
   2179                const int curTodo = babystepsTodo[axis]; // get rid of volatile for performance
   2180                if (curTodo) {
   2181                  stepper.babystep((AxisEnum)axis, curTodo > 0);
   2182                  if (curTodo > 0) babystepsTodo[axis]--;
   2183                              else babystepsTodo[axis]++;
   2184                }
   2185              }
   2186            #endif // BABYSTEPPING
   2187          
   2188            #if ENABLED(PINS_DEBUGGING)
   2189              extern bool endstop_monitor_flag;
   2190              // run the endstop monitor at 15Hz
   2191              static uint8_t endstop_monitor_count = 16;  // offset this check from the others
   2192              if (endstop_monitor_flag) {
   2193                endstop_monitor_count += _BV(1);  //  15 Hz
   2194                endstop_monitor_count &= 0x7F;
   2195                if (!endstop_monitor_count) endstop_monitor();  // report changes in endstop status
   2196              }
   2197            #endif
   2198          
   2199            #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   2200          
   2201              extern volatile uint8_t e_hit;
   2202          
   2203              if (e_hit && ENDSTOPS_ENABLED) {
   2204                endstops.update();  // call endstop update routine
   2205                e_hit--;
   2206              }
   2207            #endif
   2208          
   2209            //cli();
   2210            in_temp_isr = false;
   \                     ??TemperatureHandler_13: (+1)
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x7120             STRB     R0,[R4, #+4]
   2211            //SBI(TIMSK0, OCIE0B); //re-enable Temperature ISR
   2212            HAL_TIM_Base_Start_IT(&htim4);
   \   0000013C   0x4628             MOV      R0,R5
   \   0000013E   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   2213          }
   \                     ??TemperatureHandler_0: (+1)
   \   00000142   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return

   \                                 In section .data, align 4
   \                     _ZN11Temperature15temp_meas_readyE:
   \   00000000   0x00               DC8 0
   \                     _ZN11Temperature9pid_resetE:
   \   00000001   0x00               DC8 0
   \                     _ZN11Temperature15soft_pwm_amountE:
   \   00000002   0x00               DC8 0
   \                     _ZN11Temperature19soft_pwm_amount_bedE:
   \   00000003   0x00               DC8 0
   \                     _ZN11Temperature11in_temp_isrE:
   \   00000004   0x00               DC8 0
   \   00000005   0xFF               DC8 -1
   \   00000006   0x01               DC8 1
   \   00000007   0x01               DC8 1
   \   00000008   0x00               DC8 0
   \   00000009   0x00               DC8 0
   \   0000000A   0x00               DC8 0
   \   0000000B   0x00               DC8 0
   \                     _ZN11Temperature17watch_target_tempE:
   \   0000000C   0x0000             DC16 0
   \                     _ZN11Temperature18raw_temp_bed_valueE:
   \   0000000E   0x0000             DC16 0
   \                     _ZN11Temperature8maxttempE:
   \   00000010   0x3FFF             DC16 16383
   \                     _ZN11Temperature12minttemp_rawE:
   \   00000012   0x0000             DC16 0
   \                     _ZN11Temperature12maxttemp_rawE:
   \   00000014   0x3FFF             DC16 16383
   \                     _ZN11Temperature8minttempE:
   \   00000016   0x0000             DC16 0
   \                     _ZN11Temperature19current_temperatureE:
   \   00000018   0x00000000         DC32 0H
   \                     _ZN11Temperature23current_temperature_rawE:
   \   0000001C   0x00000000         DC32 0
   \                     _ZN11Temperature18target_temperatureE:
   \   00000020   0x00000000         DC32 0
   \                     _ZN11Temperature27current_temperature_bed_rawE:
   \   00000024   0x00000000         DC32 0
   \                     _ZN11Temperature2KpE:
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature2KiE:
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature2KdE:
   \   00000030   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature20watch_heater_next_msE:
   \   00000034   0x00000000         DC32 0
   \                     _ZN11Temperature11temp_iStateE:
   \   00000038   0x00000000         DC32 0H
   \                     _ZN11Temperature11temp_dStateE:
   \   0000003C   0x00000000         DC32 0H
   \                     _ZN11Temperature5pTermE:
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature5iTermE:
   \   00000044   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature5dTermE:
   \   00000048   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature9pid_errorE:
   \   0000004C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature17next_bed_check_msE:
   \   00000050   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature29thermal_runaway_state_machineE:
   \   00000054   0x00               DC8 0
   \   00000055   0x00               DC8 0
   \                     _ZN11Temperature14raw_temp_valueE:
   \   00000056   0x0000             DC16 0
   \                     _ZN11Temperature21thermal_runaway_timerE:
   \   00000058   0x00000000         DC32 0

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp Temperature::subobject Temperature()
   \                     _ZN11TemperatureC2Ev: (+1)
   \   00000000   0x....             B.N      _ZN11TemperatureC1Ev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   0x41200001         DC32     0x41200001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \   00000000   0x437F0000         DC32     0x437f0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_2:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_3:
   \   00000000   0x437F0001         DC32     0x437f0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \   00000000   0x........         DC32     Serial6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_1:
   \   00000000   0x........         DC32     _ZN11Temperature15temp_meas_readyE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_2:
   \   00000000   0x........         DC32     wait_for_heatup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_3:
   \   00000000   0xFFFFEC78         DC32     0xffffec78

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_4:
   \   00000000   0x40100000         DC32     0x40100000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_5:
   \   00000000   0x54442D18         DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_6:
   \   00000000   0x400921FB         DC32     0x400921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_7:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_8:
   \   00000000   0xD2F1A9FC         DC32     0xd2f1a9fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_9:
   \   00000000   0x3F50624D         DC32     0x3f50624d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_10:
   \   00000000   0x3FE33333         DC32     0x3fe33333

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_11:
   \   00000000   0x00124F81         DC32     0x124f81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_12:
   \   00000000   0x88E368F1         DC32     0x88e368f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_13:
   \   00000000   0x3FC4F8B5         DC32     0x3fc4f8b5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_14:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_15:
   \   00000000   0x........         DC32     ??killed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_16:
   \   00000000   0x........         DC32     Running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_17:
   \   00000000   0x999999A0         DC32     0x999999a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_18:
   \   00000000   0x3FA99999         DC32     0x3fa99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_19:
   \   00000000   0x3FEE6666         DC32     0x3fee6666

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_20:
   \   00000000   0x........         DC32     heater_ttbllen_map

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_21:
   \   00000000   0x3F9F4000         DC32     0x3f9f4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_22:
   \   00000000   0x........         DC32     ??tr_target_temperature

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_23:
   \   00000000   0x........         DC32     _ZN7Planner16autotemp_enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_24:
   \   00000000   0x........         DC32     print_job_timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_25:
   \   00000000   0x........         DC32     htim4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_26:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_27:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " - Invalid extruder n...">`:
   \   00000000   0x20 0x2D          DC8 " - Invalid extruder number !\012"
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x65    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x20 0x21    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "KILLED. ">`:
   \   00000000   0x4B 0x49          DC8 "KILLED. "
   \              0x4C 0x4C    
   \              0x45 0x44    
   \              0x2E 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {1}>`:
   \   00000000   0x00000001         DC32 1

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Heating failed">`:
   \   00000000   0x48 0x65          DC8 "Heating failed"
   \              0x61 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune failed! ...">`:
   \   00000000   0x50 0x49          DC8 "PID Autotune failed! Bad extruder number"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x42    
   \              0x61 0x64    
   \              0x20 0x65    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune start">`:
   \   00000000   0x50 0x49          DC8 "PID Autotune start"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " bias: ">`:
   \   00000000   0x20 0x62          DC8 " bias: "
   \              0x69 0x61    
   \              0x73 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " d: ">`:
   \   00000000   0x20 0x64          DC8 " d: "
   \              0x3A 0x20    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " min: ">`:
   \   00000000   0x20 0x6D          DC8 " min: "
   \              0x69 0x6E    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " max: ">`:
   \   00000000   0x20 0x6D          DC8 " max: "
   \              0x61 0x78    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Ku: ">`:
   \   00000000   0x20 0x4B          DC8 " Ku: "
   \              0x75 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Tu: ">`:
   \   00000000   0x20 0x54          DC8 " Tu: "
   \              0x75 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\n Classic PID \\n">`:
   \   00000000   0x0A 0x20          DC8 "\012 Classic PID \012"
   \              0x43 0x6C    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x63 0x20    
   \              0x50 0x49    
   \              0x44 0x20    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Kp: ">`:
   \   00000000   0x20 0x4B          DC8 " Kp: "
   \              0x70 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Ki: ">`:
   \   00000000   0x20 0x4B          DC8 " Ki: "
   \              0x69 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Kd: ">`:
   \   00000000   0x20 0x4B          DC8 " Kd: "
   \              0x64 0x3A    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune failed! ...">_1`:
   \   00000000   0x50 0x49          DC8 "PID Autotune failed! Temperature too high\012"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x54    
   \              0x65 0x6D    
   \              0x70 0x65    
   \              0x72 0x61    
   \              0x74 0x75    
   \              0x72 0x65    
   \              0x20 0x74    
   \              0x6F 0x6F    
   \              0x20 0x68    
   \              0x69 0x67    
   \              0x68 0x0A    
   \              0x00         
   \   0000002B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Thermal Runaway">`:
   \   00000000   0x54 0x68          DC8 "Thermal Runaway"
   \              0x65 0x72    
   \              0x6D 0x61    
   \              0x6C 0x20    
   \              0x52 0x75    
   \              0x6E 0x61    
   \              0x77 0x61    
   \              0x79 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "THERMAL RUNAWAY">`:
   \   00000000   0x54 0x48          DC8 "THERMAL RUNAWAY"
   \              0x45 0x52    
   \              0x4D 0x41    
   \              0x4C 0x20    
   \              0x52 0x55    
   \              0x4E 0x41    
   \              0x57 0x41    
   \              0x59 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune failed! ...">_2`:
   \   00000000   0x50 0x49          DC8 "PID Autotune failed! timeout\012"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "PID Autotune finished...">`:
   \   00000000   0x50 0x49          DC8 50H, 49H, 44H, 20H, 41H, 75H, 74H, 6FH
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \   00000008   0x74 0x75          DC8 74H, 75H, 6EH, 65H, 20H, 66H, 69H, 6EH
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x69 0x6E    
   \   00000010   0x69 0x73          DC8 69H, 73H, 68H, 65H, 64H, 21H, 20H, 50H
   \              0x68 0x65    
   \              0x64 0x21    
   \              0x20 0x50    
   \   00000018   0x75 0x74          DC8 75H, 74H, 20H, 74H, 68H, 65H, 20H, 6CH
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x6C    
   \   00000020   0x61 0x73          DC8 61H, 73H, 74H, 20H, 4BH, 70H, 2CH, 20H
   \              0x74 0x20    
   \              0x4B 0x70    
   \              0x2C 0x20    
   \   00000028   0x4B 0x69          DC8 4BH, 69H, 20H, 61H, 6EH, 64H, 20H, 4BH
   \              0x20 0x61    
   \              0x6E 0x64    
   \              0x20 0x4B    
   \   00000030   0x64 0x20          DC8 64H, 20H, 63H, 6FH, 6EH, 73H, 74H, 61H
   \              0x63 0x6F    
   \              0x6E 0x73    
   \              0x74 0x61    
   \   00000038   0x6E 0x74          DC8 6EH, 74H, 73H, 20H, 66H, 72H, 6FH, 6DH
   \              0x73 0x20    
   \              0x66 0x72    
   \              0x6F 0x6D    
   \   00000040   0x20 0x62          DC8 20H, 62H, 65H, 6CH, 6FH, 77H, 20H, 69H
   \              0x65 0x6C    
   \              0x6F 0x77    
   \              0x20 0x69    
   \   00000048   0x6E 0x74          DC8 6EH, 74H, 6FH, 20H, 43H, 6FH, 6EH, 66H
   \              0x6F 0x20    
   \              0x43 0x6F    
   \              0x6E 0x66    
   \   00000050   0x69 0x67          DC8 69H, 67H, 75H, 72H, 61H, 74H, 69H, 6FH
   \              0x75 0x72    
   \              0x61 0x74    
   \              0x69 0x6F    
   \   00000058   0x6E 0x2E          DC8 6EH, 2EH, 68H, 0AH, 0
   \              0x68 0x0A    
   \              0x00         
   \   0000005D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_Kp ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_Kp "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x70 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_Ki ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_Ki "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x69 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "#define  DEFAULT_Kd ">`:
   \   00000000   0x23 0x64          DC8 "#define  DEFAULT_Kd "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x64 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ", system stopped! Hea...">`:
   \   00000000   0x2C 0x20          DC8 ", system stopped! Heater_ID: "
   \              0x73 0x79    
   \              0x73 0x74    
   \              0x65 0x6D    
   \              0x20 0x73    
   \              0x74 0x6F    
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x21 0x20    
   \              0x48 0x65    
   \              0x61 0x74    
   \              0x65 0x72    
   \              0x5F 0x49    
   \              0x44 0x3A    
   \              0x20 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "bed\\n">`:
   \   00000000   0x62 0x65          DC8 "bed\012"
   \              0x64 0x0A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MINTEMP triggered">`:
   \   00000000   0x4D 0x49          DC8 "MINTEMP triggered"
   \              0x4E 0x54    
   \              0x45 0x4D    
   \              0x50 0x20    
   \              0x74 0x72    
   \              0x69 0x67    
   \              0x67 0x65    
   \              0x72 0x65    
   \              0x64 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Err: MINTEMP">`:
   \   00000000   0x45 0x72          DC8 "Err: MINTEMP"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x49 0x4E    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MAXTEMP triggered">`:
   \   00000000   0x4D 0x41          DC8 "MAXTEMP triggered"
   \              0x58 0x54    
   \              0x45 0x4D    
   \              0x50 0x20    
   \              0x74 0x72    
   \              0x69 0x67    
   \              0x67 0x65    
   \              0x72 0x65    
   \              0x64 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Err: MAXTEMP">`:
   \   00000000   0x45 0x72          DC8 "Err: MAXTEMP"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x41 0x58    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   2214          
   2215          #if HAS_TEMP_HOTEND || HAS_TEMP_BED
   2216          
   2217            void print_heater_state(const float &c, const float &t,
   2218              #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2219                const float r,
   2220              #endif
   2221              const int8_t e=-2
   2222            ) {
   2223              #if !(HAS_TEMP_BED && HAS_TEMP_HOTEND) && HOTENDS <= 1
   2224                UNUSED(e);
   2225              #endif
   2226          
   2227              SERIAL_PROTOCOLCHAR(' ');
   2228              SERIAL_PROTOCOLCHAR(
   2229                #if HAS_TEMP_BED && HAS_TEMP_HOTEND
   2230                  e == -1 ? 'B' : 'T'
   2231                #elif HAS_TEMP_HOTEND
   2232                  'T'
   2233                #else
   2234                  'B'
   2235                #endif
   2236              );
   2237              #if HOTENDS > 1
   2238                if (e >= 0) SERIAL_PROTOCOLCHAR('0' + e);
   2239              #endif
   2240              SERIAL_PROTOCOLCHAR(':');
   2241              SERIAL_PROTOCOL(c);
   2242              SERIAL_PROTOCOLPAIR(" /" , t);
   2243              #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2244                SERIAL_PROTOCOLPAIR(" (", r / OVERSAMPLENR);
   2245                SERIAL_PROTOCOLCHAR(')');
   2246              #endif
   2247            }
   2248          
   2249            extern uint8_t target_extruder;
   2250          
   2251            void Temperature::print_heaterstates() {
   2252              #if HAS_TEMP_HOTEND
   2253                print_heater_state(degHotend(target_extruder), degTargetHotend(target_extruder)
   2254                  #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2255                    , rawHotendTemp(target_extruder)
   2256                  #endif
   2257                );
   2258              #endif
   2259              #if HAS_TEMP_BED
   2260                print_heater_state(degBed(), degTargetBed()
   2261                  #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2262                    , rawBedTemp()
   2263                  #endif
   2264                  , -1 // BED
   2265                );
   2266              #endif
   2267              #if HOTENDS > 1
   2268                HOTEND_LOOP() print_heater_state(degHotend(e), degTargetHotend(e)
   2269                  #if ENABLED(SHOW_TEMP_ADC_VALUES)
   2270                    , rawHotendTemp(e)
   2271                  #endif
   2272                  , e
   2273                );
   2274              #endif
   2275              SERIAL_PROTOCOLPGM(" @:");
   2276              SERIAL_PROTOCOL(getHeaterPower(target_extruder));
   2277              #if HAS_TEMP_BED
   2278                SERIAL_PROTOCOLPGM(" B@:");
   2279                SERIAL_PROTOCOL(getHeaterPower(-1));
   2280              #endif
   2281              #if HOTENDS > 1
   2282                HOTEND_LOOP() {
   2283                  SERIAL_PROTOCOLPAIR(" @", e);
   2284                  SERIAL_PROTOCOLCHAR(':');
   2285                  SERIAL_PROTOCOL(getHeaterPower(e));
   2286                }
   2287              #endif
   2288            }
   2289          
   2290            #if ENABLED(AUTO_REPORT_TEMPERATURES)
   2291          
   2292              uint8_t Temperature::auto_report_temp_interval;
   2293              millis_t Temperature::next_temp_report_ms;
   2294          
   2295              void Temperature::auto_report_temperatures() {
   2296                if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
   2297                  next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
   2298                  print_heaterstates();
   2299                  SERIAL_EOL();
   2300                }
   2301              }
   2302          
   2303            #endif // AUTO_REPORT_TEMPERATURES
   2304          
   2305          #endif // HAS_TEMP_HOTEND || HAS_TEMP_BED

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   IsRunning()
       0   IsrTemperatureHandler
         0   -> Temperature::TemperatureHandler()
     112   Temperature::PID_autotune(float, int8_t, int8_t, bool)
       112   -> HAL_GetTick
       112   -> Print::print(char const *)
       112   -> Temperature::_temp_error(int8_t, char const *, char const *)
         0   -> Temperature::disable_all_heaters()
       112   -> Temperature::disable_all_heaters()
         0   -> Temperature::updatePID()
       112   -> Temperature::updateTemperaturesFromRawValues()
         0   -> USARTClass::write(uint8_t)
       112   -> USARTClass::write(uint8_t)
       112   -> __aeabi_d2f
       112   -> __aeabi_ddiv
       112   -> __aeabi_dmul
       112   -> __aeabi_f2d
       112   -> __aeabi_i2d
       112   -> lcd_update()
       112   -> serial_echopair_P(char const *, float)
       112   -> serial_echopair_P(char const *, long)
       112   -> serialprintPGM(char const *)
       0   Temperature::Temperature()
      32   Temperature::TemperatureHandler()
        32   -> HAL_GPIO_WritePin
        32   -> HAL_TIM_Base_Start_IT
        32   -> HAL_TIM_Base_Stop_IT
        32   -> Temperature::max_temp_error(int8_t)
        32   -> Temperature::min_temp_error(int8_t)
        32   -> Temperature::set_current_temp_raw()
        32   -> lcd_buttons_update()
        32   -> memset
      16   Temperature::_temp_error(int8_t, char const *, char const *)
        16   -> IsRunning()
        16   -> Print::print(int, int)
         0   -> Temperature::disable_all_heaters()
        16   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
      24   Temperature::analog2temp(int, uint8_t)
        24   -> Print::print(int, int)
        24   -> __aeabi_d2f
        24   -> __aeabi_dmul
        24   -> __aeabi_i2d
        24   -> kill(char const *)
        24   -> serialprintPGM(char const *)
       0   Temperature::degHotend(uint8_t)
       0   Temperature::degTargetHotend(uint8_t)
       8   Temperature::disable_all_heaters()
         0   -> Stopwatch::stop()
         8   -> Temperature::setTargetBed(float)
         8   -> Temperature::setTargetHotend(float, uint8_t)
       0   Temperature::getHeaterPower(int)
      32   Temperature::get_pid_output(int8_t)
        32   -> __aeabi_d2f
        32   -> __aeabi_dadd
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
       0   Temperature::init()
      40   Temperature::manage_heater()
        40   -> HAL_GetTick
        40   -> Temperature::_temp_error(int8_t, char const *, char const *)
        40   -> Temperature::degHotend(uint8_t)
        40   -> Temperature::get_pid_output(int8_t)
        40   -> Temperature::start_watching_heater(uint8_t)
        40   -> Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int8_t, uint16_t, uint16_t)
        40   -> Temperature::updateTemperaturesFromRawValues()
       0   Temperature::max_temp_error(int8_t)
         0   -> Temperature::_temp_error(int8_t, char const *, char const *)
       0   Temperature::min_temp_error(int8_t)
         0   -> Temperature::_temp_error(int8_t, char const *, char const *)
       0   Temperature::setTargetBed(float)
       0   Temperature::setTargetHotend(float, uint8_t)
         0   -> Temperature::start_watching_heater(uint8_t)
       0   Temperature::set_current_temp_raw()
      16   Temperature::start_watching_heater(uint8_t)
        16   -> HAL_GetTick
        16   -> Temperature::degHotend(uint8_t)
        16   -> Temperature::degTargetHotend(uint8_t)
       0   Temperature::subobject Temperature()
         0   -> Temperature::Temperature()
      24   Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int8_t, uint16_t, uint16_t)
        24   -> HAL_GetTick
         0   -> Temperature::_temp_error(int8_t, char const *, char const *)
       0   Temperature::updatePID()
      16   Temperature::updateTemperaturesFromRawValues()
        16   -> Temperature::analog2temp(int, uint8_t)
       0   lcd_buttons_update()
       0   lcd_update()
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant " - Invalid extruder n...">
       8  ?<Constant " Kd: ">
       8  ?<Constant " Ki: ">
       8  ?<Constant " Kp: ">
       8  ?<Constant " Ku: ">
       8  ?<Constant " Tu: ">
       8  ?<Constant " bias: ">
       8  ?<Constant " d: ">
       8  ?<Constant " max: ">
       8  ?<Constant " min: ">
      24  ?<Constant "#define  DEFAULT_Kd ">
      24  ?<Constant "#define  DEFAULT_Ki ">
      24  ?<Constant "#define  DEFAULT_Kp ">
      32  ?<Constant ", system stopped! Hea...">
      16  ?<Constant "Err: MAXTEMP">
      16  ?<Constant "Err: MINTEMP">
      16  ?<Constant "Heating failed">
      12  ?<Constant "KILLED. ">
      20  ?<Constant "MAXTEMP triggered">
      20  ?<Constant "MINTEMP triggered">
      44  ?<Constant "PID Autotune failed! ...">
      44  ?<Constant "PID Autotune failed! ...">_1
      32  ?<Constant "PID Autotune failed! ...">_2
      96  ?<Constant "PID Autotune finished...">
      20  ?<Constant "PID Autotune start">
      16  ?<Constant "THERMAL RUNAWAY">
      16  ?<Constant "Thermal Runaway">
      16  ?<Constant "\n Classic PID \n">
       8  ?<Constant "bed\n">
       4  ?<Constant {1}>
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable41
       4  ??DataTable42
       4  ??DataTable42_1
       4  ??DataTable42_10
       4  ??DataTable42_11
       4  ??DataTable42_12
       4  ??DataTable42_13
       4  ??DataTable42_14
       4  ??DataTable42_15
       4  ??DataTable42_16
       4  ??DataTable42_17
       4  ??DataTable42_18
       4  ??DataTable42_19
       4  ??DataTable42_2
       4  ??DataTable42_20
       4  ??DataTable42_21
       4  ??DataTable42_22
       4  ??DataTable42_23
       4  ??DataTable42_24
       4  ??DataTable42_25
       4  ??DataTable42_26
       4  ??DataTable42_27
       4  ??DataTable42_3
       4  ??DataTable42_4
       4  ??DataTable42_5
       4  ??DataTable42_6
       4  ??DataTable42_7
       4  ??DataTable42_8
       4  ??DataTable42_9
      12  IsRunning()
       2  IsrTemperatureHandler
    1056  Temperature::PID_autotune(float, int8_t, int8_t, bool)
       2  Temperature::Temperature()
     326  Temperature::TemperatureHandler()
     102  Temperature::_temp_error(int8_t, char const *, char const *)
     198  Temperature::analog2temp(int, uint8_t)
       4  Temperature::current_temperature_bed
      12  Temperature::degHotend(uint8_t)
      16  Temperature::degTargetHotend(uint8_t)
      50  Temperature::disable_all_heaters()
      18  Temperature::getHeaterPower(int)
     308  Temperature::get_pid_output(int8_t)
      26  Temperature::init()
     240  Temperature::manage_heater()
      12  Temperature::max_temp_error(int8_t)
      12  Temperature::min_temp_error(int8_t)
       2  Temperature::setTargetBed(float)
      20  Temperature::setTargetHotend(float, uint8_t)
      12  Temperature::set_current_temp_raw()
      90  Temperature::start_watching_heater(uint8_t)
       2  Temperature::subobject Temperature()
      92  Temperature::temp_meas_ready
          Temperature::pid_reset
          Temperature::soft_pwm_amount
          Temperature::soft_pwm_amount_bed
          Temperature::in_temp_isr
          temp_count
          adc_sensor_state
          pwm_count
          soft_pwm_count_0
          do_buttons
          delay_count
          Temperature::watch_target_temp
          Temperature::raw_temp_bed_value
          Temperature::maxttemp
          Temperature::minttemp_raw
          Temperature::maxttemp_raw
          Temperature::minttemp
          Temperature::current_temperature
          Temperature::current_temperature_raw
          Temperature::target_temperature
          Temperature::current_temperature_bed_raw
          Temperature::Kp
          Temperature::Ki
          Temperature::Kd
          Temperature::watch_heater_next_ms
          Temperature::temp_iState
          Temperature::temp_dState
          Temperature::pTerm
          Temperature::iTerm
          Temperature::dTerm
          Temperature::pid_error
          Temperature::next_bed_check_ms
          Temperature::thermal_runaway_state_machine
          Temperature::raw_temp_value
          Temperature::thermal_runaway_timer
     182  Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int8_t, uint16_t, uint16_t)
       2  Temperature::updatePID()
      44  Temperature::updateTemperaturesFromRawValues()
       8  heater_ttbllen_map
          heater_ttbl_map
       1  killed
       2  lcd_buttons_update()
       2  lcd_update()
      28  serialprintPGM(char const *)
       4  thermalManager
       8  tr_target_temperature
       1  -- Other

 
    25 bytes in section .bss
    92 bytes in section .data
     1 byte  in section .rodata
 3 514 bytes in section .text
 
 3 418 bytes of CODE  memory (+ 96 bytes shared)
     0 bytes of CONST memory (+  1 byte  shared)
   117 bytes of DATA  memory

Errors: none
Warnings: 46
