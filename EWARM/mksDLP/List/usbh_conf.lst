###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:31
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Src\usbh_conf.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Src\usbh_conf.c -D
#        USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\usbh_conf.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\usbh_conf.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Src\usbh_conf.c
      1          /**
      2            ******************************************************************************
      3            * @file            : usbh_conf.c
      4            * @version         : v1.0_Cube
      5            * @brief           : This file implements the board support package for the USB host library
      6            ******************************************************************************
      7            *
      8            * Copyright (c) 2016 STMicroelectronics International N.V. 
      9            * All rights reserved.
     10            *
     11            * Redistribution and use in source and binary forms, with or without 
     12            * modification, are permitted, provided that the following conditions are met:
     13            *
     14            * 1. Redistribution of source code must retain the above copyright notice, 
     15            *    this list of conditions and the following disclaimer.
     16            * 2. Redistributions in binary form must reproduce the above copyright notice,
     17            *    this list of conditions and the following disclaimer in the documentation
     18            *    and/or other materials provided with the distribution.
     19            * 3. Neither the name of STMicroelectronics nor the names of other 
     20            *    contributors to this software may be used to endorse or promote products 
     21            *    derived from this software without specific written permission.
     22            * 4. This software, including modifications and/or derivative works of this 
     23            *    software, must execute solely and exclusively on microcontroller or
     24            *    microprocessor devices manufactured by or for STMicroelectronics.
     25            * 5. Redistribution and use of this software other than as permitted under 
     26            *    this license is void and will automatically terminate your rights under 
     27            *    this license. 
     28            *
     29            * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS" 
     30            * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT 
     31            * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
     32            * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
     33            * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT 
     34            * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
     35            * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     36            * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
     37            * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
     38            * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
     39            * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     40            * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     41            *
     42            ******************************************************************************
     43          */
     44          /* Includes ------------------------------------------------------------------*/
     45          #include "usbh_core.h"
     46          

   \                                 In section .bss, align 4
     47          HCD_HandleTypeDef hhcd_USB_OTG_FS;
   \                     hhcd_USB_OTG_FS:
   \   00000000                      DS8 664
     48          void Error_Handler(void);
     49          
     50          /*******************************************************************************
     51                                 LL Driver Callbacks (HCD -> USB Host Library)
     52          *******************************************************************************/
     53          /* MSP Init */
     54          

   \                                 In section .text, align 2, keep-with-next
     55          void HAL_HCD_MspInit(HCD_HandleTypeDef* hcdHandle)
     56          {
     57            GPIO_InitTypeDef GPIO_InitStruct;
     58            if(hcdHandle->Instance==USB_OTG_FS)
   \                     HAL_HCD_MspInit: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0xF1B0 0x4FA0      CMP      R0,#+1342177280
   \   00000006   0xD000             BEQ.N    ??HAL_HCD_MspInit_0
   \   00000008   0x4770             BX       LR
     59            {
     60            /* USER CODE BEGIN USB_OTG_FS_MspInit 0 */
     61          
     62            /* USER CODE END USB_OTG_FS_MspInit 0 */
     63            
     64              /**USB_OTG_FS GPIO Configuration    
     65              PA8     ------> USB_OTG_FS_SOF
     66              PA11     ------> USB_OTG_FS_DM
     67              PA12     ------> USB_OTG_FS_DP 
     68              */
     69              GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12;
   \                     ??HAL_HCD_MspInit_0: (+1)
   \   0000000A   0xB500             PUSH     {LR}
   \   0000000C   0xB087             SUB      SP,SP,#+28
   \   0000000E   0xF44F 0x50C8      MOV      R0,#+6400
   \   00000012   0x9001             STR      R0,[SP, #+4]
     70              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x9002             STR      R0,[SP, #+8]
     71              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x9003             STR      R0,[SP, #+12]
     72              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0x9004             STR      R0,[SP, #+16]
     73              GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
   \   00000020   0x200A             MOVS     R0,#+10
   \   00000022   0x9005             STR      R0,[SP, #+20]
     74              HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \   00000024   0xA901             ADD      R1,SP,#+4
   \   00000026   0x....             LDR.N    R0,??DataTable2  ;; 0x40020000
   \   00000028   0x.... 0x....      BL       HAL_GPIO_Init
     75          
     76              /* Peripheral clock enable */
     77              __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
   \   0000002C   0x....             LDR.N    R0,??DataTable2_1  ;; 0x40023834
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000034   0x6001             STR      R1,[R0, #+0]
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x9100             STR      R1,[SP, #+0]
   \   0000003A   0x6901             LDR      R1,[R0, #+16]
   \   0000003C   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000040   0x6101             STR      R1,[R0, #+16]
   \   00000042   0x6900             LDR      R0,[R0, #+16]
   \   00000044   0xF400 0x4080      AND      R0,R0,#0x4000
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0x9800             LDR      R0,[SP, #+0]
     78          
     79              /* Peripheral interrupt init */
     80              //HAL_NVIC_SetPriority(OTG_FS_IRQn, 3, 0);
     81              HAL_NVIC_SetPriority(OTG_FS_IRQn, 2, 0);
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x2102             MOVS     R1,#+2
   \   00000050   0x2043             MOVS     R0,#+67
   \   00000052   0x.... 0x....      BL       HAL_NVIC_SetPriority
     82              HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
   \   00000056   0x2043             MOVS     R0,#+67
   \   00000058   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
     83            /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */
     84          
     85            /* USER CODE END USB_OTG_FS_MspInit 1 */
     86            }
     87          }
   \   0000005C   0xB007             ADD      SP,SP,#+28
   \   0000005E   0xBD00             POP      {PC}             ;; return
     88          

   \                                 In section .text, align 2, keep-with-next
     89          void HAL_HCD_MspDeInit(HCD_HandleTypeDef* hcdHandle)
     90          {
   \                     HAL_HCD_MspDeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     91            if(hcdHandle->Instance==USB_OTG_FS)
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF1B0 0x4FA0      CMP      R0,#+1342177280
   \   00000008   0xD10E             BNE.N    ??HAL_HCD_MspDeInit_0
     92            {
     93            /* USER CODE BEGIN USB_OTG_FS_MspDeInit 0 */
     94          
     95            /* USER CODE END USB_OTG_FS_MspDeInit 0 */
     96              /* Peripheral clock disable */
     97              __HAL_RCC_USB_OTG_FS_CLK_DISABLE();
   \   0000000A   0x....             LDR.N    R0,??DataTable2_1  ;; 0x40023834
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000012   0x6001             STR      R1,[R0, #+0]
     98            
     99              /**USB_OTG_FS GPIO Configuration    
    100              PA8     ------> USB_OTG_FS_SOF
    101              PA11     ------> USB_OTG_FS_DM
    102              PA12     ------> USB_OTG_FS_DP 
    103              */
    104              HAL_GPIO_DeInit(GPIOA, GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12);
   \   00000014   0xF44F 0x51C8      MOV      R1,#+6400
   \   00000018   0x....             LDR.N    R0,??DataTable2  ;; 0x40020000
   \   0000001A   0x.... 0x....      BL       HAL_GPIO_DeInit
    105          
    106              /* Peripheral interrupt Deinit*/
    107              HAL_NVIC_DisableIRQ(OTG_FS_IRQn);
   \   0000001E   0x2043             MOVS     R0,#+67
   \   00000020   0xE8BD 0x4002      POP      {R1,LR}
   \   00000024   0x.... 0x....      B.W      HAL_NVIC_DisableIRQ
    108          
    109            /* USER CODE BEGIN USB_OTG_FS_MspDeInit 1 */
    110          
    111            /* USER CODE END USB_OTG_FS_MspDeInit 1 */
    112            }
    113          }
   \                     ??HAL_HCD_MspDeInit_0: (+1)
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    114          
    115          /**
    116            * @brief  SOF callback.
    117            * @param  hhcd: HCD handle
    118            * @retval None
    119            */

   \                                 In section .text, align 2, keep-with-next
    120          void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
    121          {
    122            USBH_LL_IncTimer (hhcd->pData);
   \                     HAL_HCD_SOF_Callback: (+1)
   \   00000000   0xF8D0 0x0294      LDR      R0,[R0, #+660]
   \   00000004   0x.... 0x....      B.W      USBH_LL_IncTimer
    123          }
    124          
    125          /**
    126            * @brief  SOF callback.
    127            * @param  hhcd: HCD handle
    128            * @retval None
    129            */

   \                                 In section .text, align 2, keep-with-next
    130          void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
    131          {
    132            USBH_LL_Connect(hhcd->pData);
   \                     HAL_HCD_Connect_Callback: (+1)
   \   00000000   0xF8D0 0x0294      LDR      R0,[R0, #+660]
   \   00000004   0x.... 0x....      B.W      USBH_LL_Connect
    133          }
    134          
    135          /**
    136            * @brief  SOF callback.
    137            * @param  hhcd: HCD handle
    138            * @retval None
    139            */

   \                                 In section .text, align 2, keep-with-next
    140          void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
    141          {
    142            USBH_LL_Disconnect(hhcd->pData);
   \                     HAL_HCD_Disconnect_Callback: (+1)
   \   00000000   0xF8D0 0x0294      LDR      R0,[R0, #+660]
   \   00000004   0x.... 0x....      B.W      USBH_LL_Disconnect
    143          } 
    144          
    145          /**
    146            * @brief  Notify URB state change callback.
    147            * @param  hhcd: HCD handle
    148            * @retval None
    149            */

   \                                 In section .text, align 2, keep-with-next
    150          void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
    151          {
    152            /* To be used with OS to sync URB state with the global state machine */
    153          #if (USBH_USE_OS == 1)   
    154            USBH_LL_NotifyURBChange(hhcd->pData);
    155          #endif 
    156          }
   \                     HAL_HCD_HC_NotifyURBChange_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    157          /*******************************************************************************
    158                                 LL Driver Interface (USB Host Library --> HCD)
    159          *******************************************************************************/
    160          /**
    161            * @brief  USBH_LL_Init 
    162            *         Initialize the Low Level portion of the Host driver.
    163            * @param  phost: Host handle
    164            * @retval USBH Status
    165            */

   \                                 In section .text, align 2, keep-with-next
    166          USBH_StatusTypeDef  USBH_LL_Init (USBH_HandleTypeDef *phost)
    167          {
   \                     USBH_LL_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    168            /* Init USB_IP */
    169            if (phost->id == HOST_FS) {
   \   00000004   0xF894 0x03BC      LDRB     R0,[R4, #+956]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD11F             BNE.N    ??USBH_LL_Init_0
    170            /* Link The driver to the stack */
    171            hhcd_USB_OTG_FS.pData = phost;
   \   0000000C   0x....             LDR.N    R5,??DataTable2_2
   \   0000000E   0xF8C5 0x4294      STR      R4,[R5, #+660]
    172            phost->pData = &hhcd_USB_OTG_FS;
   \   00000012   0xF8C4 0x53C0      STR      R5,[R4, #+960]
    173          
    174            hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
   \   00000016   0xF04F 0x40A0      MOV      R0,#+1342177280
   \   0000001A   0x6028             STR      R0,[R5, #+0]
    175            hhcd_USB_OTG_FS.Init.Host_channels = 8;
   \   0000001C   0x2008             MOVS     R0,#+8
   \   0000001E   0x60A8             STR      R0,[R5, #+8]
    176            hhcd_USB_OTG_FS.Init.speed = HCD_SPEED_FULL;
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0x60E8             STR      R0,[R5, #+12]
    177            hhcd_USB_OTG_FS.Init.dma_enable = DISABLE;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6128             STR      R0,[R5, #+16]
    178            hhcd_USB_OTG_FS.Init.phy_itface = HCD_PHY_EMBEDDED;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x61A8             STR      R0,[R5, #+24]
    179            hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x61E8             STR      R0,[R5, #+28]
    180            if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x.... 0x....      BL       HAL_HCD_Init
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD001             BEQ.N    ??USBH_LL_Init_1
    181            {
    182              Error_Handler();
   \   0000003A   0x.... 0x....      BL       Error_Handler
    183            }
    184          
    185            USBH_LL_SetTimer (phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
   \                     ??USBH_LL_Init_1: (+1)
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       HAL_HCD_GetCurrentFrame
   \   00000044   0x4601             MOV      R1,R0
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       USBH_LL_SetTimer
    186            }
    187            return USBH_OK;
   \                     ??USBH_LL_Init_0: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    188          }
    189          
    190          /**
    191            * @brief  USBH_LL_DeInit 
    192            *         De-Initialize the Low Level portion of the Host driver.
    193            * @param  phost: Host handle
    194            * @retval USBH Status
    195            */

   \                                 In section .text, align 2, keep-with-next
    196          USBH_StatusTypeDef  USBH_LL_DeInit (USBH_HandleTypeDef *phost)
    197          {
   \                     USBH_LL_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    198            HAL_HCD_DeInit(phost->pData);
   \   00000002   0xF8D0 0x03C0      LDR      R0,[R0, #+960]
   \   00000006   0x.... 0x....      BL       HAL_HCD_DeInit
    199            return USBH_OK; 
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    200          }
    201          
    202          /**
    203            * @brief  USBH_LL_Start 
    204            *         Start the Low Level portion of the Host driver.
    205            * @param  phost: Host handle
    206            * @retval USBH Status
    207            */

   \                                 In section .text, align 2, keep-with-next
    208          USBH_StatusTypeDef  USBH_LL_Start(USBH_HandleTypeDef *phost)
    209          {
   \                     USBH_LL_Start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    210            HAL_HCD_Start(phost->pData);
   \   00000002   0xF8D0 0x03C0      LDR      R0,[R0, #+960]
   \   00000006   0x.... 0x....      BL       HAL_HCD_Start
    211            return USBH_OK; 
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    212          }
    213          
    214          /**
    215            * @brief  USBH_LL_Stop 
    216            *         Stop the Low Level portion of the Host driver.
    217            * @param  phost: Host handle
    218            * @retval USBH Status
    219            */

   \                                 In section .text, align 2, keep-with-next
    220          USBH_StatusTypeDef  USBH_LL_Stop (USBH_HandleTypeDef *phost)
    221          {
   \                     USBH_LL_Stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    222            HAL_HCD_Stop(phost->pData);
   \   00000002   0xF8D0 0x03C0      LDR      R0,[R0, #+960]
   \   00000006   0x.... 0x....      BL       HAL_HCD_Stop
    223            return USBH_OK; 
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    224          }
    225          
    226          /**
    227            * @brief  USBH_LL_GetSpeed 
    228            *         Return the USB Host Speed from the Low Level Driver.
    229            * @param  phost: Host handle
    230            * @retval USBH Speeds
    231            */

   \                                 In section .text, align 2, keep-with-next
    232          USBH_SpeedTypeDef USBH_LL_GetSpeed  (USBH_HandleTypeDef *phost)
    233          {
   \                     USBH_LL_GetSpeed: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    234            USBH_SpeedTypeDef speed = USBH_SPEED_FULL;
   \   00000002   0x2401             MOVS     R4,#+1
    235              
    236            switch (HAL_HCD_GetCurrentSpeed(phost->pData))
   \   00000004   0xF8D0 0x03C0      LDR      R0,[R0, #+960]
   \   00000008   0x.... 0x....      BL       HAL_HCD_GetCurrentSpeed
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD002             BEQ.N    ??USBH_LL_GetSpeed_0
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD002             BEQ.N    ??USBH_LL_GetSpeed_1
   \   00000014   0xE002             B.N      ??USBH_LL_GetSpeed_2
    237            {
    238            case 0 : 
    239              speed = USBH_SPEED_HIGH;
   \                     ??USBH_LL_GetSpeed_0: (+1)
   \   00000016   0x2400             MOVS     R4,#+0
    240              break;
   \   00000018   0xE000             B.N      ??USBH_LL_GetSpeed_2
    241              
    242            case 1 : 
    243              speed = USBH_SPEED_FULL;    
    244              break;
    245              
    246            case 2 : 
    247              speed = USBH_SPEED_LOW;    
   \                     ??USBH_LL_GetSpeed_1: (+1)
   \   0000001A   0x2402             MOVS     R4,#+2
    248              break;
    249          	
    250            default:  
    251             speed = USBH_SPEED_FULL;    
    252              break;  
    253            }
    254            return  speed;
   \                     ??USBH_LL_GetSpeed_2: (+1)
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    255          }
    256          
    257          /**
    258            * @brief  USBH_LL_ResetPort 
    259            *         Reset the Host Port of the Low Level Driver.
    260            * @param  phost: Host handle
    261            * @retval USBH Status
    262            */

   \                                 In section .text, align 2, keep-with-next
    263          USBH_StatusTypeDef USBH_LL_ResetPort (USBH_HandleTypeDef *phost) 
    264          {
   \                     USBH_LL_ResetPort: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    265            HAL_HCD_ResetPort(phost->pData);
   \   00000002   0xF8D0 0x03C0      LDR      R0,[R0, #+960]
   \   00000006   0x.... 0x....      BL       HAL_HCD_ResetPort
    266            return USBH_OK; 
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    267          }
    268          
    269          /**
    270            * @brief  USBH_LL_GetLastXferSize 
    271            *         Return the last transfered packet size.
    272            * @param  phost: Host handle
    273            * @param  pipe: Pipe index   
    274            * @retval Packet Size
    275            */

   \                                 In section .text, align 2, keep-with-next
    276          uint32_t USBH_LL_GetLastXferSize  (USBH_HandleTypeDef *phost, uint8_t pipe)  
    277          {
    278            return HAL_HCD_HC_GetXferCount(phost->pData, pipe);
   \                     USBH_LL_GetLastXferSize: (+1)
   \   00000000   0xF8D0 0x03C0      LDR      R0,[R0, #+960]
   \   00000004   0x.... 0x....      B.W      HAL_HCD_HC_GetXferCount
    279          }
    280          
    281          /**
    282            * @brief  USBH_LL_OpenPipe 
    283            *         Open a pipe of the Low Level Driver.
    284            * @param  phost: Host handle
    285            * @param  pipe_num: Pipe index
    286            * @param  epnum: Endpoint Number
    287            * @param  dev_address: Device USB address
    288            * @param  speed: Device Speed 
    289            * @param  ep_type: Endpoint Type
    290            * @param  mps: Endpoint Max Packet Size                 
    291            * @retval USBH Status
    292            */

   \                                 In section .text, align 2, keep-with-next
    293          USBH_StatusTypeDef   USBH_LL_OpenPipe    (USBH_HandleTypeDef *phost, 
    294                                                uint8_t pipe_num,
    295                                                uint8_t epnum,                                      
    296                                                uint8_t dev_address,
    297                                                uint8_t speed,
    298                                                uint8_t ep_type,
    299                                                uint16_t mps)
    300          {
   \                     USBH_LL_OpenPipe: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    301            HAL_HCD_HC_Init(phost->pData,
    302                            pipe_num,
    303                            epnum,
    304                            dev_address,
    305                            speed,
    306                            ep_type,
    307                            mps);
   \   00000004   0x9C08             LDR      R4,[SP, #+32]
   \   00000006   0x9402             STR      R4,[SP, #+8]
   \   00000008   0x9C07             LDR      R4,[SP, #+28]
   \   0000000A   0x9401             STR      R4,[SP, #+4]
   \   0000000C   0x9C06             LDR      R4,[SP, #+24]
   \   0000000E   0x9400             STR      R4,[SP, #+0]
   \   00000010   0xF8D0 0x03C0      LDR      R0,[R0, #+960]
   \   00000014   0x.... 0x....      BL       HAL_HCD_HC_Init
    308            return USBH_OK; 
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xB004             ADD      SP,SP,#+16
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    309          }
    310          
    311          /**
    312            * @brief  USBH_LL_ClosePipe 
    313            *         Close a pipe of the Low Level Driver.
    314            * @param  phost: Host handle
    315            * @param  pipe_num: Pipe index               
    316            * @retval USBH Status
    317            */

   \                                 In section .text, align 2, keep-with-next
    318          USBH_StatusTypeDef   USBH_LL_ClosePipe   (USBH_HandleTypeDef *phost, uint8_t pipe)   
    319          {
   \                     USBH_LL_ClosePipe: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    320            HAL_HCD_HC_Halt(phost->pData, pipe);
   \   00000002   0xF8D0 0x03C0      LDR      R0,[R0, #+960]
   \   00000006   0x.... 0x....      BL       HAL_HCD_HC_Halt
    321            return USBH_OK; 
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    322          }
    323          
    324          /**
    325            * @brief  USBH_LL_SubmitURB 
    326            *         Submit a new URB to the low level driver.
    327            * @param  phost: Host handle
    328            * @param  pipe: Pipe index    
    329            *         This parameter can be a value from 1 to 15
    330            * @param  direction : Channel number
    331            *          This parameter can be one of the these values:
    332            *           0 : Output 
    333            *           1 : Input
    334            * @param  ep_type : Endpoint Type
    335            *          This parameter can be one of the these values:
    336            *            @arg EP_TYPE_CTRL: Control type
    337            *            @arg EP_TYPE_ISOC: Isochrounous type
    338            *            @arg EP_TYPE_BULK: Bulk type
    339            *            @arg EP_TYPE_INTR: Interrupt type
    340            * @param  token : Endpoint Type
    341            *          This parameter can be one of the these values:
    342            *            @arg 0: PID_SETUP
    343            *            @arg 1: PID_DATA
    344            * @param  pbuff : pointer to URB data
    345            * @param  length : Length of URB data
    346            * @param  do_ping : activate do ping protocol (for high speed only)
    347            *          This parameter can be one of the these values:
    348            *           0 : do ping inactive 
    349            *           1 : do ping active 
    350            * @retval Status
    351            */
    352          

   \                                 In section .text, align 2, keep-with-next
    353          USBH_StatusTypeDef   USBH_LL_SubmitURB  (USBH_HandleTypeDef *phost, 
    354                                                      uint8_t pipe, 
    355                                                      uint8_t direction ,
    356                                                      uint8_t ep_type,  
    357                                                      uint8_t token, 
    358                                                      uint8_t* pbuff, 
    359                                                      uint16_t length,
    360                                                      uint8_t do_ping ) 
    361          {
   \                     USBH_LL_SubmitURB: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    362            HAL_HCD_HC_SubmitRequest (phost->pData,
    363                                      pipe, 
    364                                      direction ,
    365                                      ep_type,  
    366                                      token, 
    367                                      pbuff, 
    368                                      length,
    369                                      do_ping);
   \   00000002   0x9C09             LDR      R4,[SP, #+36]
   \   00000004   0x9403             STR      R4,[SP, #+12]
   \   00000006   0x9C08             LDR      R4,[SP, #+32]
   \   00000008   0x9402             STR      R4,[SP, #+8]
   \   0000000A   0x9C07             LDR      R4,[SP, #+28]
   \   0000000C   0x9401             STR      R4,[SP, #+4]
   \   0000000E   0x9C06             LDR      R4,[SP, #+24]
   \   00000010   0x9400             STR      R4,[SP, #+0]
   \   00000012   0xF8D0 0x03C0      LDR      R0,[R0, #+960]
   \   00000016   0x.... 0x....      BL       HAL_HCD_HC_SubmitRequest
    370            return USBH_OK;   
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xB004             ADD      SP,SP,#+16
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    371          }
    372          
    373          /**
    374            * @brief  USBH_LL_GetURBState 
    375            *         Get a URB state from the low level driver.
    376            * @param  phost: Host handle
    377            * @param  pipe: Pipe index
    378            *         This parameter can be a value from 1 to 15
    379            * @retval URB state
    380            *          This parameter can be one of the these values:
    381            *            @arg URB_IDLE
    382            *            @arg URB_DONE
    383            *            @arg URB_NOTREADY
    384            *            @arg URB_NYET 
    385            *            @arg URB_ERROR  
    386            *            @arg URB_STALL      
    387            */

   \                                 In section .text, align 2, keep-with-next
    388          USBH_URBStateTypeDef  USBH_LL_GetURBState (USBH_HandleTypeDef *phost, uint8_t pipe) 
    389          {
    390            return (USBH_URBStateTypeDef)HAL_HCD_HC_GetURBState (phost->pData, pipe);
   \                     USBH_LL_GetURBState: (+1)
   \   00000000   0xF8D0 0x03C0      LDR      R0,[R0, #+960]
   \   00000004   0x.... 0x....      B.W      HAL_HCD_HC_GetURBState
    391          }
    392          
    393          /**
    394            * @brief  USBH_LL_DriverVBUS 
    395            *         Drive VBUS.
    396            * @param  phost: Host handle
    397            * @param  state : VBUS state
    398            *          This parameter can be one of the these values:
    399            *           0 : VBUS Active 
    400            *           1 : VBUS Inactive
    401            * @retval Status
    402            */

   \                                 In section .text, align 2, keep-with-next
    403          USBH_StatusTypeDef  USBH_LL_DriverVBUS (USBH_HandleTypeDef *phost, uint8_t state)
    404          { 
   \                     USBH_LL_DriverVBUS: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    405          
    406            /* USER CODE BEGIN 0 */
    407            /* USER CODE END 0*/     
    408            if (phost->id == HOST_FS) 
    409            { 
    410              if (state == 0)
    411              {   
    412                /* Drive high Charge pump */
    413                /* ToDo: Add IOE driver control */	   
    414                /* USER CODE BEGIN DRIVE_HIGH_CHARGE_FOR_FS */
    415              
    416                /* USER CODE END DRIVE_HIGH_CHARGE_FOR_FS */ 
    417              } 
    418              else
    419              {
    420                /* Drive low Charge pump */
    421                /* ToDo: Add IOE driver control */	
    422                /* USER CODE BEGIN DRIVE_LOW_CHARGE_FOR_FS */
    423             
    424                /* USER CODE END DRIVE_HIGH_CHARGE_FOR_FS */ 
    425              }
    426            }	
    427            HAL_Delay(200);
   \   00000002   0x20C8             MOVS     R0,#+200
   \   00000004   0x.... 0x....      BL       HAL_Delay
    428            return USBH_OK;  
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    429          }
    430          
    431          /**
    432            * @brief  USBH_LL_SetToggle 
    433            *         Set toggle for a pipe.
    434            * @param  phost: Host handle
    435            * @param  pipe: Pipe index
    436            * @param  pipe_num: Pipe index     
    437            * @param  toggle: toggle (0/1)
    438            * @retval Status
    439            */

   \                                 In section .text, align 2, keep-with-next
    440          USBH_StatusTypeDef   USBH_LL_SetToggle   (USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t toggle)   
    441          {
    442            HCD_HandleTypeDef *pHandle;
    443            pHandle = phost->pData;
   \                     USBH_LL_SetToggle: (+1)
   \   00000000   0xF8D0 0x03C0      LDR      R0,[R0, #+960]
    444            
    445            if(pHandle->hc[pipe].ep_is_in)
   \   00000004   0xEB01 0x0381      ADD      R3,R1,R1, LSL #+2
   \   00000008   0xEB00 0x00C3      ADD      R0,R0,R3, LSL #+3
   \   0000000C   0xF200 0x013B      ADDW     R1,R0,#+59
   \   00000010   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??USBH_LL_SetToggle_0
    446            {
    447              pHandle->hc[pipe].toggle_in = toggle;
   \   00000018   0x754A             STRB     R2,[R1, #+21]
   \   0000001A   0xE000             B.N      ??USBH_LL_SetToggle_1
    448            }
    449            else
    450            {
    451              pHandle->hc[pipe].toggle_out = toggle;
   \                     ??USBH_LL_SetToggle_0: (+1)
   \   0000001C   0x758A             STRB     R2,[R1, #+22]
    452            }
    453            
    454            return USBH_OK; 
   \                     ??USBH_LL_SetToggle_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x4770             BX       LR               ;; return
    455          }
    456          
    457          /**
    458            * @brief  USBH_LL_GetToggle 
    459            *         Return the current toggle of a pipe.
    460            * @param  phost: Host handle
    461            * @param  pipe: Pipe index
    462            * @retval toggle (0/1)
    463            */

   \                                 In section .text, align 2, keep-with-next
    464          uint8_t  USBH_LL_GetToggle   (USBH_HandleTypeDef *phost, uint8_t pipe)   
    465          {
    466            uint8_t toggle = 0;
    467            HCD_HandleTypeDef *pHandle;
    468            pHandle = phost->pData; 
   \                     USBH_LL_GetToggle: (+1)
   \   00000000   0xF8D0 0x03C0      LDR      R0,[R0, #+960]
    469            
    470            if(pHandle->hc[pipe].ep_is_in)
   \   00000004   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000008   0xEB00 0x00C2      ADD      R0,R0,R2, LSL #+3
   \   0000000C   0xF200 0x013B      ADDW     R1,R0,#+59
   \   00000010   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??USBH_LL_GetToggle_0
    471            {
    472              toggle = pHandle->hc[pipe].toggle_in;
   \   00000018   0x7D48             LDRB     R0,[R1, #+21]
   \   0000001A   0x4770             BX       LR
    473            }
    474            else
    475            {
    476              toggle = pHandle->hc[pipe].toggle_out;
   \                     ??USBH_LL_GetToggle_0: (+1)
   \   0000001C   0x7D88             LDRB     R0,[R1, #+22]
    477            }
    478            return toggle; 
   \   0000001E   0x4770             BX       LR               ;; return
    479          }
    480          
    481          /**
    482            * @brief  USBH_Delay 
    483            *         Delay routine for the USB Host Library
    484            * @param  Delay: Delay in ms
    485            * @retval None
    486            */

   \                                 In section .text, align 2, keep-with-next
    487          void  USBH_Delay (uint32_t Delay)
    488          {
    489            HAL_Delay(Delay);  
   \                     USBH_Delay: (+1)
   \   00000000   0x.... 0x....      B.W      HAL_Delay
    490          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40023834         DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     hhcd_USB_OTG_FS
    491          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HCD_Connect_Callback
         0   -> USBH_LL_Connect
       0   HAL_HCD_Disconnect_Callback
         0   -> USBH_LL_Disconnect
       0   HAL_HCD_HC_NotifyURBChange_Callback
       8   HAL_HCD_MspDeInit
         8   -> HAL_GPIO_DeInit
         0   -> HAL_NVIC_DisableIRQ
      32   HAL_HCD_MspInit
        32   -> HAL_GPIO_Init
        32   -> HAL_NVIC_EnableIRQ
        32   -> HAL_NVIC_SetPriority
       0   HAL_HCD_SOF_Callback
         0   -> USBH_LL_IncTimer
       0   USBH_Delay
         0   -> HAL_Delay
       8   USBH_LL_ClosePipe
         8   -> HAL_HCD_HC_Halt
       8   USBH_LL_DeInit
         8   -> HAL_HCD_DeInit
       8   USBH_LL_DriverVBUS
         8   -> HAL_Delay
       0   USBH_LL_GetLastXferSize
         0   -> HAL_HCD_HC_GetXferCount
       8   USBH_LL_GetSpeed
         8   -> HAL_HCD_GetCurrentSpeed
       0   USBH_LL_GetToggle
       0   USBH_LL_GetURBState
         0   -> HAL_HCD_HC_GetURBState
      16   USBH_LL_Init
        16   -> Error_Handler
        16   -> HAL_HCD_GetCurrentFrame
        16   -> HAL_HCD_Init
        16   -> USBH_LL_SetTimer
      24   USBH_LL_OpenPipe
        24   -> HAL_HCD_HC_Init
       8   USBH_LL_ResetPort
         8   -> HAL_HCD_ResetPort
       0   USBH_LL_SetToggle
       8   USBH_LL_Start
         8   -> HAL_HCD_Start
       8   USBH_LL_Stop
         8   -> HAL_HCD_Stop
      24   USBH_LL_SubmitURB
        24   -> HAL_HCD_HC_SubmitRequest


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       8  HAL_HCD_Connect_Callback
       8  HAL_HCD_Disconnect_Callback
       2  HAL_HCD_HC_NotifyURBChange_Callback
      42  HAL_HCD_MspDeInit
      96  HAL_HCD_MspInit
       8  HAL_HCD_SOF_Callback
       4  USBH_Delay
      14  USBH_LL_ClosePipe
      14  USBH_LL_DeInit
      12  USBH_LL_DriverVBUS
       8  USBH_LL_GetLastXferSize
      32  USBH_LL_GetSpeed
      32  USBH_LL_GetToggle
       8  USBH_LL_GetURBState
      80  USBH_LL_Init
      30  USBH_LL_OpenPipe
      14  USBH_LL_ResetPort
      34  USBH_LL_SetToggle
      14  USBH_LL_Start
      14  USBH_LL_Stop
      32  USBH_LL_SubmitURB
     664  hhcd_USB_OTG_FS

 
 664 bytes in section .bss
 518 bytes in section .text
 
 518 bytes of CODE memory
 664 bytes of DATA memory

Errors: none
Warnings: none
