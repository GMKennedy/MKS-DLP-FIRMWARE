###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:32
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\FatFs\src\drivers\usbh_diskio.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\FatFs\src\drivers\usbh_diskio.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\usbh_diskio.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\usbh_diskio.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Middlewares\Third_Party\FatFs\src\drivers\usbh_diskio.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_diskio.c 
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-May-2015
      7            * @brief   USB Key Disk I/O driver.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include <string.h>
     30          #include "ff_gen_drv.h"
     31          
     32          /* Private typedef -----------------------------------------------------------*/
     33          /* Private define ------------------------------------------------------------*/
     34          /* Private variables ---------------------------------------------------------*/
     35          extern USBH_HandleTypeDef  HOST_HANDLE;
     36          #if _USE_BUFF_WO_ALIGNMENT == 0
     37          /* Local buffer use to handle buffer not aligned 32bits*/
     38          static DWORD scratch[_MAX_SS / 4];
     39          #endif
     40          
     41          /* Private function prototypes -----------------------------------------------*/
     42          DSTATUS USBH_initialize (BYTE);
     43          DSTATUS USBH_status (BYTE);
     44          DRESULT USBH_read (BYTE, BYTE*, DWORD, UINT);
     45          
     46          #if _USE_WRITE == 1
     47            DRESULT USBH_write (BYTE, const BYTE*, DWORD, UINT);
     48          #endif /* _USE_WRITE == 1 */
     49          
     50          #if _USE_IOCTL == 1
     51            DRESULT USBH_ioctl (BYTE, BYTE, void*);
     52          #endif /* _USE_IOCTL == 1 */
     53            

   \                                 In section .rodata, align 4, keep-with-next
     54          const Diskio_drvTypeDef  USBH_Driver =
   \                     USBH_Driver:
   \   00000000   0x........         DC32 USBH_initialize, USBH_status, USBH_read, USBH_write, USBH_ioctl
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
     55          {
     56            USBH_initialize,
     57            USBH_status,
     58            USBH_read, 
     59          #if  _USE_WRITE == 1
     60            USBH_write,
     61          #endif /* _USE_WRITE == 1 */  
     62          #if  _USE_IOCTL == 1
     63            USBH_ioctl,
     64          #endif /* _USE_IOCTL == 1 */
     65          };
     66          
     67          /* Private functions ---------------------------------------------------------*/
     68          
     69          /**
     70            * @brief  Initializes a Drive
     71            * @param  lun : lun id
     72            * @retval DSTATUS: Operation status
     73            */

   \                                 In section .text, align 2, keep-with-next
     74          DSTATUS USBH_initialize(BYTE lun)
     75          {
     76            return RES_OK;
   \                     USBH_initialize: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
     77          }
     78          
     79          /**
     80            * @brief  Gets Disk Status
     81            * @param  lun : lun id
     82            * @retval DSTATUS: Operation status
     83            */

   \                                 In section .text, align 2, keep-with-next
     84          DSTATUS USBH_status(BYTE lun)
     85          {
   \                     USBH_status: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     86            DRESULT res = RES_ERROR;
     87            
     88            if(USBH_MSC_UnitIsReady(&HOST_HANDLE, lun))
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0x....             LDR.N    R0,??DataTable4
   \   00000006   0x.... 0x....      BL       USBH_MSC_UnitIsReady
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   \   0000000C   0x4180             SBCS     R0,R0,R0
   \   0000000E   0x0FC0             LSRS     R0,R0,#+31
     89            {
     90              res = RES_OK;
     91            }
     92            else
     93            {
     94              res = RES_ERROR;
     95            }
     96            
     97            return res;
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
     98          }
     99          
    100          /**
    101            * @brief  Reads Sector(s) 
    102            * @param  lun : lun id
    103            * @param  *buff: Data buffer to store read data
    104            * @param  sector: Sector address (LBA)
    105            * @param  count: Number of sectors to read (1..128)
    106            * @retval DRESULT: Operation result
    107            */

   \                                 In section .text, align 2, keep-with-next
    108          DRESULT USBH_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
    109          {
   \                     USBH_read: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08F             SUB      SP,SP,#+60
   \   00000004   0x4604             MOV      R4,R0
    110            DRESULT res = RES_ERROR;
    111            MSC_LUNTypeDef info;
    112            USBH_StatusTypeDef  status = USBH_OK;
    113          
    114            if ((DWORD)buff & 3) /* DMA Alignment issue, do single up to aligned buffer */
   \   00000006   0xF011 0x0003      ANDS     R0,R1,#0x3
   \   0000000A   0xD001             BEQ.N    ??USBH_read_0
    115            {
    116          #if _USE_BUFF_WO_ALIGNMENT == 0
    117              while ((count--)&&(status == USBH_OK))
    118              {
    119                status = USBH_MSC_Read(&HOST_HANDLE, lun, sector + count, (uint8_t *)scratch, 1);
    120                if(status == USBH_OK)
    121                {
    122                  memcpy (&buff[count * _MAX_SS] ,scratch, _MAX_SS);
    123                }
    124                else
    125                {
    126                  break;
    127                }
    128              }
    129          #else
    130              return res;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE01A             B.N      ??USBH_read_1
    131          #endif
    132            }
    133            else
    134            {
    135              status = USBH_MSC_Read(&HOST_HANDLE, lun, sector, buff, count);
    136            }
    137            
    138            if(status == USBH_OK)
   \                     ??USBH_read_0: (+1)
   \   00000010   0x....             LDR.N    R5,??DataTable4
   \   00000012   0x9300             STR      R3,[SP, #+0]
   \   00000014   0x460B             MOV      R3,R1
   \   00000016   0x4621             MOV      R1,R4
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       USBH_MSC_Read
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD101             BNE.N    ??USBH_read_2
    139            {
    140              res = RES_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE00F             B.N      ??USBH_read_1
    141            }
    142            else
    143            {
    144              USBH_MSC_GetLUNInfo(&HOST_HANDLE, lun, &info); 
   \                     ??USBH_read_2: (+1)
   \   00000026   0xAA01             ADD      R2,SP,#+4
   \   00000028   0x4621             MOV      R1,R4
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       USBH_MSC_GetLUNInfo
    145              
    146              switch (info.sense.asc)
   \   00000030   0xF89D 0x0011      LDRB     R0,[SP, #+17]
   \   00000034   0x2804             CMP      R0,#+4
   \   00000036   0xD003             BEQ.N    ??USBH_read_3
   \   00000038   0x2828             CMP      R0,#+40
   \   0000003A   0xD001             BEQ.N    ??USBH_read_3
   \   0000003C   0x283A             CMP      R0,#+58
   \   0000003E   0xD101             BNE.N    ??USBH_read_4
    147              {
    148              case SCSI_ASC_LOGICAL_UNIT_NOT_READY:
    149              case SCSI_ASC_MEDIUM_NOT_PRESENT:
    150              case SCSI_ASC_NOT_READY_TO_READY_CHANGE: 
    151                USBH_ErrLog ("USB Disk is not ready!");  
    152                res = RES_NOTRDY;
   \                     ??USBH_read_3: (+1)
   \   00000040   0x2003             MOVS     R0,#+3
    153                break; 
   \   00000042   0xE000             B.N      ??USBH_read_1
    154                
    155              default:
    156                res = RES_ERROR;
   \                     ??USBH_read_4: (+1)
   \   00000044   0x2001             MOVS     R0,#+1
    157                break;
    158              }
    159            }
    160            
    161            return res;
   \                     ??USBH_read_1: (+1)
   \   00000046   0xB00F             ADD      SP,SP,#+60
   \   00000048   0xBD30             POP      {R4,R5,PC}       ;; return
    162          }
    163          
    164          /**
    165            * @brief  Writes Sector(s)
    166            * @param  lun : lun id 
    167            * @param  *buff: Data to be written
    168            * @param  sector: Sector address (LBA)
    169            * @param  count: Number of sectors to write (1..128)
    170            * @retval DRESULT: Operation result
    171            */
    172          #if _USE_WRITE == 1

   \                                 In section .text, align 2, keep-with-next
    173          DRESULT USBH_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
    174          {
   \                     USBH_write: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08F             SUB      SP,SP,#+60
   \   00000004   0x4604             MOV      R4,R0
    175            DRESULT res = RES_ERROR; 
    176            MSC_LUNTypeDef info;
    177            USBH_StatusTypeDef  status = USBH_OK;  
    178          
    179            if ((DWORD)buff & 3) /* DMA Alignment issue, do single up to aligned buffer */
   \   00000006   0xF011 0x0003      ANDS     R0,R1,#0x3
   \   0000000A   0xD001             BEQ.N    ??USBH_write_0
    180            {
    181          #if _USE_BUFF_WO_ALIGNMENT == 0
    182              while (count--)
    183              {
    184                memcpy (scratch, &buff[count * _MAX_SS], _MAX_SS);
    185                
    186                status = USBH_MSC_Write(&HOST_HANDLE, lun, sector + count, (BYTE *)scratch, 1) ;
    187                if(status == USBH_FAIL)
    188                {
    189                  break;
    190                }
    191              }
    192          #else
    193              return res;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE01F             B.N      ??USBH_write_1
    194          #endif
    195            }
    196            else
    197            {
    198              status = USBH_MSC_Write(&HOST_HANDLE, lun, sector, (BYTE *)buff, count);
    199            }
    200            
    201            if(status == USBH_OK)
   \                     ??USBH_write_0: (+1)
   \   00000010   0x....             LDR.N    R5,??DataTable4
   \   00000012   0x9300             STR      R3,[SP, #+0]
   \   00000014   0x460B             MOV      R3,R1
   \   00000016   0x4621             MOV      R1,R4
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       USBH_MSC_Write
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD101             BNE.N    ??USBH_write_2
    202            {
    203              res = RES_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE014             B.N      ??USBH_write_1
    204            }
    205            else
    206            {
    207              USBH_MSC_GetLUNInfo(&HOST_HANDLE, lun, &info); 
   \                     ??USBH_write_2: (+1)
   \   00000026   0xAA01             ADD      R2,SP,#+4
   \   00000028   0x4621             MOV      R1,R4
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       USBH_MSC_GetLUNInfo
    208              
    209              switch (info.sense.asc)
   \   00000030   0xF89D 0x0011      LDRB     R0,[SP, #+17]
   \   00000034   0x2804             CMP      R0,#+4
   \   00000036   0xD008             BEQ.N    ??USBH_write_3
   \   00000038   0x2827             CMP      R0,#+39
   \   0000003A   0xD004             BEQ.N    ??USBH_write_4
   \   0000003C   0x2828             CMP      R0,#+40
   \   0000003E   0xD004             BEQ.N    ??USBH_write_3
   \   00000040   0x283A             CMP      R0,#+58
   \   00000042   0xD002             BEQ.N    ??USBH_write_3
   \   00000044   0xE003             B.N      ??USBH_write_5
    210              {
    211              case SCSI_ASC_WRITE_PROTECTED:
    212                USBH_ErrLog("USB Disk is Write protected!");
    213                res = RES_WRPRT;
   \                     ??USBH_write_4: (+1)
   \   00000046   0x2002             MOVS     R0,#+2
    214                break;
   \   00000048   0xE002             B.N      ??USBH_write_1
    215                
    216              case SCSI_ASC_LOGICAL_UNIT_NOT_READY:
    217              case SCSI_ASC_MEDIUM_NOT_PRESENT:
    218              case SCSI_ASC_NOT_READY_TO_READY_CHANGE:
    219                USBH_ErrLog("USB Disk is not ready!");      
    220                res = RES_NOTRDY;
   \                     ??USBH_write_3: (+1)
   \   0000004A   0x2003             MOVS     R0,#+3
    221                break; 
   \   0000004C   0xE000             B.N      ??USBH_write_1
    222                
    223              default:
    224                res = RES_ERROR;
   \                     ??USBH_write_5: (+1)
   \   0000004E   0x2001             MOVS     R0,#+1
    225                break;
    226              }
    227            }
    228            
    229            return res;   
   \                     ??USBH_write_1: (+1)
   \   00000050   0xB00F             ADD      SP,SP,#+60
   \   00000052   0xBD30             POP      {R4,R5,PC}       ;; return
    230          }
    231          #endif /* _USE_WRITE == 1 */
    232          
    233          /**
    234            * @brief  I/O control operation
    235            * @param  lun : lun id
    236            * @param  cmd: Control code
    237            * @param  *buff: Buffer to send/receive control data
    238            * @retval DRESULT: Operation result
    239            */
    240          #if _USE_IOCTL == 1

   \                                 In section .text, align 2, keep-with-next
    241          DRESULT USBH_ioctl(BYTE lun, BYTE cmd, void *buff)
    242          {
   \                     USBH_ioctl: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x4614             MOV      R4,R2
    243            DRESULT res = RES_ERROR;
   \   00000006   0x2501             MOVS     R5,#+1
    244            MSC_LUNTypeDef info;
    245            
    246            switch (cmd)
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD005             BEQ.N    ??USBH_ioctl_0
   \   0000000C   0x2902             CMP      R1,#+2
   \   0000000E   0xD010             BEQ.N    ??USBH_ioctl_1
   \   00000010   0xD304             BCC.N    ??USBH_ioctl_2
   \   00000012   0x2903             CMP      R1,#+3
   \   00000014   0xD015             BEQ.N    ??USBH_ioctl_3
   \   00000016   0xE020             B.N      ??USBH_ioctl_4
    247            {
    248            /* Make sure that no pending write process */
    249            case CTRL_SYNC: 
    250              res = RES_OK;
   \                     ??USBH_ioctl_0: (+1)
   \   00000018   0x2500             MOVS     R5,#+0
    251              break;
   \   0000001A   0xE01F             B.N      ??USBH_ioctl_5
    252              
    253            /* Get number of sectors on the disk (DWORD) */  
    254            case GET_SECTOR_COUNT : 
    255              if(USBH_MSC_GetLUNInfo(&HOST_HANDLE, lun, &info) == USBH_OK)
   \                     ??USBH_ioctl_2: (+1)
   \   0000001C   0xAA00             ADD      R2,SP,#+0
   \   0000001E   0x4601             MOV      R1,R0
   \   00000020   0x....             LDR.N    R0,??DataTable4
   \   00000022   0x.... 0x....      BL       USBH_MSC_GetLUNInfo
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD118             BNE.N    ??USBH_ioctl_5
    256              {
    257                *(DWORD*)buff = info.capacity.block_nbr;
   \   0000002A   0x9801             LDR      R0,[SP, #+4]
   \   0000002C   0x6020             STR      R0,[R4, #+0]
    258                res = RES_OK;
   \   0000002E   0x2500             MOVS     R5,#+0
   \   00000030   0xE014             B.N      ??USBH_ioctl_5
    259              }
    260              else
    261              {
    262                res = RES_ERROR;
    263              }
    264              break;
    265              
    266            /* Get R/W sector size (WORD) */  
    267            case GET_SECTOR_SIZE :	
    268              if(USBH_MSC_GetLUNInfo(&HOST_HANDLE, lun, &info) == USBH_OK)
   \                     ??USBH_ioctl_1: (+1)
   \   00000032   0xAA00             ADD      R2,SP,#+0
   \   00000034   0x4601             MOV      R1,R0
   \   00000036   0x....             LDR.N    R0,??DataTable4
   \   00000038   0x.... 0x....      BL       USBH_MSC_GetLUNInfo
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD10D             BNE.N    ??USBH_ioctl_5
   \   00000040   0xE006             B.N      ??USBH_ioctl_6
    269              {
    270                *(DWORD*)buff = info.capacity.block_size;
    271                res = RES_OK;
    272              }
    273              else
    274              {
    275                res = RES_ERROR;
    276              }
    277              break;
    278              
    279              /* Get erase block size in unit of sector (DWORD) */ 
    280            case GET_BLOCK_SIZE : 
    281              
    282              if(USBH_MSC_GetLUNInfo(&HOST_HANDLE, lun, &info) == USBH_OK)
   \                     ??USBH_ioctl_3: (+1)
   \   00000042   0xAA00             ADD      R2,SP,#+0
   \   00000044   0x4601             MOV      R1,R0
   \   00000046   0x....             LDR.N    R0,??DataTable4
   \   00000048   0x.... 0x....      BL       USBH_MSC_GetLUNInfo
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD105             BNE.N    ??USBH_ioctl_5
    283              {
    284                *(DWORD*)buff = info.capacity.block_size;
   \                     ??USBH_ioctl_6: (+1)
   \   00000050   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000054   0x6020             STR      R0,[R4, #+0]
    285                res = RES_OK;
   \   00000056   0x2500             MOVS     R5,#+0
   \   00000058   0xE000             B.N      ??USBH_ioctl_5
    286              }
    287              else
    288              {
    289                res = RES_ERROR;
    290              }
    291              break;
    292              
    293            default:
    294              res = RES_PARERR;
   \                     ??USBH_ioctl_4: (+1)
   \   0000005A   0x2504             MOVS     R5,#+4
    295            }
    296            
    297            return res;
   \                     ??USBH_ioctl_5: (+1)
   \   0000005C   0x4628             MOV      R0,R5
   \   0000005E   0xB00D             ADD      SP,SP,#+52
   \   00000060   0xBD30             POP      {R4,R5,PC}       ;; return
    298          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     hUsbHostFS
    299          #endif /* _USE_IOCTL == 1 */
    300          
    301          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    302          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USBH_initialize
      64   USBH_ioctl
        64   -> USBH_MSC_GetLUNInfo
      72   USBH_read
        72   -> USBH_MSC_GetLUNInfo
        72   -> USBH_MSC_Read
       8   USBH_status
         8   -> USBH_MSC_UnitIsReady
      72   USBH_write
        72   -> USBH_MSC_GetLUNInfo
        72   -> USBH_MSC_Write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
      20  USBH_Driver
       4  USBH_initialize
      98  USBH_ioctl
      74  USBH_read
      18  USBH_status
      84  USBH_write

 
  20 bytes in section .rodata
 282 bytes in section .text
 
 282 bytes of CODE  memory
  20 bytes of CONST memory

Errors: none
Warnings: none
