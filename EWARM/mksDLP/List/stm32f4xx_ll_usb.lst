###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Jul/2019  11:15:24
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_ll_usb.c
#    Command line =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_ll_usb.c
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -lC
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\ -lA
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Inc\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Src\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertColor\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/ConvertMono\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Core\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Font\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/AntiAlias\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/GUIDemo\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/LCDDriver\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MemDev\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/MultiLayer\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/Widget\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI/WM\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/GUI_X\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../Middlewares/gui/Config\
#        -I E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui\ -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/Multi_language\
#        -I
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM/../User/ui/QRENCODE\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/List\stm32f4xx_ll_usb.lst
#    Object file  =  
#        E:\DLP_Proj\DLP_source\branches\DLP_opensource\EWARM\mksDLP/Obj\stm32f4xx_ll_usb.o
#
###############################################################################

E:\DLP_Proj\DLP_source\branches\DLP_opensource\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_ll_usb.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_ll_usb.c
      4            * @author  MCD Application Team
      5            * @version V1.5.2
      6            * @date    22-September-2016
      7            * @brief   USB Low Layer HAL module driver.
      8            *    
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities of the USB Peripheral Controller:
     11            *           + Initialization/de-initialization functions
     12            *           + I/O operation functions
     13            *           + Peripheral Control functions 
     14            *           + Peripheral State functions
     15            *         
     16            @verbatim
     17            ==============================================================================
     18                              ##### How to use this driver #####
     19            ==============================================================================
     20              [..]
     21                (#) Fill parameters of Init structure in USB_OTG_CfgTypeDef structure.
     22            
     23                (#) Call USB_CoreInit() API to initialize the USB Core peripheral.
     24          
     25                (#) The upper HAL HCD/PCD driver will call the right routines for its internal processes.
     26          
     27            @endverbatim
     28            ******************************************************************************
     29            * @attention
     30            *
     31            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     32            *
     33            * Redistribution and use in source and binary forms, with or without modification,
     34            * are permitted provided that the following conditions are met:
     35            *   1. Redistributions of source code must retain the above copyright notice,
     36            *      this list of conditions and the following disclaimer.
     37            *   2. Redistributions in binary form must reproduce the above copyright notice,
     38            *      this list of conditions and the following disclaimer in the documentation
     39            *      and/or other materials provided with the distribution.
     40            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     41            *      may be used to endorse or promote products derived from this software
     42            *      without specific prior written permission.
     43            *
     44            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     45            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     46            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     47            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     48            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     49            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     50            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     51            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     52            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     53            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     54            *
     55            ******************************************************************************
     56            */ 
     57          
     58          /* Includes ------------------------------------------------------------------*/
     59          #include "stm32f4xx_hal.h"
     60          
     61          /** @addtogroup STM32F4xx_LL_USB_DRIVER
     62            * @{
     63            */
     64          
     65          #if defined(HAL_PCD_MODULE_ENABLED) || defined(HAL_HCD_MODULE_ENABLED)
     66          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || \
     67              defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
     68              defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE) || defined(STM32F446xx) || \
     69              defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
     70              defined(STM32F412Rx) || defined(STM32F412Cx)
     71          /* Private typedef -----------------------------------------------------------*/
     72          /* Private define ------------------------------------------------------------*/
     73          /* Private macro -------------------------------------------------------------*/
     74          /* Private variables ---------------------------------------------------------*/
     75          /* Private function prototypes -----------------------------------------------*/
     76          /* Private functions ---------------------------------------------------------*/
     77          static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx);
     78          
     79          /* Exported functions --------------------------------------------------------*/
     80          
     81          /** @defgroup LL_USB_Exported_Functions USB Low Layer Exported Functions
     82            * @{
     83            */
     84          
     85          /** @defgroup LL_USB_Group1 Initialization/de-initialization functions 
     86           *  @brief    Initialization and Configuration functions 
     87           *
     88          @verbatim    
     89           ===============================================================================
     90                        ##### Initialization/de-initialization functions #####
     91           ===============================================================================
     92              [..]  This section provides functions allowing to:
     93           
     94          @endverbatim
     95            * @{
     96            */
     97          
     98          /**
     99            * @brief  Initializes the USB Core
    100            * @param  USBx: USB Instance
    101            * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
    102            *         the configuration information for the specified USBx peripheral.
    103            * @retval HAL status
    104            */

   \                                 In section .text, align 2, keep-with-next
    105          HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
    106          {
   \                     USB_CoreInit: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB518             PUSH     {R3,R4,LR}
   \   00000004   0x4604             MOV      R4,R0
    107            if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   \   00000006   0x9808             LDR      R0,[SP, #+32]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD117             BNE.N    ??USB_CoreInit_0
    108            {
    109              
    110              USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   \   0000000C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000000E   0xF420 0x3080      BIC      R0,R0,#0x10000
   \   00000012   0x63A0             STR      R0,[R4, #+56]
    111          
    112              /* Init The ULPI Interface */
    113              USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
   \   00000014   0x68E0             LDR      R0,[R4, #+12]
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0xffbdffbf
   \   0000001A   0x4008             ANDS     R0,R1,R0
   \   0000001C   0x60E0             STR      R0,[R4, #+12]
    114             
    115              /* Select vbus source */
    116              USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
   \   0000001E   0x68E0             LDR      R0,[R4, #+12]
   \   00000020   0xF420 0x1040      BIC      R0,R0,#0x300000
   \   00000024   0x60E0             STR      R0,[R4, #+12]
    117              if(cfg.use_external_vbus == 1U)
   \   00000026   0x980F             LDR      R0,[SP, #+60]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD103             BNE.N    ??USB_CoreInit_1
    118              {
    119                USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
   \   0000002C   0x68E0             LDR      R0,[R4, #+12]
   \   0000002E   0xF440 0x1080      ORR      R0,R0,#0x100000
   \   00000032   0x60E0             STR      R0,[R4, #+12]
    120              }
    121              /* Reset after a PHY select  */
    122              USB_CoreReset(USBx); 
   \                     ??USB_CoreInit_1: (+1)
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       USB_CoreReset
   \   0000003A   0xE009             B.N      ??USB_CoreInit_2
    123            }
    124            else /* FS interface (embedded Phy) */
    125            {
    126              /* Select FS Embedded PHY */
    127              USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
   \                     ??USB_CoreInit_0: (+1)
   \   0000003C   0x68E0             LDR      R0,[R4, #+12]
   \   0000003E   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000042   0x60E0             STR      R0,[R4, #+12]
    128              
    129              /* Reset after a PHY select and set Host mode */
    130              USB_CoreReset(USBx);
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       USB_CoreReset
    131              
    132              /* Deactivate the power down*/
    133              USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
   \   0000004A   0xF44F 0x3080      MOV      R0,#+65536
   \   0000004E   0x63A0             STR      R0,[R4, #+56]
    134            }
    135           
    136            if(cfg.dma_enable == ENABLE)
   \                     ??USB_CoreInit_2: (+1)
   \   00000050   0x9806             LDR      R0,[SP, #+24]
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD103             BNE.N    ??USB_CoreInit_3
    137            {
    138              USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
   \   00000056   0x68A0             LDR      R0,[R4, #+8]
   \   00000058   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000005C   0x60A0             STR      R0,[R4, #+8]
    139            }  
    140          
    141            return HAL_OK;
   \                     ??USB_CoreInit_3: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBC12             POP      {R1,R4}
   \   00000062   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
    142          }
    143          
    144          /**
    145            * @brief  USB_EnableGlobalInt
    146            *         Enables the controller's Global Int in the AHB Config reg
    147            * @param  USBx : Selected device
    148            * @retval HAL status
    149            */

   \                                 In section .text, align 2, keep-with-next
    150          HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
    151          {
    152            USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
   \                     USB_EnableGlobalInt: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000006   0x6081             STR      R1,[R0, #+8]
    153            return HAL_OK;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR               ;; return
    154          }
    155          
    156          
    157          /**
    158            * @brief  USB_DisableGlobalInt
    159            *         Disable the controller's Global Int in the AHB Config reg
    160            * @param  USBx : Selected device
    161            * @retval HAL status
    162          */

   \                                 In section .text, align 2, keep-with-next
    163          HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
    164          {
    165            USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
   \                     USB_DisableGlobalInt: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0x0849             LSRS     R1,R1,#+1
   \   00000004   0x0049             LSLS     R1,R1,#+1
   \   00000006   0x6081             STR      R1,[R0, #+8]
    166            return HAL_OK;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR               ;; return
    167          }
    168             
    169          /**
    170            * @brief  USB_SetCurrentMode : Set functional mode
    171            * @param  USBx : Selected device
    172            * @param  mode :  current core mode
    173            *          This parameter can be one of these values:
    174            *            @arg USB_OTG_DEVICE_MODE: Peripheral mode
    175            *            @arg USB_OTG_HOST_MODE: Host mode
    176            *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
    177            * @retval HAL status
    178            */

   \                                 In section .text, align 2, keep-with-next
    179          HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
    180          {
   \                     USB_SetCurrentMode: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    181            USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
   \   00000002   0x68C2             LDR      R2,[R0, #+12]
   \   00000004   0xF022 0x42C0      BIC      R2,R2,#0x60000000
   \   00000008   0x60C2             STR      R2,[R0, #+12]
    182            
    183            if ( mode == USB_OTG_HOST_MODE)
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD104             BNE.N    ??USB_SetCurrentMode_0
    184            {
    185              USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
   \   0000000E   0x68C1             LDR      R1,[R0, #+12]
   \   00000010   0xF041 0x5100      ORR      R1,R1,#0x20000000
   \   00000014   0x60C1             STR      R1,[R0, #+12]
   \   00000016   0xE005             B.N      ??USB_SetCurrentMode_1
    186            }
    187            else if ( mode == USB_OTG_DEVICE_MODE)
   \                     ??USB_SetCurrentMode_0: (+1)
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD103             BNE.N    ??USB_SetCurrentMode_1
    188            {
    189              USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
   \   0000001C   0x68C1             LDR      R1,[R0, #+12]
   \   0000001E   0xF041 0x4180      ORR      R1,R1,#0x40000000
   \   00000022   0x60C1             STR      R1,[R0, #+12]
    190            }
    191            HAL_Delay(50U);
   \                     ??USB_SetCurrentMode_1: (+1)
   \   00000024   0x2032             MOVS     R0,#+50
   \   00000026   0x.... 0x....      BL       HAL_Delay
    192            
    193            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD02             POP      {R1,PC}          ;; return
    194          }
    195          
    196          /**
    197            * @brief  USB_DevInit : Initializes the USB_OTG controller registers 
    198            *         for device mode
    199            * @param  USBx : Selected device
    200            * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
    201            *         the configuration information for the specified USBx peripheral.
    202            * @retval HAL status
    203            */

   \                                 In section .text, align 2, keep-with-next
    204          HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
    205          {
   \                     USB_DevInit: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \   00000006   0x4604             MOV      R4,R0
    206            uint32_t i = 0U;
   \   00000008   0x2700             MOVS     R7,#+0
    207          
    208            /*Activate VBUS Sensing B */
    209          #if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
    210              defined(STM32F412Rx) || defined(STM32F412Cx)
    211            USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
    212            
    213            if (cfg.vbus_sensing_enable == 0U)
    214            {
    215              /* Deactivate VBUS Sensing B */
    216              USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
    217              
    218              /* B-peripheral session valid override enable*/ 
    219              USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    220              USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
    221            }
    222          #else
    223            USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
   \   0000000A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000000C   0xF440 0x2000      ORR      R0,R0,#0x80000
   \   00000010   0x63A0             STR      R0,[R4, #+56]
    224            
    225            if (cfg.vbus_sensing_enable == 0U)
   \   00000012   0x9D11             LDR      R5,[SP, #+68]
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD103             BNE.N    ??USB_DevInit_0
    226            {
    227              USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
   \   00000018   0x6BA0             LDR      R0,[R4, #+56]
   \   0000001A   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   0000001E   0x63A0             STR      R0,[R4, #+56]
    228            }
    229          #endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx */
    230          
    231            /* Restart the Phy Clock */
    232            USBx_PCGCCTL = 0U;
   \                     ??USB_DevInit_0: (+1)
   \   00000020   0x46A0             MOV      R8,R4
   \   00000022   0x4638             MOV      R0,R7
   \   00000024   0xF508 0x6160      ADD      R1,R8,#+3584
   \   00000028   0x6008             STR      R0,[R1, #+0]
    233          
    234            /* Device mode configuration */
    235            USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
   \   0000002A   0xF508 0x6600      ADD      R6,R8,#+2048
   \   0000002E   0x6830             LDR      R0,[R6, #+0]
   \   00000030   0x6030             STR      R0,[R6, #+0]
    236            
    237            if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
   \   00000032   0x980C             LDR      R0,[SP, #+48]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD10C             BNE.N    ??USB_DevInit_1
    238            {
    239              if(cfg.speed == USB_OTG_SPEED_HIGH)
   \   00000038   0x9809             LDR      R0,[SP, #+36]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD104             BNE.N    ??USB_DevInit_2
    240              {      
    241                /* Set High speed phy */
    242                USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
   \   0000003E   0x4639             MOV      R1,R7
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       USB_SetDevSpeed
   \   00000046   0xE008             B.N      ??USB_DevInit_3
    243              }
    244              else 
    245              {
    246                /* set High speed phy in Full speed mode */
    247                USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
   \                     ??USB_DevInit_2: (+1)
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       USB_SetDevSpeed
   \   00000050   0xE003             B.N      ??USB_DevInit_3
    248              }
    249            }
    250            else
    251            {
    252              /* Set Full speed phy */
    253              USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
   \                     ??USB_DevInit_1: (+1)
   \   00000052   0x2103             MOVS     R1,#+3
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       USB_SetDevSpeed
    254            }
    255          
    256            /* Flush the FIFOs */
    257            USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
   \                     ??USB_DevInit_3: (+1)
   \   0000005A   0x2110             MOVS     R1,#+16
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       USB_FlushTxFifo
    258            USB_FlushRxFifo(USBx);
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       USB_FlushRxFifo
    259            
    260            /* Clear all pending Device Interrupts */
    261            USBx_DEVICE->DIEPMSK = 0U;
   \   00000068   0x4638             MOV      R0,R7
   \   0000006A   0x6130             STR      R0,[R6, #+16]
    262            USBx_DEVICE->DOEPMSK = 0U;
   \   0000006C   0x6170             STR      R0,[R6, #+20]
    263            USBx_DEVICE->DAINT = 0xFFFFFFFFU;
   \   0000006E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000072   0x61B0             STR      R0,[R6, #+24]
    264            USBx_DEVICE->DAINTMSK = 0U;
   \   00000074   0x4638             MOV      R0,R7
   \   00000076   0x61F0             STR      R0,[R6, #+28]
    265            
    266            for (i = 0U; i < cfg.dev_endpoints; i++)
   \   00000078   0xE006             B.N      ??USB_DevInit_4
    267            {
    268              if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
    269              {
    270                USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
    271              }
    272              else
    273              {
    274                USBx_INEP(i)->DIEPCTL = 0U;
   \                     ??USB_DevInit_5: (+1)
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x6001             STR      R1,[R0, #+0]
    275              }
    276              
    277              USBx_INEP(i)->DIEPTSIZ = 0U;
   \                     ??USB_DevInit_6: (+1)
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0x6101             STR      R1,[R0, #+16]
    278              USBx_INEP(i)->DIEPINT  = 0xFFU;
   \   00000082   0x21FF             MOVS     R1,#+255
   \   00000084   0x6081             STR      R1,[R0, #+8]
   \   00000086   0x1C7F             ADDS     R7,R7,#+1
   \                     ??USB_DevInit_4: (+1)
   \   00000088   0x9807             LDR      R0,[SP, #+28]
   \   0000008A   0x4287             CMP      R7,R0
   \   0000008C   0xD20A             BCS.N    ??USB_DevInit_7
   \   0000008E   0xEB08 0x1047      ADD      R0,R8,R7, LSL #+5
   \   00000092   0xF500 0x6010      ADD      R0,R0,#+2304
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x2900             CMP      R1,#+0
   \   0000009A   0xD5EE             BPL.N    ??USB_DevInit_5
   \   0000009C   0xF04F 0x4190      MOV      R1,#+1207959552
   \   000000A0   0x6001             STR      R1,[R0, #+0]
   \   000000A2   0xE7EC             B.N      ??USB_DevInit_6
    279            }
    280            
    281            for (i = 0U; i < cfg.dev_endpoints; i++)
   \                     ??USB_DevInit_7: (+1)
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xE006             B.N      ??USB_DevInit_8
    282            {
    283              if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
    284              {
    285                USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
    286              }
    287              else
    288              {
    289                USBx_OUTEP(i)->DOEPCTL = 0U;
   \                     ??USB_DevInit_9: (+1)
   \   000000A8   0x2200             MOVS     R2,#+0
   \   000000AA   0x600A             STR      R2,[R1, #+0]
    290              }
    291              
    292              USBx_OUTEP(i)->DOEPTSIZ = 0U;
   \                     ??USB_DevInit_10: (+1)
   \   000000AC   0x2200             MOVS     R2,#+0
   \   000000AE   0x610A             STR      R2,[R1, #+16]
    293              USBx_OUTEP(i)->DOEPINT  = 0xFFU;
   \   000000B0   0x22FF             MOVS     R2,#+255
   \   000000B2   0x608A             STR      R2,[R1, #+8]
   \   000000B4   0x1C40             ADDS     R0,R0,#+1
   \                     ??USB_DevInit_8: (+1)
   \   000000B6   0x9907             LDR      R1,[SP, #+28]
   \   000000B8   0x4288             CMP      R0,R1
   \   000000BA   0xD20A             BCS.N    ??USB_DevInit_11
   \   000000BC   0xEB08 0x1140      ADD      R1,R8,R0, LSL #+5
   \   000000C0   0xF501 0x6130      ADD      R1,R1,#+2816
   \   000000C4   0x680A             LDR      R2,[R1, #+0]
   \   000000C6   0x2A00             CMP      R2,#+0
   \   000000C8   0xD5EE             BPL.N    ??USB_DevInit_9
   \   000000CA   0xF04F 0x4290      MOV      R2,#+1207959552
   \   000000CE   0x600A             STR      R2,[R1, #+0]
   \   000000D0   0xE7EC             B.N      ??USB_DevInit_10
    294            }
    295            
    296            USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
   \                     ??USB_DevInit_11: (+1)
   \   000000D2   0x6930             LDR      R0,[R6, #+16]
   \   000000D4   0xF420 0x7080      BIC      R0,R0,#0x100
   \   000000D8   0x6130             STR      R0,[R6, #+16]
    297            
    298            if (cfg.dma_enable == 1U)
   \   000000DA   0x980A             LDR      R0,[SP, #+40]
   \   000000DC   0x2801             CMP      R0,#+1
   \   000000DE   0xD109             BNE.N    ??USB_DevInit_12
    299            {
    300              /*Set threshold parameters */
    301              USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x800100
   \   000000E4   0x6331             STR      R1,[R6, #+48]
    302              USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
   \   000000E6   0x6B31             LDR      R1,[R6, #+48]
   \   000000E8   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   000000EC   0xF041 0x0103      ORR      R1,R1,#0x3
   \   000000F0   0x6331             STR      R1,[R6, #+48]
    303              
    304              i= USBx_DEVICE->DTHRCTL;
   \   000000F2   0x6B31             LDR      R1,[R6, #+48]
    305            }
    306            
    307            /* Disable all interrupts. */
    308            USBx->GINTMSK = 0U;
   \                     ??USB_DevInit_12: (+1)
   \   000000F4   0x2100             MOVS     R1,#+0
   \   000000F6   0x61A1             STR      R1,[R4, #+24]
    309            
    310            /* Clear any pending interrupts */
    311            USBx->GINTSTS = 0xBFFFFFFFU;
   \   000000F8   0xF06F 0x4180      MVN      R1,#+1073741824
   \   000000FC   0x6161             STR      R1,[R4, #+20]
    312          
    313            /* Enable the common interrupts */
    314            if (cfg.dma_enable == DISABLE)
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD103             BNE.N    ??USB_DevInit_13
    315            {
    316              USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
   \   00000102   0x69A0             LDR      R0,[R4, #+24]
   \   00000104   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000108   0x61A0             STR      R0,[R4, #+24]
    317            }
    318            
    319            /* Enable interrupts matching to the Device mode ONLY */
    320            USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
    321                              USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
    322                              USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
    323                              USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
   \                     ??USB_DevInit_13: (+1)
   \   0000010A   0x69A0             LDR      R0,[R4, #+24]
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable10_1  ;; 0x803c3800
   \   00000110   0x4308             ORRS     R0,R1,R0
   \   00000112   0x61A0             STR      R0,[R4, #+24]
    324            
    325            if(cfg.Sof_enable)
   \   00000114   0x980D             LDR      R0,[SP, #+52]
   \   00000116   0x2800             CMP      R0,#+0
   \   00000118   0xD003             BEQ.N    ??USB_DevInit_14
    326            {
    327              USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
   \   0000011A   0x69A0             LDR      R0,[R4, #+24]
   \   0000011C   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000120   0x61A0             STR      R0,[R4, #+24]
    328            }
    329          
    330            if (cfg.vbus_sensing_enable == ENABLE)
   \                     ??USB_DevInit_14: (+1)
   \   00000122   0x2D01             CMP      R5,#+1
   \   00000124   0xD105             BNE.N    ??USB_DevInit_15
    331            {
    332              USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
   \   00000126   0x69A0             LDR      R0,[R4, #+24]
   \   00000128   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \   0000012C   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000130   0x61A0             STR      R0,[R4, #+24]
    333            }
    334            
    335            return HAL_OK;
   \                     ??USB_DevInit_15: (+1)
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0xE8BD 0x01F2      POP      {R1,R4-R8}
   \   00000138   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
    336          }
    337          
    338          
    339          /**
    340            * @brief  USB_OTG_FlushTxFifo : Flush a Tx FIFO
    341            * @param  USBx : Selected device
    342            * @param  num : FIFO number
    343            *         This parameter can be a value from 1 to 15
    344                      15 means Flush all Tx FIFOs
    345            * @retval HAL status
    346            */

   \                                 In section .text, align 2, keep-with-next
    347          HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
    348          {
    349            uint32_t count = 0U;
   \                     USB_FlushTxFifo: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    350           
    351            USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
   \   00000002   0x0189             LSLS     R1,R1,#+6
   \   00000004   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000008   0x6101             STR      R1,[R0, #+16]
    352           
    353            do
    354            {
    355              if (++count > 200000U)
   \                     ??USB_FlushTxFifo_0: (+1)
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x30d41
   \   00000010   0x428A             CMP      R2,R1
   \   00000012   0xD301             BCC.N    ??USB_FlushTxFifo_1
    356              {
    357                return HAL_TIMEOUT;
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0x4770             BX       LR
    358              }
    359            }
    360            while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
   \                     ??USB_FlushTxFifo_1: (+1)
   \   00000018   0x6901             LDR      R1,[R0, #+16]
   \   0000001A   0x0689             LSLS     R1,R1,#+26
   \   0000001C   0xD4F5             BMI.N    ??USB_FlushTxFifo_0
    361            
    362            return HAL_OK;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x4770             BX       LR               ;; return
    363          }
    364          
    365          
    366          /**
    367            * @brief  USB_FlushRxFifo : Flush Rx FIFO
    368            * @param  USBx : Selected device
    369            * @retval HAL status
    370            */

   \                                 In section .text, align 2, keep-with-next
    371          HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
    372          {
    373            uint32_t count = 0U;
   \                     USB_FlushRxFifo: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    374            
    375            USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
   \   00000002   0x2210             MOVS     R2,#+16
   \   00000004   0x6102             STR      R2,[R0, #+16]
    376            
    377            do
    378            {
    379              if (++count > 200000U)
   \                     ??USB_FlushRxFifo_0: (+1)
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable10_2  ;; 0x30d41
   \   0000000C   0x4291             CMP      R1,R2
   \   0000000E   0xD301             BCC.N    ??USB_FlushRxFifo_1
    380              {
    381                return HAL_TIMEOUT;
   \   00000010   0x2003             MOVS     R0,#+3
   \   00000012   0x4770             BX       LR
    382              }
    383            }
    384            while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
   \                     ??USB_FlushRxFifo_1: (+1)
   \   00000014   0x6902             LDR      R2,[R0, #+16]
   \   00000016   0x06D2             LSLS     R2,R2,#+27
   \   00000018   0xD4F5             BMI.N    ??USB_FlushRxFifo_0
    385            
    386            return HAL_OK;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
    387          }
    388          
    389          /**
    390            * @brief  USB_SetDevSpeed :Initializes the DevSpd field of DCFG register 
    391            *         depending the PHY type and the enumeration speed of the device.
    392            * @param  USBx : Selected device
    393            * @param  speed : device speed
    394            *          This parameter can be one of these values:
    395            *            @arg USB_OTG_SPEED_HIGH: High speed mode
    396            *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode
    397            *            @arg USB_OTG_SPEED_FULL: Full speed mode
    398            *            @arg USB_OTG_SPEED_LOW: Low speed mode
    399            * @retval  Hal status
    400            */

   \                                 In section .text, align 2, keep-with-next
    401          HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
    402          {
    403            USBx_DEVICE->DCFG |= speed;
   \                     USB_SetDevSpeed: (+1)
   \   00000000   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0x6001             STR      R1,[R0, #+0]
    404            return HAL_OK;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR               ;; return
    405          }
    406          
    407          /**
    408            * @brief  USB_GetDevSpeed :Return the  Dev Speed 
    409            * @param  USBx : Selected device
    410            * @retval speed : device speed
    411            *          This parameter can be one of these values:
    412            *            @arg USB_OTG_SPEED_HIGH: High speed mode
    413            *            @arg USB_OTG_SPEED_FULL: Full speed mode
    414            *            @arg USB_OTG_SPEED_LOW: Low speed mode
    415            */

   \                                 In section .text, align 2, keep-with-next
    416          uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
    417          {
    418            uint8_t speed = 0U;
   \                     USB_GetDevSpeed: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    419            
    420            if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
   \   00000002   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000006   0x6882             LDR      R2,[R0, #+8]
   \   00000008   0xF012 0x0F06      TST      R2,#0x6
   \   0000000C   0xD011             BEQ.N    ??USB_GetDevSpeed_0
    421            {
    422              speed = USB_OTG_SPEED_HIGH;
    423            }
    424            else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
    425                     ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
   \   0000000E   0x6882             LDR      R2,[R0, #+8]
   \   00000010   0xF002 0x0206      AND      R2,R2,#0x6
   \   00000014   0x2A02             CMP      R2,#+2
   \   00000016   0xD004             BEQ.N    ??USB_GetDevSpeed_1
   \   00000018   0x6882             LDR      R2,[R0, #+8]
   \   0000001A   0xF002 0x0206      AND      R2,R2,#0x6
   \   0000001E   0x2A06             CMP      R2,#+6
   \   00000020   0xD101             BNE.N    ??USB_GetDevSpeed_2
    426            {
    427              speed = USB_OTG_SPEED_FULL;
   \                     ??USB_GetDevSpeed_1: (+1)
   \   00000022   0x2103             MOVS     R1,#+3
   \   00000024   0xE005             B.N      ??USB_GetDevSpeed_0
    428            }
    429            else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
   \                     ??USB_GetDevSpeed_2: (+1)
   \   00000026   0x6880             LDR      R0,[R0, #+8]
   \   00000028   0xF000 0x0006      AND      R0,R0,#0x6
   \   0000002C   0x2804             CMP      R0,#+4
   \   0000002E   0xD100             BNE.N    ??USB_GetDevSpeed_0
    430            {
    431              speed = USB_OTG_SPEED_LOW;
   \   00000030   0x2102             MOVS     R1,#+2
    432            }
    433            
    434            return speed;
   \                     ??USB_GetDevSpeed_0: (+1)
   \   00000032   0x4608             MOV      R0,R1
   \   00000034   0x4770             BX       LR               ;; return
    435          }
    436          
    437          /**
    438            * @brief  Activate and configure an endpoint
    439            * @param  USBx : Selected device
    440            * @param  ep: pointer to endpoint structure
    441            * @retval HAL status
    442            */

   \                                 In section .text, align 2, keep-with-next
    443          HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    444          {
   \                     USB_ActivateEndpoint: (+1)
   \   00000000   0xB410             PUSH     {R4}
    445            if (ep->is_in == 1U)
   \   00000002   0xF500 0x6200      ADD      R2,R0,#+2048
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0x780C             LDRB     R4,[R1, #+0]
   \   0000000A   0x40A3             LSLS     R3,R3,R4
   \   0000000C   0x784C             LDRB     R4,[R1, #+1]
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0x69D4             LDR      R4,[R2, #+28]
   \   00000012   0xD11A             BNE.N    ??USB_ActivateEndpoint_0
    446            {
    447             USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));
   \   00000014   0xB29B             UXTH     R3,R3
   \   00000016   0x4323             ORRS     R3,R3,R4
   \   00000018   0x61D3             STR      R3,[R2, #+28]
    448             
    449              if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)
   \   0000001A   0x780A             LDRB     R2,[R1, #+0]
   \   0000001C   0xEB00 0x1042      ADD      R0,R0,R2, LSL #+5
   \   00000020   0xF500 0x6010      ADD      R0,R0,#+2304
   \   00000024   0x6803             LDR      R3,[R0, #+0]
   \   00000026   0x041B             LSLS     R3,R3,#+16
   \   00000028   0xD427             BMI.N    ??USB_ActivateEndpoint_1
    450              {
    451                USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18U) |\
    452                  ((ep->num) << 22U) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
   \   0000002A   0x6803             LDR      R3,[R0, #+0]
   \   0000002C   0x688C             LDR      R4,[R1, #+8]
   \   0000002E   0x0564             LSLS     R4,R4,#+21
   \   00000030   0x0D64             LSRS     R4,R4,#+21
   \   00000032   0x78C9             LDRB     R1,[R1, #+3]
   \   00000034   0xEA44 0x4181      ORR      R1,R4,R1, LSL #+18
   \   00000038   0xEA41 0x5182      ORR      R1,R1,R2, LSL #+22
   \   0000003C   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \   00000040   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000044   0x4319             ORRS     R1,R1,R3
   \   00000046   0x6001             STR      R1,[R0, #+0]
   \   00000048   0xE017             B.N      ??USB_ActivateEndpoint_1
    453              } 
    454            }
    455            else
    456            {
    457               USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U);
   \                     ??USB_ActivateEndpoint_0: (+1)
   \   0000004A   0xEA44 0x4303      ORR      R3,R4,R3, LSL #+16
   \   0000004E   0x61D3             STR      R3,[R2, #+28]
    458               
    459              if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
   \   00000050   0x780A             LDRB     R2,[R1, #+0]
   \   00000052   0xEB00 0x1042      ADD      R0,R0,R2, LSL #+5
   \   00000056   0xF500 0x6030      ADD      R0,R0,#+2816
   \   0000005A   0x6802             LDR      R2,[R0, #+0]
   \   0000005C   0x0412             LSLS     R2,R2,#+16
   \   0000005E   0xD40C             BMI.N    ??USB_ActivateEndpoint_1
    460              {
    461                USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18U) |\
    462                 (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
   \   00000060   0x6802             LDR      R2,[R0, #+0]
   \   00000062   0x688B             LDR      R3,[R1, #+8]
   \   00000064   0x055B             LSLS     R3,R3,#+21
   \   00000066   0x0D5B             LSRS     R3,R3,#+21
   \   00000068   0x78C9             LDRB     R1,[R1, #+3]
   \   0000006A   0xEA43 0x4181      ORR      R1,R3,R1, LSL #+18
   \   0000006E   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \   00000072   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000076   0x4311             ORRS     R1,R1,R2
   \   00000078   0x6001             STR      R1,[R0, #+0]
    463              } 
    464            }
    465            return HAL_OK;
   \                     ??USB_ActivateEndpoint_1: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xBC10             POP      {R4}
   \   0000007E   0x4770             BX       LR               ;; return
    466          }
    467          /**
    468            * @brief  Activate and configure a dedicated endpoint
    469            * @param  USBx : Selected device
    470            * @param  ep: pointer to endpoint structure
    471            * @retval HAL status
    472            */

   \                                 In section .text, align 2, keep-with-next
    473          HAL_StatusTypeDef USB_ActivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    474          {
   \                     USB_ActivateDedicatedEndpoint: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    475            static __IO uint32_t debug = 0U;
    476            
    477            /* Read DEPCTLn register */
    478            if (ep->is_in == 1U)
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0xEB00 0x1342      ADD      R3,R0,R2, LSL #+5
   \   00000008   0x784C             LDRB     R4,[R1, #+1]
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD12B             BNE.N    ??USB_ActivateDedicatedEndpoint_0
   \   0000000E   0xF503 0x6410      ADD      R4,R3,#+2304
   \   00000012   0x.... 0x....      LDR.W    R3,??DataTable10_3  ;; 0x10008000
   \   00000016   0x6825             LDR      R5,[R4, #+0]
   \   00000018   0x042D             LSLS     R5,R5,#+16
   \   0000001A   0xD40B             BMI.N    ??USB_ActivateDedicatedEndpoint_1
    479            {
    480              if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)
    481              {
    482                USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18U) |\
    483                  ((ep->num) << 22U) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
   \   0000001C   0x6825             LDR      R5,[R4, #+0]
   \   0000001E   0x688E             LDR      R6,[R1, #+8]
   \   00000020   0x0576             LSLS     R6,R6,#+21
   \   00000022   0x0D76             LSRS     R6,R6,#+21
   \   00000024   0x78CF             LDRB     R7,[R1, #+3]
   \   00000026   0xEA46 0x4687      ORR      R6,R6,R7, LSL #+18
   \   0000002A   0xEA46 0x5282      ORR      R2,R6,R2, LSL #+22
   \   0000002E   0x431A             ORRS     R2,R3,R2
   \   00000030   0x432A             ORRS     R2,R2,R5
   \   00000032   0x6022             STR      R2,[R4, #+0]
    484              } 
    485              
    486              
    487              debug  |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18U) |\
    488                  ((ep->num) << 22U) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
   \                     ??USB_ActivateDedicatedEndpoint_1: (+1)
   \   00000034   0x780A             LDRB     R2,[R1, #+0]
   \   00000036   0x.... 0x....      LDR.W    R4,??DataTable10_4
   \   0000003A   0x6825             LDR      R5,[R4, #+0]
   \   0000003C   0x688E             LDR      R6,[R1, #+8]
   \   0000003E   0x0576             LSLS     R6,R6,#+21
   \   00000040   0x0D76             LSRS     R6,R6,#+21
   \   00000042   0x78C9             LDRB     R1,[R1, #+3]
   \   00000044   0xEA46 0x4181      ORR      R1,R6,R1, LSL #+18
   \   00000048   0xEA41 0x5182      ORR      R1,R1,R2, LSL #+22
   \   0000004C   0x4319             ORRS     R1,R3,R1
   \   0000004E   0x4329             ORRS     R1,R1,R5
   \   00000050   0x6021             STR      R1,[R4, #+0]
    489              
    490             USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));
   \   00000052   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000056   0x6BC1             LDR      R1,[R0, #+60]
   \   00000058   0x2301             MOVS     R3,#+1
   \   0000005A   0xFA03 0xF202      LSL      R2,R3,R2
   \   0000005E   0xB292             UXTH     R2,R2
   \   00000060   0x4311             ORRS     R1,R2,R1
   \   00000062   0x63C1             STR      R1,[R0, #+60]
   \   00000064   0xE033             B.N      ??USB_ActivateDedicatedEndpoint_2
    491            }
   \                     ??USB_ActivateDedicatedEndpoint_0: (+1)
   \   00000066   0xF503 0x6330      ADD      R3,R3,#+2816
   \   0000006A   0x681C             LDR      R4,[R3, #+0]
   \   0000006C   0x0424             LSLS     R4,R4,#+16
   \   0000006E   0xD424             BMI.N    ??USB_ActivateDedicatedEndpoint_3
    492            else
    493            {
    494              if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
    495              {
    496                USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18U) |\
    497                  ((ep->num) << 22U) | (USB_OTG_DOEPCTL_USBAEP));
   \   00000070   0x681C             LDR      R4,[R3, #+0]
   \   00000072   0x688D             LDR      R5,[R1, #+8]
   \   00000074   0x056D             LSLS     R5,R5,#+21
   \   00000076   0x0D6D             LSRS     R5,R5,#+21
   \   00000078   0x78CE             LDRB     R6,[R1, #+3]
   \   0000007A   0xEA45 0x4586      ORR      R5,R5,R6, LSL #+18
   \   0000007E   0xEA45 0x5282      ORR      R2,R5,R2, LSL #+22
   \   00000082   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   00000086   0x4322             ORRS     R2,R2,R4
   \   00000088   0x601A             STR      R2,[R3, #+0]
    498                
    499                debug = (uint32_t)(((uint32_t )USBx) + USB_OTG_OUT_ENDPOINT_BASE + (0U)*USB_OTG_EP_REG_SIZE);
   \   0000008A   0x.... 0x....      LDR.W    R4,??DataTable10_4
   \   0000008E   0xF500 0x6230      ADD      R2,R0,#+2816
   \   00000092   0x6022             STR      R2,[R4, #+0]
    500                debug = (uint32_t )&USBx_OUTEP(ep->num)->DOEPCTL;
   \   00000094   0x780A             LDRB     R2,[R1, #+0]
   \   00000096   0xEB00 0x1342      ADD      R3,R0,R2, LSL #+5
   \   0000009A   0xF503 0x6330      ADD      R3,R3,#+2816
   \   0000009E   0x6023             STR      R3,[R4, #+0]
    501                debug |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18U) |\
    502                  ((ep->num) << 22U) | (USB_OTG_DOEPCTL_USBAEP)); 
   \   000000A0   0x6823             LDR      R3,[R4, #+0]
   \   000000A2   0x688D             LDR      R5,[R1, #+8]
   \   000000A4   0x056D             LSLS     R5,R5,#+21
   \   000000A6   0x0D6D             LSRS     R5,R5,#+21
   \   000000A8   0x78CE             LDRB     R6,[R1, #+3]
   \   000000AA   0xEA45 0x4586      ORR      R5,R5,R6, LSL #+18
   \   000000AE   0xEA45 0x5282      ORR      R2,R5,R2, LSL #+22
   \   000000B2   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   000000B6   0x431A             ORRS     R2,R2,R3
   \   000000B8   0x6022             STR      R2,[R4, #+0]
    503              } 
    504              
    505               USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U);
   \                     ??USB_ActivateDedicatedEndpoint_3: (+1)
   \   000000BA   0xF500 0x6000      ADD      R0,R0,#+2048
   \   000000BE   0x6BC2             LDR      R2,[R0, #+60]
   \   000000C0   0x2301             MOVS     R3,#+1
   \   000000C2   0x7809             LDRB     R1,[R1, #+0]
   \   000000C4   0xFA03 0xF101      LSL      R1,R3,R1
   \   000000C8   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   000000CC   0x63C1             STR      R1,[R0, #+60]
    506            }
    507          
    508            return HAL_OK;
   \                     ??USB_ActivateDedicatedEndpoint_2: (+1)
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xBCF0             POP      {R4-R7}
   \   000000D2   0x4770             BX       LR               ;; return
    509          }

   \                                 In section .bss, align 4
   \                     ??debug:
   \   00000000                      DS8 4
    510          /**
    511            * @brief  De-activate and de-initialize an endpoint
    512            * @param  USBx : Selected device
    513            * @param  ep: pointer to endpoint structure
    514            * @retval HAL status
    515            */

   \                                 In section .text, align 2, keep-with-next
    516          HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    517          {
   \                     USB_DeactivateEndpoint: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    518            /* Read DEPCTLn register */
    519            if (ep->is_in == 1U)
   \   00000002   0xF500 0x6200      ADD      R2,R0,#+2048
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0x780C             LDRB     R4,[R1, #+0]
   \   0000000A   0xFA03 0xF404      LSL      R4,R3,R4
   \   0000000E   0x784D             LDRB     R5,[R1, #+1]
   \   00000010   0x2D01             CMP      R5,#+1
   \   00000012   0x6BD5             LDR      R5,[R2, #+60]
   \   00000014   0xD114             BNE.N    ??USB_DeactivateEndpoint_0
    520            {
    521             USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));
   \   00000016   0xB2A4             UXTH     R4,R4
   \   00000018   0xEA25 0x0404      BIC      R4,R5,R4
   \   0000001C   0x63D4             STR      R4,[R2, #+60]
    522             USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));   
   \   0000001E   0x69D4             LDR      R4,[R2, #+28]
   \   00000020   0x780D             LDRB     R5,[R1, #+0]
   \   00000022   0x40AB             LSLS     R3,R3,R5
   \   00000024   0xB29B             UXTH     R3,R3
   \   00000026   0xEA24 0x0303      BIC      R3,R4,R3
   \   0000002A   0x61D3             STR      R3,[R2, #+28]
    523             USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;   
   \   0000002C   0x7809             LDRB     R1,[R1, #+0]
   \   0000002E   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000032   0xF500 0x6010      ADD      R0,R0,#+2304
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000003C   0x6001             STR      R1,[R0, #+0]
   \   0000003E   0xE011             B.N      ??USB_DeactivateEndpoint_1
    524            }
    525            else
    526            {
    527               USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));
   \                     ??USB_DeactivateEndpoint_0: (+1)
   \   00000040   0xEA25 0x4404      BIC      R4,R5,R4, LSL #+16
   \   00000044   0x63D4             STR      R4,[R2, #+60]
    528               USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));     
   \   00000046   0x69D4             LDR      R4,[R2, #+28]
   \   00000048   0x780D             LDRB     R5,[R1, #+0]
   \   0000004A   0x40AB             LSLS     R3,R3,R5
   \   0000004C   0xEA24 0x4303      BIC      R3,R4,R3, LSL #+16
   \   00000050   0x61D3             STR      R3,[R2, #+28]
    529               USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;      
   \   00000052   0x7809             LDRB     R1,[R1, #+0]
   \   00000054   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000058   0xF500 0x6030      ADD      R0,R0,#+2816
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000062   0x6001             STR      R1,[R0, #+0]
    530            }
    531            return HAL_OK;
   \                     ??USB_DeactivateEndpoint_1: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xBC30             POP      {R4,R5}
   \   00000068   0x4770             BX       LR               ;; return
    532          }
    533          
    534          /**
    535            * @brief  De-activate and de-initialize a dedicated endpoint
    536            * @param  USBx : Selected device
    537            * @param  ep: pointer to endpoint structure
    538            * @retval HAL status
    539            */

   \                                 In section .text, align 2, keep-with-next
    540          HAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    541          {
   \                     USB_DeactivateDedicatedEndpoint: (+1)
   \   00000000   0xB410             PUSH     {R4}
    542            /* Read DEPCTLn register */
    543            if (ep->is_in == 1U)
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0xEB00 0x1342      ADD      R3,R0,R2, LSL #+5
   \   00000008   0xF500 0x6000      ADD      R0,R0,#+2048
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x784C             LDRB     R4,[R1, #+1]
   \   00000010   0x2C01             CMP      R4,#+1
   \   00000012   0xD10E             BNE.N    ??USB_DeactivateDedicatedEndpoint_0
   \   00000014   0xF503 0x6310      ADD      R3,R3,#+2304
   \   00000018   0x681C             LDR      R4,[R3, #+0]
   \   0000001A   0xF424 0x4400      BIC      R4,R4,#0x8000
   \   0000001E   0x601C             STR      R4,[R3, #+0]
    544            {
    545             USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;
    546             USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));
   \   00000020   0x69C3             LDR      R3,[R0, #+28]
   \   00000022   0x7809             LDRB     R1,[R1, #+0]
   \   00000024   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000028   0xB289             UXTH     R1,R1
   \   0000002A   0xEA23 0x0101      BIC      R1,R3,R1
   \   0000002E   0x61C1             STR      R1,[R0, #+28]
   \   00000030   0xE00C             B.N      ??USB_DeactivateDedicatedEndpoint_1
    547            }
   \                     ??USB_DeactivateDedicatedEndpoint_0: (+1)
   \   00000032   0xF503 0x6330      ADD      R3,R3,#+2816
   \   00000036   0x681C             LDR      R4,[R3, #+0]
   \   00000038   0xF424 0x4400      BIC      R4,R4,#0x8000
   \   0000003C   0x601C             STR      R4,[R3, #+0]
    548            else
    549            {
    550               USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP; 
    551               USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));
   \   0000003E   0x69C3             LDR      R3,[R0, #+28]
   \   00000040   0x7809             LDRB     R1,[R1, #+0]
   \   00000042   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000046   0xEA23 0x4101      BIC      R1,R3,R1, LSL #+16
   \   0000004A   0x61C1             STR      R1,[R0, #+28]
    552            }
    553            return HAL_OK;
   \                     ??USB_DeactivateDedicatedEndpoint_1: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBC10             POP      {R4}
   \   00000050   0x4770             BX       LR               ;; return
    554          }
    555          
    556          /**
    557            * @brief  USB_EPStartXfer : setup and starts a transfer over an EP
    558            * @param  USBx : Selected device
    559            * @param  ep: pointer to endpoint structure
    560            * @param  dma: USB dma enabled or disabled 
    561            *          This parameter can be one of these values:
    562            *           0 : DMA feature not used 
    563            *           1 : DMA feature used  
    564            * @retval HAL status
    565            */

   \                                 In section .text, align 2, keep-with-next
    566          HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
    567          {
   \                     USB_EPStartXfer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    568            uint16_t pktcnt = 0U;
    569            
    570            /* IN endpoint */
    571            if (ep->is_in == 1U)
   \   00000002   0x4603             MOV      R3,R0
   \   00000004   0x780C             LDRB     R4,[R1, #+0]
   \   00000006   0xEB03 0x1544      ADD      R5,R3,R4, LSL #+5
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable10_5  ;; 0xe007ffff
   \   0000000E   0x784E             LDRB     R6,[R1, #+1]
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xF040 0x8099      BNE.W    ??USB_EPStartXfer_0
   \   00000016   0xF505 0x6510      ADD      R5,R5,#+2304
   \   0000001A   0x694E             LDR      R6,[R1, #+20]
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0x692E             LDR      R6,[R5, #+16]
   \   00000020   0xD114             BNE.N    ??USB_EPStartXfer_1
    572            {
    573              /* Zero Length Packet? */
    574              if (ep->xfer_len == 0U)
    575              {
    576                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
   \   00000022   0x4034             ANDS     R4,R4,R6
   \   00000024   0x612C             STR      R4,[R5, #+16]
    577                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
   \   00000026   0x780C             LDRB     R4,[R1, #+0]
   \   00000028   0xEB03 0x1444      ADD      R4,R3,R4, LSL #+5
   \   0000002C   0xF504 0x6410      ADD      R4,R4,#+2304
   \   00000030   0x6925             LDR      R5,[R4, #+16]
   \   00000032   0xF445 0x2500      ORR      R5,R5,#0x80000
   \   00000036   0x6125             STR      R5,[R4, #+16]
    578                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
   \   00000038   0x780C             LDRB     R4,[R1, #+0]
   \   0000003A   0xEB03 0x1444      ADD      R4,R3,R4, LSL #+5
   \   0000003E   0xF504 0x6410      ADD      R4,R4,#+2304
   \   00000042   0x6925             LDR      R5,[R4, #+16]
   \   00000044   0x0CED             LSRS     R5,R5,#+19
   \   00000046   0x04ED             LSLS     R5,R5,#+19
   \   00000048   0x6125             STR      R5,[R4, #+16]
   \   0000004A   0xE03C             B.N      ??USB_EPStartXfer_2
    579              }
    580              else
    581              {
    582                /* Program the transfer size and packet count
    583                * as follows: xfersize = N * maxpacket +
    584                * short_packet pktcnt = N + (short_packet
    585                * exist ? 1 : 0)
    586                */
    587                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
   \                     ??USB_EPStartXfer_1: (+1)
   \   0000004C   0x0CF6             LSRS     R6,R6,#+19
   \   0000004E   0x04F6             LSLS     R6,R6,#+19
   \   00000050   0x612E             STR      R6,[R5, #+16]
    588                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
   \   00000052   0x780D             LDRB     R5,[R1, #+0]
   \   00000054   0xEB03 0x1545      ADD      R5,R3,R5, LSL #+5
   \   00000058   0xF505 0x6510      ADD      R5,R5,#+2304
   \   0000005C   0x692E             LDR      R6,[R5, #+16]
   \   0000005E   0x4034             ANDS     R4,R4,R6
   \   00000060   0x612C             STR      R4,[R5, #+16]
    589                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket) << 19U)) ;
   \   00000062   0x780C             LDRB     R4,[R1, #+0]
   \   00000064   0xEB03 0x1444      ADD      R4,R3,R4, LSL #+5
   \   00000068   0xF504 0x6410      ADD      R4,R4,#+2304
   \   0000006C   0x688D             LDR      R5,[R1, #+8]
   \   0000006E   0x6926             LDR      R6,[R4, #+16]
   \   00000070   0x694F             LDR      R7,[R1, #+20]
   \   00000072   0x19EF             ADDS     R7,R5,R7
   \   00000074   0x1E7F             SUBS     R7,R7,#+1
   \   00000076   0xFBB7 0xF5F5      UDIV     R5,R7,R5
   \   0000007A   0x.... 0x....      LDR.W    R7,??DataTable10_6  ;; 0x1ff80000
   \   0000007E   0xEA07 0x45C5      AND      R5,R7,R5, LSL #+19
   \   00000082   0x4335             ORRS     R5,R5,R6
   \   00000084   0x6125             STR      R5,[R4, #+16]
    590                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
   \   00000086   0x780C             LDRB     R4,[R1, #+0]
   \   00000088   0xEB03 0x1444      ADD      R4,R3,R4, LSL #+5
   \   0000008C   0xF504 0x6410      ADD      R4,R4,#+2304
   \   00000090   0x6925             LDR      R5,[R4, #+16]
   \   00000092   0x694E             LDR      R6,[R1, #+20]
   \   00000094   0x0376             LSLS     R6,R6,#+13
   \   00000096   0xEA55 0x3556      ORRS     R5,R5,R6, LSR #+13
   \   0000009A   0x6125             STR      R5,[R4, #+16]
    591                
    592                if (ep->type == EP_TYPE_ISOC)
   \   0000009C   0x78CC             LDRB     R4,[R1, #+3]
   \   0000009E   0x2C01             CMP      R4,#+1
   \   000000A0   0xD111             BNE.N    ??USB_EPStartXfer_2
    593                {
    594                  USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
   \   000000A2   0x780C             LDRB     R4,[R1, #+0]
   \   000000A4   0xEB03 0x1444      ADD      R4,R3,R4, LSL #+5
   \   000000A8   0xF504 0x6410      ADD      R4,R4,#+2304
   \   000000AC   0x6925             LDR      R5,[R4, #+16]
   \   000000AE   0xF025 0x45C0      BIC      R5,R5,#0x60000000
   \   000000B2   0x6125             STR      R5,[R4, #+16]
    595                  USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29U)); 
   \   000000B4   0x780C             LDRB     R4,[R1, #+0]
   \   000000B6   0xEB03 0x1444      ADD      R4,R3,R4, LSL #+5
   \   000000BA   0xF504 0x6410      ADD      R4,R4,#+2304
   \   000000BE   0x6925             LDR      R5,[R4, #+16]
   \   000000C0   0xF045 0x5500      ORR      R5,R5,#0x20000000
   \   000000C4   0x6125             STR      R5,[R4, #+16]
    596                }       
    597              }
    598          
    599              if (dma == 1U)
   \                     ??USB_EPStartXfer_2: (+1)
   \   000000C6   0x2A01             CMP      R2,#+1
   \   000000C8   0xD107             BNE.N    ??USB_EPStartXfer_3
    600              {
    601                USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
   \   000000CA   0x780C             LDRB     R4,[R1, #+0]
   \   000000CC   0xEB03 0x1444      ADD      R4,R3,R4, LSL #+5
   \   000000D0   0xF504 0x6410      ADD      R4,R4,#+2304
   \   000000D4   0x690D             LDR      R5,[R1, #+16]
   \   000000D6   0x6165             STR      R5,[R4, #+20]
   \   000000D8   0xE00D             B.N      ??USB_EPStartXfer_4
    602              }
    603              else
    604              {
    605                if (ep->type != EP_TYPE_ISOC)
   \                     ??USB_EPStartXfer_3: (+1)
   \   000000DA   0x78CC             LDRB     R4,[R1, #+3]
   \   000000DC   0x2C01             CMP      R4,#+1
   \   000000DE   0xD00A             BEQ.N    ??USB_EPStartXfer_4
    606                {
    607                  /* Enable the Tx FIFO Empty Interrupt for this EP */
    608                  if (ep->xfer_len > 0U)
   \   000000E0   0x694C             LDR      R4,[R1, #+20]
   \   000000E2   0x2C00             CMP      R4,#+0
   \   000000E4   0xD007             BEQ.N    ??USB_EPStartXfer_4
    609                  {
    610                    USBx_DEVICE->DIEPEMPMSK |= 1U << ep->num;
   \   000000E6   0xF503 0x6400      ADD      R4,R3,#+2048
   \   000000EA   0x6B65             LDR      R5,[R4, #+52]
   \   000000EC   0x2601             MOVS     R6,#+1
   \   000000EE   0x780F             LDRB     R7,[R1, #+0]
   \   000000F0   0x40BE             LSLS     R6,R6,R7
   \   000000F2   0x4335             ORRS     R5,R6,R5
   \   000000F4   0x6365             STR      R5,[R4, #+52]
    611                  }
    612                }
    613              }
    614          
    615              if (ep->type == EP_TYPE_ISOC)
   \                     ??USB_EPStartXfer_4: (+1)
   \   000000F6   0x78CC             LDRB     R4,[R1, #+3]
   \   000000F8   0x2C01             CMP      R4,#+1
   \   000000FA   0xD111             BNE.N    ??USB_EPStartXfer_5
    616              {
    617                if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
   \   000000FC   0x780C             LDRB     R4,[R1, #+0]
   \   000000FE   0xEB03 0x1444      ADD      R4,R3,R4, LSL #+5
   \   00000102   0xF504 0x6410      ADD      R4,R4,#+2304
   \   00000106   0xF503 0x6500      ADD      R5,R3,#+2048
   \   0000010A   0x68AD             LDR      R5,[R5, #+8]
   \   0000010C   0x05ED             LSLS     R5,R5,#+23
   \   0000010E   0x6825             LDR      R5,[R4, #+0]
   \   00000110   0xD403             BMI.N    ??USB_EPStartXfer_6
    618                {
    619                  USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
   \   00000112   0xF045 0x5500      ORR      R5,R5,#0x20000000
   \   00000116   0x6025             STR      R5,[R4, #+0]
   \   00000118   0xE002             B.N      ??USB_EPStartXfer_5
    620                }
    621                else
    622                {
    623                  USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
   \                     ??USB_EPStartXfer_6: (+1)
   \   0000011A   0xF045 0x5580      ORR      R5,R5,#0x10000000
   \   0000011E   0x6025             STR      R5,[R4, #+0]
    624                }
    625              } 
    626              
    627              /* EP enable, IN data in FIFO */
    628              USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
   \                     ??USB_EPStartXfer_5: (+1)
   \   00000120   0x780C             LDRB     R4,[R1, #+0]
   \   00000122   0xEB03 0x1344      ADD      R3,R3,R4, LSL #+5
   \   00000126   0xF503 0x6310      ADD      R3,R3,#+2304
   \   0000012A   0x681C             LDR      R4,[R3, #+0]
   \   0000012C   0xF044 0x4404      ORR      R4,R4,#0x84000000
   \   00000130   0x601C             STR      R4,[R3, #+0]
    629              
    630              if (ep->type == EP_TYPE_ISOC)
   \   00000132   0x78CB             LDRB     R3,[R1, #+3]
   \   00000134   0x2B01             CMP      R3,#+1
   \   00000136   0xD16C             BNE.N    ??USB_EPStartXfer_7
    631              {
    632                USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   
   \   00000138   0x9200             STR      R2,[SP, #+0]
   \   0000013A   0x694B             LDR      R3,[R1, #+20]
   \   0000013C   0xB29B             UXTH     R3,R3
   \   0000013E   0x780A             LDRB     R2,[R1, #+0]
   \   00000140   0x68C9             LDR      R1,[R1, #+12]
   \   00000142   0x.... 0x....      BL       USB_WritePacket
   \   00000146   0xE064             B.N      ??USB_EPStartXfer_7
    633              }    
    634            }
   \                     ??USB_EPStartXfer_0: (+1)
   \   00000148   0xF505 0x6030      ADD      R0,R5,#+2816
   \   0000014C   0x6905             LDR      R5,[R0, #+16]
   \   0000014E   0x0CED             LSRS     R5,R5,#+19
   \   00000150   0x04ED             LSLS     R5,R5,#+19
   \   00000152   0x6105             STR      R5,[R0, #+16]
    635            else /* OUT endpoint */
    636            {
    637              /* Program the transfer size and packet count as follows:
    638              * pktcnt = N
    639              * xfersize = N * maxpacket
    640              */  
    641              USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
    642              USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
   \   00000154   0x7808             LDRB     R0,[R1, #+0]
   \   00000156   0xEB03 0x1040      ADD      R0,R3,R0, LSL #+5
   \   0000015A   0xF500 0x6030      ADD      R0,R0,#+2816
   \   0000015E   0x6905             LDR      R5,[R0, #+16]
   \   00000160   0x402C             ANDS     R4,R4,R5
   \   00000162   0x6104             STR      R4,[R0, #+16]
    643          
    644              if (ep->xfer_len == 0U)
   \   00000164   0x7808             LDRB     R0,[R1, #+0]
   \   00000166   0xEB03 0x1040      ADD      R0,R3,R0, LSL #+5
   \   0000016A   0xF500 0x6030      ADD      R0,R0,#+2816
   \   0000016E   0x688C             LDR      R4,[R1, #+8]
   \   00000170   0x694D             LDR      R5,[R1, #+20]
   \   00000172   0x2D00             CMP      R5,#+0
   \   00000174   0xD10E             BNE.N    ??USB_EPStartXfer_8
    645              {
    646                USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
   \   00000176   0x6905             LDR      R5,[R0, #+16]
   \   00000178   0x0364             LSLS     R4,R4,#+13
   \   0000017A   0xEA55 0x3454      ORRS     R4,R5,R4, LSR #+13
   \   0000017E   0x6104             STR      R4,[R0, #+16]
    647                USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
   \   00000180   0x7808             LDRB     R0,[R1, #+0]
   \   00000182   0xEB03 0x1040      ADD      R0,R3,R0, LSL #+5
   \   00000186   0xF500 0x6030      ADD      R0,R0,#+2816
   \   0000018A   0x6904             LDR      R4,[R0, #+16]
   \   0000018C   0xF444 0x2400      ORR      R4,R4,#0x80000
   \   00000190   0x6104             STR      R4,[R0, #+16]
   \   00000192   0xE017             B.N      ??USB_EPStartXfer_9
    648              }
    649              else
    650              {
    651                pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
   \                     ??USB_EPStartXfer_8: (+1)
   \   00000194   0x1965             ADDS     R5,R4,R5
   \   00000196   0x1E6D             SUBS     R5,R5,#+1
   \   00000198   0xFBB5 0xF4F4      UDIV     R4,R5,R4
   \   0000019C   0xB2A4             UXTH     R4,R4
    652                USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
   \   0000019E   0x6905             LDR      R5,[R0, #+16]
   \   000001A0   0x.... 0x....      LDR.W    R6,??DataTable10_6  ;; 0x1ff80000
   \   000001A4   0xEA06 0x46C4      AND      R6,R6,R4, LSL #+19
   \   000001A8   0x4335             ORRS     R5,R6,R5
   \   000001AA   0x6105             STR      R5,[R0, #+16]
    653                USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt));
   \   000001AC   0x7808             LDRB     R0,[R1, #+0]
   \   000001AE   0xEB03 0x1040      ADD      R0,R3,R0, LSL #+5
   \   000001B2   0xF500 0x6030      ADD      R0,R0,#+2816
   \   000001B6   0x6905             LDR      R5,[R0, #+16]
   \   000001B8   0x688E             LDR      R6,[R1, #+8]
   \   000001BA   0x4374             MULS     R4,R4,R6
   \   000001BC   0x0364             LSLS     R4,R4,#+13
   \   000001BE   0xEA55 0x3454      ORRS     R4,R5,R4, LSR #+13
   \   000001C2   0x6104             STR      R4,[R0, #+16]
    654              }
    655          
    656              if (dma == 1U)
   \                     ??USB_EPStartXfer_9: (+1)
   \   000001C4   0x2A01             CMP      R2,#+1
   \   000001C6   0xD106             BNE.N    ??USB_EPStartXfer_10
    657              {
    658                USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
   \   000001C8   0x7808             LDRB     R0,[R1, #+0]
   \   000001CA   0xEB03 0x1040      ADD      R0,R3,R0, LSL #+5
   \   000001CE   0xF500 0x6030      ADD      R0,R0,#+2816
   \   000001D2   0x68CA             LDR      R2,[R1, #+12]
   \   000001D4   0x6142             STR      R2,[R0, #+20]
    659              }
    660              
    661              if (ep->type == EP_TYPE_ISOC)
   \                     ??USB_EPStartXfer_10: (+1)
   \   000001D6   0x78C8             LDRB     R0,[R1, #+3]
   \   000001D8   0x2801             CMP      R0,#+1
   \   000001DA   0xD111             BNE.N    ??USB_EPStartXfer_11
    662              {
    663                if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
   \   000001DC   0x7808             LDRB     R0,[R1, #+0]
   \   000001DE   0xEB03 0x1040      ADD      R0,R3,R0, LSL #+5
   \   000001E2   0xF500 0x6030      ADD      R0,R0,#+2816
   \   000001E6   0xF503 0x6200      ADD      R2,R3,#+2048
   \   000001EA   0x6892             LDR      R2,[R2, #+8]
   \   000001EC   0x05D2             LSLS     R2,R2,#+23
   \   000001EE   0x6802             LDR      R2,[R0, #+0]
   \   000001F0   0xD403             BMI.N    ??USB_EPStartXfer_12
    664                {
    665                  USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
   \   000001F2   0xF042 0x5200      ORR      R2,R2,#0x20000000
   \   000001F6   0x6002             STR      R2,[R0, #+0]
   \   000001F8   0xE002             B.N      ??USB_EPStartXfer_11
    666                }
    667                else
    668                {
    669                  USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
   \                     ??USB_EPStartXfer_12: (+1)
   \   000001FA   0xF042 0x5280      ORR      R2,R2,#0x10000000
   \   000001FE   0x6002             STR      R2,[R0, #+0]
    670                }
    671              }
    672              /* EP enable */
    673              USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
   \                     ??USB_EPStartXfer_11: (+1)
   \   00000200   0x7808             LDRB     R0,[R1, #+0]
   \   00000202   0xEB03 0x1040      ADD      R0,R3,R0, LSL #+5
   \   00000206   0xF500 0x6030      ADD      R0,R0,#+2816
   \   0000020A   0x6801             LDR      R1,[R0, #+0]
   \   0000020C   0xF041 0x4104      ORR      R1,R1,#0x84000000
   \   00000210   0x6001             STR      R1,[R0, #+0]
    674            }
    675            return HAL_OK;
   \                     ??USB_EPStartXfer_7: (+1)
   \   00000212   0x2000             MOVS     R0,#+0
   \   00000214   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    676          }
    677          
    678          /**
    679            * @brief  USB_EP0StartXfer : setup and starts a transfer over the EP  0
    680            * @param  USBx : Selected device
    681            * @param  ep: pointer to endpoint structure
    682            * @param  dma: USB dma enabled or disabled 
    683            *          This parameter can be one of these values:
    684            *           0 : DMA feature not used 
    685            *           1 : DMA feature used  
    686            * @retval HAL status
    687            */

   \                                 In section .text, align 2, keep-with-next
    688          HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
    689          {
   \                     USB_EP0StartXfer: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    690            /* IN endpoint */
    691            if (ep->is_in == 1U)
   \   00000002   0x780B             LDRB     R3,[R1, #+0]
   \   00000004   0xEB00 0x1443      ADD      R4,R0,R3, LSL #+5
   \   00000008   0x.... 0x....      LDR.W    R3,??DataTable10_5  ;; 0xe007ffff
   \   0000000C   0x784D             LDRB     R5,[R1, #+1]
   \   0000000E   0x2D01             CMP      R5,#+1
   \   00000010   0xD15E             BNE.N    ??USB_EP0StartXfer_0
   \   00000012   0xF504 0x6410      ADD      R4,R4,#+2304
   \   00000016   0x694D             LDR      R5,[R1, #+20]
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0x6925             LDR      R5,[R4, #+16]
   \   0000001C   0xD114             BNE.N    ??USB_EP0StartXfer_1
    692            {
    693              /* Zero Length Packet? */
    694              if (ep->xfer_len == 0U)
    695              {
    696                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
   \   0000001E   0x402B             ANDS     R3,R3,R5
   \   00000020   0x6123             STR      R3,[R4, #+16]
    697                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
   \   00000022   0x780B             LDRB     R3,[R1, #+0]
   \   00000024   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   00000028   0xF503 0x6310      ADD      R3,R3,#+2304
   \   0000002C   0x691C             LDR      R4,[R3, #+16]
   \   0000002E   0xF444 0x2400      ORR      R4,R4,#0x80000
   \   00000032   0x611C             STR      R4,[R3, #+16]
    698                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
   \   00000034   0x780B             LDRB     R3,[R1, #+0]
   \   00000036   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   0000003A   0xF503 0x6310      ADD      R3,R3,#+2304
   \   0000003E   0x691C             LDR      R4,[R3, #+16]
   \   00000040   0x0CE4             LSRS     R4,R4,#+19
   \   00000042   0x04E4             LSLS     R4,R4,#+19
   \   00000044   0x611C             STR      R4,[R3, #+16]
   \   00000046   0xE024             B.N      ??USB_EP0StartXfer_2
    699              }
    700              else
    701              {
    702                /* Program the transfer size and packet count
    703                * as follows: xfersize = N * maxpacket +
    704                * short_packet pktcnt = N + (short_packet
    705                * exist ? 1 : 0)
    706                */
    707                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
   \                     ??USB_EP0StartXfer_1: (+1)
   \   00000048   0x0CED             LSRS     R5,R5,#+19
   \   0000004A   0x04ED             LSLS     R5,R5,#+19
   \   0000004C   0x6125             STR      R5,[R4, #+16]
    708                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
   \   0000004E   0x780C             LDRB     R4,[R1, #+0]
   \   00000050   0xEB00 0x1444      ADD      R4,R0,R4, LSL #+5
   \   00000054   0xF504 0x6410      ADD      R4,R4,#+2304
   \   00000058   0x6925             LDR      R5,[R4, #+16]
   \   0000005A   0x402B             ANDS     R3,R3,R5
   \   0000005C   0x6123             STR      R3,[R4, #+16]
    709                
    710                if(ep->xfer_len > ep->maxpacket)
   \   0000005E   0x688B             LDR      R3,[R1, #+8]
   \   00000060   0x694C             LDR      R4,[R1, #+20]
   \   00000062   0x42A3             CMP      R3,R4
   \   00000064   0xD900             BLS.N    ??USB_EP0StartXfer_3
   \   00000066   0x4623             MOV      R3,R4
   \                     ??USB_EP0StartXfer_3: (+1)
   \   00000068   0x614B             STR      R3,[R1, #+20]
    711                {
    712                  ep->xfer_len = ep->maxpacket;
    713                }
    714                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
   \   0000006A   0x780B             LDRB     R3,[R1, #+0]
   \   0000006C   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   00000070   0xF503 0x6310      ADD      R3,R3,#+2304
   \   00000074   0x691C             LDR      R4,[R3, #+16]
   \   00000076   0xF444 0x2400      ORR      R4,R4,#0x80000
   \   0000007A   0x611C             STR      R4,[R3, #+16]
    715                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
   \   0000007C   0x780B             LDRB     R3,[R1, #+0]
   \   0000007E   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   00000082   0xF503 0x6310      ADD      R3,R3,#+2304
   \   00000086   0x691C             LDR      R4,[R3, #+16]
   \   00000088   0x694D             LDR      R5,[R1, #+20]
   \   0000008A   0x036D             LSLS     R5,R5,#+13
   \   0000008C   0xEA54 0x3455      ORRS     R4,R4,R5, LSR #+13
   \   00000090   0x611C             STR      R4,[R3, #+16]
    716              
    717              }
    718              
    719              if (dma == 1)
   \                     ??USB_EP0StartXfer_2: (+1)
   \   00000092   0x2A01             CMP      R2,#+1
   \   00000094   0xD107             BNE.N    ??USB_EP0StartXfer_4
    720              {
    721                USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
   \   00000096   0x780A             LDRB     R2,[R1, #+0]
   \   00000098   0xEB00 0x1242      ADD      R2,R0,R2, LSL #+5
   \   0000009C   0xF502 0x6210      ADD      R2,R2,#+2304
   \   000000A0   0x690B             LDR      R3,[R1, #+16]
   \   000000A2   0x6153             STR      R3,[R2, #+20]
   \   000000A4   0xE00A             B.N      ??USB_EP0StartXfer_5
    722              }
    723              else
    724              {
    725                /* Enable the Tx FIFO Empty Interrupt for this EP */
    726                if (ep->xfer_len > 0U)
   \                     ??USB_EP0StartXfer_4: (+1)
   \   000000A6   0x694A             LDR      R2,[R1, #+20]
   \   000000A8   0x2A00             CMP      R2,#+0
   \   000000AA   0xD007             BEQ.N    ??USB_EP0StartXfer_5
    727                {
    728                  USBx_DEVICE->DIEPEMPMSK |= 1U << (ep->num);
   \   000000AC   0xF500 0x6200      ADD      R2,R0,#+2048
   \   000000B0   0x6B53             LDR      R3,[R2, #+52]
   \   000000B2   0x2401             MOVS     R4,#+1
   \   000000B4   0x780D             LDRB     R5,[R1, #+0]
   \   000000B6   0x40AC             LSLS     R4,R4,R5
   \   000000B8   0x4323             ORRS     R3,R4,R3
   \   000000BA   0x6353             STR      R3,[R2, #+52]
    729                }
    730              }
    731              
    732              /* EP enable, IN data in FIFO */
    733              USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);   
   \                     ??USB_EP0StartXfer_5: (+1)
   \   000000BC   0x7809             LDRB     R1,[R1, #+0]
   \   000000BE   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   000000C2   0xF500 0x6010      ADD      R0,R0,#+2304
   \   000000C6   0x6801             LDR      R1,[R0, #+0]
   \   000000C8   0xF041 0x4104      ORR      R1,R1,#0x84000000
   \   000000CC   0x6001             STR      R1,[R0, #+0]
   \   000000CE   0xE038             B.N      ??USB_EP0StartXfer_6
    734            }
   \                     ??USB_EP0StartXfer_0: (+1)
   \   000000D0   0xF504 0x6430      ADD      R4,R4,#+2816
   \   000000D4   0x6925             LDR      R5,[R4, #+16]
   \   000000D6   0x0CED             LSRS     R5,R5,#+19
   \   000000D8   0x04ED             LSLS     R5,R5,#+19
   \   000000DA   0x6125             STR      R5,[R4, #+16]
    735            else /* OUT endpoint */
    736            {
    737              /* Program the transfer size and packet count as follows:
    738              * pktcnt = N
    739              * xfersize = N * maxpacket
    740              */
    741              USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
    742              USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
   \   000000DC   0x780C             LDRB     R4,[R1, #+0]
   \   000000DE   0xEB00 0x1444      ADD      R4,R0,R4, LSL #+5
   \   000000E2   0xF504 0x6430      ADD      R4,R4,#+2816
   \   000000E6   0x6925             LDR      R5,[R4, #+16]
   \   000000E8   0x402B             ANDS     R3,R3,R5
   \   000000EA   0x6123             STR      R3,[R4, #+16]
    743                
    744              if (ep->xfer_len > 0U)
   \   000000EC   0x694B             LDR      R3,[R1, #+20]
   \   000000EE   0x2B00             CMP      R3,#+0
   \   000000F0   0xD001             BEQ.N    ??USB_EP0StartXfer_7
    745              {
    746                ep->xfer_len = ep->maxpacket;
   \   000000F2   0x688B             LDR      R3,[R1, #+8]
   \   000000F4   0x614B             STR      R3,[R1, #+20]
    747              }
    748              
    749              USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
   \                     ??USB_EP0StartXfer_7: (+1)
   \   000000F6   0x780B             LDRB     R3,[R1, #+0]
   \   000000F8   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   000000FC   0xF503 0x6330      ADD      R3,R3,#+2816
   \   00000100   0x691C             LDR      R4,[R3, #+16]
   \   00000102   0xF444 0x2400      ORR      R4,R4,#0x80000
   \   00000106   0x611C             STR      R4,[R3, #+16]
    750              USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
   \   00000108   0x780B             LDRB     R3,[R1, #+0]
   \   0000010A   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   0000010E   0xF503 0x6330      ADD      R3,R3,#+2816
   \   00000112   0x691C             LDR      R4,[R3, #+16]
   \   00000114   0x688D             LDR      R5,[R1, #+8]
   \   00000116   0x036D             LSLS     R5,R5,#+13
   \   00000118   0xEA54 0x3455      ORRS     R4,R4,R5, LSR #+13
   \   0000011C   0x611C             STR      R4,[R3, #+16]
    751              
    752          
    753              if (dma == 1U)
   \   0000011E   0x2A01             CMP      R2,#+1
   \   00000120   0xD106             BNE.N    ??USB_EP0StartXfer_8
    754              {
    755                USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
   \   00000122   0x780A             LDRB     R2,[R1, #+0]
   \   00000124   0xEB00 0x1242      ADD      R2,R0,R2, LSL #+5
   \   00000128   0xF502 0x6230      ADD      R2,R2,#+2816
   \   0000012C   0x68CB             LDR      R3,[R1, #+12]
   \   0000012E   0x6153             STR      R3,[R2, #+20]
    756              }
    757              
    758              /* EP enable */
    759              USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
   \                     ??USB_EP0StartXfer_8: (+1)
   \   00000130   0x7809             LDRB     R1,[R1, #+0]
   \   00000132   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000136   0xF500 0x6030      ADD      R0,R0,#+2816
   \   0000013A   0x6801             LDR      R1,[R0, #+0]
   \   0000013C   0xF041 0x4104      ORR      R1,R1,#0x84000000
   \   00000140   0x6001             STR      R1,[R0, #+0]
    760            }
    761            return HAL_OK;
   \                     ??USB_EP0StartXfer_6: (+1)
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0xBC30             POP      {R4,R5}
   \   00000146   0x4770             BX       LR               ;; return
    762          }
    763          
    764          /**
    765            * @brief  USB_WritePacket : Writes a packet into the Tx FIFO associated 
    766            *         with the EP/channel
    767            * @param  USBx : Selected device           
    768            * @param  src :  pointer to source buffer
    769            * @param  ch_ep_num : endpoint or host channel number
    770            * @param  len : Number of bytes to write
    771            * @param  dma: USB dma enabled or disabled 
    772            *          This parameter can be one of these values:
    773            *           0 : DMA feature not used 
    774            *           1 : DMA feature used  
    775            * @retval HAL status
    776            */

   \                                 In section .text, align 2, keep-with-next
    777          HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
    778          {
   \                     USB_WritePacket: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    779            uint32_t count32b = 0U , i = 0U;
   \   00000002   0x2500             MOVS     R5,#+0
    780            
    781            if (dma == 0U)
   \   00000004   0x9C03             LDR      R4,[SP, #+12]
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD10C             BNE.N    ??USB_WritePacket_0
    782            {
    783              count32b =  (len + 3U) / 4U;
   \   0000000A   0x1CDB             ADDS     R3,R3,#+3
    784              for (i = 0U; i < count32b; i++, src += 4U)
   \   0000000C   0xE007             B.N      ??USB_WritePacket_1
    785              {
    786                USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
   \                     ??USB_WritePacket_2: (+1)
   \   0000000E   0xF851 0x4B04      LDR      R4,[R1], #+4
   \   00000012   0xEB00 0x3602      ADD      R6,R0,R2, LSL #+12
   \   00000016   0xF506 0x5680      ADD      R6,R6,#+4096
   \   0000001A   0x6034             STR      R4,[R6, #+0]
    787              }
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??USB_WritePacket_1: (+1)
   \   0000001E   0xEBB5 0x0F93      CMP      R5,R3, LSR #+2
   \   00000022   0xD3F4             BCC.N    ??USB_WritePacket_2
    788            }
    789            return HAL_OK;
   \                     ??USB_WritePacket_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBC70             POP      {R4-R6}
   \   00000028   0x4770             BX       LR               ;; return
    790          }
    791          
    792          /**
    793            * @brief  USB_ReadPacket : read a packet from the Tx FIFO associated 
    794            *         with the EP/channel
    795            * @param  USBx : Selected device  
    796            * @param  src : source pointer
    797            * @param  ch_ep_num : endpoint or host channel number
    798            * @param  len : Number of bytes to read
    799            * @param  dma: USB dma enabled or disabled 
    800            *          This parameter can be one of these values:
    801            *           0 : DMA feature not used 
    802            *           1 : DMA feature used  
    803            * @retval pointer to destination buffer
    804            */

   \                                 In section .text, align 2, keep-with-next
    805          void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
    806          {
   \                     USB_ReadPacket: (+1)
   \   00000000   0xB410             PUSH     {R4}
    807            uint32_t i=0U;
   \   00000002   0x2300             MOVS     R3,#+0
    808            uint32_t count32b = (len + 3U) / 4U;
   \   00000004   0x1CD2             ADDS     R2,R2,#+3
    809            
    810            for ( i = 0U; i < count32b; i++, dest += 4U )
   \   00000006   0xE005             B.N      ??USB_ReadPacket_0
    811            {
    812              *(__packed uint32_t *)dest = USBx_DFIFO(0U);
   \                     ??USB_ReadPacket_1: (+1)
   \   00000008   0xF500 0x5480      ADD      R4,R0,#+4096
   \   0000000C   0x6824             LDR      R4,[R4, #+0]
   \   0000000E   0xF841 0x4B04      STR      R4,[R1], #+4
    813              
    814            }
   \   00000012   0x1C5B             ADDS     R3,R3,#+1
   \                     ??USB_ReadPacket_0: (+1)
   \   00000014   0xEBB3 0x0F92      CMP      R3,R2, LSR #+2
   \   00000018   0xD3F6             BCC.N    ??USB_ReadPacket_1
    815            return ((void *)dest);
   \   0000001A   0x4608             MOV      R0,R1
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
    816          }
    817          
    818          /**
    819            * @brief  USB_EPSetStall : set a stall condition over an EP
    820            * @param  USBx : Selected device
    821            * @param  ep: pointer to endpoint structure   
    822            * @retval HAL status
    823            */

   \                                 In section .text, align 2, keep-with-next
    824          HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
    825          {
    826            if (ep->is_in == 1U)
   \                     USB_EPSetStall: (+1)
   \   00000000   0x780A             LDRB     R2,[R1, #+0]
   \   00000002   0xEB00 0x1242      ADD      R2,R0,R2, LSL #+5
   \   00000006   0x784B             LDRB     R3,[R1, #+1]
   \   00000008   0x2B01             CMP      R3,#+1
   \   0000000A   0xD112             BNE.N    ??USB_EPSetStall_0
   \   0000000C   0xF502 0x6210      ADD      R2,R2,#+2304
   \   00000010   0x6813             LDR      R3,[R2, #+0]
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD403             BMI.N    ??USB_EPSetStall_1
    827            {
    828              if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0U)
    829              {
    830                USBx_INEP(ep->num)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS); 
   \   00000016   0x6813             LDR      R3,[R2, #+0]
   \   00000018   0xF023 0x4380      BIC      R3,R3,#0x40000000
   \   0000001C   0x6013             STR      R3,[R2, #+0]
    831              } 
    832              USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
   \                     ??USB_EPSetStall_1: (+1)
   \   0000001E   0x7809             LDRB     R1,[R1, #+0]
   \   00000020   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000024   0xF500 0x6010      ADD      R0,R0,#+2304
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0xF441 0x1100      ORR      R1,R1,#0x200000
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   \   00000030   0xE011             B.N      ??USB_EPSetStall_2
    833            }
   \                     ??USB_EPSetStall_0: (+1)
   \   00000032   0xF502 0x6230      ADD      R2,R2,#+2816
   \   00000036   0x6813             LDR      R3,[R2, #+0]
   \   00000038   0x2B00             CMP      R3,#+0
   \   0000003A   0xD403             BMI.N    ??USB_EPSetStall_3
    834            else
    835            {
    836              if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0U)
    837              {
    838                USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); 
   \   0000003C   0x6813             LDR      R3,[R2, #+0]
   \   0000003E   0xF023 0x4380      BIC      R3,R3,#0x40000000
   \   00000042   0x6013             STR      R3,[R2, #+0]
    839              } 
    840              USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
   \                     ??USB_EPSetStall_3: (+1)
   \   00000044   0x7809             LDRB     R1,[R1, #+0]
   \   00000046   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   0000004A   0xF500 0x6030      ADD      R0,R0,#+2816
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0xF441 0x1100      ORR      R1,R1,#0x200000
   \   00000054   0x6001             STR      R1,[R0, #+0]
    841            }
    842            return HAL_OK;
   \                     ??USB_EPSetStall_2: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x4770             BX       LR               ;; return
    843          }
    844          
    845          
    846          /**
    847            * @brief  USB_EPClearStall : Clear a stall condition over an EP
    848            * @param  USBx : Selected device
    849            * @param  ep: pointer to endpoint structure   
    850            * @retval HAL status
    851            */

   \                                 In section .text, align 2, keep-with-next
    852          HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    853          {
    854            if (ep->is_in == 1U)
   \                     USB_EPClearStall: (+1)
   \   00000000   0x780A             LDRB     R2,[R1, #+0]
   \   00000002   0xEB00 0x1242      ADD      R2,R0,R2, LSL #+5
   \   00000006   0x784B             LDRB     R3,[R1, #+1]
   \   00000008   0x2B01             CMP      R3,#+1
   \   0000000A   0xD114             BNE.N    ??USB_EPClearStall_0
   \   0000000C   0xF502 0x6210      ADD      R2,R2,#+2304
   \   00000010   0x6813             LDR      R3,[R2, #+0]
   \   00000012   0xF423 0x1300      BIC      R3,R3,#0x200000
   \   00000016   0x6013             STR      R3,[R2, #+0]
    855            {
    856              USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
    857              if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
   \   00000018   0x78CA             LDRB     R2,[R1, #+3]
   \   0000001A   0x2A03             CMP      R2,#+3
   \   0000001C   0xD001             BEQ.N    ??USB_EPClearStall_1
   \   0000001E   0x2A02             CMP      R2,#+2
   \   00000020   0xD11D             BNE.N    ??USB_EPClearStall_2
    858              {
    859                 USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
   \                     ??USB_EPClearStall_1: (+1)
   \   00000022   0x7809             LDRB     R1,[R1, #+0]
   \   00000024   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000028   0xF500 0x6010      ADD      R0,R0,#+2304
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \   00000032   0x6001             STR      R1,[R0, #+0]
   \   00000034   0xE013             B.N      ??USB_EPClearStall_2
    860              }    
    861            }
   \                     ??USB_EPClearStall_0: (+1)
   \   00000036   0xF502 0x6230      ADD      R2,R2,#+2816
   \   0000003A   0x6813             LDR      R3,[R2, #+0]
   \   0000003C   0xF423 0x1300      BIC      R3,R3,#0x200000
   \   00000040   0x6013             STR      R3,[R2, #+0]
    862            else
    863            {
    864              USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
    865              if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
   \   00000042   0x78CA             LDRB     R2,[R1, #+3]
   \   00000044   0x2A03             CMP      R2,#+3
   \   00000046   0xD001             BEQ.N    ??USB_EPClearStall_3
   \   00000048   0x2A02             CMP      R2,#+2
   \   0000004A   0xD108             BNE.N    ??USB_EPClearStall_2
    866              {
    867                USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
   \                     ??USB_EPClearStall_3: (+1)
   \   0000004C   0x7809             LDRB     R1,[R1, #+0]
   \   0000004E   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000052   0xF500 0x6030      ADD      R0,R0,#+2816
   \   00000056   0x6801             LDR      R1,[R0, #+0]
   \   00000058   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \   0000005C   0x6001             STR      R1,[R0, #+0]
    868              }    
    869            }
    870            return HAL_OK;
   \                     ??USB_EPClearStall_2: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x4770             BX       LR               ;; return
    871          }
    872          
    873          /**
    874            * @brief  USB_StopDevice : Stop the usb device mode
    875            * @param  USBx : Selected device
    876            * @retval HAL status
    877            */

   \                                 In section .text, align 2, keep-with-next
    878          HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)
    879          {
   \                     USB_StopDevice: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    880            uint32_t i;
    881            
    882            /* Clear Pending interrupt */
    883            for (i = 0U; i < 15U ; i++)
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x22FF             MOVS     R2,#+255
   \   00000008   0xE008             B.N      ??USB_StopDevice_0
    884            {
    885              USBx_INEP(i)->DIEPINT  = 0xFFU;
   \                     ??USB_StopDevice_1: (+1)
   \   0000000A   0xEB01 0x1140      ADD      R1,R1,R0, LSL #+5
   \   0000000E   0xF501 0x6310      ADD      R3,R1,#+2304
   \   00000012   0x609A             STR      R2,[R3, #+8]
    886              USBx_OUTEP(i)->DOEPINT  = 0xFFU;
   \   00000014   0xF501 0x6130      ADD      R1,R1,#+2816
   \   00000018   0x608A             STR      R2,[R1, #+8]
    887            }
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \                     ??USB_StopDevice_0: (+1)
   \   0000001C   0x4621             MOV      R1,R4
   \   0000001E   0x280F             CMP      R0,#+15
   \   00000020   0xD3F3             BCC.N    ??USB_StopDevice_1
    888            USBx_DEVICE->DAINT = 0xFFFFFFFFU;
   \   00000022   0xF501 0x6000      ADD      R0,R1,#+2048
   \   00000026   0xF04F 0x31FF      MOV      R1,#-1
   \   0000002A   0x6181             STR      R1,[R0, #+24]
    889            
    890            /* Clear interrupt masks */
    891            USBx_DEVICE->DIEPMSK  = 0U;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6101             STR      R1,[R0, #+16]
    892            USBx_DEVICE->DOEPMSK  = 0U;
   \   00000030   0x6141             STR      R1,[R0, #+20]
    893            USBx_DEVICE->DAINTMSK = 0U;
   \   00000032   0x61C1             STR      R1,[R0, #+28]
    894            
    895            /* Flush the FIFO */
    896            USB_FlushRxFifo(USBx);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       USB_FlushRxFifo
    897            USB_FlushTxFifo(USBx ,  0x10U);  
   \   0000003A   0x2110             MOVS     R1,#+16
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       USB_FlushTxFifo
    898            
    899            return HAL_OK;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    900          }
    901          
    902          /**
    903            * @brief  USB_SetDevAddress : Stop the usb device mode
    904            * @param  USBx : Selected device
    905            * @param  address : new device address to be assigned
    906            *          This parameter can be a value from 0 to 255
    907            * @retval HAL status
    908            */

   \                                 In section .text, align 2, keep-with-next
    909          HAL_StatusTypeDef  USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address)
    910          {
    911            USBx_DEVICE->DCFG &= ~ (USB_OTG_DCFG_DAD);
   \                     USB_SetDevAddress: (+1)
   \   00000000   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0xF422 0x62FE      BIC      R2,R2,#0x7F0
   \   0000000A   0x6002             STR      R2,[R0, #+0]
    912            USBx_DEVICE->DCFG |= (address << 4U) & USB_OTG_DCFG_DAD ;
   \   0000000C   0x6802             LDR      R2,[R0, #+0]
   \   0000000E   0x0109             LSLS     R1,R1,#+4
   \   00000010   0xF401 0x61FE      AND      R1,R1,#0x7F0
   \   00000014   0x4311             ORRS     R1,R1,R2
   \   00000016   0x6001             STR      R1,[R0, #+0]
    913            
    914            return HAL_OK;  
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    915          }
    916          
    917          /**
    918            * @brief  USB_DevConnect : Connect the USB device by enabling the pull-up/pull-down
    919            * @param  USBx : Selected device
    920            * @retval HAL status
    921            */

   \                                 In section .text, align 2, keep-with-next
    922          HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
    923          {
   \                     USB_DevConnect: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    924            USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ;
   \   00000002   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    925            HAL_Delay(3U);
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x.... 0x....      BL       HAL_Delay
    926            
    927            return HAL_OK;  
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    928          }
    929          
    930          /**
    931            * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
    932            * @param  USBx : Selected device
    933            * @retval HAL status
    934            */

   \                                 In section .text, align 2, keep-with-next
    935          HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
    936          {
   \                     USB_DevDisconnect: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    937            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
   \   00000002   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    938            HAL_Delay(3U);
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x.... 0x....      BL       HAL_Delay
    939            
    940            return HAL_OK;  
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    941          }
    942          
    943          /**
    944            * @brief  USB_ReadInterrupts: return the global USB interrupt status
    945            * @param  USBx : Selected device
    946            * @retval HAL status
    947            */

   \                                 In section .text, align 2, keep-with-next
    948          uint32_t  USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx)
    949          {
    950            uint32_t v = 0U;
    951            
    952            v = USBx->GINTSTS;
   \                     USB_ReadInterrupts: (+1)
   \   00000000   0x6941             LDR      R1,[R0, #+20]
    953            v &= USBx->GINTMSK;
   \   00000002   0x6980             LDR      R0,[R0, #+24]
   \   00000004   0x4008             ANDS     R0,R0,R1
    954            return v;  
   \   00000006   0x4770             BX       LR               ;; return
    955          }
    956          
    957          /**
    958            * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
    959            * @param  USBx : Selected device
    960            * @retval HAL status
    961            */

   \                                 In section .text, align 2, keep-with-next
    962          uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
    963          {
    964            uint32_t v;
    965            v  = USBx_DEVICE->DAINT;
   \                     USB_ReadDevAllOutEpInterrupt: (+1)
   \   00000000   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000004   0x6981             LDR      R1,[R0, #+24]
    966            v &= USBx_DEVICE->DAINTMSK;
   \   00000006   0x69C0             LDR      R0,[R0, #+28]
   \   00000008   0x4008             ANDS     R0,R0,R1
    967            return ((v & 0xffff0000U) >> 16U);
   \   0000000A   0x0C00             LSRS     R0,R0,#+16
   \   0000000C   0x4770             BX       LR               ;; return
    968          }
    969          
    970          /**
    971            * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
    972            * @param  USBx : Selected device
    973            * @retval HAL status
    974            */

   \                                 In section .text, align 2, keep-with-next
    975          uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
    976          {
    977            uint32_t v;
    978            v  = USBx_DEVICE->DAINT;
   \                     USB_ReadDevAllInEpInterrupt: (+1)
   \   00000000   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000004   0x6981             LDR      R1,[R0, #+24]
    979            v &= USBx_DEVICE->DAINTMSK;
   \   00000006   0x69C0             LDR      R0,[R0, #+28]
   \   00000008   0x4008             ANDS     R0,R0,R1
    980            return ((v & 0xFFFFU));
   \   0000000A   0xB280             UXTH     R0,R0
   \   0000000C   0x4770             BX       LR               ;; return
    981          }
    982          
    983          /**
    984            * @brief  Returns Device OUT EP Interrupt register
    985            * @param  USBx : Selected device
    986            * @param  epnum : endpoint number
    987            *          This parameter can be a value from 0 to 15
    988            * @retval Device OUT EP Interrupt register
    989            */

   \                                 In section .text, align 2, keep-with-next
    990          uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
    991          {
    992            uint32_t v;
    993            v  = USBx_OUTEP(epnum)->DOEPINT;
   \                     USB_ReadDevOutEPInterrupt: (+1)
   \   00000000   0xEB00 0x1141      ADD      R1,R0,R1, LSL #+5
   \   00000004   0xF501 0x6130      ADD      R1,R1,#+2816
   \   00000008   0x6889             LDR      R1,[R1, #+8]
    994            v &= USBx_DEVICE->DOEPMSK;
   \   0000000A   0xF500 0x6000      ADD      R0,R0,#+2048
   \   0000000E   0x6940             LDR      R0,[R0, #+20]
   \   00000010   0x4008             ANDS     R0,R0,R1
    995            return v;
   \   00000012   0x4770             BX       LR               ;; return
    996          }
    997          
    998          /**
    999            * @brief  Returns Device IN EP Interrupt register
   1000            * @param  USBx : Selected device
   1001            * @param  epnum : endpoint number
   1002            *          This parameter can be a value from 0 to 15
   1003            * @retval Device IN EP Interrupt register
   1004            */

   \                                 In section .text, align 2, keep-with-next
   1005          uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
   1006          {
   1007            uint32_t v, msk, emp;
   1008            
   1009            msk = USBx_DEVICE->DIEPMSK;
   \                     USB_ReadDevInEPInterrupt: (+1)
   \   00000000   0xF500 0x6200      ADD      R2,R0,#+2048
   \   00000004   0x6913             LDR      R3,[R2, #+16]
   1010            emp = USBx_DEVICE->DIEPEMPMSK;
   \   00000006   0x6B52             LDR      R2,[R2, #+52]
   1011            msk |= ((emp >> epnum) & 0x1U) << 7U;
   1012            v = USBx_INEP(epnum)->DIEPINT & msk;
   \   00000008   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   0000000C   0xF500 0x6010      ADD      R0,R0,#+2304
   \   00000010   0x6880             LDR      R0,[R0, #+8]
   \   00000012   0xFA22 0xF101      LSR      R1,R2,R1
   \   00000016   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000001A   0xEA43 0x11C1      ORR      R1,R3,R1, LSL #+7
   \   0000001E   0x4008             ANDS     R0,R1,R0
   1013            return v;
   \   00000020   0x4770             BX       LR               ;; return
   1014          }
   1015          
   1016          /**
   1017            * @brief  USB_ClearInterrupts: clear a USB interrupt
   1018            * @param  USBx : Selected device
   1019            * @param  interrupt : interrupt flag
   1020            * @retval None
   1021            */

   \                                 In section .text, align 2, keep-with-next
   1022          void  USB_ClearInterrupts (USB_OTG_GlobalTypeDef *USBx, uint32_t interrupt)
   1023          {
   1024            USBx->GINTSTS |= interrupt; 
   \                     USB_ClearInterrupts: (+1)
   \   00000000   0x6942             LDR      R2,[R0, #+20]
   \   00000002   0x4311             ORRS     R1,R1,R2
   \   00000004   0x6141             STR      R1,[R0, #+20]
   1025          }
   \   00000006   0x4770             BX       LR               ;; return
   1026          
   1027          /**
   1028            * @brief  Returns USB core mode
   1029            * @param  USBx : Selected device
   1030            * @retval return core mode : Host or Device
   1031            *          This parameter can be one of these values:
   1032            *           0 : Host 
   1033            *           1 : Device
   1034            */

   \                                 In section .text, align 2, keep-with-next
   1035          uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
   1036          {
   1037            return ((USBx->GINTSTS ) & 0x1U);
   \                     USB_GetMode: (+1)
   \   00000000   0x6940             LDR      R0,[R0, #+20]
   \   00000002   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000006   0x4770             BX       LR               ;; return
   1038          }
   1039          
   1040          
   1041          /**
   1042            * @brief  Activate EP0 for Setup transactions
   1043            * @param  USBx : Selected device
   1044            * @retval HAL status
   1045            */

   \                                 In section .text, align 2, keep-with-next
   1046          HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
   1047          {
   1048            /* Set the MPS of the IN EP based on the enumeration speed */
   1049            USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
   \                     USB_ActivateSetup: (+1)
   \   00000000   0xF500 0x6110      ADD      R1,R0,#+2304
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x0AD2             LSRS     R2,R2,#+11
   \   00000008   0x02D2             LSLS     R2,R2,#+11
   \   0000000A   0x600A             STR      R2,[R1, #+0]
   1050            
   1051            if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
   \   0000000C   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000010   0x6882             LDR      R2,[R0, #+8]
   \   00000012   0xF002 0x0206      AND      R2,R2,#0x6
   \   00000016   0x2A04             CMP      R2,#+4
   \   00000018   0xD103             BNE.N    ??USB_ActivateSetup_0
   1052            {
   1053              USBx_INEP(0U)->DIEPCTL |= 3U;
   \   0000001A   0x680A             LDR      R2,[R1, #+0]
   \   0000001C   0xF042 0x0203      ORR      R2,R2,#0x3
   \   00000020   0x600A             STR      R2,[R1, #+0]
   1054            }
   1055            USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
   \                     ??USB_ActivateSetup_0: (+1)
   \   00000022   0x6841             LDR      R1,[R0, #+4]
   \   00000024   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000028   0x6041             STR      R1,[R0, #+4]
   1056          
   1057            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4770             BX       LR               ;; return
   1058          }
   1059          
   1060          
   1061          /**
   1062            * @brief  Prepare the EP0 to start the first control setup
   1063            * @param  USBx : Selected device
   1064            * @param  dma: USB dma enabled or disabled 
   1065            *          This parameter can be one of these values:
   1066            *           0 : DMA feature not used 
   1067            *           1 : DMA feature used  
   1068            * @param  psetup : pointer to setup packet
   1069            * @retval HAL status
   1070            */

   \                                 In section .text, align 2, keep-with-next
   1071          HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
   1072          {
   1073            USBx_OUTEP(0U)->DOEPTSIZ = 0U;
   \                     USB_EP0_OutStart: (+1)
   \   00000000   0xF500 0x6030      ADD      R0,R0,#+2816
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x6103             STR      R3,[R0, #+16]
   1074            USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
   \   00000008   0x6903             LDR      R3,[R0, #+16]
   \   0000000A   0xF443 0x2300      ORR      R3,R3,#0x80000
   \   0000000E   0x6103             STR      R3,[R0, #+16]
   1075            USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
   \   00000010   0x6903             LDR      R3,[R0, #+16]
   \   00000012   0xF043 0x0318      ORR      R3,R3,#0x18
   \   00000016   0x6103             STR      R3,[R0, #+16]
   1076            USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
   \   00000018   0x6903             LDR      R3,[R0, #+16]
   \   0000001A   0xF043 0x43C0      ORR      R3,R3,#0x60000000
   \   0000001E   0x6103             STR      R3,[R0, #+16]
   1077            
   1078            if (dma == 1U)
   \   00000020   0x2901             CMP      R1,#+1
   \   00000022   0xD103             BNE.N    ??USB_EP0_OutStart_0
   1079            {
   1080              USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
   \   00000024   0x6142             STR      R2,[R0, #+20]
   1081              /* EP enable */
   1082              USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
   \   00000026   0xF04F 0x2180      MOV      R1,#-2147450880
   \   0000002A   0x6001             STR      R1,[R0, #+0]
   1083            }
   1084            
   1085            return HAL_OK;  
   \                     ??USB_EP0_OutStart_0: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x4770             BX       LR               ;; return
   1086          }
   1087          
   1088          
   1089          /**
   1090            * @brief  Reset the USB Core (needed after USB clock settings change)
   1091            * @param  USBx : Selected device
   1092            * @retval HAL status
   1093            */

   \                                 In section .text, align 2, keep-with-next
   1094          static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
   1095          {
   1096            uint32_t count = 0U;
   \                     USB_CoreReset: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable10_2  ;; 0x30d41
   1097          
   1098            /* Wait for AHB master IDLE state. */
   1099            do
   1100            {
   1101              if (++count > 200000U)
   \                     ??USB_CoreReset_0: (+1)
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0xD20A             BCS.N    ??USB_CoreReset_1
   1102              {
   1103                return HAL_TIMEOUT;
   1104              }
   1105            }
   1106            while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
   \   0000000C   0x6903             LDR      R3,[R0, #+16]
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD5F9             BPL.N    ??USB_CoreReset_0
   1107            
   1108            /* Core Soft Reset */
   1109            count = 0U;
   \   00000012   0x2100             MOVS     R1,#+0
   1110            USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
   \   00000014   0x6903             LDR      R3,[R0, #+16]
   \   00000016   0xF043 0x0301      ORR      R3,R3,#0x1
   \   0000001A   0x6103             STR      R3,[R0, #+16]
   1111          
   1112            do
   1113            {
   1114              if (++count > 200000U)
   \                     ??USB_CoreReset_2: (+1)
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
   \   0000001E   0x4291             CMP      R1,R2
   \   00000020   0xD301             BCC.N    ??USB_CoreReset_3
   1115              {
   1116                return HAL_TIMEOUT;
   \                     ??USB_CoreReset_1: (+1)
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0x4770             BX       LR
   1117              }
   1118            }
   1119            while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
   \                     ??USB_CoreReset_3: (+1)
   \   00000026   0x6903             LDR      R3,[R0, #+16]
   \   00000028   0x07DB             LSLS     R3,R3,#+31
   \   0000002A   0xD4F7             BMI.N    ??USB_CoreReset_2
   1120            
   1121            return HAL_OK;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x4770             BX       LR               ;; return
   1122          }
   1123          
   1124          
   1125          /**
   1126            * @brief  USB_HostInit : Initializes the USB OTG controller registers 
   1127            *         for Host mode 
   1128            * @param  USBx : Selected device
   1129            * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
   1130            *         the configuration information for the specified USBx peripheral.
   1131            * @retval HAL status
   1132            */

   \                                 In section .text, align 2, keep-with-next
   1133          HAL_StatusTypeDef USB_HostInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
   1134          {
   \                     USB_HostInit: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB578             PUSH     {R3-R6,LR}
   \   00000004   0x4604             MOV      R4,R0
   1135            uint32_t i;
   1136            
   1137            /* Restart the Phy Clock */
   1138            USBx_PCGCCTL = 0U;
   \   00000006   0x4625             MOV      R5,R4
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF505 0x6160      ADD      R1,R5,#+3584
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   1139            
   1140            /* Activate VBUS Sensing B */
   1141          #if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || \
   1142              defined(STM32F412Rx) || defined(STM32F412Cx)
   1143            USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
   1144          #else
   1145            USBx->GCCFG &=~ (USB_OTG_GCCFG_VBUSASEN);
   \   00000010   0x6BA0             LDR      R0,[R4, #+56]
   \   00000012   0xF420 0x2080      BIC      R0,R0,#0x40000
   \   00000016   0x63A0             STR      R0,[R4, #+56]
   1146            USBx->GCCFG &=~ (USB_OTG_GCCFG_VBUSBSEN);
   \   00000018   0x6BA0             LDR      R0,[R4, #+56]
   \   0000001A   0xF420 0x2000      BIC      R0,R0,#0x80000
   \   0000001E   0x63A0             STR      R0,[R4, #+56]
   1147            USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
   \   00000020   0x6BA0             LDR      R0,[R4, #+56]
   \   00000022   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   00000026   0x63A0             STR      R0,[R4, #+56]
   1148          #endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx */
   1149          
   1150            /* Disable the FS/LS support mode only */
   1151            if((cfg.speed == USB_OTG_SPEED_FULL)&&
   1152               (USBx != USB_OTG_FS))
   \   00000028   0x9807             LDR      R0,[SP, #+28]
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xD109             BNE.N    ??USB_HostInit_0
   \   0000002E   0xF1B4 0x4FA0      CMP      R4,#+1342177280
   \   00000032   0xD006             BEQ.N    ??USB_HostInit_0
   1153            {
   1154              USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS; 
   \   00000034   0xF505 0x6080      ADD      R0,R5,#+1024
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000003E   0x6001             STR      R1,[R0, #+0]
   \   00000040   0xE005             B.N      ??USB_HostInit_1
   1155            }
   1156            else
   1157            {
   1158              USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);  
   \                     ??USB_HostInit_0: (+1)
   \   00000042   0xF505 0x6080      ADD      R0,R5,#+1024
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0xF021 0x0104      BIC      R1,R1,#0x4
   \   0000004C   0x6001             STR      R1,[R0, #+0]
   1159            }
   1160          
   1161            /* Make sure the FIFOs are flushed. */
   1162            USB_FlushTxFifo(USBx, 0x10U); /* all Tx FIFOs */
   \                     ??USB_HostInit_1: (+1)
   \   0000004E   0x2110             MOVS     R1,#+16
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       USB_FlushTxFifo
   1163            USB_FlushRxFifo(USBx);
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       USB_FlushRxFifo
   1164          
   1165            /* Clear all pending HC Interrupts */
   1166            for (i = 0U; i < cfg.Host_channels; i++)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x4602             MOV      R2,R0
   \   00000060   0xF04F 0x36FF      MOV      R6,#-1
   \   00000064   0xE006             B.N      ??USB_HostInit_2
   1167            {
   1168              USBx_HC(i)->HCINT = 0xFFFFFFFFU;
   \                     ??USB_HostInit_3: (+1)
   \   00000066   0xEB05 0x1140      ADD      R1,R5,R0, LSL #+5
   \   0000006A   0xF501 0x61A0      ADD      R1,R1,#+1280
   \   0000006E   0x608E             STR      R6,[R1, #+8]
   1169              USBx_HC(i)->HCINTMSK = 0U;
   \   00000070   0x60CA             STR      R2,[R1, #+12]
   1170            }
   \   00000072   0x1C40             ADDS     R0,R0,#+1
   \                     ??USB_HostInit_2: (+1)
   \   00000074   0x9906             LDR      R1,[SP, #+24]
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xD3F5             BCC.N    ??USB_HostInit_3
   1171            
   1172            /* Enable VBUS driving */
   1173            USB_DriveVbus(USBx, 1U);
   \   0000007A   0x2101             MOVS     R1,#+1
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       USB_DriveVbus
   1174            
   1175            HAL_Delay(200U);
   \   00000082   0x20C8             MOVS     R0,#+200
   \   00000084   0x.... 0x....      BL       HAL_Delay
   1176            
   1177            /* Disable all interrupts. */
   1178            USBx->GINTMSK = 0U;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x61A0             STR      R0,[R4, #+24]
   1179            
   1180            /* Clear any pending interrupts */
   1181            USBx->GINTSTS = 0xFFFFFFFFU;
   \   0000008C   0x6166             STR      R6,[R4, #+20]
   1182            
   1183            if(USBx == USB_OTG_FS)
   \   0000008E   0xF1B4 0x4FA0      CMP      R4,#+1342177280
   \   00000092   0xD10C             BNE.N    ??USB_HostInit_4
   1184            {
   1185              /* set Rx FIFO size */
   1186              USBx->GRXFSIZ  = (uint32_t )0x80U; 
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable10_7  ;; 0x50000024
   \   00000098   0x2180             MOVS     R1,#+128
   \   0000009A   0x6001             STR      R1,[R0, #+0]
   1187              USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t )(((0x60U << 16U)& USB_OTG_NPTXFD) | 0x80U);
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable10_8  ;; 0x600080
   \   000000A0   0x6041             STR      R1,[R0, #+4]
   1188              USBx->HPTXFSIZ = (uint32_t )(((0x40U << 16U)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable10_9  ;; 0x4000e0
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable10_10  ;; 0x50000100
   \   000000AA   0x6008             STR      R0,[R1, #+0]
   \   000000AC   0xE009             B.N      ??USB_HostInit_5
   1189            }
   1190            else
   1191            {
   1192              /* set Rx FIFO size */
   1193              USBx->GRXFSIZ  = (uint32_t )0x200U; 
   \                     ??USB_HostInit_4: (+1)
   \   000000AE   0xF44F 0x7000      MOV      R0,#+512
   \   000000B2   0x6260             STR      R0,[R4, #+36]
   1194              USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t )(((0x100U << 16U)& USB_OTG_NPTXFD) | 0x200U);
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable10_11  ;; 0x1000200
   \   000000B8   0x62A0             STR      R0,[R4, #+40]
   1195              USBx->HPTXFSIZ = (uint32_t )(((0xE0U << 16U)& USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable10_12  ;; 0xe00300
   \   000000BE   0xF8C4 0x0100      STR      R0,[R4, #+256]
   1196            }
   1197            
   1198            /* Enable the common interrupts */
   1199            if (cfg.dma_enable == DISABLE)
   \                     ??USB_HostInit_5: (+1)
   \   000000C2   0x9808             LDR      R0,[SP, #+32]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD103             BNE.N    ??USB_HostInit_6
   1200            {
   1201              USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
   \   000000C8   0x69A0             LDR      R0,[R4, #+24]
   \   000000CA   0xF040 0x0010      ORR      R0,R0,#0x10
   \   000000CE   0x61A0             STR      R0,[R4, #+24]
   1202            }
   1203            
   1204            /* Enable interrupts matching to the Host mode ONLY */
   1205            USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM |\
   1206                              USB_OTG_GINTMSK_SOFM             |USB_OTG_GINTSTS_DISCINT|\
   1207                              USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);
   \                     ??USB_HostInit_6: (+1)
   \   000000D0   0x69A0             LDR      R0,[R4, #+24]
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable10_13  ;; 0xa3200008
   \   000000D6   0x4308             ORRS     R0,R1,R0
   \   000000D8   0x61A0             STR      R0,[R4, #+24]
   1208          
   1209            return HAL_OK;
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0xBC72             POP      {R1,R4-R6}
   \   000000DE   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
   1210          }
   1211          
   1212          /**
   1213            * @brief  USB_InitFSLSPClkSel : Initializes the FSLSPClkSel field of the 
   1214            *         HCFG register on the PHY type and set the right frame interval
   1215            * @param  USBx : Selected device
   1216            * @param  freq : clock frequency
   1217            *          This parameter can be one of these values:
   1218            *           HCFG_48_MHZ : Full Speed 48 MHz Clock 
   1219            *           HCFG_6_MHZ : Low Speed 6 MHz Clock 
   1220            * @retval HAL status
   1221            */

   \                                 In section .text, align 2, keep-with-next
   1222          HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx , uint8_t freq)
   1223          {
   1224            USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
   \                     USB_InitFSLSPClkSel: (+1)
   \   00000000   0xF500 0x6080      ADD      R0,R0,#+1024
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x0892             LSRS     R2,R2,#+2
   \   00000008   0x0092             LSLS     R2,R2,#+2
   \   0000000A   0x6002             STR      R2,[R0, #+0]
   1225            USBx_HOST->HCFG |= (freq & USB_OTG_HCFG_FSLSPCS);
   \   0000000C   0x6802             LDR      R2,[R0, #+0]
   \   0000000E   0xF001 0x0303      AND      R3,R1,#0x3
   \   00000012   0x431A             ORRS     R2,R3,R2
   \   00000014   0x6002             STR      R2,[R0, #+0]
   1226            
   1227            if (freq ==  HCFG_48_MHZ)
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xD103             BNE.N    ??USB_InitFSLSPClkSel_0
   1228            {
   1229              USBx_HOST->HFIR = (uint32_t)48000U;
   \   0000001A   0xF64B 0x3180      MOVW     R1,#+48000
   \   0000001E   0x6041             STR      R1,[R0, #+4]
   \   00000020   0xE004             B.N      ??USB_InitFSLSPClkSel_1
   1230            }
   1231            else if (freq ==  HCFG_6_MHZ)
   \                     ??USB_InitFSLSPClkSel_0: (+1)
   \   00000022   0x2902             CMP      R1,#+2
   \   00000024   0xD102             BNE.N    ??USB_InitFSLSPClkSel_1
   1232            {
   1233              USBx_HOST->HFIR = (uint32_t)6000U;
   \   00000026   0xF241 0x7170      MOVW     R1,#+6000
   \   0000002A   0x6041             STR      R1,[R0, #+4]
   1234            } 
   1235            return HAL_OK;  
   \                     ??USB_InitFSLSPClkSel_1: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x4770             BX       LR               ;; return
   1236          }
   1237          
   1238          /**
   1239          * @brief  USB_OTG_ResetPort : Reset Host Port
   1240            * @param  USBx : Selected device
   1241            * @retval HAL status
   1242            * @note   (1)The application must wait at least 10 ms
   1243            *   before clearing the reset bit.
   1244            */

   \                                 In section .text, align 2, keep-with-next
   1245          HAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx)
   1246          {
   \                     USB_ResetPort: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1247            __IO uint32_t hprt0;
   1248            
   1249            hprt0 = USBx_HPRT0;
   \   00000004   0xF500 0x6488      ADD      R4,R0,#+1088
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   1250            
   1251            hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\
   1252              USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \   0000000C   0x9800             LDR      R0,[SP, #+0]
   \   0000000E   0xF020 0x002E      BIC      R0,R0,#0x2E
   \   00000012   0x9000             STR      R0,[SP, #+0]
   1253            
   1254            USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);  
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0xF440 0x7080      ORR      R0,R0,#0x100
   \   0000001A   0x6020             STR      R0,[R4, #+0]
   1255            HAL_Delay (10U);                                /* See Note #1 */
   \   0000001C   0x200A             MOVS     R0,#+10
   \   0000001E   0x.... 0x....      BL       HAL_Delay
   1256            USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0); 
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0xF420 0x7080      BIC      R0,R0,#0x100
   \   00000028   0x6020             STR      R0,[R4, #+0]
   1257            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1258          }
   1259          
   1260          /**
   1261            * @brief  USB_DriveVbus : activate or de-activate vbus
   1262            * @param  state : VBUS state
   1263            *          This parameter can be one of these values:
   1264            *           0 : VBUS Active 
   1265            *           1 : VBUS Inactive
   1266            * @retval HAL status
   1267          */

   \                                 In section .text, align 2, keep-with-next
   1268          HAL_StatusTypeDef USB_DriveVbus (USB_OTG_GlobalTypeDef *USBx, uint8_t state)
   1269          {
   \                     USB_DriveVbus: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   1270            __IO uint32_t hprt0;
   1271          
   1272            hprt0 = USBx_HPRT0;
   \   00000002   0xF500 0x6088      ADD      R0,R0,#+1088
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x9200             STR      R2,[SP, #+0]
   1273            hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\
   1274                                   USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \   0000000A   0x9A00             LDR      R2,[SP, #+0]
   \   0000000C   0xF022 0x022E      BIC      R2,R2,#0x2E
   \   00000010   0x9200             STR      R2,[SP, #+0]
   1275            
   1276            if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
   \   00000012   0x9A00             LDR      R2,[SP, #+0]
   \   00000014   0x04D2             LSLS     R2,R2,#+19
   \   00000016   0xD405             BMI.N    ??USB_DriveVbus_0
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD103             BNE.N    ??USB_DriveVbus_0
   1277            {
   1278              USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0); 
   \   0000001C   0x9A00             LDR      R2,[SP, #+0]
   \   0000001E   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   00000022   0x6002             STR      R2,[R0, #+0]
   1279            }
   1280            if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
   \                     ??USB_DriveVbus_0: (+1)
   \   00000024   0x9A00             LDR      R2,[SP, #+0]
   \   00000026   0x04D2             LSLS     R2,R2,#+19
   \   00000028   0xD505             BPL.N    ??USB_DriveVbus_1
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD103             BNE.N    ??USB_DriveVbus_1
   1281            {
   1282              USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0); 
   \   0000002E   0x9900             LDR      R1,[SP, #+0]
   \   00000030   0xF421 0x5180      BIC      R1,R1,#0x1000
   \   00000034   0x6001             STR      R1,[R0, #+0]
   1283            }
   1284            return HAL_OK; 
   \                     ??USB_DriveVbus_1: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xB001             ADD      SP,SP,#+4
   \   0000003A   0x4770             BX       LR               ;; return
   1285          }
   1286          
   1287          /**
   1288            * @brief  Return Host Core speed
   1289            * @param  USBx : Selected device
   1290            * @retval speed : Host speed
   1291            *          This parameter can be one of these values:
   1292            *            @arg USB_OTG_SPEED_HIGH: High speed mode
   1293            *            @arg USB_OTG_SPEED_FULL: Full speed mode
   1294            *            @arg USB_OTG_SPEED_LOW: Low speed mode
   1295            */

   \                                 In section .text, align 2, keep-with-next
   1296          uint32_t USB_GetHostSpeed (USB_OTG_GlobalTypeDef *USBx)
   1297          {
   \                     USB_GetHostSpeed: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   1298            __IO uint32_t hprt0;
   1299            
   1300            hprt0 = USBx_HPRT0;
   \   00000002   0xF500 0x6088      ADD      R0,R0,#+1088
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1301            return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17U);
   \   0000000A   0x9800             LDR      R0,[SP, #+0]
   \   0000000C   0xF3C0 0x4041      UBFX     R0,R0,#+17,#+2
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0x4770             BX       LR               ;; return
   1302          }
   1303          
   1304          /**
   1305            * @brief  Return Host Current Frame number
   1306            * @param  USBx : Selected device
   1307            * @retval current frame number
   1308          */

   \                                 In section .text, align 2, keep-with-next
   1309          uint32_t USB_GetCurrentFrame (USB_OTG_GlobalTypeDef *USBx)
   1310          {
   1311            return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
   \                     USB_GetCurrentFrame: (+1)
   \   00000000   0xF500 0x6080      ADD      R0,R0,#+1024
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0xB280             UXTH     R0,R0
   \   00000008   0x4770             BX       LR               ;; return
   1312          }
   1313          
   1314          /**
   1315            * @brief  Initialize a host channel
   1316            * @param  USBx : Selected device
   1317            * @param  ch_num : Channel number
   1318            *         This parameter can be a value from 1 to 15
   1319            * @param  epnum : Endpoint number
   1320            *          This parameter can be a value from 1 to 15
   1321            * @param  dev_address : Current device address
   1322            *          This parameter can be a value from 0 to 255
   1323            * @param  speed : Current device speed
   1324            *          This parameter can be one of these values:
   1325            *            @arg USB_OTG_SPEED_HIGH: High speed mode
   1326            *            @arg USB_OTG_SPEED_FULL: Full speed mode
   1327            *            @arg USB_OTG_SPEED_LOW: Low speed mode
   1328            * @param  ep_type : Endpoint Type
   1329            *          This parameter can be one of these values:
   1330            *            @arg EP_TYPE_CTRL: Control type
   1331            *            @arg EP_TYPE_ISOC: Isochronous type
   1332            *            @arg EP_TYPE_BULK: Bulk type
   1333            *            @arg EP_TYPE_INTR: Interrupt type
   1334            * @param  mps : Max Packet Size
   1335            *          This parameter can be a value from 0 to32K
   1336            * @retval HAL state
   1337            */

   \                                 In section .text, align 2, keep-with-next
   1338          HAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx,  
   1339                                        uint8_t ch_num,
   1340                                        uint8_t epnum,
   1341                                        uint8_t dev_address,
   1342                                        uint8_t speed,
   1343                                        uint8_t ep_type,
   1344                                        uint16_t mps)
   1345          {
   \                     USB_HC_Init: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   1346              
   1347            /* Clear old interrupt conditions for this host channel. */
   1348            USBx_HC(ch_num)->HCINT = 0xFFFFFFFFU;
   \   00000002   0x4607             MOV      R7,R0
   \   00000004   0xEB07 0x1441      ADD      R4,R7,R1, LSL #+5
   \   00000008   0xF504 0x65A0      ADD      R5,R4,#+1280
   \   0000000C   0xF04F 0x34FF      MOV      R4,#-1
   \   00000010   0x60AC             STR      R4,[R5, #+8]
   \   00000012   0x9C06             LDR      R4,[SP, #+24]
   1349            
   1350            /* Enable channel interrupts required for this transfer. */
   1351            switch (ep_type) 
   \   00000014   0x0026             MOVS     R6,R4
   \   00000016   0xD005             BEQ.N    ??USB_HC_Init_0
   \   00000018   0x2E02             CMP      R6,#+2
   \   0000001A   0xD003             BEQ.N    ??USB_HC_Init_0
   \   0000001C   0xD328             BCC.N    ??USB_HC_Init_1
   \   0000001E   0x2E03             CMP      R6,#+3
   \   00000020   0xD018             BEQ.N    ??USB_HC_Init_2
   \   00000022   0xE032             B.N      ??USB_HC_Init_3
   1352            {
   1353            case EP_TYPE_CTRL:
   1354            case EP_TYPE_BULK:
   1355              
   1356              USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
   1357                                          USB_OTG_HCINTMSK_STALLM |\
   1358                                          USB_OTG_HCINTMSK_TXERRM |\
   1359                                          USB_OTG_HCINTMSK_DTERRM |\
   1360                                          USB_OTG_HCINTMSK_AHBERR |\
   1361                                          USB_OTG_HCINTMSK_NAKM ;
   \                     ??USB_HC_Init_0: (+1)
   \   00000024   0xF240 0x4C9D      MOVW     R12,#+1181
   \   00000028   0xF8C5 0xC00C      STR      R12,[R5, #+12]
   1362           
   1363              if (epnum & 0x80U) 
   \   0000002C   0xEA5F 0x6C02      LSLS     R12,R2,#+24
   \   00000030   0xD506             BPL.N    ??USB_HC_Init_4
   1364              {
   1365                USBx_HC(ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
   \   00000032   0xF8D5 0xC00C      LDR      R12,[R5, #+12]
   \   00000036   0xF44C 0x7C80      ORR      R12,R12,#0x100
   \   0000003A   0xF8C5 0xC00C      STR      R12,[R5, #+12]
   \   0000003E   0xE024             B.N      ??USB_HC_Init_3
   1366              } 
   1367              else 
   1368              {
   1369                if(USBx != USB_OTG_FS)
   \                     ??USB_HC_Init_4: (+1)
   \   00000040   0xF1B0 0x4FA0      CMP      R0,#+1342177280
   \   00000044   0xD021             BEQ.N    ??USB_HC_Init_3
   1370                {
   1371                  USBx_HC(ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
   \   00000046   0xF8D5 0xC00C      LDR      R12,[R5, #+12]
   \   0000004A   0xF04C 0x0C60      ORR      R12,R12,#0x60
   \   0000004E   0xF8C5 0xC00C      STR      R12,[R5, #+12]
   \   00000052   0xE01A             B.N      ??USB_HC_Init_3
   1372                }
   1373              }
   1374              break;
   1375              
   1376            case EP_TYPE_INTR:
   1377              
   1378              USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
   1379                                          USB_OTG_HCINTMSK_STALLM |\
   1380                                          USB_OTG_HCINTMSK_TXERRM |\
   1381                                          USB_OTG_HCINTMSK_DTERRM |\
   1382                                          USB_OTG_HCINTMSK_NAKM   |\
   1383                                          USB_OTG_HCINTMSK_AHBERR |\
   1384                                          USB_OTG_HCINTMSK_FRMORM ;    
   \                     ??USB_HC_Init_2: (+1)
   \   00000054   0xF240 0x6C9D      MOVW     R12,#+1693
   \   00000058   0xF8C5 0xC00C      STR      R12,[R5, #+12]
   1385              
   1386              if (epnum & 0x80U) 
   \   0000005C   0xEA5F 0x6C02      LSLS     R12,R2,#+24
   \   00000060   0xD513             BPL.N    ??USB_HC_Init_3
   1387              {
   1388                USBx_HC(ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
   \   00000062   0xF8D5 0xC00C      LDR      R12,[R5, #+12]
   \   00000066   0xF44C 0x7C80      ORR      R12,R12,#0x100
   \   0000006A   0xF8C5 0xC00C      STR      R12,[R5, #+12]
   \   0000006E   0xE00C             B.N      ??USB_HC_Init_3
   1389              }
   1390              
   1391              break;
   1392            case EP_TYPE_ISOC:
   1393              
   1394              USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
   1395                                          USB_OTG_HCINTMSK_ACKM   |\
   1396                                          USB_OTG_HCINTMSK_AHBERR |\
   1397                                          USB_OTG_HCINTMSK_FRMORM ;   
   \                     ??USB_HC_Init_1: (+1)
   \   00000070   0xF240 0x2C25      MOVW     R12,#+549
   \   00000074   0xF8C5 0xC00C      STR      R12,[R5, #+12]
   1398              
   1399              if (epnum & 0x80U) 
   \   00000078   0xEA5F 0x6C02      LSLS     R12,R2,#+24
   \   0000007C   0xD505             BPL.N    ??USB_HC_Init_3
   1400              {
   1401                USBx_HC(ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);      
   \   0000007E   0xF8D5 0xC00C      LDR      R12,[R5, #+12]
   \   00000082   0xF44C 0x7CC0      ORR      R12,R12,#0x180
   \   00000086   0xF8C5 0xC00C      STR      R12,[R5, #+12]
   1402              }
   1403              break;
   1404            }
   1405            
   1406            /* Enable the top level host channel interrupt. */
   1407            USBx_HOST->HAINTMSK |= (1 << ch_num);
   \                     ??USB_HC_Init_3: (+1)
   \   0000008A   0xF507 0x6780      ADD      R7,R7,#+1024
   \   0000008E   0xF8D7 0xC018      LDR      R12,[R7, #+24]
   \   00000092   0xF04F 0x0E01      MOV      LR,#+1
   \   00000096   0xFA0E 0xF101      LSL      R1,LR,R1
   \   0000009A   0xEA41 0x010C      ORR      R1,R1,R12
   \   0000009E   0x61B9             STR      R1,[R7, #+24]
   1408            
   1409            /* Make sure host channel interrupts are enabled. */
   1410            USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   \   000000A0   0x6981             LDR      R1,[R0, #+24]
   \   000000A2   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   000000A6   0x6181             STR      R1,[R0, #+24]
   1411            
   1412            /* Program the HCCHAR register */
   1413            USBx_HC(ch_num)->HCCHAR = (((dev_address << 22U) & USB_OTG_HCCHAR_DAD)  |\
   1414                                       (((epnum & 0x7FU)<< 11U) & USB_OTG_HCCHAR_EPNUM)|\
   1415                                       ((((epnum & 0x80U) == 0x80U)<< 15U) & USB_OTG_HCCHAR_EPDIR)|\
   1416                                       (((speed == USB_OTG_SPEED_LOW)<< 17U) & USB_OTG_HCCHAR_LSDEV)|\
   1417                                       ((ep_type << 18U) & USB_OTG_HCCHAR_EPTYP)|\
   1418                                       (mps & USB_OTG_HCCHAR_MPSIZ));
   \   000000A8   0x09D0             LSRS     R0,R2,#+7
   \   000000AA   0xF000 0x0101      AND      R1,R0,#0x1
   \   000000AE   0x9805             LDR      R0,[SP, #+20]
   \   000000B0   0x2802             CMP      R0,#+2
   \   000000B2   0xD101             BNE.N    ??USB_HC_Init_5
   \   000000B4   0x4670             MOV      R0,LR
   \   000000B6   0xE000             B.N      ??USB_HC_Init_6
   \                     ??USB_HC_Init_5: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \                     ??USB_HC_Init_6: (+1)
   \   000000BA   0x059B             LSLS     R3,R3,#+22
   \   000000BC   0xF003 0x53FE      AND      R3,R3,#0x1FC00000
   \   000000C0   0x02D2             LSLS     R2,R2,#+11
   \   000000C2   0xF402 0x42F0      AND      R2,R2,#0x7800
   \   000000C6   0x431A             ORRS     R2,R2,R3
   \   000000C8   0xEA42 0x31C1      ORR      R1,R2,R1, LSL #+15
   \   000000CC   0xEA41 0x4040      ORR      R0,R1,R0, LSL #+17
   \   000000D0   0x04A1             LSLS     R1,R4,#+18
   \   000000D2   0xF401 0x2140      AND      R1,R1,#0xC0000
   \   000000D6   0x4301             ORRS     R1,R1,R0
   \   000000D8   0x9807             LDR      R0,[SP, #+28]
   \   000000DA   0x0540             LSLS     R0,R0,#+21
   \   000000DC   0xEA51 0x5050      ORRS     R0,R1,R0, LSR #+21
   \   000000E0   0x6028             STR      R0,[R5, #+0]
   1419              
   1420            if (ep_type == EP_TYPE_INTR)
   \   000000E2   0x2E03             CMP      R6,#+3
   \   000000E4   0xD103             BNE.N    ??USB_HC_Init_7
   1421            {
   1422              USBx_HC(ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM ;
   \   000000E6   0x6828             LDR      R0,[R5, #+0]
   \   000000E8   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \   000000EC   0x6028             STR      R0,[R5, #+0]
   1423            }
   1424          
   1425            return HAL_OK; 
   \                     ??USB_HC_Init_7: (+1)
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xBDF0             POP      {R4-R7,PC}       ;; return
   1426          }
   1427          
   1428          /**
   1429            * @brief  Start a transfer over a host channel
   1430            * @param  USBx : Selected device
   1431            * @param  hc : pointer to host channel structure
   1432            * @param  dma: USB dma enabled or disabled 
   1433            *          This parameter can be one of these values:
   1434            *           0 : DMA feature not used 
   1435            *           1 : DMA feature used  
   1436            * @retval HAL state
   1437            */
   1438          #if defined   (__CC_ARM) /*!< ARM Compiler */
   1439          #pragma O0
   1440          #elif defined (__GNUC__) /*!< GNU Compiler */
   1441          #pragma GCC optimize ("O0")
   1442          #endif /* __CC_ARM */

   \                                 In section .text, align 2, keep-with-next
   1443          HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
   1444          {
   \                     USB_HC_StartXfer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1445            uint8_t  is_oddframe = 0U; 
   1446            uint16_t len_words = 0U;   
   1447            uint16_t num_packets = 0U;
   1448            uint16_t max_hc_pkt_count = 256U;
   1449            uint32_t tmpreg = 0U;
   1450              
   1451            if((USBx != USB_OTG_FS) && (hc->speed == USB_OTG_SPEED_HIGH))
   \   00000002   0x4603             MOV      R3,R0
   \   00000004   0xF1B0 0x4FA0      CMP      R0,#+1342177280
   \   00000008   0xD019             BEQ.N    ??USB_HC_StartXfer_0
   \   0000000A   0x790C             LDRB     R4,[R1, #+4]
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD116             BNE.N    ??USB_HC_StartXfer_0
   1452            {
   1453              if((dma == 0U) && (hc->do_ping == 1U))
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD107             BNE.N    ??USB_HC_StartXfer_1
   \   00000014   0x794C             LDRB     R4,[R1, #+5]
   \   00000016   0x2C01             CMP      R4,#+1
   \   00000018   0xD104             BNE.N    ??USB_HC_StartXfer_1
   1454              {
   1455                USB_DoPing(USBx, hc->ch_num);
   \   0000001A   0x7849             LDRB     R1,[R1, #+1]
   \   0000001C   0x.... 0x....      BL       USB_DoPing
   1456                return HAL_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBDF2             POP      {R1,R4-R7,PC}
   1457              }
   1458              else if(dma == 1U)
   \                     ??USB_HC_StartXfer_1: (+1)
   \   00000024   0x2A01             CMP      R2,#+1
   \   00000026   0xD10A             BNE.N    ??USB_HC_StartXfer_0
   \   00000028   0x784C             LDRB     R4,[R1, #+1]
   \   0000002A   0xEB03 0x1444      ADD      R4,R3,R4, LSL #+5
   \   0000002E   0xF504 0x64A0      ADD      R4,R4,#+1280
   \   00000032   0x68E5             LDR      R5,[R4, #+12]
   \   00000034   0xF025 0x0560      BIC      R5,R5,#0x60
   \   00000038   0x60E5             STR      R5,[R4, #+12]
   1459              {
   1460                USBx_HC(hc->ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
   1461                hc->do_ping = 0U;
   \   0000003A   0x2400             MOVS     R4,#+0
   \   0000003C   0x714C             STRB     R4,[R1, #+5]
   1462              }
   1463            }
   1464            
   1465            /* Compute the expected number of packets associated to the transfer */
   1466            if (hc->xfer_len > 0U)
   \                     ??USB_HC_StartXfer_0: (+1)
   \   0000003E   0x690C             LDR      R4,[R1, #+16]
   \   00000040   0x2C00             CMP      R4,#+0
   \   00000042   0xD00D             BEQ.N    ??USB_HC_StartXfer_2
   1467            {
   1468              num_packets = (hc->xfer_len + hc->max_packet - 1U) / hc->max_packet;
   \   00000044   0x890D             LDRH     R5,[R1, #+8]
   \   00000046   0x192C             ADDS     R4,R5,R4
   \   00000048   0x1E64             SUBS     R4,R4,#+1
   \   0000004A   0xFBB4 0xF4F5      UDIV     R4,R4,R5
   \   0000004E   0xB2A4             UXTH     R4,R4
   1469              
   1470              if (num_packets > max_hc_pkt_count)
   \   00000050   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000054   0xDD05             BLE.N    ??USB_HC_StartXfer_3
   1471              {
   1472                num_packets = max_hc_pkt_count;
   \   00000056   0xF44F 0x7480      MOV      R4,#+256
   1473                hc->xfer_len = num_packets * hc->max_packet;
   \   0000005A   0x022D             LSLS     R5,R5,#+8
   \   0000005C   0x610D             STR      R5,[R1, #+16]
   \   0000005E   0xE000             B.N      ??USB_HC_StartXfer_3
   1474              }
   1475            }
   1476            else
   1477            {
   1478              num_packets = 1U;
   \                     ??USB_HC_StartXfer_2: (+1)
   \   00000060   0x2401             MOVS     R4,#+1
   1479            }
   1480            if (hc->ep_is_in)
   \                     ??USB_HC_StartXfer_3: (+1)
   \   00000062   0x78CD             LDRB     R5,[R1, #+3]
   \   00000064   0x2D00             CMP      R5,#+0
   \   00000066   0xD002             BEQ.N    ??USB_HC_StartXfer_4
   1481            {
   1482              hc->xfer_len = num_packets * hc->max_packet;
   \   00000068   0x890D             LDRH     R5,[R1, #+8]
   \   0000006A   0x4365             MULS     R5,R5,R4
   \   0000006C   0x610D             STR      R5,[R1, #+16]
   1483            }
   1484            
   1485            /* Initialize the HCTSIZn register */
   1486            USBx_HC(hc->ch_num)->HCTSIZ = (((hc->xfer_len) & USB_OTG_HCTSIZ_XFRSIZ)) |\
   1487              ((num_packets << 19U) & USB_OTG_HCTSIZ_PKTCNT) |\
   1488                (((hc->data_pid) << 29U) & USB_OTG_HCTSIZ_DPID);
   \                     ??USB_HC_StartXfer_4: (+1)
   \   0000006E   0x784D             LDRB     R5,[R1, #+1]
   \   00000070   0xEB03 0x1545      ADD      R5,R3,R5, LSL #+5
   \   00000074   0xF505 0x65A0      ADD      R5,R5,#+1280
   \   00000078   0x690E             LDR      R6,[R1, #+16]
   \   0000007A   0x0376             LSLS     R6,R6,#+13
   \   0000007C   0x....             LDR.N    R7,??DataTable10_6  ;; 0x1ff80000
   \   0000007E   0xEA07 0x44C4      AND      R4,R7,R4, LSL #+19
   \   00000082   0xEA54 0x3456      ORRS     R4,R4,R6, LSR #+13
   \   00000086   0x7A8E             LDRB     R6,[R1, #+10]
   \   00000088   0x0776             LSLS     R6,R6,#+29
   \   0000008A   0xF006 0x46C0      AND      R6,R6,#0x60000000
   \   0000008E   0x4334             ORRS     R4,R6,R4
   \   00000090   0x612C             STR      R4,[R5, #+16]
   1489            
   1490            if (dma)
   \   00000092   0x2A00             CMP      R2,#+0
   \   00000094   0xD006             BEQ.N    ??USB_HC_StartXfer_5
   1491            {
   1492              /* xfer_buff MUST be 32-bits aligned */
   1493              USBx_HC(hc->ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
   \   00000096   0x784C             LDRB     R4,[R1, #+1]
   \   00000098   0xEB03 0x1444      ADD      R4,R3,R4, LSL #+5
   \   0000009C   0xF504 0x64A0      ADD      R4,R4,#+1280
   \   000000A0   0x68CD             LDR      R5,[R1, #+12]
   \   000000A2   0x6165             STR      R5,[R4, #+20]
   1494            }
   1495            
   1496            is_oddframe = (USBx_HOST->HFNUM & 0x01U) ? 0U : 1U;
   \                     ??USB_HC_StartXfer_5: (+1)
   \   000000A4   0xF503 0x6480      ADD      R4,R3,#+1024
   \   000000A8   0x68A5             LDR      R5,[R4, #+8]
   \   000000AA   0xF005 0x0501      AND      R5,R5,#0x1
   \   000000AE   0xF085 0x0501      EOR      R5,R5,#0x1
   1497            USBx_HC(hc->ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
   \   000000B2   0x784E             LDRB     R6,[R1, #+1]
   \   000000B4   0xEB03 0x1646      ADD      R6,R3,R6, LSL #+5
   \   000000B8   0xF506 0x66A0      ADD      R6,R6,#+1280
   \   000000BC   0x6837             LDR      R7,[R6, #+0]
   \   000000BE   0xF027 0x5700      BIC      R7,R7,#0x20000000
   \   000000C2   0x6037             STR      R7,[R6, #+0]
   1498            USBx_HC(hc->ch_num)->HCCHAR |= (is_oddframe << 29U);
   \   000000C4   0x784E             LDRB     R6,[R1, #+1]
   \   000000C6   0xEB03 0x1646      ADD      R6,R3,R6, LSL #+5
   \   000000CA   0xF506 0x66A0      ADD      R6,R6,#+1280
   \   000000CE   0x6837             LDR      R7,[R6, #+0]
   \   000000D0   0xEA47 0x7545      ORR      R5,R7,R5, LSL #+29
   \   000000D4   0x6035             STR      R5,[R6, #+0]
   1499            
   1500            /* Set host channel enable */
   1501            tmpreg = USBx_HC(hc->ch_num)->HCCHAR;
   \   000000D6   0x784D             LDRB     R5,[R1, #+1]
   \   000000D8   0xEB03 0x1345      ADD      R3,R3,R5, LSL #+5
   \   000000DC   0xF503 0x63A0      ADD      R3,R3,#+1280
   \   000000E0   0x681D             LDR      R5,[R3, #+0]
   1502            tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   1503            tmpreg |= USB_OTG_HCCHAR_CHENA;
   1504            USBx_HC(hc->ch_num)->HCCHAR = tmpreg;
   \   000000E2   0xF025 0x4580      BIC      R5,R5,#0x40000000
   \   000000E6   0xF045 0x4500      ORR      R5,R5,#0x80000000
   \   000000EA   0x601D             STR      R5,[R3, #+0]
   1505            
   1506            if (dma == 0U) /* Slave mode */
   \   000000EC   0xD12D             BNE.N    ??USB_HC_StartXfer_6
   1507            {  
   1508              if((hc->ep_is_in == 0U) && (hc->xfer_len > 0U))
   \   000000EE   0x78CA             LDRB     R2,[R1, #+3]
   \   000000F0   0x2A00             CMP      R2,#+0
   \   000000F2   0xD12A             BNE.N    ??USB_HC_StartXfer_6
   \   000000F4   0x690A             LDR      R2,[R1, #+16]
   \   000000F6   0x2A00             CMP      R2,#+0
   \   000000F8   0xD027             BEQ.N    ??USB_HC_StartXfer_6
   1509              {
   1510                switch(hc->ep_type) 
   \   000000FA   0x79CB             LDRB     R3,[R1, #+7]
   \   000000FC   0x2B00             CMP      R3,#+0
   \   000000FE   0xD005             BEQ.N    ??USB_HC_StartXfer_7
   \   00000100   0x2B02             CMP      R3,#+2
   \   00000102   0xD003             BEQ.N    ??USB_HC_StartXfer_7
   \   00000104   0xD30E             BCC.N    ??USB_HC_StartXfer_8
   \   00000106   0x2B03             CMP      R3,#+3
   \   00000108   0xD00C             BEQ.N    ??USB_HC_StartXfer_8
   \   0000010A   0xE016             B.N      ??USB_HC_StartXfer_9
   1511                {
   1512                  /* Non periodic transfer */
   1513                case EP_TYPE_CTRL:
   1514                case EP_TYPE_BULK:
   1515                  
   1516                  len_words = (hc->xfer_len + 3U) / 4U;
   1517                  
   1518                  /* check if there is enough space in FIFO space */
   1519                  if(len_words > (USBx->HNPTXSTS & 0xFFFFU))
   \                     ??USB_HC_StartXfer_7: (+1)
   \   0000010C   0x6AC3             LDR      R3,[R0, #+44]
   \   0000010E   0xB29B             UXTH     R3,R3
   \   00000110   0x1CD2             ADDS     R2,R2,#+3
   \   00000112   0x0892             LSRS     R2,R2,#+2
   \   00000114   0xB292             UXTH     R2,R2
   \   00000116   0x4293             CMP      R3,R2
   \   00000118   0xD20F             BCS.N    ??USB_HC_StartXfer_9
   1520                  {
   1521                    /* need to process data in nptxfempty interrupt */
   1522                    USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
   \   0000011A   0x6982             LDR      R2,[R0, #+24]
   \   0000011C   0xF042 0x0220      ORR      R2,R2,#0x20
   \   00000120   0x6182             STR      R2,[R0, #+24]
   \   00000122   0xE00A             B.N      ??USB_HC_StartXfer_9
   1523                  }
   1524                  break;
   1525                  /* Periodic transfer */
   1526                case EP_TYPE_INTR:
   1527                case EP_TYPE_ISOC:
   1528                  len_words = (hc->xfer_len + 3U) / 4U;
   1529                  /* check if there is enough space in FIFO space */
   1530                  if(len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
   \                     ??USB_HC_StartXfer_8: (+1)
   \   00000124   0x6923             LDR      R3,[R4, #+16]
   \   00000126   0xB29B             UXTH     R3,R3
   \   00000128   0x1CD2             ADDS     R2,R2,#+3
   \   0000012A   0x0892             LSRS     R2,R2,#+2
   \   0000012C   0xB292             UXTH     R2,R2
   \   0000012E   0x4293             CMP      R3,R2
   \   00000130   0xD203             BCS.N    ??USB_HC_StartXfer_9
   1531                  {
   1532                    /* need to process data in ptxfempty interrupt */
   1533                    USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;          
   \   00000132   0x6982             LDR      R2,[R0, #+24]
   \   00000134   0xF042 0x6280      ORR      R2,R2,#0x4000000
   \   00000138   0x6182             STR      R2,[R0, #+24]
   1534                  }
   1535                  break;
   1536                  
   1537                default:
   1538                  break;
   1539                }
   1540                
   1541                /* Write packet into the Tx FIFO. */
   1542                USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, hc->xfer_len, 0);
   \                     ??USB_HC_StartXfer_9: (+1)
   \   0000013A   0x2200             MOVS     R2,#+0
   \   0000013C   0x9200             STR      R2,[SP, #+0]
   \   0000013E   0x690B             LDR      R3,[R1, #+16]
   \   00000140   0xB29B             UXTH     R3,R3
   \   00000142   0x784A             LDRB     R2,[R1, #+1]
   \   00000144   0x68C9             LDR      R1,[R1, #+12]
   \   00000146   0x.... 0x....      BL       USB_WritePacket
   1543              }
   1544            }
   1545            
   1546            return HAL_OK;
   \                     ??USB_HC_StartXfer_6: (+1)
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1547          }
   1548          
   1549          /**
   1550            * @brief Read all host channel interrupts status
   1551            * @param  USBx : Selected device
   1552            * @retval HAL state
   1553            */

   \                                 In section .text, align 2, keep-with-next
   1554          uint32_t USB_HC_ReadInterrupt (USB_OTG_GlobalTypeDef *USBx)
   1555          {
   1556            return ((USBx_HOST->HAINT) & 0xFFFFU);
   \                     USB_HC_ReadInterrupt: (+1)
   \   00000000   0xF500 0x6080      ADD      R0,R0,#+1024
   \   00000004   0x6940             LDR      R0,[R0, #+20]
   \   00000006   0xB280             UXTH     R0,R0
   \   00000008   0x4770             BX       LR               ;; return
   1557          }
   1558          
   1559          /**
   1560            * @brief  Halt a host channel
   1561            * @param  USBx : Selected device
   1562            * @param  hc_num : Host Channel number
   1563            *         This parameter can be a value from 1 to 15
   1564            * @retval HAL state
   1565            */

   \                                 In section .text, align 2, keep-with-next
   1566          HAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx , uint8_t hc_num)
   1567          {
   \                     USB_HC_Halt: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1568            uint32_t count = 0U;
   \   00000002   0x2200             MOVS     R2,#+0
   1569            
   1570            /* Check for space in the request queue to issue the halt. */
   1571            if (((((USBx_HC(hc_num)->HCCHAR) & USB_OTG_HCCHAR_EPTYP) >> 18) == HCCHAR_CTRL) || (((((USBx_HC(hc_num)->HCCHAR) & 
   1572            USB_OTG_HCCHAR_EPTYP) >> 18) == HCCHAR_BULK)))
   \   00000004   0x4603             MOV      R3,R0
   \   00000006   0xEB03 0x1141      ADD      R1,R3,R1, LSL #+5
   \   0000000A   0xF501 0x61A0      ADD      R1,R1,#+1280
   \   0000000E   0x680C             LDR      R4,[R1, #+0]
   \   00000010   0xF3C4 0x4481      UBFX     R4,R4,#+18,#+2
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD004             BEQ.N    ??USB_HC_Halt_0
   \   00000018   0x680C             LDR      R4,[R1, #+0]
   \   0000001A   0xF3C4 0x4481      UBFX     R4,R4,#+18,#+2
   \   0000001E   0x2C02             CMP      R4,#+2
   \   00000020   0xD11B             BNE.N    ??USB_HC_Halt_1
   1573            {
   1574              USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
   \                     ??USB_HC_Halt_0: (+1)
   \   00000022   0x680B             LDR      R3,[R1, #+0]
   \   00000024   0xF043 0x4380      ORR      R3,R3,#0x40000000
   \   00000028   0x600B             STR      R3,[R1, #+0]
   1575              
   1576              if ((USBx->HNPTXSTS & 0xFF0000U) == 0U)
   \   0000002A   0x6AC0             LDR      R0,[R0, #+44]
   \   0000002C   0xF410 0x0F7F      TST      R0,#0xFF0000
   \   00000030   0x6808             LDR      R0,[R1, #+0]
   \   00000032   0xD10E             BNE.N    ??USB_HC_Halt_2
   1577              {
   1578                USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   \   00000034   0x0040             LSLS     R0,R0,#+1
   \   00000036   0x0840             LSRS     R0,R0,#+1
   \   00000038   0x6008             STR      R0,[R1, #+0]
   1579                USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;  
   \   0000003A   0x6808             LDR      R0,[R1, #+0]
   \   0000003C   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   00000040   0x6008             STR      R0,[R1, #+0]
   1580                do 
   1581                {
   1582                  if (++count > 1000U) 
   \                     ??USB_HC_Halt_3: (+1)
   \   00000042   0x1C52             ADDS     R2,R2,#+1
   \   00000044   0xF5B2 0x7F7A      CMP      R2,#+1000
   \   00000048   0xD823             BHI.N    ??USB_HC_Halt_4
   1583                  {
   1584                    break;
   1585                  }
   1586                } 
   1587                while ((USBx_HC(hc_num)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);     
   \   0000004A   0x6808             LDR      R0,[R1, #+0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD4F8             BMI.N    ??USB_HC_Halt_3
   \   00000050   0xE01F             B.N      ??USB_HC_Halt_4
   1588              }
   1589              else
   1590              {
   1591                USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; 
   \                     ??USB_HC_Halt_2: (+1)
   \   00000052   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   00000056   0x6008             STR      R0,[R1, #+0]
   \   00000058   0xE01B             B.N      ??USB_HC_Halt_4
   1592              }
   1593            }
   1594            else
   1595            {
   1596              USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
   \                     ??USB_HC_Halt_1: (+1)
   \   0000005A   0x6808             LDR      R0,[R1, #+0]
   \   0000005C   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \   00000060   0x6008             STR      R0,[R1, #+0]
   1597              
   1598              if ((USBx_HOST->HPTXSTS & 0xFFFFU) == 0U)
   \   00000062   0xF503 0x6080      ADD      R0,R3,#+1024
   \   00000066   0x6900             LDR      R0,[R0, #+16]
   \   00000068   0x0400             LSLS     R0,R0,#+16
   \   0000006A   0x6808             LDR      R0,[R1, #+0]
   \   0000006C   0xD10E             BNE.N    ??USB_HC_Halt_5
   1599              {
   1600                USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   \   0000006E   0x0040             LSLS     R0,R0,#+1
   \   00000070   0x0840             LSRS     R0,R0,#+1
   \   00000072   0x6008             STR      R0,[R1, #+0]
   1601                USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;  
   \   00000074   0x6808             LDR      R0,[R1, #+0]
   \   00000076   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   1602                do 
   1603                {
   1604                  if (++count > 1000U) 
   \                     ??USB_HC_Halt_6: (+1)
   \   0000007C   0x1C52             ADDS     R2,R2,#+1
   \   0000007E   0xF5B2 0x7F7A      CMP      R2,#+1000
   \   00000082   0xD806             BHI.N    ??USB_HC_Halt_4
   1605                  {
   1606                    break;
   1607                  }
   1608                } 
   1609                while ((USBx_HC(hc_num)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);     
   \   00000084   0x6808             LDR      R0,[R1, #+0]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD4F8             BMI.N    ??USB_HC_Halt_6
   \   0000008A   0xE002             B.N      ??USB_HC_Halt_4
   1610              }
   1611              else
   1612              {
   1613                 USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; 
   \                     ??USB_HC_Halt_5: (+1)
   \   0000008C   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   00000090   0x6008             STR      R0,[R1, #+0]
   1614              }
   1615            }
   1616            
   1617            return HAL_OK;
   \                     ??USB_HC_Halt_4: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xBC10             POP      {R4}
   \   00000096   0x4770             BX       LR               ;; return
   1618          }
   1619          
   1620          /**
   1621            * @brief  Initiate Do Ping protocol
   1622            * @param  USBx : Selected device
   1623            * @param  hc_num : Host Channel number
   1624            *         This parameter can be a value from 1 to 15
   1625            * @retval HAL state
   1626            */

   \                                 In section .text, align 2, keep-with-next
   1627          HAL_StatusTypeDef USB_DoPing(USB_OTG_GlobalTypeDef *USBx , uint8_t ch_num)
   1628          {
   1629            uint8_t  num_packets = 1U;
   1630            uint32_t tmpreg = 0U;
   1631          
   1632            USBx_HC(ch_num)->HCTSIZ = ((num_packets << 19U) & USB_OTG_HCTSIZ_PKTCNT) |\
   1633                                          USB_OTG_HCTSIZ_DOPING;
   \                     USB_DoPing: (+1)
   \   00000000   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000004   0xF500 0x60A0      ADD      R0,R0,#+1280
   \   00000008   0x....             LDR.N    R1,??DataTable10_14  ;; 0x80080000
   \   0000000A   0x6101             STR      R1,[R0, #+16]
   1634            
   1635            /* Set host channel enable */
   1636            tmpreg = USBx_HC(ch_num)->HCCHAR;
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   1637            tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   1638            tmpreg |= USB_OTG_HCCHAR_CHENA;
   1639            USBx_HC(ch_num)->HCCHAR = tmpreg;
   \   0000000E   0xF021 0x4180      BIC      R1,R1,#0x40000000
   \   00000012   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \   00000016   0x6001             STR      R1,[R0, #+0]
   1640            
   1641            return HAL_OK;  
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
   1642          }
   1643          
   1644          /**
   1645            * @brief  Stop Host Core
   1646            * @param  USBx : Selected device
   1647            * @retval HAL state
   1648            */

   \                                 In section .text, align 2, keep-with-next
   1649          HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
   1650          {
   \                     USB_StopHost: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1651            uint8_t i;
   1652            uint32_t count = 0U;
   \   00000004   0x2500             MOVS     R5,#+0
   1653            uint32_t value;
   1654            
   1655            USB_DisableGlobalInt(USBx);
   \   00000006   0x.... 0x....      BL       USB_DisableGlobalInt
   1656            
   1657              /* Flush FIFO */
   1658            USB_FlushTxFifo(USBx, 0x10U);
   \   0000000A   0x2110             MOVS     R1,#+16
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       USB_FlushTxFifo
   1659            USB_FlushRxFifo(USBx);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       USB_FlushRxFifo
   1660            
   1661            /* Flush out any leftover queued requests. */
   1662            for (i = 0U; i <= 15U; i++)
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0xF06F 0x2380      MVN      R3,#-2147450880
   \   0000001E   0xE009             B.N      ??USB_StopHost_0
   1663            {   
   1664          
   1665              value = USBx_HC(i)->HCCHAR ;
   \                     ??USB_StopHost_1: (+1)
   \   00000020   0xEB01 0x1140      ADD      R1,R1,R0, LSL #+5
   \   00000024   0xF501 0x61A0      ADD      R1,R1,#+1280
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   1666              value |=  USB_OTG_HCCHAR_CHDIS;
   1667              value &= ~USB_OTG_HCCHAR_CHENA;  
   1668              value &= ~USB_OTG_HCCHAR_EPDIR;
   1669              USBx_HC(i)->HCCHAR = value;
   \   0000002A   0x401A             ANDS     R2,R3,R2
   \   0000002C   0xF042 0x4280      ORR      R2,R2,#0x40000000
   \   00000030   0x600A             STR      R2,[R1, #+0]
   1670            }
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \                     ??USB_StopHost_0: (+1)
   \   00000034   0x4621             MOV      R1,R4
   \   00000036   0x2810             CMP      R0,#+16
   \   00000038   0xD3F2             BCC.N    ??USB_StopHost_1
   1671            
   1672            /* Halt all channels to put them into a known state. */  
   1673            for (i = 0U; i <= 15U; i++)
   \   0000003A   0x4628             MOV      R0,R5
   \   0000003C   0xE011             B.N      ??USB_StopHost_2
   1674            {
   1675              value = USBx_HC(i)->HCCHAR ;
   \                     ??USB_StopHost_3: (+1)
   \   0000003E   0xEB01 0x1240      ADD      R2,R1,R0, LSL #+5
   \   00000042   0xF502 0x63A0      ADD      R3,R2,#+1280
   \   00000046   0x681A             LDR      R2,[R3, #+0]
   1676              
   1677              value |= USB_OTG_HCCHAR_CHDIS;
   1678              value |= USB_OTG_HCCHAR_CHENA;  
   1679              value &= ~USB_OTG_HCCHAR_EPDIR;
   1680              
   1681              USBx_HC(i)->HCCHAR = value;
   \   00000048   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   0000004C   0xF042 0x4240      ORR      R2,R2,#0xC0000000
   \   00000050   0x601A             STR      R2,[R3, #+0]
   1682              do 
   1683              {
   1684                if (++count > 1000U) 
   \                     ??USB_StopHost_4: (+1)
   \   00000052   0x1C6D             ADDS     R5,R5,#+1
   \   00000054   0xF5B5 0x7F7A      CMP      R5,#+1000
   \   00000058   0xD802             BHI.N    ??USB_StopHost_5
   1685                {
   1686                  break;
   1687                }
   1688              } 
   1689              while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   \   0000005A   0x681A             LDR      R2,[R3, #+0]
   \   0000005C   0x2A00             CMP      R2,#+0
   \   0000005E   0xD4F8             BMI.N    ??USB_StopHost_4
   1690            }
   \                     ??USB_StopHost_5: (+1)
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \                     ??USB_StopHost_2: (+1)
   \   00000062   0x2810             CMP      R0,#+16
   \   00000064   0xD3EB             BCC.N    ??USB_StopHost_3
   1691          
   1692            /* Clear any pending Host interrupts */  
   1693            USBx_HOST->HAINT = 0xFFFFFFFFU;
   \   00000066   0xF04F 0x30FF      MOV      R0,#-1
   \   0000006A   0xF501 0x6180      ADD      R1,R1,#+1024
   \   0000006E   0x6148             STR      R0,[R1, #+20]
   1694            USBx->GINTSTS = 0xFFFFFFFFU;
   \   00000070   0x6160             STR      R0,[R4, #+20]
   1695            USB_EnableGlobalInt(USBx);
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       USB_EnableGlobalInt
   1696            return HAL_OK;  
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1697          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0xFFBDFFBF         DC32     0xffbdffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x00800100         DC32     0x800100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x803C3800         DC32     0x803c3800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x00030D41         DC32     0x30d41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x10008000         DC32     0x10008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     ??debug

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0xE007FFFF         DC32     0xe007ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x1FF80000         DC32     0x1ff80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x50000024         DC32     0x50000024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x00600080         DC32     0x600080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x004000E0         DC32     0x4000e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x50000100         DC32     0x50000100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x01000200         DC32     0x1000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x00E00300         DC32     0xe00300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0xA3200008         DC32     0xa3200008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x80080000         DC32     0x80080000
   1698          /**
   1699            * @}
   1700            */
   1701          #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx ||
   1702                    STM32F401xC || STM32F401xE || STM32F411xE || STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx ||
   1703                    STM32F412Vx || STM32F412Cx */
   1704          #endif /* defined(HAL_PCD_MODULE_ENABLED) || defined(HAL_HCD_MODULE_ENABLED) */
   1705          
   1706          /**
   1707            * @}
   1708            */
   1709          
   1710          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USB_ActivateDedicatedEndpoint
       4   USB_ActivateEndpoint
       0   USB_ActivateSetup
       0   USB_ClearInterrupts
      24   USB_CoreInit
        24   -> USB_CoreReset
       0   USB_CoreReset
       4   USB_DeactivateDedicatedEndpoint
       8   USB_DeactivateEndpoint
       8   USB_DevConnect
         8   -> HAL_Delay
       8   USB_DevDisconnect
         8   -> HAL_Delay
      40   USB_DevInit
        40   -> USB_FlushRxFifo
        40   -> USB_FlushTxFifo
        40   -> USB_SetDevSpeed
       0   USB_DisableGlobalInt
       0   USB_DoPing
       4   USB_DriveVbus
       8   USB_EP0StartXfer
       0   USB_EP0_OutStart
       0   USB_EPClearStall
       0   USB_EPSetStall
      24   USB_EPStartXfer
        24   -> USB_WritePacket
       0   USB_EnableGlobalInt
       0   USB_FlushRxFifo
       0   USB_FlushTxFifo
       0   USB_GetCurrentFrame
       0   USB_GetDevSpeed
       4   USB_GetHostSpeed
       0   USB_GetMode
       4   USB_HC_Halt
      20   USB_HC_Init
       0   USB_HC_ReadInterrupt
      24   USB_HC_StartXfer
        24   -> USB_DoPing
        24   -> USB_WritePacket
      32   USB_HostInit
        32   -> HAL_Delay
        32   -> USB_DriveVbus
        32   -> USB_FlushRxFifo
        32   -> USB_FlushTxFifo
       0   USB_InitFSLSPClkSel
       0   USB_ReadDevAllInEpInterrupt
       0   USB_ReadDevAllOutEpInterrupt
       0   USB_ReadDevInEPInterrupt
       0   USB_ReadDevOutEPInterrupt
       0   USB_ReadInterrupts
       4   USB_ReadPacket
      16   USB_ResetPort
        16   -> HAL_Delay
       8   USB_SetCurrentMode
         8   -> HAL_Delay
       0   USB_SetDevAddress
       0   USB_SetDevSpeed
       8   USB_StopDevice
         8   -> USB_FlushRxFifo
         8   -> USB_FlushTxFifo
      16   USB_StopHost
        16   -> USB_DisableGlobalInt
        16   -> USB_EnableGlobalInt
        16   -> USB_FlushRxFifo
        16   -> USB_FlushTxFifo
      12   USB_WritePacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable8
     212  USB_ActivateDedicatedEndpoint
     128  USB_ActivateEndpoint
      46  USB_ActivateSetup
       8  USB_ClearInterrupts
     102  USB_CoreInit
      48  USB_CoreReset
      82  USB_DeactivateDedicatedEndpoint
     106  USB_DeactivateEndpoint
      24  USB_DevConnect
      24  USB_DevDisconnect
     316  USB_DevInit
      12  USB_DisableGlobalInt
      28  USB_DoPing
      60  USB_DriveVbus
     328  USB_EP0StartXfer
      48  USB_EP0_OutStart
      98  USB_EPClearStall
      90  USB_EPSetStall
     534  USB_EPStartXfer
      12  USB_EnableGlobalInt
      30  USB_FlushRxFifo
      34  USB_FlushTxFifo
      10  USB_GetCurrentFrame
      54  USB_GetDevSpeed
      20  USB_GetHostSpeed
       8  USB_GetMode
     152  USB_HC_Halt
     242  USB_HC_Init
      10  USB_HC_ReadInterrupt
     334  USB_HC_StartXfer
     226  USB_HostInit
      48  USB_InitFSLSPClkSel
      14  USB_ReadDevAllInEpInterrupt
      14  USB_ReadDevAllOutEpInterrupt
      34  USB_ReadDevInEPInterrupt
      20  USB_ReadDevOutEPInterrupt
       8  USB_ReadInterrupts
      32  USB_ReadPacket
      46  USB_ResetPort
      46  USB_SetCurrentMode
      28  USB_SetDevAddress
      14  USB_SetDevSpeed
      70  USB_StopDevice
     124  USB_StopHost
      42  USB_WritePacket
       4  debug

 
     4 bytes in section .bss
 4 030 bytes in section .text
 
 4 030 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none
